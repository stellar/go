// Code generated by goxdr -p gxdr -enum-comments -o gxdr/xdr_generated.go xdr/Stellar-SCP.x xdr/Stellar-ledger-entries.x xdr/Stellar-ledger.x xdr/Stellar-overlay.x xdr/Stellar-transaction.x xdr/Stellar-types.x xdr/Stellar-contract-env-meta.x xdr/Stellar-contract-meta.x xdr/Stellar-contract-spec.x xdr/Stellar-contract.x xdr/Stellar-internal.x xdr/Stellar-contract-config-setting.x xdr/Stellar-lighthorizon.x xdr/Stellar-exporter.x; DO NOT EDIT.

package gxdr

import "fmt"
import "context"
import . "github.com/xdrpp/goxdr/xdr"

var _ XDR
var _ = fmt.Sprintf
var _ context.Context

//
// Data types defined in XDR file
//

type Value = []byte

type SCPBallot struct {
	// n
	Counter Uint32
	// x
	Value Value
}

type SCPStatementType int32

const (
	SCP_ST_PREPARE     SCPStatementType = 0
	SCP_ST_CONFIRM     SCPStatementType = 1
	SCP_ST_EXTERNALIZE SCPStatementType = 2
	SCP_ST_NOMINATE    SCPStatementType = 3
)

type SCPNomination struct {
	// D
	QuorumSetHash Hash
	// X
	Votes []Value
	// Y
	Accepted []Value
}

type SCPStatement struct {
	// v
	NodeID NodeID
	// i
	SlotIndex Uint64
	Pledges   XdrAnon_SCPStatement_Pledges
}
type XdrAnon_SCPStatement_Pledges struct {
	// The union discriminant Type selects among the following arms:
	//   SCP_ST_PREPARE:
	//      Prepare() *XdrAnon_SCPStatement_Pledges_Prepare
	//   SCP_ST_CONFIRM:
	//      Confirm() *XdrAnon_SCPStatement_Pledges_Confirm
	//   SCP_ST_EXTERNALIZE:
	//      Externalize() *XdrAnon_SCPStatement_Pledges_Externalize
	//   SCP_ST_NOMINATE:
	//      Nominate() *SCPNomination
	Type SCPStatementType
	_u   interface{}
}
type XdrAnon_SCPStatement_Pledges_Prepare struct {
	// D
	QuorumSetHash Hash
	// b
	Ballot SCPBallot
	// p
	Prepared *SCPBallot
	// p'
	PreparedPrime *SCPBallot
	// c.n
	NC Uint32
	// h.n
	NH Uint32
}
type XdrAnon_SCPStatement_Pledges_Confirm struct {
	// b
	Ballot SCPBallot
	// p.n
	NPrepared Uint32
	// c.n
	NCommit Uint32
	// h.n
	NH Uint32
	// D
	QuorumSetHash Hash
}
type XdrAnon_SCPStatement_Pledges_Externalize struct {
	// c
	Commit SCPBallot
	// h.n
	NH Uint32
	// D used before EXTERNALIZE
	CommitQuorumSetHash Hash
}

type SCPEnvelope struct {
	Statement SCPStatement
	Signature Signature
}

// supports things like: A,B,C,(D,E,F),(G,H,(I,J,K,L))
// only allows 2 levels of nesting
type SCPQuorumSet struct {
	Threshold  Uint32
	Validators []NodeID
	InnerSets  []SCPQuorumSet
}

type Thresholds = [4]byte

type String32 = string // bound 32

type String64 = string // bound 64

type SequenceNumber = Int64

type DataValue = []byte // bound 64

// SHA256(LiquidityPoolParameters)
type PoolID = Hash

// 1-4 alphanumeric characters right-padded with 0 bytes
type AssetCode4 = [4]byte

// 5-12 alphanumeric characters right-padded with 0 bytes
type AssetCode12 = [12]byte

type AssetType int32

const (
	ASSET_TYPE_NATIVE            AssetType = 0
	ASSET_TYPE_CREDIT_ALPHANUM4  AssetType = 1
	ASSET_TYPE_CREDIT_ALPHANUM12 AssetType = 2
	ASSET_TYPE_POOL_SHARE        AssetType = 3
)

type AssetCode struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AssetCode4() *AssetCode4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AssetCode12() *AssetCode12
	Type AssetType
	_u   interface{}
}

type AlphaNum4 struct {
	AssetCode AssetCode4
	Issuer    AccountID
}

type AlphaNum12 struct {
	AssetCode AssetCode12
	Issuer    AccountID
}

type Asset struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_NATIVE:
	//      void
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AlphaNum4() *AlphaNum4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AlphaNum12() *AlphaNum12
	Type AssetType
	_u   interface{}
}

// price in fractional representation
type Price struct {
	// numerator
	N Int32
	// denominator
	D Int32
}

type Liabilities struct {
	Buying  Int64
	Selling Int64
}

// the 'Thresholds' type is packed uint8_t values
// defined by these indexes
type ThresholdIndexes int32

const (
	THRESHOLD_MASTER_WEIGHT ThresholdIndexes = 0
	THRESHOLD_LOW           ThresholdIndexes = 1
	THRESHOLD_MED           ThresholdIndexes = 2
	THRESHOLD_HIGH          ThresholdIndexes = 3
)

type LedgerEntryType int32

const (
	ACCOUNT           LedgerEntryType = 0
	TRUSTLINE         LedgerEntryType = 1
	OFFER             LedgerEntryType = 2
	DATA              LedgerEntryType = 3
	CLAIMABLE_BALANCE LedgerEntryType = 4
	LIQUIDITY_POOL    LedgerEntryType = 5
	CONTRACT_DATA     LedgerEntryType = 6
	CONTRACT_CODE     LedgerEntryType = 7
	CONFIG_SETTING    LedgerEntryType = 8
	TTL               LedgerEntryType = 9
)

type Signer struct {
	Key SignerKey
	// really only need 1 byte
	Weight Uint32
}

type AccountFlags int32

const (
	// Flags set on issuer accounts
	// TrustLines are created with authorized set to "false" requiring
	// the issuer to set it for each TrustLine
	AUTH_REQUIRED_FLAG AccountFlags = AccountFlags(0x1)
	// If set, the authorized flag in TrustLines can be cleared
	// otherwise, authorization cannot be revoked
	AUTH_REVOCABLE_FLAG AccountFlags = AccountFlags(0x2)
	// Once set, causes all AUTH_* flags to be read-only
	AUTH_IMMUTABLE_FLAG AccountFlags = AccountFlags(0x4)
	// Trustlines are created with clawback enabled set to "true",
	// and claimable balances created from those trustlines are created
	// with clawback enabled set to "true"
	AUTH_CLAWBACK_ENABLED_FLAG AccountFlags = AccountFlags(0x8)
)

// mask for all valid flags
const MASK_ACCOUNT_FLAGS = 0x7

const MASK_ACCOUNT_FLAGS_V17 = 0xF

// maximum number of signers
const MAX_SIGNERS = 20

type SponsorshipDescriptor = *AccountID

type AccountEntryExtensionV3 struct {
	// We can use this to add more fields, or because it is first, to
	// change AccountEntryExtensionV3 into a union.
	Ext ExtensionPoint
	// Ledger number at which `seqNum` took on its present value.
	SeqLedger Uint32
	// Time at which `seqNum` took on its present value.
	SeqTime TimePoint
}

type AccountEntryExtensionV2 struct {
	NumSponsored        Uint32
	NumSponsoring       Uint32
	SignerSponsoringIDs []SponsorshipDescriptor // bound MAX_SIGNERS
	Ext                 XdrAnon_AccountEntryExtensionV2_Ext
}
type XdrAnon_AccountEntryExtensionV2_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   3:
	//      V3() *AccountEntryExtensionV3
	V  int32
	_u interface{}
}

type AccountEntryExtensionV1 struct {
	Liabilities Liabilities
	Ext         XdrAnon_AccountEntryExtensionV1_Ext
}
type XdrAnon_AccountEntryExtensionV1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   2:
	//      V2() *AccountEntryExtensionV2
	V  int32
	_u interface{}
}

/*
AccountEntry

	Main entry representing a user in Stellar. All transactions are
	performed using an account.

	Other ledger entries created require an account.
*/
type AccountEntry struct {
	// master public key for this account
	AccountID AccountID
	// in stroops
	Balance Int64
	// last sequence number used for this account
	SeqNum SequenceNumber
	// number of sub-entries this account has
	NumSubEntries Uint32
	// drives the reserve
	InflationDest *AccountID
	// see AccountFlags
	Flags Uint32
	// can be used for reverse federation and memo lookup
	HomeDomain String32
	// fields used for signatures
	// thresholds stores unsigned bytes: [weight of master|low|medium|high]
	Thresholds Thresholds
	// possible signers for this account
	Signers []Signer // bound MAX_SIGNERS
	Ext     XdrAnon_AccountEntry_Ext
}

// reserved for future use
type XdrAnon_AccountEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *AccountEntryExtensionV1
	V  int32
	_u interface{}
}

type TrustLineFlags int32

const (
	// issuer has authorized account to perform transactions with its credit
	AUTHORIZED_FLAG TrustLineFlags = 1
	// issuer has authorized account to maintain and reduce liabilities for its
	// credit
	AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG TrustLineFlags = 2
	// issuer has specified that it may clawback its credit, and that claimable
	// balances created with its credit may also be clawed back
	TRUSTLINE_CLAWBACK_ENABLED_FLAG TrustLineFlags = 4
)

// mask for all trustline flags
const MASK_TRUSTLINE_FLAGS = 1

const MASK_TRUSTLINE_FLAGS_V13 = 3

const MASK_TRUSTLINE_FLAGS_V17 = 7

type LiquidityPoolType int32

const (
	LIQUIDITY_POOL_CONSTANT_PRODUCT LiquidityPoolType = 0
)

type TrustLineAsset struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_NATIVE:
	//      void
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AlphaNum4() *AlphaNum4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AlphaNum12() *AlphaNum12
	//   ASSET_TYPE_POOL_SHARE:
	//      LiquidityPoolID() *PoolID
	Type AssetType
	_u   interface{}
}

type TrustLineEntryExtensionV2 struct {
	LiquidityPoolUseCount Int32
	Ext                   XdrAnon_TrustLineEntryExtensionV2_Ext
}
type XdrAnon_TrustLineEntryExtensionV2_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type TrustLineEntry struct {
	// account this trustline belongs to
	AccountID AccountID
	// type of asset (with issuer)
	Asset TrustLineAsset
	// how much of this asset the user has.
	Balance Int64
	// balance cannot be above this
	Limit Int64
	// see TrustLineFlags
	Flags Uint32
	Ext   XdrAnon_TrustLineEntry_Ext
}

// reserved for future use
type XdrAnon_TrustLineEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *XdrAnon_TrustLineEntry_Ext_V1
	V  int32
	_u interface{}
}
type XdrAnon_TrustLineEntry_Ext_V1 struct {
	Liabilities Liabilities
	Ext         XdrAnon_TrustLineEntry_Ext_V1_Ext
}
type XdrAnon_TrustLineEntry_Ext_V1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   2:
	//      V2() *TrustLineEntryExtensionV2
	V  int32
	_u interface{}
}

type OfferEntryFlags int32

const (
	// an offer with this flag will not act on and take a reverse offer of equal
	// price
	PASSIVE_FLAG OfferEntryFlags = 1
)

// Mask for OfferEntry flags
const MASK_OFFERENTRY_FLAGS = 1

/*
OfferEntry

	An offer is the building block of the offer book, they are automatically
	claimed by payments when the price set by the owner is met.

	For example an Offer is selling 10A where 1A is priced at 1.5B
*/
type OfferEntry struct {
	SellerID AccountID
	OfferID  Int64
	// A
	Selling Asset
	// B
	Buying Asset
	// amount of A
	Amount Int64
	/* price for this offer:
	   price of A in terms of B
	   price=AmountB/AmountA=priceNumerator/priceDenominator
	   price is after fees
	*/
	Price Price
	// see OfferEntryFlags
	Flags Uint32
	Ext   XdrAnon_OfferEntry_Ext
}

// reserved for future use
type XdrAnon_OfferEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

/*
DataEntry

	Data can be attached to accounts.
*/
type DataEntry struct {
	// account this data belongs to
	AccountID AccountID
	DataName  String64
	DataValue DataValue
	Ext       XdrAnon_DataEntry_Ext
}

// reserved for future use
type XdrAnon_DataEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type ClaimPredicateType int32

const (
	CLAIM_PREDICATE_UNCONDITIONAL        ClaimPredicateType = 0
	CLAIM_PREDICATE_AND                  ClaimPredicateType = 1
	CLAIM_PREDICATE_OR                   ClaimPredicateType = 2
	CLAIM_PREDICATE_NOT                  ClaimPredicateType = 3
	CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME ClaimPredicateType = 4
	CLAIM_PREDICATE_BEFORE_RELATIVE_TIME ClaimPredicateType = 5
)

type ClaimPredicate struct {
	// The union discriminant Type selects among the following arms:
	//   CLAIM_PREDICATE_UNCONDITIONAL:
	//      void
	//   CLAIM_PREDICATE_AND:
	//      AndPredicates() *[]ClaimPredicate // bound 2
	//   CLAIM_PREDICATE_OR:
	//      OrPredicates() *[]ClaimPredicate // bound 2
	//   CLAIM_PREDICATE_NOT:
	//      NotPredicate() **ClaimPredicate
	//   CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
	//      AbsBefore() *Int64
	//   CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
	//      RelBefore() *Int64
	Type ClaimPredicateType
	_u   interface{}
}

type ClaimantType int32

const (
	CLAIMANT_TYPE_V0 ClaimantType = 0
)

type Claimant struct {
	// The union discriminant Type selects among the following arms:
	//   CLAIMANT_TYPE_V0:
	//      V0() *XdrAnon_Claimant_V0
	Type ClaimantType
	_u   interface{}
}
type XdrAnon_Claimant_V0 struct {
	// The account that can use this condition
	Destination AccountID
	// Claimable if predicate is true
	Predicate ClaimPredicate
}

type ClaimableBalanceIDType int32

const (
	CLAIMABLE_BALANCE_ID_TYPE_V0 ClaimableBalanceIDType = 0
)

type ClaimableBalanceID struct {
	// The union discriminant Type selects among the following arms:
	//   CLAIMABLE_BALANCE_ID_TYPE_V0:
	//      V0() *Hash
	Type ClaimableBalanceIDType
	_u   interface{}
}

type ClaimableBalanceFlags int32

const (
	// If set, the issuer account of the asset held by the claimable balance may
	// clawback the claimable balance
	CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG ClaimableBalanceFlags = ClaimableBalanceFlags(0x1)
)

const MASK_CLAIMABLE_BALANCE_FLAGS = 0x1

type ClaimableBalanceEntryExtensionV1 struct {
	Ext XdrAnon_ClaimableBalanceEntryExtensionV1_Ext
	// see ClaimableBalanceFlags
	Flags Uint32
}
type XdrAnon_ClaimableBalanceEntryExtensionV1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type ClaimableBalanceEntry struct {
	// Unique identifier for this ClaimableBalanceEntry
	BalanceID ClaimableBalanceID
	// List of claimants with associated predicate
	Claimants []Claimant // bound 10
	// Any asset including native
	Asset Asset
	// Amount of asset
	Amount Int64
	Ext    XdrAnon_ClaimableBalanceEntry_Ext
}

// reserved for future use
type XdrAnon_ClaimableBalanceEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *ClaimableBalanceEntryExtensionV1
	V  int32
	_u interface{}
}

type LiquidityPoolConstantProductParameters struct {
	// assetA < assetB
	AssetA Asset
	AssetB Asset
	// Fee is in basis points, so the actual rate is (fee/100)%
	Fee Int32
}

type LiquidityPoolEntry struct {
	LiquidityPoolID PoolID
	Body            XdrAnon_LiquidityPoolEntry_Body
}
type XdrAnon_LiquidityPoolEntry_Body struct {
	// The union discriminant Type selects among the following arms:
	//   LIQUIDITY_POOL_CONSTANT_PRODUCT:
	//      ConstantProduct() *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct
	Type LiquidityPoolType
	_u   interface{}
}
type XdrAnon_LiquidityPoolEntry_Body_ConstantProduct struct {
	Params LiquidityPoolConstantProductParameters
	// amount of A in the pool
	ReserveA Int64
	// amount of B in the pool
	ReserveB Int64
	// total number of pool shares issued
	TotalPoolShares Int64
	// number of trust lines for the
	PoolSharesTrustLineCount Int64
}

type ContractDataDurability int32

const (
	TEMPORARY  ContractDataDurability = 0
	PERSISTENT ContractDataDurability = 1
)

type ContractDataEntry struct {
	Ext        ExtensionPoint
	Contract   SCAddress
	Key        SCVal
	Durability ContractDataDurability
	Val        SCVal
}

type ContractCodeCostInputs struct {
	Ext               ExtensionPoint
	NInstructions     Uint32
	NFunctions        Uint32
	NGlobals          Uint32
	NTableEntries     Uint32
	NTypes            Uint32
	NDataSegments     Uint32
	NElemSegments     Uint32
	NImports          Uint32
	NExports          Uint32
	NDataSegmentBytes Uint32
}

type ContractCodeEntry struct {
	Ext  XdrAnon_ContractCodeEntry_Ext
	Hash Hash
	Code []byte
}
type XdrAnon_ContractCodeEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *XdrAnon_ContractCodeEntry_Ext_V1
	V  int32
	_u interface{}
}
type XdrAnon_ContractCodeEntry_Ext_V1 struct {
	Ext        ExtensionPoint
	CostInputs ContractCodeCostInputs
}

type TTLEntry struct {
	// Hash of the LedgerKey that is associated with this TTLEntry
	KeyHash            Hash
	LiveUntilLedgerSeq Uint32
}

type LedgerEntryExtensionV1 struct {
	SponsoringID SponsorshipDescriptor
	Ext          XdrAnon_LedgerEntryExtensionV1_Ext
}
type XdrAnon_LedgerEntryExtensionV1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type LedgerEntry struct {
	// ledger the LedgerEntry was last changed
	LastModifiedLedgerSeq Uint32
	Data                  XdrAnon_LedgerEntry_Data
	Ext                   XdrAnon_LedgerEntry_Ext
}
type XdrAnon_LedgerEntry_Data struct {
	// The union discriminant Type selects among the following arms:
	//   ACCOUNT:
	//      Account() *AccountEntry
	//   TRUSTLINE:
	//      TrustLine() *TrustLineEntry
	//   OFFER:
	//      Offer() *OfferEntry
	//   DATA:
	//      Data() *DataEntry
	//   CLAIMABLE_BALANCE:
	//      ClaimableBalance() *ClaimableBalanceEntry
	//   LIQUIDITY_POOL:
	//      LiquidityPool() *LiquidityPoolEntry
	//   CONTRACT_DATA:
	//      ContractData() *ContractDataEntry
	//   CONTRACT_CODE:
	//      ContractCode() *ContractCodeEntry
	//   CONFIG_SETTING:
	//      ConfigSetting() *ConfigSettingEntry
	//   TTL:
	//      Ttl() *TTLEntry
	Type LedgerEntryType
	_u   interface{}
}

// reserved for future use
type XdrAnon_LedgerEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *LedgerEntryExtensionV1
	V  int32
	_u interface{}
}

type LedgerKey struct {
	// The union discriminant Type selects among the following arms:
	//   ACCOUNT:
	//      Account() *XdrAnon_LedgerKey_Account
	//   TRUSTLINE:
	//      TrustLine() *XdrAnon_LedgerKey_TrustLine
	//   OFFER:
	//      Offer() *XdrAnon_LedgerKey_Offer
	//   DATA:
	//      Data() *XdrAnon_LedgerKey_Data
	//   CLAIMABLE_BALANCE:
	//      ClaimableBalance() *XdrAnon_LedgerKey_ClaimableBalance
	//   LIQUIDITY_POOL:
	//      LiquidityPool() *XdrAnon_LedgerKey_LiquidityPool
	//   CONTRACT_DATA:
	//      ContractData() *XdrAnon_LedgerKey_ContractData
	//   CONTRACT_CODE:
	//      ContractCode() *XdrAnon_LedgerKey_ContractCode
	//   CONFIG_SETTING:
	//      ConfigSetting() *XdrAnon_LedgerKey_ConfigSetting
	//   TTL:
	//      Ttl() *XdrAnon_LedgerKey_Ttl
	Type LedgerEntryType
	_u   interface{}
}
type XdrAnon_LedgerKey_Account struct {
	AccountID AccountID
}
type XdrAnon_LedgerKey_TrustLine struct {
	AccountID AccountID
	Asset     TrustLineAsset
}
type XdrAnon_LedgerKey_Offer struct {
	SellerID AccountID
	OfferID  Int64
}
type XdrAnon_LedgerKey_Data struct {
	AccountID AccountID
	DataName  String64
}
type XdrAnon_LedgerKey_ClaimableBalance struct {
	BalanceID ClaimableBalanceID
}
type XdrAnon_LedgerKey_LiquidityPool struct {
	LiquidityPoolID PoolID
}
type XdrAnon_LedgerKey_ContractData struct {
	Contract   SCAddress
	Key        SCVal
	Durability ContractDataDurability
}
type XdrAnon_LedgerKey_ContractCode struct {
	Hash Hash
}
type XdrAnon_LedgerKey_ConfigSetting struct {
	ConfigSettingID ConfigSettingID
}
type XdrAnon_LedgerKey_Ttl struct {
	// Hash of the LedgerKey that is associated with this TTLEntry
	KeyHash Hash
}

// list of all envelope types used in the application
// those are prefixes used when building signatures for
// the respective envelopes
type EnvelopeType int32

const (
	ENVELOPE_TYPE_TX_V0                 EnvelopeType = 0
	ENVELOPE_TYPE_SCP                   EnvelopeType = 1
	ENVELOPE_TYPE_TX                    EnvelopeType = 2
	ENVELOPE_TYPE_AUTH                  EnvelopeType = 3
	ENVELOPE_TYPE_SCPVALUE              EnvelopeType = 4
	ENVELOPE_TYPE_TX_FEE_BUMP           EnvelopeType = 5
	ENVELOPE_TYPE_OP_ID                 EnvelopeType = 6
	ENVELOPE_TYPE_POOL_REVOKE_OP_ID     EnvelopeType = 7
	ENVELOPE_TYPE_CONTRACT_ID           EnvelopeType = 8
	ENVELOPE_TYPE_SOROBAN_AUTHORIZATION EnvelopeType = 9
)

type UpgradeType = []byte // bound 128

type StellarValueType int32

const (
	STELLAR_VALUE_BASIC  StellarValueType = 0
	STELLAR_VALUE_SIGNED StellarValueType = 1
)

type LedgerCloseValueSignature struct {
	// which node introduced the value
	NodeID NodeID
	// nodeID's signature
	Signature Signature
}

/* StellarValue is the value used by SCP to reach consensus on a given ledger
 */
type StellarValue struct {
	// transaction set to apply to previous ledger
	TxSetHash Hash
	// network close time
	CloseTime TimePoint
	// upgrades to apply to the previous ledger (usually empty)
	// this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
	// unknown steps during consensus if needed.
	// see notes below on 'LedgerUpgrade' for more detail
	// max size is dictated by number of upgrade types (+ room for future)
	Upgrades []UpgradeType // bound 6
	Ext      XdrAnon_StellarValue_Ext
}

// reserved for future use
type XdrAnon_StellarValue_Ext struct {
	// The union discriminant V selects among the following arms:
	//   STELLAR_VALUE_BASIC:
	//      void
	//   STELLAR_VALUE_SIGNED:
	//      LcValueSignature() *LedgerCloseValueSignature
	V  StellarValueType
	_u interface{}
}

const MASK_LEDGER_HEADER_FLAGS = 0x7

type LedgerHeaderFlags int32

const (
	DISABLE_LIQUIDITY_POOL_TRADING_FLAG    LedgerHeaderFlags = LedgerHeaderFlags(0x1)
	DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG    LedgerHeaderFlags = LedgerHeaderFlags(0x2)
	DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG LedgerHeaderFlags = LedgerHeaderFlags(0x4)
)

type LedgerHeaderExtensionV1 struct {
	// LedgerHeaderFlags
	Flags Uint32
	Ext   XdrAnon_LedgerHeaderExtensionV1_Ext
}
type XdrAnon_LedgerHeaderExtensionV1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

/* The LedgerHeader is the highest level structure representing the
 * state of a ledger, cryptographically linked to previous ledgers.
 */
type LedgerHeader struct {
	// the protocol version of the ledger
	LedgerVersion Uint32
	// hash of the previous ledger header
	PreviousLedgerHash Hash
	// what consensus agreed to
	ScpValue StellarValue
	// the TransactionResultSet that led to this ledger
	TxSetResultHash Hash
	// hash of the ledger state
	BucketListHash Hash
	// sequence number of this ledger
	LedgerSeq Uint32
	// total number of stroops in existence.
	TotalCoins Int64
	// fees burned since last inflation run
	FeePool Int64
	// inflation sequence number
	InflationSeq Uint32
	// last used global ID, used for generating objects
	IdPool Uint64
	// base fee per operation in stroops
	BaseFee Uint32
	// account base reserve in stroops
	BaseReserve Uint32
	// maximum size a transaction set can be
	MaxTxSetSize Uint32
	// hashes of ledgers in the past. allows you to jump back
	SkipList [4]Hash
	Ext      XdrAnon_LedgerHeader_Ext
}

// reserved for future use
type XdrAnon_LedgerHeader_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *LedgerHeaderExtensionV1
	V  int32
	_u interface{}
}

/*
	Ledger upgrades

note that the `upgrades` field from StellarValue is normalized such that
it only contains one entry per LedgerUpgradeType, and entries are sorted
in ascending order
*/
type LedgerUpgradeType int32

const (
	LEDGER_UPGRADE_VERSION                 LedgerUpgradeType = 1
	LEDGER_UPGRADE_BASE_FEE                LedgerUpgradeType = 2
	LEDGER_UPGRADE_MAX_TX_SET_SIZE         LedgerUpgradeType = 3
	LEDGER_UPGRADE_BASE_RESERVE            LedgerUpgradeType = 4
	LEDGER_UPGRADE_FLAGS                   LedgerUpgradeType = 5
	LEDGER_UPGRADE_CONFIG                  LedgerUpgradeType = 6
	LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE LedgerUpgradeType = 7
)

type ConfigUpgradeSetKey struct {
	ContractID  Hash
	ContentHash Hash
}

type LedgerUpgrade struct {
	// The union discriminant Type selects among the following arms:
	//   LEDGER_UPGRADE_VERSION:
	//      NewLedgerVersion() *Uint32
	//   LEDGER_UPGRADE_BASE_FEE:
	//      NewBaseFee() *Uint32
	//   LEDGER_UPGRADE_MAX_TX_SET_SIZE:
	//      NewMaxTxSetSize() *Uint32
	//   LEDGER_UPGRADE_BASE_RESERVE:
	//      NewBaseReserve() *Uint32
	//   LEDGER_UPGRADE_FLAGS:
	//      NewFlags() *Uint32
	//   LEDGER_UPGRADE_CONFIG:
	//      NewConfig() *ConfigUpgradeSetKey
	//   LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
	//      NewMaxSorobanTxSetSize() *Uint32
	Type LedgerUpgradeType
	_u   interface{}
}

type ConfigUpgradeSet struct {
	UpdatedEntry []ConfigSettingEntry
}

/* Entries used to define the bucket list */
type BucketEntryType int32

const (
	// At-and-after protocol 11: bucket metadata, should come first.
	METAENTRY BucketEntryType = -1
	// Before protocol 11: created-or-updated;
	LIVEENTRY BucketEntryType = 0
	// At-and-after protocol 11: only updated.
	DEADENTRY BucketEntryType = 1
	// At-and-after protocol 11: only created.
	INITENTRY BucketEntryType = 2
)

type BucketMetadata struct {
	// Indicates the protocol version used to create / merge this bucket.
	LedgerVersion Uint32
	Ext           XdrAnon_BucketMetadata_Ext
}

// reserved for future use
type XdrAnon_BucketMetadata_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type BucketEntry struct {
	// The union discriminant Type selects among the following arms:
	//   LIVEENTRY, INITENTRY:
	//      LiveEntry() *LedgerEntry
	//   DEADENTRY:
	//      DeadEntry() *LedgerKey
	//   METAENTRY:
	//      MetaEntry() *BucketMetadata
	Type BucketEntryType
	_u   interface{}
}

type TxSetComponentType int32

const (
	// txs with effective fee <= bid derived from a base fee (if any).
	// If base fee is not specified, no discount is applied.
	TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE TxSetComponentType = 0
)

type TxSetComponent struct {
	// The union discriminant Type selects among the following arms:
	//   TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
	//      TxsMaybeDiscountedFee() *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee
	Type TxSetComponentType
	_u   interface{}
}
type XdrAnon_TxSetComponent_TxsMaybeDiscountedFee struct {
	BaseFee *Int64
	Txs     []TransactionEnvelope
}

type TransactionPhase struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0Components() *[]TxSetComponent
	V  int32
	_u interface{}
}

// Transaction sets are the unit used by SCP to decide on transitions
// between ledgers
type TransactionSet struct {
	PreviousLedgerHash Hash
	Txs                []TransactionEnvelope
}

type TransactionSetV1 struct {
	PreviousLedgerHash Hash
	Phases             []TransactionPhase
}

type GeneralizedTransactionSet struct {
	// The union discriminant V selects among the following arms:
	//   1:
	//      V1TxSet() *TransactionSetV1
	V  int32
	_u interface{}
}

type TransactionResultPair struct {
	TransactionHash Hash
	// result for the transaction
	Result TransactionResult
}

// TransactionResultSet is used to recover results between ledgers
type TransactionResultSet struct {
	Results []TransactionResultPair
}

type TransactionHistoryEntry struct {
	LedgerSeq Uint32
	TxSet     TransactionSet
	Ext       XdrAnon_TransactionHistoryEntry_Ext
}

// when v != 0, txSet must be empty
type XdrAnon_TransactionHistoryEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      GeneralizedTxSet() *GeneralizedTransactionSet
	V  int32
	_u interface{}
}

type TransactionHistoryResultEntry struct {
	LedgerSeq   Uint32
	TxResultSet TransactionResultSet
	Ext         XdrAnon_TransactionHistoryResultEntry_Ext
}

// reserved for future use
type XdrAnon_TransactionHistoryResultEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type LedgerHeaderHistoryEntry struct {
	Hash   Hash
	Header LedgerHeader
	Ext    XdrAnon_LedgerHeaderHistoryEntry_Ext
}

// reserved for future use
type XdrAnon_LedgerHeaderHistoryEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type LedgerSCPMessages struct {
	LedgerSeq Uint32
	Messages  []SCPEnvelope
}

// note: ledgerMessages may refer to any quorumSets encountered
// in the file so far, not just the one from this entry
type SCPHistoryEntryV0 struct {
	// additional quorum sets used by ledgerMessages
	QuorumSets     []SCPQuorumSet
	LedgerMessages LedgerSCPMessages
}

// SCP history file is an array of these
type SCPHistoryEntry struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *SCPHistoryEntryV0
	V  int32
	_u interface{}
}

type LedgerEntryChangeType int32

const (
	// entry was added to the ledger
	LEDGER_ENTRY_CREATED LedgerEntryChangeType = 0
	// entry was modified in the ledger
	LEDGER_ENTRY_UPDATED LedgerEntryChangeType = 1
	// entry was removed from the ledger
	LEDGER_ENTRY_REMOVED LedgerEntryChangeType = 2
	// value of the entry
	LEDGER_ENTRY_STATE LedgerEntryChangeType = 3
)

type LedgerEntryChange struct {
	// The union discriminant Type selects among the following arms:
	//   LEDGER_ENTRY_CREATED:
	//      Created() *LedgerEntry
	//   LEDGER_ENTRY_UPDATED:
	//      Updated() *LedgerEntry
	//   LEDGER_ENTRY_REMOVED:
	//      Removed() *LedgerKey
	//   LEDGER_ENTRY_STATE:
	//      State() *LedgerEntry
	Type LedgerEntryChangeType
	_u   interface{}
}

type LedgerEntryChanges = []LedgerEntryChange

type OperationMeta struct {
	Changes LedgerEntryChanges
}

type TransactionMetaV1 struct {
	// tx level changes if any
	TxChanges LedgerEntryChanges
	// meta for each operation
	Operations []OperationMeta
}

type TransactionMetaV2 struct {
	// tx level changes before operations
	TxChangesBefore LedgerEntryChanges
	// are applied if any
	Operations []OperationMeta
	// tx level changes after operations are
	TxChangesAfter LedgerEntryChanges
}

type ContractEventType int32

const (
	SYSTEM     ContractEventType = 0
	CONTRACT   ContractEventType = 1
	DIAGNOSTIC ContractEventType = 2
)

type ContractEvent struct {
	// We can use this to add more fields, or because it
	// is first, to change ContractEvent into a union.
	Ext        ExtensionPoint
	ContractID *Hash
	Type       ContractEventType
	Body       XdrAnon_ContractEvent_Body
}
type XdrAnon_ContractEvent_Body struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *XdrAnon_ContractEvent_Body_V0
	V  int32
	_u interface{}
}
type XdrAnon_ContractEvent_Body_V0 struct {
	Topics []SCVal
	Data   SCVal
}

type DiagnosticEvent struct {
	InSuccessfulContractCall bool
	Event                    ContractEvent
}

type SorobanTransactionMetaExtV1 struct {
	Ext ExtensionPoint
	// Total amount (in stroops) that has been charged for non-refundable
	// Soroban resources.
	// Non-refundable resources are charged based on the usage declared in
	// the transaction envelope (such as `instructions`, `readBytes` etc.) and
	// is charged regardless of the success of the transaction.
	TotalNonRefundableResourceFeeCharged Int64
	// Total amount (in stroops) that has been charged for refundable
	// Soroban resource fees.
	// Currently this comprises the rent fee (`rentFeeCharged`) and the
	// fee for the events and return value.
	// Refundable resources are charged based on the actual resources usage.
	// Since currently refundable resources are only used for the successful
	// transactions, this will be `0` for failed transactions.
	TotalRefundableResourceFeeCharged Int64
	// Amount (in stroops) that has been charged for rent.
	// This is a part of `totalNonRefundableResourceFeeCharged`.
	RentFeeCharged Int64
}

type SorobanTransactionMetaExt struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *SorobanTransactionMetaExtV1
	V  int32
	_u interface{}
}

type SorobanTransactionMeta struct {
	Ext SorobanTransactionMetaExt
	// custom events populated by the
	Events []ContractEvent
	// contracts themselves.
	ReturnValue SCVal
	// Diagnostics events that are not hashed.
	// This will contain all contract and diagnostic events. Even ones
	// that were emitted in a failed contract call.
	DiagnosticEvents []DiagnosticEvent
}

type TransactionMetaV3 struct {
	Ext ExtensionPoint
	// tx level changes before operations
	TxChangesBefore LedgerEntryChanges
	// are applied if any
	Operations []OperationMeta
	// tx level changes after operations are
	TxChangesAfter LedgerEntryChanges
	// applied if any
	SorobanMeta *SorobanTransactionMeta
}

// This is in Stellar-ledger.x to due to a circular dependency
type InvokeHostFunctionSuccessPreImage struct {
	ReturnValue SCVal
	Events      []ContractEvent
}

// this is the meta produced when applying transactions
// it does not include pre-apply updates such as fees
type TransactionMeta struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      Operations() *[]OperationMeta
	//   1:
	//      V1() *TransactionMetaV1
	//   2:
	//      V2() *TransactionMetaV2
	//   3:
	//      V3() *TransactionMetaV3
	V  int32
	_u interface{}
}

// This struct groups together changes on a per transaction basis
// note however that fees and transaction application are done in separate
// phases
type TransactionResultMeta struct {
	Result            TransactionResultPair
	FeeProcessing     LedgerEntryChanges
	TxApplyProcessing TransactionMeta
}

// this represents a single upgrade that was performed as part of a ledger
// upgrade
type UpgradeEntryMeta struct {
	Upgrade LedgerUpgrade
	Changes LedgerEntryChanges
}

type LedgerCloseMetaV0 struct {
	LedgerHeader LedgerHeaderHistoryEntry
	// NB: txSet is sorted in "Hash order"
	TxSet TransactionSet
	// NB: transactions are sorted in apply order here
	// fees for all transactions are processed first
	// followed by applying transactions
	TxProcessing []TransactionResultMeta
	// upgrades are applied last
	UpgradesProcessing []UpgradeEntryMeta
	// other misc information attached to the ledger close
	ScpInfo []SCPHistoryEntry
}

type LedgerCloseMetaExtV1 struct {
	Ext                ExtensionPoint
	SorobanFeeWrite1KB Int64
}

type LedgerCloseMetaExt struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *LedgerCloseMetaExtV1
	V  int32
	_u interface{}
}

type LedgerCloseMetaV1 struct {
	Ext          LedgerCloseMetaExt
	LedgerHeader LedgerHeaderHistoryEntry
	TxSet        GeneralizedTransactionSet
	// NB: transactions are sorted in apply order here
	// fees for all transactions are processed first
	// followed by applying transactions
	TxProcessing []TransactionResultMeta
	// upgrades are applied last
	UpgradesProcessing []UpgradeEntryMeta
	// other misc information attached to the ledger close
	ScpInfo []SCPHistoryEntry
	// Size in bytes of BucketList, to support downstream
	// systems calculating storage fees correctly.
	TotalByteSizeOfBucketList Uint64
	// Temp keys that are being evicted at this ledger.
	EvictedTemporaryLedgerKeys []LedgerKey
	// Archived restorable ledger entries that are being
	// evicted at this ledger.
	EvictedPersistentLedgerEntries []LedgerEntry
}

type LedgerCloseMeta struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *LedgerCloseMetaV0
	//   1:
	//      V1() *LedgerCloseMetaV1
	V  int32
	_u interface{}
}

type ErrorCode int32

const (
	// Unspecific error
	ERR_MISC ErrorCode = 0
	// Malformed data
	ERR_DATA ErrorCode = 1
	// Misconfiguration error
	ERR_CONF ErrorCode = 2
	// Authentication failure
	ERR_AUTH ErrorCode = 3
	// System overloaded
	ERR_LOAD ErrorCode = 4
)

type Error struct {
	Code ErrorCode
	Msg  string // bound 100
}

type SendMore struct {
	NumMessages Uint32
}

type SendMoreExtended struct {
	NumMessages Uint32
	NumBytes    Uint32
}

type AuthCert struct {
	Pubkey     Curve25519Public
	Expiration Uint64
	Sig        Signature
}

type Hello struct {
	LedgerVersion     Uint32
	OverlayVersion    Uint32
	OverlayMinVersion Uint32
	NetworkID         Hash
	VersionStr        string // bound 100
	ListeningPort     int32
	PeerID            NodeID
	Cert              AuthCert
	Nonce             Uint256
}

// During the roll-out phrase, nodes can disable flow control in bytes.
// Therefore, we need a way to communicate with other nodes
// that we want/don't want flow control in bytes.
// We use the `flags` field in the Auth message with a special value
// set to communicate this. Note that AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED != 0
// AND AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED != 100 (as previously
// that value was used for other purposes).
const AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED = 200

type Auth struct {
	Flags int32
}

type IPAddrType int32

const (
	IPv4 IPAddrType = 0
	IPv6 IPAddrType = 1
)

type PeerAddress struct {
	Ip          XdrAnon_PeerAddress_Ip
	Port        Uint32
	NumFailures Uint32
}
type XdrAnon_PeerAddress_Ip struct {
	// The union discriminant Type selects among the following arms:
	//   IPv4:
	//      Ipv4() *[4]byte
	//   IPv6:
	//      Ipv6() *[16]byte
	Type IPAddrType
	_u   interface{}
}

// Next ID: 21
type MessageType int32

const (
	ERROR_MSG MessageType = 0
	AUTH      MessageType = 2
	DONT_HAVE MessageType = 3
	// gets a list of peers this guy knows about
	GET_PEERS MessageType = 4
	PEERS     MessageType = 5
	// gets a particular txset by hash
	GET_TX_SET         MessageType = 6
	TX_SET             MessageType = 7
	GENERALIZED_TX_SET MessageType = 17
	// pass on a tx you have heard about
	TRANSACTION MessageType = 8
	// SCP
	GET_SCP_QUORUMSET MessageType = 9
	SCP_QUORUMSET     MessageType = 10
	SCP_MESSAGE       MessageType = 11
	GET_SCP_STATE     MessageType = 12
	// new messages
	HELLO              MessageType = 13
	SURVEY_REQUEST     MessageType = 14
	SURVEY_RESPONSE    MessageType = 15
	SEND_MORE          MessageType = 16
	SEND_MORE_EXTENDED MessageType = 20
	FLOOD_ADVERT       MessageType = 18
	FLOOD_DEMAND       MessageType = 19
)

type DontHave struct {
	Type    MessageType
	ReqHash Uint256
}

type SurveyMessageCommandType int32

const (
	SURVEY_TOPOLOGY SurveyMessageCommandType = 0
)

type SurveyMessageResponseType int32

const (
	SURVEY_TOPOLOGY_RESPONSE_V0 SurveyMessageResponseType = 0
	SURVEY_TOPOLOGY_RESPONSE_V1 SurveyMessageResponseType = 1
)

type SurveyRequestMessage struct {
	SurveyorPeerID NodeID
	SurveyedPeerID NodeID
	LedgerNum      Uint32
	EncryptionKey  Curve25519Public
	CommandType    SurveyMessageCommandType
}

type SignedSurveyRequestMessage struct {
	RequestSignature Signature
	Request          SurveyRequestMessage
}

type EncryptedBody = []byte // bound 64000

type SurveyResponseMessage struct {
	SurveyorPeerID NodeID
	SurveyedPeerID NodeID
	LedgerNum      Uint32
	CommandType    SurveyMessageCommandType
	EncryptedBody  EncryptedBody
}

type SignedSurveyResponseMessage struct {
	ResponseSignature Signature
	Response          SurveyResponseMessage
}

type PeerStats struct {
	Id                        NodeID
	VersionStr                string // bound 100
	MessagesRead              Uint64
	MessagesWritten           Uint64
	BytesRead                 Uint64
	BytesWritten              Uint64
	SecondsConnected          Uint64
	UniqueFloodBytesRecv      Uint64
	DuplicateFloodBytesRecv   Uint64
	UniqueFetchBytesRecv      Uint64
	DuplicateFetchBytesRecv   Uint64
	UniqueFloodMessageRecv    Uint64
	DuplicateFloodMessageRecv Uint64
	UniqueFetchMessageRecv    Uint64
	DuplicateFetchMessageRecv Uint64
}

type PeerStatList = []PeerStats // bound 25

type TopologyResponseBodyV0 struct {
	InboundPeers           PeerStatList
	OutboundPeers          PeerStatList
	TotalInboundPeerCount  Uint32
	TotalOutboundPeerCount Uint32
}

type TopologyResponseBodyV1 struct {
	InboundPeers           PeerStatList
	OutboundPeers          PeerStatList
	TotalInboundPeerCount  Uint32
	TotalOutboundPeerCount Uint32
	MaxInboundPeerCount    Uint32
	MaxOutboundPeerCount   Uint32
}

type SurveyResponseBody struct {
	// The union discriminant Type selects among the following arms:
	//   SURVEY_TOPOLOGY_RESPONSE_V0:
	//      TopologyResponseBodyV0() *TopologyResponseBodyV0
	//   SURVEY_TOPOLOGY_RESPONSE_V1:
	//      TopologyResponseBodyV1() *TopologyResponseBodyV1
	Type SurveyMessageResponseType
	_u   interface{}
}

const TX_ADVERT_VECTOR_MAX_SIZE = 1000

type TxAdvertVector = []Hash // bound TX_ADVERT_VECTOR_MAX_SIZE

type FloodAdvert struct {
	TxHashes TxAdvertVector
}

const TX_DEMAND_VECTOR_MAX_SIZE = 1000

type TxDemandVector = []Hash // bound TX_DEMAND_VECTOR_MAX_SIZE

type FloodDemand struct {
	TxHashes TxDemandVector
}

type StellarMessage struct {
	// The union discriminant Type selects among the following arms:
	//   ERROR_MSG:
	//      Error() *Error
	//   HELLO:
	//      Hello() *Hello
	//   AUTH:
	//      Auth() *Auth
	//   DONT_HAVE:
	//      DontHave() *DontHave
	//   GET_PEERS:
	//      void
	//   PEERS:
	//      Peers() *[]PeerAddress // bound 100
	//   GET_TX_SET:
	//      TxSetHash() *Uint256
	//   TX_SET:
	//      TxSet() *TransactionSet
	//   GENERALIZED_TX_SET:
	//      GeneralizedTxSet() *GeneralizedTransactionSet
	//   TRANSACTION:
	//      Transaction() *TransactionEnvelope
	//   SURVEY_REQUEST:
	//      SignedSurveyRequestMessage() *SignedSurveyRequestMessage
	//   SURVEY_RESPONSE:
	//      SignedSurveyResponseMessage() *SignedSurveyResponseMessage
	//   GET_SCP_QUORUMSET:
	//      QSetHash() *Uint256
	//   SCP_QUORUMSET:
	//      QSet() *SCPQuorumSet
	//   SCP_MESSAGE:
	//      Envelope() *SCPEnvelope
	//   GET_SCP_STATE:
	//      GetSCPLedgerSeq() *Uint32
	//   SEND_MORE:
	//      SendMoreMessage() *SendMore
	//   SEND_MORE_EXTENDED:
	//      SendMoreExtendedMessage() *SendMoreExtended
	//   FLOOD_ADVERT:
	//      FloodAdvert() *FloodAdvert
	//   FLOOD_DEMAND:
	//      FloodDemand() *FloodDemand
	Type MessageType
	_u   interface{}
}

type AuthenticatedMessage struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *XdrAnon_AuthenticatedMessage_V0
	V  Uint32
	_u interface{}
}
type XdrAnon_AuthenticatedMessage_V0 struct {
	Sequence Uint64
	Message  StellarMessage
	Mac      HmacSha256Mac
}

// maximum number of operations per transaction
const MAX_OPS_PER_TX = 100

type LiquidityPoolParameters struct {
	// The union discriminant Type selects among the following arms:
	//   LIQUIDITY_POOL_CONSTANT_PRODUCT:
	//      ConstantProduct() *LiquidityPoolConstantProductParameters
	Type LiquidityPoolType
	_u   interface{}
}

// Source or destination of a payment operation
type MuxedAccount struct {
	// The union discriminant Type selects among the following arms:
	//   KEY_TYPE_ED25519:
	//      Ed25519() *Uint256
	//   KEY_TYPE_MUXED_ED25519:
	//      Med25519() *XdrAnon_MuxedAccount_Med25519
	Type CryptoKeyType
	_u   interface{}
}
type XdrAnon_MuxedAccount_Med25519 struct {
	Id      Uint64
	Ed25519 Uint256
}

type DecoratedSignature struct {
	// last 4 bytes of the public key, used as a hint
	Hint SignatureHint
	// actual signature
	Signature Signature
}

type OperationType int32

const (
	CREATE_ACCOUNT                   OperationType = 0
	PAYMENT                          OperationType = 1
	PATH_PAYMENT_STRICT_RECEIVE      OperationType = 2
	MANAGE_SELL_OFFER                OperationType = 3
	CREATE_PASSIVE_SELL_OFFER        OperationType = 4
	SET_OPTIONS                      OperationType = 5
	CHANGE_TRUST                     OperationType = 6
	ALLOW_TRUST                      OperationType = 7
	ACCOUNT_MERGE                    OperationType = 8
	INFLATION                        OperationType = 9
	MANAGE_DATA                      OperationType = 10
	BUMP_SEQUENCE                    OperationType = 11
	MANAGE_BUY_OFFER                 OperationType = 12
	PATH_PAYMENT_STRICT_SEND         OperationType = 13
	CREATE_CLAIMABLE_BALANCE         OperationType = 14
	CLAIM_CLAIMABLE_BALANCE          OperationType = 15
	BEGIN_SPONSORING_FUTURE_RESERVES OperationType = 16
	END_SPONSORING_FUTURE_RESERVES   OperationType = 17
	REVOKE_SPONSORSHIP               OperationType = 18
	CLAWBACK                         OperationType = 19
	CLAWBACK_CLAIMABLE_BALANCE       OperationType = 20
	SET_TRUST_LINE_FLAGS             OperationType = 21
	LIQUIDITY_POOL_DEPOSIT           OperationType = 22
	LIQUIDITY_POOL_WITHDRAW          OperationType = 23
	INVOKE_HOST_FUNCTION             OperationType = 24
	EXTEND_FOOTPRINT_TTL             OperationType = 25
	RESTORE_FOOTPRINT                OperationType = 26
)

/*
	CreateAccount

Creates and funds a new account with the specified starting balance.

Threshold: med

Result: CreateAccountResult
*/
type CreateAccountOp struct {
	// account to create
	Destination AccountID
	// amount they end up with
	StartingBalance Int64
}

/*
Payment

	Send an amount in specified asset to a destination account.

	Threshold: med

	Result: PaymentResult
*/
type PaymentOp struct {
	// recipient of the payment
	Destination MuxedAccount
	// what they end up with
	Asset Asset
	// amount they end up with
	Amount Int64
}

/*
	PathPaymentStrictReceive

send an amount to a destination account through a path.
(up to sendMax, sendAsset)
(X0, Path[0]) .. (Xn, Path[n])
(destAmount, destAsset)

Threshold: med

Result: PathPaymentStrictReceiveResult
*/
type PathPaymentStrictReceiveOp struct {
	// asset we pay with
	SendAsset Asset
	// the maximum amount of sendAsset to
	SendMax Int64
	// recipient of the payment
	Destination MuxedAccount
	// what they end up with
	DestAsset Asset
	// amount they end up with
	DestAmount Int64
	// additional hops it must go through to get there
	Path []Asset // bound 5
}

/*
	PathPaymentStrictSend

send an amount to a destination account through a path.
(sendMax, sendAsset)
(X0, Path[0]) .. (Xn, Path[n])
(at least destAmount, destAsset)

Threshold: med

Result: PathPaymentStrictSendResult
*/
type PathPaymentStrictSendOp struct {
	// asset we pay with
	SendAsset Asset
	// amount of sendAsset to send (excluding fees)
	SendAmount Int64
	// recipient of the payment
	Destination MuxedAccount
	// what they end up with
	DestAsset Asset
	// the minimum amount of dest asset to
	DestMin Int64
	// additional hops it must go through to get there
	Path []Asset // bound 5
}

/*
	Creates, updates or deletes an offer

Threshold: med

Result: ManageSellOfferResult
*/
type ManageSellOfferOp struct {
	Selling Asset
	Buying  Asset
	// amount being sold. if set to 0, delete the offer
	Amount Int64
	// price of thing being sold in terms of what you are buying
	Price Price
	// 0=create a new offer, otherwise edit an existing offer
	OfferID Int64
}

/*
	Creates, updates or deletes an offer with amount in terms of buying asset

Threshold: med

Result: ManageBuyOfferResult
*/
type ManageBuyOfferOp struct {
	Selling Asset
	Buying  Asset
	// amount being bought. if set to 0, delete the offer
	BuyAmount Int64
	// price of thing being bought in terms of what you are
	Price Price
	// 0=create a new offer, otherwise edit an existing offer
	OfferID Int64
}

/*
	Creates an offer that doesn't take offers of the same price

Threshold: med

Result: CreatePassiveSellOfferResult
*/
type CreatePassiveSellOfferOp struct {
	// A
	Selling Asset
	// B
	Buying Asset
	// amount taker gets
	Amount Int64
	// cost of A in terms of B
	Price Price
}

/*
Set Account Options

	updates "AccountEntry" fields.
	note: updating thresholds or signers requires high threshold

	Threshold: med or high

	Result: SetOptionsResult
*/
type SetOptionsOp struct {
	// sets the inflation destination
	InflationDest *AccountID
	// which flags to clear
	ClearFlags *Uint32
	// which flags to set
	SetFlags *Uint32
	// account threshold manipulation
	MasterWeight  *Uint32
	LowThreshold  *Uint32
	MedThreshold  *Uint32
	HighThreshold *Uint32
	// sets the home domain
	HomeDomain *String32
	// Add, update or remove a signer for the account
	// signer is deleted if the weight is 0
	Signer *Signer
}

type ChangeTrustAsset struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_NATIVE:
	//      void
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AlphaNum4() *AlphaNum4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AlphaNum12() *AlphaNum12
	//   ASSET_TYPE_POOL_SHARE:
	//      LiquidityPool() *LiquidityPoolParameters
	Type AssetType
	_u   interface{}
}

/*
Creates, updates or deletes a trust line

	Threshold: med

	Result: ChangeTrustResult
*/
type ChangeTrustOp struct {
	Line ChangeTrustAsset
	// if limit is set to 0, deletes the trust line
	Limit Int64
}

/*
Updates the "authorized" flag of an existing trust line

	this is called by the issuer of the related asset.

	note that authorize can only be set (and not cleared) if
	the issuer account does not have the AUTH_REVOCABLE_FLAG set
	Threshold: low

	Result: AllowTrustResult
*/
type AllowTrustOp struct {
	Trustor AccountID
	Asset   AssetCode
	// One of 0, AUTHORIZED_FLAG, or AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG
	Authorize Uint32
}

/*
ManageData

	Adds, Updates, or Deletes a key value pair associated with a particular
	    account.

	Threshold: med

	Result: ManageDataResult
*/
type ManageDataOp struct {
	DataName String64
	// set to null to clear
	DataValue *DataValue
}

/*
Bump Sequence

	increases the sequence to a given level

	Threshold: low

	Result: BumpSequenceResult
*/
type BumpSequenceOp struct {
	BumpTo SequenceNumber
}

/*
Creates a claimable balance entry

	Threshold: med

	Result: CreateClaimableBalanceResult
*/
type CreateClaimableBalanceOp struct {
	Asset     Asset
	Amount    Int64
	Claimants []Claimant // bound 10
}

/*
Claims a claimable balance entry

	Threshold: low

	Result: ClaimClaimableBalanceResult
*/
type ClaimClaimableBalanceOp struct {
	BalanceID ClaimableBalanceID
}

/*
BeginSponsoringFutureReserves

	Establishes the is-sponsoring-future-reserves-for relationship between
	the source account and sponsoredID

	Threshold: med

	Result: BeginSponsoringFutureReservesResult
*/
type BeginSponsoringFutureReservesOp struct {
	SponsoredID AccountID
}

/*
RevokeSponsorship

	If source account is not sponsored or is sponsored by the owner of the
	specified entry or sub-entry, then attempt to revoke the sponsorship.
	If source account is sponsored, then attempt to transfer the sponsorship
	to the sponsor of source account.

	Threshold: med

	Result: RevokeSponsorshipResult
*/
type RevokeSponsorshipType int32

const (
	REVOKE_SPONSORSHIP_LEDGER_ENTRY RevokeSponsorshipType = 0
	REVOKE_SPONSORSHIP_SIGNER       RevokeSponsorshipType = 1
)

type RevokeSponsorshipOp struct {
	// The union discriminant Type selects among the following arms:
	//   REVOKE_SPONSORSHIP_LEDGER_ENTRY:
	//      LedgerKey() *LedgerKey
	//   REVOKE_SPONSORSHIP_SIGNER:
	//      Signer() *XdrAnon_RevokeSponsorshipOp_Signer
	Type RevokeSponsorshipType
	_u   interface{}
}
type XdrAnon_RevokeSponsorshipOp_Signer struct {
	AccountID AccountID
	SignerKey SignerKey
}

/*
Claws back an amount of an asset from an account

	Threshold: med

	Result: ClawbackResult
*/
type ClawbackOp struct {
	Asset  Asset
	From   MuxedAccount
	Amount Int64
}

/*
Claws back a claimable balance

	Threshold: med

	Result: ClawbackClaimableBalanceResult
*/
type ClawbackClaimableBalanceOp struct {
	BalanceID ClaimableBalanceID
}

/*
SetTrustLineFlagsOp

	Updates the flags of an existing trust line.
	This is called by the issuer of the related asset.

	Threshold: low

	Result: SetTrustLineFlagsResult
*/
type SetTrustLineFlagsOp struct {
	Trustor AccountID
	Asset   Asset
	// which flags to clear
	ClearFlags Uint32
	// which flags to set
	SetFlags Uint32
}

const LIQUIDITY_POOL_FEE_V18 = 30

/*
Deposit assets into a liquidity pool

	Threshold: med

	Result: LiquidityPoolDepositResult
*/
type LiquidityPoolDepositOp struct {
	LiquidityPoolID PoolID
	// maximum amount of first asset to deposit
	MaxAmountA Int64
	// maximum amount of second asset to deposit
	MaxAmountB Int64
	// minimum depositA/depositB
	MinPrice Price
	// maximum depositA/depositB
	MaxPrice Price
}

/*
Withdraw assets from a liquidity pool

	Threshold: med

	Result: LiquidityPoolWithdrawResult
*/
type LiquidityPoolWithdrawOp struct {
	LiquidityPoolID PoolID
	// amount of pool shares to withdraw
	Amount Int64
	// minimum amount of first asset to withdraw
	MinAmountA Int64
	// minimum amount of second asset to withdraw
	MinAmountB Int64
}

type HostFunctionType int32

const (
	HOST_FUNCTION_TYPE_INVOKE_CONTRACT      HostFunctionType = 0
	HOST_FUNCTION_TYPE_CREATE_CONTRACT      HostFunctionType = 1
	HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM HostFunctionType = 2
)

type ContractIDPreimageType int32

const (
	CONTRACT_ID_PREIMAGE_FROM_ADDRESS ContractIDPreimageType = 0
	CONTRACT_ID_PREIMAGE_FROM_ASSET   ContractIDPreimageType = 1
)

type ContractIDPreimage struct {
	// The union discriminant Type selects among the following arms:
	//   CONTRACT_ID_PREIMAGE_FROM_ADDRESS:
	//      FromAddress() *XdrAnon_ContractIDPreimage_FromAddress
	//   CONTRACT_ID_PREIMAGE_FROM_ASSET:
	//      FromAsset() *Asset
	Type ContractIDPreimageType
	_u   interface{}
}
type XdrAnon_ContractIDPreimage_FromAddress struct {
	Address SCAddress
	Salt    Uint256
}

type CreateContractArgs struct {
	ContractIDPreimage ContractIDPreimage
	Executable         ContractExecutable
}

type InvokeContractArgs struct {
	ContractAddress SCAddress
	FunctionName    SCSymbol
	Args            []SCVal
}

type HostFunction struct {
	// The union discriminant Type selects among the following arms:
	//   HOST_FUNCTION_TYPE_INVOKE_CONTRACT:
	//      InvokeContract() *InvokeContractArgs
	//   HOST_FUNCTION_TYPE_CREATE_CONTRACT:
	//      CreateContract() *CreateContractArgs
	//   HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
	//      Wasm() *[]byte
	Type HostFunctionType
	_u   interface{}
}

type SorobanAuthorizedFunctionType int32

const (
	SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN             SorobanAuthorizedFunctionType = 0
	SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN SorobanAuthorizedFunctionType = 1
)

type SorobanAuthorizedFunction struct {
	// The union discriminant Type selects among the following arms:
	//   SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN:
	//      ContractFn() *InvokeContractArgs
	//   SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
	//      CreateContractHostFn() *CreateContractArgs
	Type SorobanAuthorizedFunctionType
	_u   interface{}
}

type SorobanAuthorizedInvocation struct {
	Function       SorobanAuthorizedFunction
	SubInvocations []SorobanAuthorizedInvocation
}

type SorobanAddressCredentials struct {
	Address                   SCAddress
	Nonce                     Int64
	SignatureExpirationLedger Uint32
	Signature                 SCVal
}

type SorobanCredentialsType int32

const (
	SOROBAN_CREDENTIALS_SOURCE_ACCOUNT SorobanCredentialsType = 0
	SOROBAN_CREDENTIALS_ADDRESS        SorobanCredentialsType = 1
)

type SorobanCredentials struct {
	// The union discriminant Type selects among the following arms:
	//   SOROBAN_CREDENTIALS_SOURCE_ACCOUNT:
	//      void
	//   SOROBAN_CREDENTIALS_ADDRESS:
	//      Address() *SorobanAddressCredentials
	Type SorobanCredentialsType
	_u   interface{}
}

/*
Unit of authorization data for Soroban.

	Represents an authorization for executing the tree of authorized contract
	and/or host function calls by the user defined by `credentials`.
*/
type SorobanAuthorizationEntry struct {
	Credentials    SorobanCredentials
	RootInvocation SorobanAuthorizedInvocation
}

/*
Upload Wasm, create, and invoke contracts in Soroban.

	Threshold: med
	Result: InvokeHostFunctionResult
*/
type InvokeHostFunctionOp struct {
	// Host function to invoke.
	HostFunction HostFunction
	// Per-address authorizations for this host function.
	Auth []SorobanAuthorizationEntry
}

/*
Extend the TTL of the entries specified in the readOnly footprint

	so they will live at least extendTo ledgers from lcl.

	 Threshold: low
	 Result: ExtendFootprintTTLResult
*/
type ExtendFootprintTTLOp struct {
	Ext      ExtensionPoint
	ExtendTo Uint32
}

/*
Restore the archived entries specified in the readWrite footprint.

	Threshold: low
	Result: RestoreFootprintOp
*/
type RestoreFootprintOp struct {
	Ext ExtensionPoint
}

/* An operation is the lowest unit of work that a transaction does */
type Operation struct {
	// sourceAccount is the account used to run the operation
	// if not set, the runtime defaults to "sourceAccount" specified at
	// the transaction level
	SourceAccount *MuxedAccount
	Body          XdrAnon_Operation_Body
}
type XdrAnon_Operation_Body struct {
	// The union discriminant Type selects among the following arms:
	//   CREATE_ACCOUNT:
	//      CreateAccountOp() *CreateAccountOp
	//   PAYMENT:
	//      PaymentOp() *PaymentOp
	//   PATH_PAYMENT_STRICT_RECEIVE:
	//      PathPaymentStrictReceiveOp() *PathPaymentStrictReceiveOp
	//   MANAGE_SELL_OFFER:
	//      ManageSellOfferOp() *ManageSellOfferOp
	//   CREATE_PASSIVE_SELL_OFFER:
	//      CreatePassiveSellOfferOp() *CreatePassiveSellOfferOp
	//   SET_OPTIONS:
	//      SetOptionsOp() *SetOptionsOp
	//   CHANGE_TRUST:
	//      ChangeTrustOp() *ChangeTrustOp
	//   ALLOW_TRUST:
	//      AllowTrustOp() *AllowTrustOp
	//   ACCOUNT_MERGE:
	//      Destination() *MuxedAccount
	//   INFLATION:
	//      void
	//   MANAGE_DATA:
	//      ManageDataOp() *ManageDataOp
	//   BUMP_SEQUENCE:
	//      BumpSequenceOp() *BumpSequenceOp
	//   MANAGE_BUY_OFFER:
	//      ManageBuyOfferOp() *ManageBuyOfferOp
	//   PATH_PAYMENT_STRICT_SEND:
	//      PathPaymentStrictSendOp() *PathPaymentStrictSendOp
	//   CREATE_CLAIMABLE_BALANCE:
	//      CreateClaimableBalanceOp() *CreateClaimableBalanceOp
	//   CLAIM_CLAIMABLE_BALANCE:
	//      ClaimClaimableBalanceOp() *ClaimClaimableBalanceOp
	//   BEGIN_SPONSORING_FUTURE_RESERVES:
	//      BeginSponsoringFutureReservesOp() *BeginSponsoringFutureReservesOp
	//   END_SPONSORING_FUTURE_RESERVES:
	//      void
	//   REVOKE_SPONSORSHIP:
	//      RevokeSponsorshipOp() *RevokeSponsorshipOp
	//   CLAWBACK:
	//      ClawbackOp() *ClawbackOp
	//   CLAWBACK_CLAIMABLE_BALANCE:
	//      ClawbackClaimableBalanceOp() *ClawbackClaimableBalanceOp
	//   SET_TRUST_LINE_FLAGS:
	//      SetTrustLineFlagsOp() *SetTrustLineFlagsOp
	//   LIQUIDITY_POOL_DEPOSIT:
	//      LiquidityPoolDepositOp() *LiquidityPoolDepositOp
	//   LIQUIDITY_POOL_WITHDRAW:
	//      LiquidityPoolWithdrawOp() *LiquidityPoolWithdrawOp
	//   INVOKE_HOST_FUNCTION:
	//      InvokeHostFunctionOp() *InvokeHostFunctionOp
	//   EXTEND_FOOTPRINT_TTL:
	//      ExtendFootprintTTLOp() *ExtendFootprintTTLOp
	//   RESTORE_FOOTPRINT:
	//      RestoreFootprintOp() *RestoreFootprintOp
	Type OperationType
	_u   interface{}
}

type HashIDPreimage struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_OP_ID:
	//      OperationID() *XdrAnon_HashIDPreimage_OperationID
	//   ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
	//      RevokeID() *XdrAnon_HashIDPreimage_RevokeID
	//   ENVELOPE_TYPE_CONTRACT_ID:
	//      ContractID() *XdrAnon_HashIDPreimage_ContractID
	//   ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
	//      SorobanAuthorization() *XdrAnon_HashIDPreimage_SorobanAuthorization
	Type EnvelopeType
	_u   interface{}
}
type XdrAnon_HashIDPreimage_OperationID struct {
	SourceAccount AccountID
	SeqNum        SequenceNumber
	OpNum         Uint32
}
type XdrAnon_HashIDPreimage_RevokeID struct {
	SourceAccount   AccountID
	SeqNum          SequenceNumber
	OpNum           Uint32
	LiquidityPoolID PoolID
	Asset           Asset
}
type XdrAnon_HashIDPreimage_ContractID struct {
	NetworkID          Hash
	ContractIDPreimage ContractIDPreimage
}
type XdrAnon_HashIDPreimage_SorobanAuthorization struct {
	NetworkID                 Hash
	Nonce                     Int64
	SignatureExpirationLedger Uint32
	Invocation                SorobanAuthorizedInvocation
}

type MemoType int32

const (
	MEMO_NONE   MemoType = 0
	MEMO_TEXT   MemoType = 1
	MEMO_ID     MemoType = 2
	MEMO_HASH   MemoType = 3
	MEMO_RETURN MemoType = 4
)

type Memo struct {
	// The union discriminant Type selects among the following arms:
	//   MEMO_NONE:
	//      void
	//   MEMO_TEXT:
	//      Text() *string // bound 28
	//   MEMO_ID:
	//      Id() *Uint64
	//   MEMO_HASH:
	//      Hash() *Hash
	//   MEMO_RETURN:
	//      RetHash() *Hash
	Type MemoType
	_u   interface{}
}

type TimeBounds struct {
	MinTime TimePoint
	// 0 here means no maxTime
	MaxTime TimePoint
}

type LedgerBounds struct {
	MinLedger Uint32
	// 0 here means no maxLedger
	MaxLedger Uint32
}

type PreconditionsV2 struct {
	TimeBounds *TimeBounds
	// Transaction only valid for ledger numbers n such that
	// minLedger <= n < maxLedger (if maxLedger == 0, then
	// only minLedger is checked)
	LedgerBounds *LedgerBounds
	// If NULL, only valid when sourceAccount's sequence number
	// is seqNum - 1.  Otherwise, valid when sourceAccount's
	// sequence number n satisfies minSeqNum <= n < tx.seqNum.
	// Note that after execution the account's sequence number
	// is always raised to tx.seqNum, and a transaction is not
	// valid if tx.seqNum is too high to ensure replay protection.
	MinSeqNum *SequenceNumber
	// For the transaction to be valid, the current ledger time must
	// be at least minSeqAge greater than sourceAccount's seqTime.
	MinSeqAge Duration
	// For the transaction to be valid, the current ledger number
	// must be at least minSeqLedgerGap greater than sourceAccount's
	// seqLedger.
	MinSeqLedgerGap Uint32
	// For the transaction to be valid, there must be a signature
	// corresponding to every Signer in this array, even if the
	// signature is not otherwise required by the sourceAccount or
	// operations.
	ExtraSigners []SignerKey // bound 2
}

type PreconditionType int32

const (
	PRECOND_NONE PreconditionType = 0
	PRECOND_TIME PreconditionType = 1
	PRECOND_V2   PreconditionType = 2
)

type Preconditions struct {
	// The union discriminant Type selects among the following arms:
	//   PRECOND_NONE:
	//      void
	//   PRECOND_TIME:
	//      TimeBounds() *TimeBounds
	//   PRECOND_V2:
	//      V2() *PreconditionsV2
	Type PreconditionType
	_u   interface{}
}

// Ledger key sets touched by a smart contract transaction.
type LedgerFootprint struct {
	ReadOnly  []LedgerKey
	ReadWrite []LedgerKey
}

// Resource limits for a Soroban transaction.
// The transaction will fail if it exceeds any of these limits.
type SorobanResources struct {
	// The ledger footprint of the transaction.
	Footprint LedgerFootprint
	// The maximum number of instructions this transaction can use
	Instructions Uint32
	// The maximum number of bytes this transaction can read from ledger
	ReadBytes Uint32
	// The maximum number of bytes this transaction can write to ledger
	WriteBytes Uint32
}

// The transaction extension for Soroban.
type SorobanTransactionData struct {
	Ext       ExtensionPoint
	Resources SorobanResources
	// Amount of the transaction `fee` allocated to the Soroban resource fees.
	// The fraction of `resourceFee` corresponding to `resources` specified
	// above is *not* refundable (i.e. fees for instructions, ledger I/O), as
	// well as fees for the transaction size.
	// The remaining part of the fee is refundable and the charged value is
	// based on the actual consumption of refundable resources (events, ledger
	// rent bumps).
	// The `inclusionFee` used for prioritization of the transaction is defined
	// as `tx.fee - resourceFee`.
	ResourceFee Int64
}

// TransactionV0 is a transaction with the AccountID discriminant stripped off,
// leaving a raw ed25519 public key to identify the source account. This is used
// for backwards compatibility starting from the protocol 12/13 boundary. If an
// "old-style" TransactionEnvelope containing a Transaction is parsed with this
// XDR definition, it will be parsed as a "new-style" TransactionEnvelope
// containing a TransactionV0.
type TransactionV0 struct {
	SourceAccountEd25519 Uint256
	Fee                  Uint32
	SeqNum               SequenceNumber
	TimeBounds           *TimeBounds
	Memo                 Memo
	Operations           []Operation // bound MAX_OPS_PER_TX
	Ext                  XdrAnon_TransactionV0_Ext
}
type XdrAnon_TransactionV0_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type TransactionV0Envelope struct {
	Tx TransactionV0
	/* Each decorated signature is a signature over the SHA256 hash of
	 * a TransactionSignaturePayload */
	Signatures []DecoratedSignature // bound 20
}

/*
a transaction is a container for a set of operations
  - is executed by an account
  - fees are collected from the account
  - operations are executed in order as one ACID transaction
    either all operations are applied or none are
    if any returns a failing code
*/
type Transaction struct {
	// account used to run the transaction
	SourceAccount MuxedAccount
	// the fee the sourceAccount will pay
	Fee Uint32
	// sequence number to consume in the account
	SeqNum SequenceNumber
	// validity conditions
	Cond       Preconditions
	Memo       Memo
	Operations []Operation // bound MAX_OPS_PER_TX
	Ext        XdrAnon_Transaction_Ext
}

// reserved for future use
type XdrAnon_Transaction_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      SorobanData() *SorobanTransactionData
	V  int32
	_u interface{}
}

type TransactionV1Envelope struct {
	Tx Transaction
	/* Each decorated signature is a signature over the SHA256 hash of
	 * a TransactionSignaturePayload */
	Signatures []DecoratedSignature // bound 20
}

type FeeBumpTransaction struct {
	FeeSource MuxedAccount
	Fee       Int64
	InnerTx   XdrAnon_FeeBumpTransaction_InnerTx
	Ext       XdrAnon_FeeBumpTransaction_Ext
}
type XdrAnon_FeeBumpTransaction_InnerTx struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_TX:
	//      V1() *TransactionV1Envelope
	Type EnvelopeType
	_u   interface{}
}
type XdrAnon_FeeBumpTransaction_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type FeeBumpTransactionEnvelope struct {
	Tx FeeBumpTransaction
	/* Each decorated signature is a signature over the SHA256 hash of
	 * a TransactionSignaturePayload */
	Signatures []DecoratedSignature // bound 20
}

/* A TransactionEnvelope wraps a transaction with signatures. */
type TransactionEnvelope struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_TX_V0:
	//      V0() *TransactionV0Envelope
	//   ENVELOPE_TYPE_TX:
	//      V1() *TransactionV1Envelope
	//   ENVELOPE_TYPE_TX_FEE_BUMP:
	//      FeeBump() *FeeBumpTransactionEnvelope
	Type EnvelopeType
	_u   interface{}
}

type TransactionSignaturePayload struct {
	NetworkId         Hash
	TaggedTransaction XdrAnon_TransactionSignaturePayload_TaggedTransaction
}
type XdrAnon_TransactionSignaturePayload_TaggedTransaction struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_TX:
	//      Tx() *Transaction
	//   ENVELOPE_TYPE_TX_FEE_BUMP:
	//      FeeBump() *FeeBumpTransaction
	Type EnvelopeType
	_u   interface{}
}

type ClaimAtomType int32

const (
	CLAIM_ATOM_TYPE_V0             ClaimAtomType = 0
	CLAIM_ATOM_TYPE_ORDER_BOOK     ClaimAtomType = 1
	CLAIM_ATOM_TYPE_LIQUIDITY_POOL ClaimAtomType = 2
)

// ClaimOfferAtomV0 is a ClaimOfferAtom with the AccountID discriminant stripped
// off, leaving a raw ed25519 public key to identify the source account. This is
// used for backwards compatibility starting from the protocol 17/18 boundary.
// If an "old-style" ClaimOfferAtom is parsed with this XDR definition, it will
// be parsed as a "new-style" ClaimAtom containing a ClaimOfferAtomV0.
type ClaimOfferAtomV0 struct {
	// emitted to identify the offer
	SellerEd25519 Uint256
	OfferID       Int64
	// amount and asset taken from the owner
	AssetSold  Asset
	AmountSold Int64
	// amount and asset sent to the owner
	AssetBought  Asset
	AmountBought Int64
}

type ClaimOfferAtom struct {
	// emitted to identify the offer
	SellerID AccountID
	OfferID  Int64
	// amount and asset taken from the owner
	AssetSold  Asset
	AmountSold Int64
	// amount and asset sent to the owner
	AssetBought  Asset
	AmountBought Int64
}

type ClaimLiquidityAtom struct {
	LiquidityPoolID PoolID
	// amount and asset taken from the pool
	AssetSold  Asset
	AmountSold Int64
	// amount and asset sent to the pool
	AssetBought  Asset
	AmountBought Int64
}

/*
This result is used when offers are taken or liquidity is exchanged with a

	liquidity pool during an operation
*/
type ClaimAtom struct {
	// The union discriminant Type selects among the following arms:
	//   CLAIM_ATOM_TYPE_V0:
	//      V0() *ClaimOfferAtomV0
	//   CLAIM_ATOM_TYPE_ORDER_BOOK:
	//      OrderBook() *ClaimOfferAtom
	//   CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
	//      LiquidityPool() *ClaimLiquidityAtom
	Type ClaimAtomType
	_u   interface{}
}

type CreateAccountResultCode int32

const (
	// account was created
	CREATE_ACCOUNT_SUCCESS CreateAccountResultCode = 0
	// invalid destination
	CREATE_ACCOUNT_MALFORMED CreateAccountResultCode = -1
	// not enough funds in source account
	CREATE_ACCOUNT_UNDERFUNDED CreateAccountResultCode = -2
	// would create an account below the min reserve
	CREATE_ACCOUNT_LOW_RESERVE CreateAccountResultCode = -3
	// account already exists
	CREATE_ACCOUNT_ALREADY_EXIST CreateAccountResultCode = -4
)

type CreateAccountResult struct {
	// The union discriminant Code selects among the following arms:
	//   CREATE_ACCOUNT_SUCCESS:
	//      void
	//   CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
	//      void
	Code CreateAccountResultCode
	_u   interface{}
}

type PaymentResultCode int32

const (
	// payment successfully completed
	PAYMENT_SUCCESS PaymentResultCode = 0
	// bad input
	PAYMENT_MALFORMED PaymentResultCode = -1
	// not enough funds in source account
	PAYMENT_UNDERFUNDED PaymentResultCode = -2
	// no trust line on source account
	PAYMENT_SRC_NO_TRUST PaymentResultCode = -3
	// source not authorized to transfer
	PAYMENT_SRC_NOT_AUTHORIZED PaymentResultCode = -4
	// destination account does not exist
	PAYMENT_NO_DESTINATION PaymentResultCode = -5
	// destination missing a trust line for asset
	PAYMENT_NO_TRUST PaymentResultCode = -6
	// destination not authorized to hold asset
	PAYMENT_NOT_AUTHORIZED PaymentResultCode = -7
	// destination would go above their limit
	PAYMENT_LINE_FULL PaymentResultCode = -8
	// missing issuer on asset
	PAYMENT_NO_ISSUER PaymentResultCode = -9
)

type PaymentResult struct {
	// The union discriminant Code selects among the following arms:
	//   PAYMENT_SUCCESS:
	//      void
	//   PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
	//      void
	Code PaymentResultCode
	_u   interface{}
}

type PathPaymentStrictReceiveResultCode int32

const (
	// success
	PATH_PAYMENT_STRICT_RECEIVE_SUCCESS PathPaymentStrictReceiveResultCode = 0
	// bad input
	PATH_PAYMENT_STRICT_RECEIVE_MALFORMED PathPaymentStrictReceiveResultCode = -1
	// not enough funds in source account
	PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED PathPaymentStrictReceiveResultCode = -2
	// no trust line on source account
	PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST PathPaymentStrictReceiveResultCode = -3
	// source not authorized to transfer
	PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED PathPaymentStrictReceiveResultCode = -4
	// destination account does not exist
	PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION PathPaymentStrictReceiveResultCode = -5
	// dest missing a trust line for asset
	PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST PathPaymentStrictReceiveResultCode = -6
	// dest not authorized to hold asset
	PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED PathPaymentStrictReceiveResultCode = -7
	// dest would go above their limit
	PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL PathPaymentStrictReceiveResultCode = -8
	// missing issuer on one asset
	PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER PathPaymentStrictReceiveResultCode = -9
	// not enough offers to satisfy path
	PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS PathPaymentStrictReceiveResultCode = -10
	// would cross one of its own offers
	PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF PathPaymentStrictReceiveResultCode = -11
	// could not satisfy sendmax
	PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX PathPaymentStrictReceiveResultCode = -12
)

type SimplePaymentResult struct {
	Destination AccountID
	Asset       Asset
	Amount      Int64
}

type PathPaymentStrictReceiveResult struct {
	// The union discriminant Code selects among the following arms:
	//   PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
	//      Success() *XdrAnon_PathPaymentStrictReceiveResult_Success
	//   PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
	//      void
	//   PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
	//      NoIssuer() *Asset
	//   PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
	//      void
	Code PathPaymentStrictReceiveResultCode
	_u   interface{}
}
type XdrAnon_PathPaymentStrictReceiveResult_Success struct {
	Offers []ClaimAtom
	Last   SimplePaymentResult
}

type PathPaymentStrictSendResultCode int32

const (
	// success
	PATH_PAYMENT_STRICT_SEND_SUCCESS PathPaymentStrictSendResultCode = 0
	// bad input
	PATH_PAYMENT_STRICT_SEND_MALFORMED PathPaymentStrictSendResultCode = -1
	// not enough funds in source account
	PATH_PAYMENT_STRICT_SEND_UNDERFUNDED PathPaymentStrictSendResultCode = -2
	// no trust line on source account
	PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST PathPaymentStrictSendResultCode = -3
	// source not authorized to transfer
	PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED PathPaymentStrictSendResultCode = -4
	// destination account does not exist
	PATH_PAYMENT_STRICT_SEND_NO_DESTINATION PathPaymentStrictSendResultCode = -5
	// dest missing a trust line for asset
	PATH_PAYMENT_STRICT_SEND_NO_TRUST PathPaymentStrictSendResultCode = -6
	// dest not authorized to hold asset
	PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED PathPaymentStrictSendResultCode = -7
	// dest would go above their limit
	PATH_PAYMENT_STRICT_SEND_LINE_FULL PathPaymentStrictSendResultCode = -8
	// missing issuer on one asset
	PATH_PAYMENT_STRICT_SEND_NO_ISSUER PathPaymentStrictSendResultCode = -9
	// not enough offers to satisfy path
	PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS PathPaymentStrictSendResultCode = -10
	// would cross one of its own offers
	PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF PathPaymentStrictSendResultCode = -11
	// could not satisfy destMin
	PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN PathPaymentStrictSendResultCode = -12
)

type PathPaymentStrictSendResult struct {
	// The union discriminant Code selects among the following arms:
	//   PATH_PAYMENT_STRICT_SEND_SUCCESS:
	//      Success() *XdrAnon_PathPaymentStrictSendResult_Success
	//   PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL:
	//      void
	//   PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
	//      NoIssuer() *Asset
	//   PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
	//      void
	Code PathPaymentStrictSendResultCode
	_u   interface{}
}
type XdrAnon_PathPaymentStrictSendResult_Success struct {
	Offers []ClaimAtom
	Last   SimplePaymentResult
}

type ManageSellOfferResultCode int32

const (
	// codes considered as "success" for the operation
	MANAGE_SELL_OFFER_SUCCESS ManageSellOfferResultCode = 0
	// generated offer would be invalid
	MANAGE_SELL_OFFER_MALFORMED ManageSellOfferResultCode = -1
	// no trust line for what we're selling
	MANAGE_SELL_OFFER_SELL_NO_TRUST ManageSellOfferResultCode = -2
	// no trust line for what we're buying
	MANAGE_SELL_OFFER_BUY_NO_TRUST ManageSellOfferResultCode = -3
	// not authorized to sell
	MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED ManageSellOfferResultCode = -4
	// not authorized to buy
	MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED ManageSellOfferResultCode = -5
	// can't receive more of what it's buying
	MANAGE_SELL_OFFER_LINE_FULL ManageSellOfferResultCode = -6
	// doesn't hold what it's trying to sell
	MANAGE_SELL_OFFER_UNDERFUNDED ManageSellOfferResultCode = -7
	// would cross an offer from the same user
	MANAGE_SELL_OFFER_CROSS_SELF ManageSellOfferResultCode = -8
	// no issuer for what we're selling
	MANAGE_SELL_OFFER_SELL_NO_ISSUER ManageSellOfferResultCode = -9
	// no issuer for what we're buying
	MANAGE_SELL_OFFER_BUY_NO_ISSUER ManageSellOfferResultCode = -10
	// offerID does not match an existing offer
	MANAGE_SELL_OFFER_NOT_FOUND ManageSellOfferResultCode = -11
	// not enough funds to create a new Offer
	MANAGE_SELL_OFFER_LOW_RESERVE ManageSellOfferResultCode = -12
)

type ManageOfferEffect int32

const (
	MANAGE_OFFER_CREATED ManageOfferEffect = 0
	MANAGE_OFFER_UPDATED ManageOfferEffect = 1
	MANAGE_OFFER_DELETED ManageOfferEffect = 2
)

type ManageOfferSuccessResult struct {
	// offers that got claimed while creating this offer
	OffersClaimed []ClaimAtom
	Offer         XdrAnon_ManageOfferSuccessResult_Offer
}
type XdrAnon_ManageOfferSuccessResult_Offer struct {
	// The union discriminant Effect selects among the following arms:
	//   MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
	//      Offer() *OfferEntry
	//   MANAGE_OFFER_DELETED:
	//      void
	Effect ManageOfferEffect
	_u     interface{}
}

type ManageSellOfferResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_SELL_OFFER_SUCCESS:
	//      Success() *ManageOfferSuccessResult
	//   MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
	//      void
	Code ManageSellOfferResultCode
	_u   interface{}
}

type ManageBuyOfferResultCode int32

const (
	// codes considered as "success" for the operation
	MANAGE_BUY_OFFER_SUCCESS ManageBuyOfferResultCode = 0
	// generated offer would be invalid
	MANAGE_BUY_OFFER_MALFORMED ManageBuyOfferResultCode = -1
	// no trust line for what we're selling
	MANAGE_BUY_OFFER_SELL_NO_TRUST ManageBuyOfferResultCode = -2
	// no trust line for what we're buying
	MANAGE_BUY_OFFER_BUY_NO_TRUST ManageBuyOfferResultCode = -3
	// not authorized to sell
	MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED ManageBuyOfferResultCode = -4
	// not authorized to buy
	MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED ManageBuyOfferResultCode = -5
	// can't receive more of what it's buying
	MANAGE_BUY_OFFER_LINE_FULL ManageBuyOfferResultCode = -6
	// doesn't hold what it's trying to sell
	MANAGE_BUY_OFFER_UNDERFUNDED ManageBuyOfferResultCode = -7
	// would cross an offer from the same user
	MANAGE_BUY_OFFER_CROSS_SELF ManageBuyOfferResultCode = -8
	// no issuer for what we're selling
	MANAGE_BUY_OFFER_SELL_NO_ISSUER ManageBuyOfferResultCode = -9
	// no issuer for what we're buying
	MANAGE_BUY_OFFER_BUY_NO_ISSUER ManageBuyOfferResultCode = -10
	// offerID does not match an existing offer
	MANAGE_BUY_OFFER_NOT_FOUND ManageBuyOfferResultCode = -11
	// not enough funds to create a new Offer
	MANAGE_BUY_OFFER_LOW_RESERVE ManageBuyOfferResultCode = -12
)

type ManageBuyOfferResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_BUY_OFFER_SUCCESS:
	//      Success() *ManageOfferSuccessResult
	//   MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
	//      void
	Code ManageBuyOfferResultCode
	_u   interface{}
}

type SetOptionsResultCode int32

const (
	// codes considered as "success" for the operation
	SET_OPTIONS_SUCCESS SetOptionsResultCode = 0
	// not enough funds to add a signer
	SET_OPTIONS_LOW_RESERVE SetOptionsResultCode = -1
	// max number of signers already reached
	SET_OPTIONS_TOO_MANY_SIGNERS SetOptionsResultCode = -2
	// invalid combination of clear/set flags
	SET_OPTIONS_BAD_FLAGS SetOptionsResultCode = -3
	// inflation account does not exist
	SET_OPTIONS_INVALID_INFLATION SetOptionsResultCode = -4
	// can no longer change this option
	SET_OPTIONS_CANT_CHANGE SetOptionsResultCode = -5
	// can't set an unknown flag
	SET_OPTIONS_UNKNOWN_FLAG SetOptionsResultCode = -6
	// bad value for weight/threshold
	SET_OPTIONS_THRESHOLD_OUT_OF_RANGE SetOptionsResultCode = -7
	// signer cannot be masterkey
	SET_OPTIONS_BAD_SIGNER SetOptionsResultCode = -8
	// malformed home domain
	SET_OPTIONS_INVALID_HOME_DOMAIN SetOptionsResultCode = -9
	// auth revocable is required for clawback
	SET_OPTIONS_AUTH_REVOCABLE_REQUIRED SetOptionsResultCode = -10
)

type SetOptionsResult struct {
	// The union discriminant Code selects among the following arms:
	//   SET_OPTIONS_SUCCESS:
	//      void
	//   SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
	//      void
	Code SetOptionsResultCode
	_u   interface{}
}

type ChangeTrustResultCode int32

const (
	// codes considered as "success" for the operation
	CHANGE_TRUST_SUCCESS ChangeTrustResultCode = 0
	// bad input
	CHANGE_TRUST_MALFORMED ChangeTrustResultCode = -1
	// could not find issuer
	CHANGE_TRUST_NO_ISSUER ChangeTrustResultCode = -2
	// cannot drop limit below balance
	CHANGE_TRUST_INVALID_LIMIT ChangeTrustResultCode = -3
	// not enough funds to create a new trust line,
	CHANGE_TRUST_LOW_RESERVE ChangeTrustResultCode = -4
	// trusting self is not allowed
	CHANGE_TRUST_SELF_NOT_ALLOWED ChangeTrustResultCode = -5
	// Asset trustline is missing for pool
	CHANGE_TRUST_TRUST_LINE_MISSING ChangeTrustResultCode = -6
	// Asset trustline is still referenced in a pool
	CHANGE_TRUST_CANNOT_DELETE ChangeTrustResultCode = -7
	// Asset trustline is deauthorized
	CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES ChangeTrustResultCode = -8
)

type ChangeTrustResult struct {
	// The union discriminant Code selects among the following arms:
	//   CHANGE_TRUST_SUCCESS:
	//      void
	//   CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
	//      void
	Code ChangeTrustResultCode
	_u   interface{}
}

type AllowTrustResultCode int32

const (
	// codes considered as "success" for the operation
	ALLOW_TRUST_SUCCESS AllowTrustResultCode = 0
	// asset is not ASSET_TYPE_ALPHANUM
	ALLOW_TRUST_MALFORMED AllowTrustResultCode = -1
	// trustor does not have a trustline
	ALLOW_TRUST_NO_TRUST_LINE AllowTrustResultCode = -2
	// source account does not require trust
	ALLOW_TRUST_TRUST_NOT_REQUIRED AllowTrustResultCode = -3
	// source account can't revoke trust,
	ALLOW_TRUST_CANT_REVOKE AllowTrustResultCode = -4
	// trusting self is not allowed
	ALLOW_TRUST_SELF_NOT_ALLOWED AllowTrustResultCode = -5
	// claimable balances can't be created
	ALLOW_TRUST_LOW_RESERVE AllowTrustResultCode = -6
)

type AllowTrustResult struct {
	// The union discriminant Code selects among the following arms:
	//   ALLOW_TRUST_SUCCESS:
	//      void
	//   ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
	//      void
	Code AllowTrustResultCode
	_u   interface{}
}

type AccountMergeResultCode int32

const (
	// codes considered as "success" for the operation
	ACCOUNT_MERGE_SUCCESS AccountMergeResultCode = 0
	// can't merge onto itself
	ACCOUNT_MERGE_MALFORMED AccountMergeResultCode = -1
	// destination does not exist
	ACCOUNT_MERGE_NO_ACCOUNT AccountMergeResultCode = -2
	// source account has AUTH_IMMUTABLE set
	ACCOUNT_MERGE_IMMUTABLE_SET AccountMergeResultCode = -3
	// account has trust lines/offers
	ACCOUNT_MERGE_HAS_SUB_ENTRIES AccountMergeResultCode = -4
	// sequence number is over max allowed
	ACCOUNT_MERGE_SEQNUM_TOO_FAR AccountMergeResultCode = -5
	// can't add source balance to
	ACCOUNT_MERGE_DEST_FULL AccountMergeResultCode = -6
	// destination balance
	ACCOUNT_MERGE_IS_SPONSOR AccountMergeResultCode = -7
)

type AccountMergeResult struct {
	// The union discriminant Code selects among the following arms:
	//   ACCOUNT_MERGE_SUCCESS:
	//      SourceAccountBalance() *Int64
	//   ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
	//      void
	Code AccountMergeResultCode
	_u   interface{}
}

type InflationResultCode int32

const (
	// codes considered as "success" for the operation
	INFLATION_SUCCESS InflationResultCode = 0
	// codes considered as "failure" for the operation
	INFLATION_NOT_TIME InflationResultCode = -1
)

type InflationPayout struct {
	Destination AccountID
	Amount      Int64
}

type InflationResult struct {
	// The union discriminant Code selects among the following arms:
	//   INFLATION_SUCCESS:
	//      Payouts() *[]InflationPayout
	//   INFLATION_NOT_TIME:
	//      void
	Code InflationResultCode
	_u   interface{}
}

type ManageDataResultCode int32

const (
	// codes considered as "success" for the operation
	MANAGE_DATA_SUCCESS ManageDataResultCode = 0
	// The network hasn't moved to this protocol change yet
	MANAGE_DATA_NOT_SUPPORTED_YET ManageDataResultCode = -1
	// Trying to remove a Data Entry that isn't there
	MANAGE_DATA_NAME_NOT_FOUND ManageDataResultCode = -2
	// not enough funds to create a new Data Entry
	MANAGE_DATA_LOW_RESERVE ManageDataResultCode = -3
	// Name not a valid string
	MANAGE_DATA_INVALID_NAME ManageDataResultCode = -4
)

type ManageDataResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_DATA_SUCCESS:
	//      void
	//   MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
	//      void
	Code ManageDataResultCode
	_u   interface{}
}

type BumpSequenceResultCode int32

const (
	// codes considered as "success" for the operation
	BUMP_SEQUENCE_SUCCESS BumpSequenceResultCode = 0
	// codes considered as "failure" for the operation
	BUMP_SEQUENCE_BAD_SEQ BumpSequenceResultCode = -1
)

type BumpSequenceResult struct {
	// The union discriminant Code selects among the following arms:
	//   BUMP_SEQUENCE_SUCCESS:
	//      void
	//   BUMP_SEQUENCE_BAD_SEQ:
	//      void
	Code BumpSequenceResultCode
	_u   interface{}
}

type CreateClaimableBalanceResultCode int32

const (
	CREATE_CLAIMABLE_BALANCE_SUCCESS        CreateClaimableBalanceResultCode = 0
	CREATE_CLAIMABLE_BALANCE_MALFORMED      CreateClaimableBalanceResultCode = -1
	CREATE_CLAIMABLE_BALANCE_LOW_RESERVE    CreateClaimableBalanceResultCode = -2
	CREATE_CLAIMABLE_BALANCE_NO_TRUST       CreateClaimableBalanceResultCode = -3
	CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED CreateClaimableBalanceResultCode = -4
	CREATE_CLAIMABLE_BALANCE_UNDERFUNDED    CreateClaimableBalanceResultCode = -5
)

type CreateClaimableBalanceResult struct {
	// The union discriminant Code selects among the following arms:
	//   CREATE_CLAIMABLE_BALANCE_SUCCESS:
	//      BalanceID() *ClaimableBalanceID
	//   CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
	//      void
	Code CreateClaimableBalanceResultCode
	_u   interface{}
}

type ClaimClaimableBalanceResultCode int32

const (
	CLAIM_CLAIMABLE_BALANCE_SUCCESS        ClaimClaimableBalanceResultCode = 0
	CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST ClaimClaimableBalanceResultCode = -1
	CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM   ClaimClaimableBalanceResultCode = -2
	CLAIM_CLAIMABLE_BALANCE_LINE_FULL      ClaimClaimableBalanceResultCode = -3
	CLAIM_CLAIMABLE_BALANCE_NO_TRUST       ClaimClaimableBalanceResultCode = -4
	CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED ClaimClaimableBalanceResultCode = -5
)

type ClaimClaimableBalanceResult struct {
	// The union discriminant Code selects among the following arms:
	//   CLAIM_CLAIMABLE_BALANCE_SUCCESS:
	//      void
	//   CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
	//      void
	Code ClaimClaimableBalanceResultCode
	_u   interface{}
}

type BeginSponsoringFutureReservesResultCode int32

const (
	// codes considered as "success" for the operation
	BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS BeginSponsoringFutureReservesResultCode = 0
	// codes considered as "failure" for the operation
	BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED         BeginSponsoringFutureReservesResultCode = -1
	BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED BeginSponsoringFutureReservesResultCode = -2
	BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE         BeginSponsoringFutureReservesResultCode = -3
)

type BeginSponsoringFutureReservesResult struct {
	// The union discriminant Code selects among the following arms:
	//   BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
	//      void
	//   BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
	//      void
	Code BeginSponsoringFutureReservesResultCode
	_u   interface{}
}

type EndSponsoringFutureReservesResultCode int32

const (
	// codes considered as "success" for the operation
	END_SPONSORING_FUTURE_RESERVES_SUCCESS EndSponsoringFutureReservesResultCode = 0
	// codes considered as "failure" for the operation
	END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED EndSponsoringFutureReservesResultCode = -1
)

type EndSponsoringFutureReservesResult struct {
	// The union discriminant Code selects among the following arms:
	//   END_SPONSORING_FUTURE_RESERVES_SUCCESS:
	//      void
	//   END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
	//      void
	Code EndSponsoringFutureReservesResultCode
	_u   interface{}
}

type RevokeSponsorshipResultCode int32

const (
	// codes considered as "success" for the operation
	REVOKE_SPONSORSHIP_SUCCESS RevokeSponsorshipResultCode = 0
	// codes considered as "failure" for the operation
	REVOKE_SPONSORSHIP_DOES_NOT_EXIST    RevokeSponsorshipResultCode = -1
	REVOKE_SPONSORSHIP_NOT_SPONSOR       RevokeSponsorshipResultCode = -2
	REVOKE_SPONSORSHIP_LOW_RESERVE       RevokeSponsorshipResultCode = -3
	REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE RevokeSponsorshipResultCode = -4
	REVOKE_SPONSORSHIP_MALFORMED         RevokeSponsorshipResultCode = -5
)

type RevokeSponsorshipResult struct {
	// The union discriminant Code selects among the following arms:
	//   REVOKE_SPONSORSHIP_SUCCESS:
	//      void
	//   REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
	//      void
	Code RevokeSponsorshipResultCode
	_u   interface{}
}

type ClawbackResultCode int32

const (
	// codes considered as "success" for the operation
	CLAWBACK_SUCCESS ClawbackResultCode = 0
	// codes considered as "failure" for the operation
	CLAWBACK_MALFORMED            ClawbackResultCode = -1
	CLAWBACK_NOT_CLAWBACK_ENABLED ClawbackResultCode = -2
	CLAWBACK_NO_TRUST             ClawbackResultCode = -3
	CLAWBACK_UNDERFUNDED          ClawbackResultCode = -4
)

type ClawbackResult struct {
	// The union discriminant Code selects among the following arms:
	//   CLAWBACK_SUCCESS:
	//      void
	//   CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
	//      void
	Code ClawbackResultCode
	_u   interface{}
}

type ClawbackClaimableBalanceResultCode int32

const (
	// codes considered as "success" for the operation
	CLAWBACK_CLAIMABLE_BALANCE_SUCCESS ClawbackClaimableBalanceResultCode = 0
	// codes considered as "failure" for the operation
	CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST       ClawbackClaimableBalanceResultCode = -1
	CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER           ClawbackClaimableBalanceResultCode = -2
	CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED ClawbackClaimableBalanceResultCode = -3
)

type ClawbackClaimableBalanceResult struct {
	// The union discriminant Code selects among the following arms:
	//   CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
	//      void
	//   CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
	//      void
	Code ClawbackClaimableBalanceResultCode
	_u   interface{}
}

type SetTrustLineFlagsResultCode int32

const (
	// codes considered as "success" for the operation
	SET_TRUST_LINE_FLAGS_SUCCESS SetTrustLineFlagsResultCode = 0
	// codes considered as "failure" for the operation
	SET_TRUST_LINE_FLAGS_MALFORMED     SetTrustLineFlagsResultCode = -1
	SET_TRUST_LINE_FLAGS_NO_TRUST_LINE SetTrustLineFlagsResultCode = -2
	SET_TRUST_LINE_FLAGS_CANT_REVOKE   SetTrustLineFlagsResultCode = -3
	SET_TRUST_LINE_FLAGS_INVALID_STATE SetTrustLineFlagsResultCode = -4
	// claimable balances can't be created
	SET_TRUST_LINE_FLAGS_LOW_RESERVE SetTrustLineFlagsResultCode = -5
)

type SetTrustLineFlagsResult struct {
	// The union discriminant Code selects among the following arms:
	//   SET_TRUST_LINE_FLAGS_SUCCESS:
	//      void
	//   SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
	//      void
	Code SetTrustLineFlagsResultCode
	_u   interface{}
}

type LiquidityPoolDepositResultCode int32

const (
	// codes considered as "success" for the operation
	LIQUIDITY_POOL_DEPOSIT_SUCCESS LiquidityPoolDepositResultCode = 0
	// bad input
	LIQUIDITY_POOL_DEPOSIT_MALFORMED LiquidityPoolDepositResultCode = -1
	// no trust line for one of the
	LIQUIDITY_POOL_DEPOSIT_NO_TRUST LiquidityPoolDepositResultCode = -2
	// not authorized for one of the
	LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED LiquidityPoolDepositResultCode = -3
	// not enough balance for one of
	LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED LiquidityPoolDepositResultCode = -4
	// pool share trust line doesn't
	LIQUIDITY_POOL_DEPOSIT_LINE_FULL LiquidityPoolDepositResultCode = -5
	// deposit price outside bounds
	LIQUIDITY_POOL_DEPOSIT_BAD_PRICE LiquidityPoolDepositResultCode = -6
	// pool reserves are full
	LIQUIDITY_POOL_DEPOSIT_POOL_FULL LiquidityPoolDepositResultCode = -7
)

type LiquidityPoolDepositResult struct {
	// The union discriminant Code selects among the following arms:
	//   LIQUIDITY_POOL_DEPOSIT_SUCCESS:
	//      void
	//   LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
	//      void
	Code LiquidityPoolDepositResultCode
	_u   interface{}
}

type LiquidityPoolWithdrawResultCode int32

const (
	// codes considered as "success" for the operation
	LIQUIDITY_POOL_WITHDRAW_SUCCESS LiquidityPoolWithdrawResultCode = 0
	// bad input
	LIQUIDITY_POOL_WITHDRAW_MALFORMED LiquidityPoolWithdrawResultCode = -1
	// no trust line for one of the
	LIQUIDITY_POOL_WITHDRAW_NO_TRUST LiquidityPoolWithdrawResultCode = -2
	// not enough balance of the
	LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED LiquidityPoolWithdrawResultCode = -3
	// would go above limit for one
	LIQUIDITY_POOL_WITHDRAW_LINE_FULL LiquidityPoolWithdrawResultCode = -4
	// of the assets
	LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM LiquidityPoolWithdrawResultCode = -5
)

type LiquidityPoolWithdrawResult struct {
	// The union discriminant Code selects among the following arms:
	//   LIQUIDITY_POOL_WITHDRAW_SUCCESS:
	//      void
	//   LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
	//      void
	Code LiquidityPoolWithdrawResultCode
	_u   interface{}
}

type InvokeHostFunctionResultCode int32

const (
	// codes considered as "success" for the operation
	INVOKE_HOST_FUNCTION_SUCCESS InvokeHostFunctionResultCode = 0
	// codes considered as "failure" for the operation
	INVOKE_HOST_FUNCTION_MALFORMED                   InvokeHostFunctionResultCode = -1
	INVOKE_HOST_FUNCTION_TRAPPED                     InvokeHostFunctionResultCode = -2
	INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED     InvokeHostFunctionResultCode = -3
	INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED              InvokeHostFunctionResultCode = -4
	INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE InvokeHostFunctionResultCode = -5
)

type InvokeHostFunctionResult struct {
	// The union discriminant Code selects among the following arms:
	//   INVOKE_HOST_FUNCTION_SUCCESS:
	//      Success() *Hash
	//   INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED, INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED, INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED, INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE:
	//      void
	Code InvokeHostFunctionResultCode
	_u   interface{}
}

type ExtendFootprintTTLResultCode int32

const (
	// codes considered as "success" for the operation
	EXTEND_FOOTPRINT_TTL_SUCCESS ExtendFootprintTTLResultCode = 0
	// codes considered as "failure" for the operation
	EXTEND_FOOTPRINT_TTL_MALFORMED                   ExtendFootprintTTLResultCode = -1
	EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED     ExtendFootprintTTLResultCode = -2
	EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE ExtendFootprintTTLResultCode = -3
)

type ExtendFootprintTTLResult struct {
	// The union discriminant Code selects among the following arms:
	//   EXTEND_FOOTPRINT_TTL_SUCCESS:
	//      void
	//   EXTEND_FOOTPRINT_TTL_MALFORMED, EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED, EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE:
	//      void
	Code ExtendFootprintTTLResultCode
	_u   interface{}
}

type RestoreFootprintResultCode int32

const (
	// codes considered as "success" for the operation
	RESTORE_FOOTPRINT_SUCCESS RestoreFootprintResultCode = 0
	// codes considered as "failure" for the operation
	RESTORE_FOOTPRINT_MALFORMED                   RestoreFootprintResultCode = -1
	RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED     RestoreFootprintResultCode = -2
	RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE RestoreFootprintResultCode = -3
)

type RestoreFootprintResult struct {
	// The union discriminant Code selects among the following arms:
	//   RESTORE_FOOTPRINT_SUCCESS:
	//      void
	//   RESTORE_FOOTPRINT_MALFORMED, RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED, RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE:
	//      void
	Code RestoreFootprintResultCode
	_u   interface{}
}

/* High level Operation Result */
type OperationResultCode int32

const (
	// inner object result is valid
	OpINNER OperationResultCode = 0
	// too few valid signatures / wrong network
	OpBAD_AUTH OperationResultCode = -1
	// source account was not found
	OpNO_ACCOUNT OperationResultCode = -2
	// operation not supported at this time
	OpNOT_SUPPORTED OperationResultCode = -3
	// max number of subentries already reached
	OpTOO_MANY_SUBENTRIES OperationResultCode = -4
	// operation did too much work
	OpEXCEEDED_WORK_LIMIT OperationResultCode = -5
	// account is sponsoring too many entries
	OpTOO_MANY_SPONSORING OperationResultCode = -6
)

type OperationResult struct {
	// The union discriminant Code selects among the following arms:
	//   OpINNER:
	//      Tr() *XdrAnon_OperationResult_Tr
	//   OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
	//      void
	Code OperationResultCode
	_u   interface{}
}
type XdrAnon_OperationResult_Tr struct {
	// The union discriminant Type selects among the following arms:
	//   CREATE_ACCOUNT:
	//      CreateAccountResult() *CreateAccountResult
	//   PAYMENT:
	//      PaymentResult() *PaymentResult
	//   PATH_PAYMENT_STRICT_RECEIVE:
	//      PathPaymentStrictReceiveResult() *PathPaymentStrictReceiveResult
	//   MANAGE_SELL_OFFER:
	//      ManageSellOfferResult() *ManageSellOfferResult
	//   CREATE_PASSIVE_SELL_OFFER:
	//      CreatePassiveSellOfferResult() *ManageSellOfferResult
	//   SET_OPTIONS:
	//      SetOptionsResult() *SetOptionsResult
	//   CHANGE_TRUST:
	//      ChangeTrustResult() *ChangeTrustResult
	//   ALLOW_TRUST:
	//      AllowTrustResult() *AllowTrustResult
	//   ACCOUNT_MERGE:
	//      AccountMergeResult() *AccountMergeResult
	//   INFLATION:
	//      InflationResult() *InflationResult
	//   MANAGE_DATA:
	//      ManageDataResult() *ManageDataResult
	//   BUMP_SEQUENCE:
	//      BumpSeqResult() *BumpSequenceResult
	//   MANAGE_BUY_OFFER:
	//      ManageBuyOfferResult() *ManageBuyOfferResult
	//   PATH_PAYMENT_STRICT_SEND:
	//      PathPaymentStrictSendResult() *PathPaymentStrictSendResult
	//   CREATE_CLAIMABLE_BALANCE:
	//      CreateClaimableBalanceResult() *CreateClaimableBalanceResult
	//   CLAIM_CLAIMABLE_BALANCE:
	//      ClaimClaimableBalanceResult() *ClaimClaimableBalanceResult
	//   BEGIN_SPONSORING_FUTURE_RESERVES:
	//      BeginSponsoringFutureReservesResult() *BeginSponsoringFutureReservesResult
	//   END_SPONSORING_FUTURE_RESERVES:
	//      EndSponsoringFutureReservesResult() *EndSponsoringFutureReservesResult
	//   REVOKE_SPONSORSHIP:
	//      RevokeSponsorshipResult() *RevokeSponsorshipResult
	//   CLAWBACK:
	//      ClawbackResult() *ClawbackResult
	//   CLAWBACK_CLAIMABLE_BALANCE:
	//      ClawbackClaimableBalanceResult() *ClawbackClaimableBalanceResult
	//   SET_TRUST_LINE_FLAGS:
	//      SetTrustLineFlagsResult() *SetTrustLineFlagsResult
	//   LIQUIDITY_POOL_DEPOSIT:
	//      LiquidityPoolDepositResult() *LiquidityPoolDepositResult
	//   LIQUIDITY_POOL_WITHDRAW:
	//      LiquidityPoolWithdrawResult() *LiquidityPoolWithdrawResult
	//   INVOKE_HOST_FUNCTION:
	//      InvokeHostFunctionResult() *InvokeHostFunctionResult
	//   EXTEND_FOOTPRINT_TTL:
	//      ExtendFootprintTTLResult() *ExtendFootprintTTLResult
	//   RESTORE_FOOTPRINT:
	//      RestoreFootprintResult() *RestoreFootprintResult
	Type OperationType
	_u   interface{}
}

type TransactionResultCode int32

const (
	// fee bump inner transaction succeeded
	TxFEE_BUMP_INNER_SUCCESS TransactionResultCode = 1
	// all operations succeeded
	TxSUCCESS TransactionResultCode = 0
	// one of the operations failed (none were applied)
	TxFAILED TransactionResultCode = -1
	// ledger closeTime before minTime
	TxTOO_EARLY TransactionResultCode = -2
	// ledger closeTime after maxTime
	TxTOO_LATE TransactionResultCode = -3
	// no operation was specified
	TxMISSING_OPERATION TransactionResultCode = -4
	// sequence number does not match source account
	TxBAD_SEQ TransactionResultCode = -5
	// too few valid signatures / wrong network
	TxBAD_AUTH TransactionResultCode = -6
	// fee would bring account below reserve
	TxINSUFFICIENT_BALANCE TransactionResultCode = -7
	// source account not found
	TxNO_ACCOUNT TransactionResultCode = -8
	// fee is too small
	TxINSUFFICIENT_FEE TransactionResultCode = -9
	// unused signatures attached to transaction
	TxBAD_AUTH_EXTRA TransactionResultCode = -10
	// an unknown error occurred
	TxINTERNAL_ERROR TransactionResultCode = -11
	// transaction type not supported
	TxNOT_SUPPORTED TransactionResultCode = -12
	// fee bump inner transaction failed
	TxFEE_BUMP_INNER_FAILED TransactionResultCode = -13
	// sponsorship not confirmed
	TxBAD_SPONSORSHIP TransactionResultCode = -14
	// minSeqAge or minSeqLedgerGap conditions not met
	TxBAD_MIN_SEQ_AGE_OR_GAP TransactionResultCode = -15
	// precondition is invalid
	TxMALFORMED TransactionResultCode = -16
	// soroban-specific preconditions were not met
	TxSOROBAN_INVALID TransactionResultCode = -17
)

// InnerTransactionResult must be binary compatible with TransactionResult
// because it is be used to represent the result of a Transaction.
type InnerTransactionResult struct {
	// Always 0. Here for binary compatibility.
	FeeCharged Int64
	Result     XdrAnon_InnerTransactionResult_Result
	Ext        XdrAnon_InnerTransactionResult_Ext
}
type XdrAnon_InnerTransactionResult_Result struct {
	// The union discriminant Code selects among the following arms:
	//   TxSUCCESS, TxFAILED:
	//      Results() *[]OperationResult
	//   TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
	//      void
	Code TransactionResultCode
	_u   interface{}
}

// reserved for future use
type XdrAnon_InnerTransactionResult_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type InnerTransactionResultPair struct {
	// hash of the inner transaction
	TransactionHash Hash
	// result for the inner transaction
	Result InnerTransactionResult
}

type TransactionResult struct {
	// actual fee charged for the transaction
	FeeCharged Int64
	Result     XdrAnon_TransactionResult_Result
	Ext        XdrAnon_TransactionResult_Ext
}
type XdrAnon_TransactionResult_Result struct {
	// The union discriminant Code selects among the following arms:
	//   TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
	//      InnerResultPair() *InnerTransactionResultPair
	//   TxSUCCESS, TxFAILED:
	//      Results() *[]OperationResult
	//   TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
	//      void
	Code TransactionResultCode
	_u   interface{}
}

// reserved for future use
type XdrAnon_TransactionResult_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type Hash = [32]byte

type Uint256 = [32]byte

type Uint32 = uint32

type Int32 = int32

type Uint64 = uint64

type Int64 = int64

type TimePoint = Uint64

type Duration = Uint64

// An ExtensionPoint is always marshaled as a 32-bit 0 value.  At a
// later point, it can be replaced by a different union so as to
// extend a structure.
type ExtensionPoint struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type CryptoKeyType int32

const (
	KEY_TYPE_ED25519                CryptoKeyType = 0
	KEY_TYPE_PRE_AUTH_TX            CryptoKeyType = 1
	KEY_TYPE_HASH_X                 CryptoKeyType = 2
	KEY_TYPE_ED25519_SIGNED_PAYLOAD CryptoKeyType = 3
	// MUXED enum values for supported type are derived from the enum values
	// above by ORing them with 0x100
	KEY_TYPE_MUXED_ED25519 CryptoKeyType = CryptoKeyType(0x100)
)

type PublicKeyType int32

const (
	PUBLIC_KEY_TYPE_ED25519 PublicKeyType = PublicKeyType(KEY_TYPE_ED25519)
)

type SignerKeyType int32

const (
	SIGNER_KEY_TYPE_ED25519                SignerKeyType = SignerKeyType(KEY_TYPE_ED25519)
	SIGNER_KEY_TYPE_PRE_AUTH_TX            SignerKeyType = SignerKeyType(KEY_TYPE_PRE_AUTH_TX)
	SIGNER_KEY_TYPE_HASH_X                 SignerKeyType = SignerKeyType(KEY_TYPE_HASH_X)
	SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD SignerKeyType = SignerKeyType(KEY_TYPE_ED25519_SIGNED_PAYLOAD)
)

type PublicKey struct {
	// The union discriminant Type selects among the following arms:
	//   PUBLIC_KEY_TYPE_ED25519:
	//      Ed25519() *Uint256
	Type PublicKeyType
	_u   interface{}
}

type SignerKey struct {
	// The union discriminant Type selects among the following arms:
	//   SIGNER_KEY_TYPE_ED25519:
	//      Ed25519() *Uint256
	//   SIGNER_KEY_TYPE_PRE_AUTH_TX:
	//      PreAuthTx() *Uint256
	//   SIGNER_KEY_TYPE_HASH_X:
	//      HashX() *Uint256
	//   SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
	//      Ed25519SignedPayload() *XdrAnon_SignerKey_Ed25519SignedPayload
	Type SignerKeyType
	_u   interface{}
}
type XdrAnon_SignerKey_Ed25519SignedPayload struct {
	/* Public key that must sign the payload. */
	Ed25519 Uint256
	/* Payload to be raw signed by ed25519. */
	Payload []byte // bound 64
}

// variable size as the size depends on the signature scheme used
type Signature = []byte // bound 64

type SignatureHint = [4]byte

type NodeID = PublicKey

type AccountID = PublicKey

type Curve25519Secret struct {
	Key [32]byte
}

type Curve25519Public struct {
	Key [32]byte
}

type HmacSha256Key struct {
	Key [32]byte
}

type HmacSha256Mac struct {
	Mac [32]byte
}

type SCEnvMetaKind int32

const (
	SC_ENV_META_KIND_INTERFACE_VERSION SCEnvMetaKind = 0
)

type SCEnvMetaEntry struct {
	// The union discriminant Kind selects among the following arms:
	//   SC_ENV_META_KIND_INTERFACE_VERSION:
	//      InterfaceVersion() *Uint64
	Kind SCEnvMetaKind
	_u   interface{}
}

type SCMetaV0 struct {
	Key string
	Val string
}

type SCMetaKind int32

const (
	SC_META_V0 SCMetaKind = 0
)

type SCMetaEntry struct {
	// The union discriminant Kind selects among the following arms:
	//   SC_META_V0:
	//      V0() *SCMetaV0
	Kind SCMetaKind
	_u   interface{}
}

const SC_SPEC_DOC_LIMIT = 1024

type SCSpecType int32

const (
	SC_SPEC_TYPE_VAL SCSpecType = 0
	// Types with no parameters.
	SC_SPEC_TYPE_BOOL      SCSpecType = 1
	SC_SPEC_TYPE_VOID      SCSpecType = 2
	SC_SPEC_TYPE_ERROR     SCSpecType = 3
	SC_SPEC_TYPE_U32       SCSpecType = 4
	SC_SPEC_TYPE_I32       SCSpecType = 5
	SC_SPEC_TYPE_U64       SCSpecType = 6
	SC_SPEC_TYPE_I64       SCSpecType = 7
	SC_SPEC_TYPE_TIMEPOINT SCSpecType = 8
	SC_SPEC_TYPE_DURATION  SCSpecType = 9
	SC_SPEC_TYPE_U128      SCSpecType = 10
	SC_SPEC_TYPE_I128      SCSpecType = 11
	SC_SPEC_TYPE_U256      SCSpecType = 12
	SC_SPEC_TYPE_I256      SCSpecType = 13
	SC_SPEC_TYPE_BYTES     SCSpecType = 14
	SC_SPEC_TYPE_STRING    SCSpecType = 16
	SC_SPEC_TYPE_SYMBOL    SCSpecType = 17
	SC_SPEC_TYPE_ADDRESS   SCSpecType = 19
	// Types with parameters.
	SC_SPEC_TYPE_OPTION  SCSpecType = 1000
	SC_SPEC_TYPE_RESULT  SCSpecType = 1001
	SC_SPEC_TYPE_VEC     SCSpecType = 1002
	SC_SPEC_TYPE_MAP     SCSpecType = 1004
	SC_SPEC_TYPE_TUPLE   SCSpecType = 1005
	SC_SPEC_TYPE_BYTES_N SCSpecType = 1006
	SC_SPEC_TYPE_HASH    SCSpecType = 1007
	// User defined types.
	SC_SPEC_TYPE_UDT SCSpecType = 2000
)

type SCSpecTypeOption struct {
	ValueType SCSpecTypeDef
}

type SCSpecTypeResult struct {
	OkType    SCSpecTypeDef
	ErrorType SCSpecTypeDef
}

type SCSpecTypeVec struct {
	ElementType SCSpecTypeDef
}

type SCSpecTypeMap struct {
	KeyType   SCSpecTypeDef
	ValueType SCSpecTypeDef
}

type SCSpecTypeTuple struct {
	ValueTypes []SCSpecTypeDef // bound 12
}

type SCSpecTypeBytesN struct {
	N Uint32
}

type SCSpectTypeHash struct {
	N Uint32
}

type SCSpecTypeUDT struct {
	Name string // bound 60
}

type SCSpecTypeDef struct {
	// The union discriminant Type selects among the following arms:
	//   SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_VOID, SC_SPEC_TYPE_ERROR, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_TIMEPOINT, SC_SPEC_TYPE_DURATION, SC_SPEC_TYPE_U128, SC_SPEC_TYPE_I128, SC_SPEC_TYPE_U256, SC_SPEC_TYPE_I256, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_STRING, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_ADDRESS:
	//      void
	//   SC_SPEC_TYPE_OPTION:
	//      Option() *SCSpecTypeOption
	//   SC_SPEC_TYPE_RESULT:
	//      Result() *SCSpecTypeResult
	//   SC_SPEC_TYPE_VEC:
	//      Vec() *SCSpecTypeVec
	//   SC_SPEC_TYPE_MAP:
	//      Map() *SCSpecTypeMap
	//   SC_SPEC_TYPE_TUPLE:
	//      Tuple() *SCSpecTypeTuple
	//   SC_SPEC_TYPE_BYTES_N:
	//      BytesN() *SCSpecTypeBytesN
	//   SC_SPEC_TYPE_HASH:
	//      Hash() *SCSpectTypeHash
	//   SC_SPEC_TYPE_UDT:
	//      Udt() *SCSpecTypeUDT
	Type SCSpecType
	_u   interface{}
}

type SCSpecUDTStructFieldV0 struct {
	Doc  string // bound SC_SPEC_DOC_LIMIT
	Name string // bound 30
	Type SCSpecTypeDef
}

type SCSpecUDTStructV0 struct {
	Doc    string                   // bound SC_SPEC_DOC_LIMIT
	Lib    string                   // bound 80
	Name   string                   // bound 60
	Fields []SCSpecUDTStructFieldV0 // bound 40
}

type SCSpecUDTUnionCaseVoidV0 struct {
	Doc  string // bound SC_SPEC_DOC_LIMIT
	Name string // bound 60
}

type SCSpecUDTUnionCaseTupleV0 struct {
	Doc  string          // bound SC_SPEC_DOC_LIMIT
	Name string          // bound 60
	Type []SCSpecTypeDef // bound 12
}

type SCSpecUDTUnionCaseV0Kind int32

const (
	SC_SPEC_UDT_UNION_CASE_VOID_V0  SCSpecUDTUnionCaseV0Kind = 0
	SC_SPEC_UDT_UNION_CASE_TUPLE_V0 SCSpecUDTUnionCaseV0Kind = 1
)

type SCSpecUDTUnionCaseV0 struct {
	// The union discriminant Kind selects among the following arms:
	//   SC_SPEC_UDT_UNION_CASE_VOID_V0:
	//      VoidCase() *SCSpecUDTUnionCaseVoidV0
	//   SC_SPEC_UDT_UNION_CASE_TUPLE_V0:
	//      TupleCase() *SCSpecUDTUnionCaseTupleV0
	Kind SCSpecUDTUnionCaseV0Kind
	_u   interface{}
}

type SCSpecUDTUnionV0 struct {
	Doc   string                 // bound SC_SPEC_DOC_LIMIT
	Lib   string                 // bound 80
	Name  string                 // bound 60
	Cases []SCSpecUDTUnionCaseV0 // bound 50
}

type SCSpecUDTEnumCaseV0 struct {
	Doc   string // bound SC_SPEC_DOC_LIMIT
	Name  string // bound 60
	Value Uint32
}

type SCSpecUDTEnumV0 struct {
	Doc   string                // bound SC_SPEC_DOC_LIMIT
	Lib   string                // bound 80
	Name  string                // bound 60
	Cases []SCSpecUDTEnumCaseV0 // bound 50
}

type SCSpecUDTErrorEnumCaseV0 struct {
	Doc   string // bound SC_SPEC_DOC_LIMIT
	Name  string // bound 60
	Value Uint32
}

type SCSpecUDTErrorEnumV0 struct {
	Doc   string                     // bound SC_SPEC_DOC_LIMIT
	Lib   string                     // bound 80
	Name  string                     // bound 60
	Cases []SCSpecUDTErrorEnumCaseV0 // bound 50
}

type SCSpecFunctionInputV0 struct {
	Doc  string // bound SC_SPEC_DOC_LIMIT
	Name string // bound 30
	Type SCSpecTypeDef
}

type SCSpecFunctionV0 struct {
	Doc     string // bound SC_SPEC_DOC_LIMIT
	Name    SCSymbol
	Inputs  []SCSpecFunctionInputV0 // bound 10
	Outputs []SCSpecTypeDef         // bound 1
}

type SCSpecEntryKind int32

const (
	SC_SPEC_ENTRY_FUNCTION_V0       SCSpecEntryKind = 0
	SC_SPEC_ENTRY_UDT_STRUCT_V0     SCSpecEntryKind = 1
	SC_SPEC_ENTRY_UDT_UNION_V0      SCSpecEntryKind = 2
	SC_SPEC_ENTRY_UDT_ENUM_V0       SCSpecEntryKind = 3
	SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0 SCSpecEntryKind = 4
)

type SCSpecEntry struct {
	// The union discriminant Kind selects among the following arms:
	//   SC_SPEC_ENTRY_FUNCTION_V0:
	//      FunctionV0() *SCSpecFunctionV0
	//   SC_SPEC_ENTRY_UDT_STRUCT_V0:
	//      UdtStructV0() *SCSpecUDTStructV0
	//   SC_SPEC_ENTRY_UDT_UNION_V0:
	//      UdtUnionV0() *SCSpecUDTUnionV0
	//   SC_SPEC_ENTRY_UDT_ENUM_V0:
	//      UdtEnumV0() *SCSpecUDTEnumV0
	//   SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
	//      UdtErrorEnumV0() *SCSpecUDTErrorEnumV0
	Kind SCSpecEntryKind
	_u   interface{}
}

type SCValType int32

const (
	SCV_BOOL  SCValType = 0
	SCV_VOID  SCValType = 1
	SCV_ERROR SCValType = 2
	// 32 bits is the smallest type in WASM or XDR; no need for u8/u16.
	SCV_U32 SCValType = 3
	SCV_I32 SCValType = 4
	// 64 bits is naturally supported by both WASM and XDR also.
	SCV_U64 SCValType = 5
	SCV_I64 SCValType = 6
	// Time-related u64 subtypes with their own functions and formatting.
	SCV_TIMEPOINT SCValType = 7
	SCV_DURATION  SCValType = 8
	// 128 bits is naturally supported by Rust and we use it for Soroban
	// fixed-point arithmetic prices / balances / similar "quantities". These
	// are represented in XDR as a pair of 2 u64s.
	SCV_U128 SCValType = 9
	SCV_I128 SCValType = 10
	// 256 bits is the size of sha256 output, ed25519 keys, and the EVM machine
	// word, so for interop use we include this even though it requires a small
	// amount of Rust guest and/or host library code.
	SCV_U256 SCValType = 11
	SCV_I256 SCValType = 12
	// Bytes come in 3 flavors, 2 of which have meaningfully different
	// formatting and validity-checking / domain-restriction.
	SCV_BYTES  SCValType = 13
	SCV_STRING SCValType = 14
	SCV_SYMBOL SCValType = 15
	// Vecs and maps are just polymorphic containers of other ScVals.
	SCV_VEC SCValType = 16
	SCV_MAP SCValType = 17
	// Address is the universal identifier for contracts and classic
	// accounts.
	SCV_ADDRESS SCValType = 18
	// The following are the internal SCVal variants that are not
	// exposed to the contracts.
	SCV_CONTRACT_INSTANCE SCValType = 19
	// SCV_LEDGER_KEY_CONTRACT_INSTANCE and SCV_LEDGER_KEY_NONCE are unique
	// symbolic SCVals used as the key for ledger entries for a contract's
	// instance and an address' nonce, respectively.
	SCV_LEDGER_KEY_CONTRACT_INSTANCE SCValType = 20
	SCV_LEDGER_KEY_NONCE             SCValType = 21
)

type SCErrorType int32

const (
	// Contract-specific, user-defined codes.
	SCE_CONTRACT SCErrorType = 0
	// Errors while interpreting WASM bytecode.
	SCE_WASM_VM SCErrorType = 1
	// Errors in the contract's host context.
	SCE_CONTEXT SCErrorType = 2
	// Errors accessing host storage.
	SCE_STORAGE SCErrorType = 3
	// Errors working with host objects.
	SCE_OBJECT SCErrorType = 4
	// Errors in cryptographic operations.
	SCE_CRYPTO SCErrorType = 5
	// Errors while emitting events.
	SCE_EVENTS SCErrorType = 6
	// Errors relating to budget limits.
	SCE_BUDGET SCErrorType = 7
	// Errors working with host values or SCVals.
	SCE_VALUE SCErrorType = 8
	// Errors from the authentication subsystem.
	SCE_AUTH SCErrorType = 9
)

type SCErrorCode int32

const (
	// Some arithmetic was undefined (overflow, divide-by-zero).
	SCEC_ARITH_DOMAIN SCErrorCode = 0
	// Something was indexed beyond its bounds.
	SCEC_INDEX_BOUNDS SCErrorCode = 1
	// User provided some otherwise-bad data.
	SCEC_INVALID_INPUT SCErrorCode = 2
	// Some value was required but not provided.
	SCEC_MISSING_VALUE SCErrorCode = 3
	// Some value was provided where not allowed.
	SCEC_EXISTING_VALUE SCErrorCode = 4
	// Some arbitrary limit -- gas or otherwise -- was hit.
	SCEC_EXCEEDED_LIMIT SCErrorCode = 5
	// Data was valid but action requested was not.
	SCEC_INVALID_ACTION SCErrorCode = 6
	// The host detected an error in its own logic.
	SCEC_INTERNAL_ERROR SCErrorCode = 7
	// Some type wasn't as expected.
	SCEC_UNEXPECTED_TYPE SCErrorCode = 8
	// Something's size wasn't as expected.
	SCEC_UNEXPECTED_SIZE SCErrorCode = 9
)

type SCError struct {
	// The union discriminant Type selects among the following arms:
	//   SCE_CONTRACT:
	//      ContractCode() *Uint32
	//   SCE_WASM_VM, SCE_CONTEXT, SCE_STORAGE, SCE_OBJECT, SCE_CRYPTO, SCE_EVENTS, SCE_BUDGET, SCE_VALUE, SCE_AUTH:
	//      Code() *SCErrorCode
	Type SCErrorType
	_u   interface{}
}

type UInt128Parts struct {
	Hi Uint64
	Lo Uint64
}

// A signed int128 has a high sign bit and 127 value bits. We break it into a
// signed high int64 (that carries the sign bit and the high 63 value bits) and
// a low unsigned uint64 that carries the low 64 bits. This will sort in
// generated code in the same order the underlying int128 sorts.
type Int128Parts struct {
	Hi Int64
	Lo Uint64
}

type UInt256Parts struct {
	Hi_hi Uint64
	Hi_lo Uint64
	Lo_hi Uint64
	Lo_lo Uint64
}

// A signed int256 has a high sign bit and 255 value bits. We break it into a
// signed high int64 (that carries the sign bit and the high 63 value bits) and
// three low unsigned `uint64`s that carry the lower bits. This will sort in
// generated code in the same order the underlying int256 sorts.
type Int256Parts struct {
	Hi_hi Int64
	Hi_lo Uint64
	Lo_hi Uint64
	Lo_lo Uint64
}

type ContractExecutableType int32

const (
	CONTRACT_EXECUTABLE_WASM          ContractExecutableType = 0
	CONTRACT_EXECUTABLE_STELLAR_ASSET ContractExecutableType = 1
)

type ContractExecutable struct {
	// The union discriminant Type selects among the following arms:
	//   CONTRACT_EXECUTABLE_WASM:
	//      Wasm_hash() *Hash
	//   CONTRACT_EXECUTABLE_STELLAR_ASSET:
	//      void
	Type ContractExecutableType
	_u   interface{}
}

type SCAddressType int32

const (
	SC_ADDRESS_TYPE_ACCOUNT  SCAddressType = 0
	SC_ADDRESS_TYPE_CONTRACT SCAddressType = 1
)

type SCAddress struct {
	// The union discriminant Type selects among the following arms:
	//   SC_ADDRESS_TYPE_ACCOUNT:
	//      AccountId() *AccountID
	//   SC_ADDRESS_TYPE_CONTRACT:
	//      ContractId() *Hash
	Type SCAddressType
	_u   interface{}
}

const SCSYMBOL_LIMIT = 32

type SCVec = []SCVal

type SCMap = []SCMapEntry

type SCBytes = []byte

type SCString = string

type SCSymbol = string // bound SCSYMBOL_LIMIT

type SCNonceKey struct {
	Nonce Int64
}

type SCContractInstance struct {
	Executable ContractExecutable
	Storage    *SCMap
}

type SCVal struct {
	// The union discriminant Type selects among the following arms:
	//   SCV_BOOL:
	//      B() *bool
	//   SCV_VOID:
	//      void
	//   SCV_ERROR:
	//      Error() *SCError
	//   SCV_U32:
	//      U32() *Uint32
	//   SCV_I32:
	//      I32() *Int32
	//   SCV_U64:
	//      U64() *Uint64
	//   SCV_I64:
	//      I64() *Int64
	//   SCV_TIMEPOINT:
	//      Timepoint() *TimePoint
	//   SCV_DURATION:
	//      Duration() *Duration
	//   SCV_U128:
	//      U128() *UInt128Parts
	//   SCV_I128:
	//      I128() *Int128Parts
	//   SCV_U256:
	//      U256() *UInt256Parts
	//   SCV_I256:
	//      I256() *Int256Parts
	//   SCV_BYTES:
	//      Bytes() *SCBytes
	//   SCV_STRING:
	//      Str() *SCString
	//   SCV_SYMBOL:
	//      Sym() *SCSymbol
	//   SCV_VEC:
	//      Vec() **SCVec
	//   SCV_MAP:
	//      Map() **SCMap
	//   SCV_ADDRESS:
	//      Address() *SCAddress
	//   SCV_LEDGER_KEY_CONTRACT_INSTANCE:
	//      void
	//   SCV_LEDGER_KEY_NONCE:
	//      Nonce_key() *SCNonceKey
	//   SCV_CONTRACT_INSTANCE:
	//      Instance() *SCContractInstance
	Type SCValType
	_u   interface{}
}

type SCMapEntry struct {
	Key SCVal
	Val SCVal
}

type StoredTransactionSet struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      TxSet() *TransactionSet
	//   1:
	//      GeneralizedTxSet() *GeneralizedTransactionSet
	V  int32
	_u interface{}
}

type StoredDebugTransactionSet struct {
	TxSet     StoredTransactionSet
	LedgerSeq Uint32
	ScpValue  StellarValue
}

type PersistedSCPStateV0 struct {
	ScpEnvelopes []SCPEnvelope
	QuorumSets   []SCPQuorumSet
	TxSets       []StoredTransactionSet
}

type PersistedSCPStateV1 struct {
	// Tx sets are saved separately
	ScpEnvelopes []SCPEnvelope
	QuorumSets   []SCPQuorumSet
}

type PersistedSCPState struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *PersistedSCPStateV0
	//   1:
	//      V1() *PersistedSCPStateV1
	V  int32
	_u interface{}
}

// General “Soroban execution lane” settings
type ConfigSettingContractExecutionLanesV0 struct {
	// maximum number of Soroban transactions per ledger
	LedgerMaxTxCount Uint32
}

// "Compute" settings for contracts (instructions and memory).
type ConfigSettingContractComputeV0 struct {
	// Maximum instructions per ledger
	LedgerMaxInstructions Int64
	// Maximum instructions per transaction
	TxMaxInstructions Int64
	// Cost of 10000 instructions
	FeeRatePerInstructionsIncrement Int64
	// Memory limit per transaction. Unlike instructions, there is no fee
	// for memory, just the limit.
	TxMemoryLimit Uint32
}

// Ledger access settings for contracts.
type ConfigSettingContractLedgerCostV0 struct {
	// Maximum number of ledger entry read operations per ledger
	LedgerMaxReadLedgerEntries Uint32
	// Maximum number of bytes that can be read per ledger
	LedgerMaxReadBytes Uint32
	// Maximum number of ledger entry write operations per ledger
	LedgerMaxWriteLedgerEntries Uint32
	// Maximum number of bytes that can be written per ledger
	LedgerMaxWriteBytes Uint32
	// Maximum number of ledger entry read operations per transaction
	TxMaxReadLedgerEntries Uint32
	// Maximum number of bytes that can be read per transaction
	TxMaxReadBytes Uint32
	// Maximum number of ledger entry write operations per transaction
	TxMaxWriteLedgerEntries Uint32
	// Maximum number of bytes that can be written per transaction
	TxMaxWriteBytes Uint32
	// Fee per ledger entry read
	FeeReadLedgerEntry Int64
	// Fee per ledger entry write
	FeeWriteLedgerEntry Int64
	// Fee for reading 1KB
	FeeRead1KB Int64
	// The following parameters determine the write fee per 1KB.
	// Write fee grows linearly until bucket list reaches this size
	BucketListTargetSizeBytes Int64
	// Fee per 1KB write when the bucket list is empty
	WriteFee1KBBucketListLow Int64
	// Fee per 1KB write when the bucket list has reached `bucketListTargetSizeBytes`
	WriteFee1KBBucketListHigh Int64
	// Write fee multiplier for any additional data past the first `bucketListTargetSizeBytes`
	BucketListWriteFeeGrowthFactor Uint32
}

// Historical data (pushed to core archives) settings for contracts.
type ConfigSettingContractHistoricalDataV0 struct {
	// Fee for storing 1KB in archives
	FeeHistorical1KB Int64
}

// Contract event-related settings.
type ConfigSettingContractEventsV0 struct {
	// Maximum size of events that a contract call can emit.
	TxMaxContractEventsSizeBytes Uint32
	// Fee for generating 1KB of contract events.
	FeeContractEvents1KB Int64
}

// Bandwidth related data settings for contracts.
// We consider bandwidth to only be consumed by the transaction envelopes, hence
// this concerns only transaction sizes.
type ConfigSettingContractBandwidthV0 struct {
	// Maximum sum of all transaction sizes in the ledger in bytes
	LedgerMaxTxsSizeBytes Uint32
	// Maximum size in bytes for a transaction
	TxMaxSizeBytes Uint32
	// Fee for 1 KB of transaction size
	FeeTxSize1KB Int64
}

type ContractCostType int32

const (
	// Cost of running 1 wasm instruction
	WasmInsnExec ContractCostType = 0
	// Cost of allocating a slice of memory (in bytes)
	MemAlloc ContractCostType = 1
	// Cost of copying a slice of bytes into a pre-allocated memory
	MemCpy ContractCostType = 2
	// Cost of comparing two slices of memory
	MemCmp ContractCostType = 3
	// Cost of a host function dispatch, not including the actual work done by
	// the function nor the cost of VM invocation machinary
	DispatchHostFunction ContractCostType = 4
	// Cost of visiting a host object from the host object storage. Exists to
	// make sure some baseline cost coverage, i.e. repeatly visiting objects
	// by the guest will always incur some charges.
	VisitObject ContractCostType = 5
	// Cost of serializing an xdr object to bytes
	ValSer ContractCostType = 6
	// Cost of deserializing an xdr object from bytes
	ValDeser ContractCostType = 7
	// Cost of computing the sha256 hash from bytes
	ComputeSha256Hash ContractCostType = 8
	// Cost of computing the ed25519 pubkey from bytes
	ComputeEd25519PubKey ContractCostType = 9
	// Cost of verifying ed25519 signature of a payload.
	VerifyEd25519Sig ContractCostType = 10
	// Cost of instantiation a VM from wasm bytes code.
	VmInstantiation ContractCostType = 11
	// Cost of instantiation a VM from a cached state.
	VmCachedInstantiation ContractCostType = 12
	// Cost of invoking a function on the VM. If the function is a host function,
	// additional cost will be covered by `DispatchHostFunction`.
	InvokeVmFunction ContractCostType = 13
	// Cost of computing a keccak256 hash from bytes.
	ComputeKeccak256Hash ContractCostType = 14
	// Cost of decoding an ECDSA signature computed from a 256-bit prime modulus
	// curve (e.g. secp256k1 and secp256r1)
	DecodeEcdsaCurve256Sig ContractCostType = 15
	// Cost of recovering an ECDSA secp256k1 key from a signature.
	RecoverEcdsaSecp256k1Key ContractCostType = 16
	// Cost of int256 addition (`+`) and subtraction (`-`) operations
	Int256AddSub ContractCostType = 17
	// Cost of int256 multiplication (`*`) operation
	Int256Mul ContractCostType = 18
	// Cost of int256 division (`/`) operation
	Int256Div ContractCostType = 19
	// Cost of int256 power (`exp`) operation
	Int256Pow ContractCostType = 20
	// Cost of int256 shift (`shl`, `shr`) operation
	Int256Shift ContractCostType = 21
	// Cost of drawing random bytes using a ChaCha20 PRNG
	ChaCha20DrawBytes ContractCostType = 22
	// Cost of parsing wasm bytes that only encode instructions.
	ParseWasmInstructions ContractCostType = 23
	// Cost of parsing a known number of wasm functions.
	ParseWasmFunctions ContractCostType = 24
	// Cost of parsing a known number of wasm globals.
	ParseWasmGlobals ContractCostType = 25
	// Cost of parsing a known number of wasm table entries.
	ParseWasmTableEntries ContractCostType = 26
	// Cost of parsing a known number of wasm types.
	ParseWasmTypes ContractCostType = 27
	// Cost of parsing a known number of wasm data segments.
	ParseWasmDataSegments ContractCostType = 28
	// Cost of parsing a known number of wasm element segments.
	ParseWasmElemSegments ContractCostType = 29
	// Cost of parsing a known number of wasm imports.
	ParseWasmImports ContractCostType = 30
	// Cost of parsing a known number of wasm exports.
	ParseWasmExports ContractCostType = 31
	// Cost of parsing a known number of data segment bytes.
	ParseWasmDataSegmentBytes ContractCostType = 32
	// Cost of instantiating wasm bytes that only encode instructions.
	InstantiateWasmInstructions ContractCostType = 33
	// Cost of instantiating a known number of wasm functions.
	InstantiateWasmFunctions ContractCostType = 34
	// Cost of instantiating a known number of wasm globals.
	InstantiateWasmGlobals ContractCostType = 35
	// Cost of instantiating a known number of wasm table entries.
	InstantiateWasmTableEntries ContractCostType = 36
	// Cost of instantiating a known number of wasm types.
	InstantiateWasmTypes ContractCostType = 37
	// Cost of instantiating a known number of wasm data segments.
	InstantiateWasmDataSegments ContractCostType = 38
	// Cost of instantiating a known number of wasm element segments.
	InstantiateWasmElemSegments ContractCostType = 39
	// Cost of instantiating a known number of wasm imports.
	InstantiateWasmImports ContractCostType = 40
	// Cost of instantiating a known number of wasm exports.
	InstantiateWasmExports ContractCostType = 41
	// Cost of instantiating a known number of data segment bytes.
	InstantiateWasmDataSegmentBytes ContractCostType = 42
	// Cost of decoding a bytes array representing an uncompressed SEC-1 encoded
	// point on a 256-bit elliptic curve
	Sec1DecodePointUncompressed ContractCostType = 43
	// Cost of verifying an ECDSA Secp256r1 signature
	VerifyEcdsaSecp256r1Sig ContractCostType = 44
)

type ContractCostParamEntry struct {
	// use `ext` to add more terms (e.g. higher order polynomials) in the future
	Ext        ExtensionPoint
	ConstTerm  Int64
	LinearTerm Int64
}

type StateArchivalSettings struct {
	MaxEntryTTL      Uint32
	MinTemporaryTTL  Uint32
	MinPersistentTTL Uint32
	// rent_fee = wfee_rate_average / rent_rate_denominator_for_type
	PersistentRentRateDenominator Int64
	TempRentRateDenominator       Int64
	// max number of entries that emit archival meta in a single ledger
	MaxEntriesToArchive Uint32
	// Number of snapshots to use when calculating average BucketList size
	BucketListSizeWindowSampleSize Uint32
	// How often to sample the BucketList size for the average, in ledgers
	BucketListWindowSamplePeriod Uint32
	// Maximum number of bytes that we scan for eviction per ledger
	EvictionScanSize Uint32
	// Lowest BucketList level to be scanned to evict entries
	StartingEvictionScanLevel Uint32
}

type EvictionIterator struct {
	BucketListLevel  Uint32
	IsCurrBucket     bool
	BucketFileOffset Uint64
}

// limits the ContractCostParams size to 20kB
const CONTRACT_COST_COUNT_LIMIT = 1024

type ContractCostParams = []ContractCostParamEntry // bound CONTRACT_COST_COUNT_LIMIT

// Identifiers of all the network settings.
type ConfigSettingID int32

const (
	CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES               ConfigSettingID = 0
	CONFIG_SETTING_CONTRACT_COMPUTE_V0                   ConfigSettingID = 1
	CONFIG_SETTING_CONTRACT_LEDGER_COST_V0               ConfigSettingID = 2
	CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0           ConfigSettingID = 3
	CONFIG_SETTING_CONTRACT_EVENTS_V0                    ConfigSettingID = 4
	CONFIG_SETTING_CONTRACT_BANDWIDTH_V0                 ConfigSettingID = 5
	CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS ConfigSettingID = 6
	CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES     ConfigSettingID = 7
	CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES          ConfigSettingID = 8
	CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES        ConfigSettingID = 9
	CONFIG_SETTING_STATE_ARCHIVAL                        ConfigSettingID = 10
	CONFIG_SETTING_CONTRACT_EXECUTION_LANES              ConfigSettingID = 11
	CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW                ConfigSettingID = 12
	CONFIG_SETTING_EVICTION_ITERATOR                     ConfigSettingID = 13
)

type ConfigSettingEntry struct {
	// The union discriminant ConfigSettingID selects among the following arms:
	//   CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES:
	//      ContractMaxSizeBytes() *Uint32
	//   CONFIG_SETTING_CONTRACT_COMPUTE_V0:
	//      ContractCompute() *ConfigSettingContractComputeV0
	//   CONFIG_SETTING_CONTRACT_LEDGER_COST_V0:
	//      ContractLedgerCost() *ConfigSettingContractLedgerCostV0
	//   CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0:
	//      ContractHistoricalData() *ConfigSettingContractHistoricalDataV0
	//   CONFIG_SETTING_CONTRACT_EVENTS_V0:
	//      ContractEvents() *ConfigSettingContractEventsV0
	//   CONFIG_SETTING_CONTRACT_BANDWIDTH_V0:
	//      ContractBandwidth() *ConfigSettingContractBandwidthV0
	//   CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS:
	//      ContractCostParamsCpuInsns() *ContractCostParams
	//   CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES:
	//      ContractCostParamsMemBytes() *ContractCostParams
	//   CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES:
	//      ContractDataKeySizeBytes() *Uint32
	//   CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES:
	//      ContractDataEntrySizeBytes() *Uint32
	//   CONFIG_SETTING_STATE_ARCHIVAL:
	//      StateArchivalSettings() *StateArchivalSettings
	//   CONFIG_SETTING_CONTRACT_EXECUTION_LANES:
	//      ContractExecutionLanes() *ConfigSettingContractExecutionLanesV0
	//   CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW:
	//      BucketListSizeWindow() *[]Uint64
	//   CONFIG_SETTING_EVICTION_ITERATOR:
	//      EvictionIterator() *EvictionIterator
	ConfigSettingID ConfigSettingID
	_u              interface{}
}

type BitmapIndex struct {
	FirstBit Uint32
	LastBit  Uint32
	Bitmap   Value
}

type TrieIndex struct {
	// goxdr gives an error if we simply use "version" as an identifier
	Version_ Uint32
	Root     TrieNode
}

type TrieNodeChild struct {
	Key  [1]byte
	Node TrieNode
}

type TrieNode struct {
	Prefix   Value
	Value    Value
	Children []TrieNodeChild
}

type SerializedLedgerCloseMeta struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *LedgerCloseMeta
	V  int32
	_u interface{}
}

// Batch of ledgers along with their transaction metadata
type LedgerCloseMetaBatch struct {
	// starting ledger sequence number in the batch
	StartSequence Uint32
	// ending ledger sequence number in the batch
	EndSequence Uint32
	// Ledger close meta for each ledger within the batch
	LedgerCloseMetas []LedgerCloseMeta
}

//
// Helper types and generated marshaling functions
//

type XdrType_Value struct {
	XdrVecOpaque
}

func XDR_Value(v *Value) XdrType_Value {
	return XdrType_Value{XdrVecOpaque{v, 0xffffffff}}
}
func (XdrType_Value) XdrTypeName() string  { return "Value" }
func (v XdrType_Value) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_SCPBallot = *SCPBallot

func (v *SCPBallot) XdrPointer() interface{}       { return v }
func (SCPBallot) XdrTypeName() string              { return "SCPBallot" }
func (v SCPBallot) XdrValue() interface{}          { return v }
func (v *SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPBallot) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scounter", name), XDR_Uint32(&v.Counter))
	x.Marshal(x.Sprintf("%svalue", name), XDR_Value(&v.Value))
}
func XDR_SCPBallot(v *SCPBallot) *SCPBallot { return v }

var _XdrNames_SCPStatementType = map[int32]string{
	int32(SCP_ST_PREPARE):     "SCP_ST_PREPARE",
	int32(SCP_ST_CONFIRM):     "SCP_ST_CONFIRM",
	int32(SCP_ST_EXTERNALIZE): "SCP_ST_EXTERNALIZE",
	int32(SCP_ST_NOMINATE):    "SCP_ST_NOMINATE",
}
var _XdrValues_SCPStatementType = map[string]int32{
	"SCP_ST_PREPARE":     int32(SCP_ST_PREPARE),
	"SCP_ST_CONFIRM":     int32(SCP_ST_CONFIRM),
	"SCP_ST_EXTERNALIZE": int32(SCP_ST_EXTERNALIZE),
	"SCP_ST_NOMINATE":    int32(SCP_ST_NOMINATE),
}

func (SCPStatementType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCPStatementType
}
func (v SCPStatementType) String() string {
	if s, ok := _XdrNames_SCPStatementType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCPStatementType#%d", v)
}
func (v *SCPStatementType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCPStatementType[stok]; ok {
			*v = SCPStatementType(val)
			return nil
		} else if stok == "SCPStatementType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCPStatementType.", stok))
	}
}
func (v SCPStatementType) GetU32() uint32                 { return uint32(v) }
func (v *SCPStatementType) SetU32(n uint32)               { *v = SCPStatementType(n) }
func (v *SCPStatementType) XdrPointer() interface{}       { return v }
func (SCPStatementType) XdrTypeName() string              { return "SCPStatementType" }
func (v SCPStatementType) XdrValue() interface{}          { return v }
func (v *SCPStatementType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCPStatementType = *SCPStatementType

func XDR_SCPStatementType(v *SCPStatementType) *SCPStatementType { return v }

type _XdrVec_unbounded_Value []Value

func (_XdrVec_unbounded_Value) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Value) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Value length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Value length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Value) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Value) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Value, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Value) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Value(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Value) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Value) XdrTypeName() string              { return "Value<>" }
func (v *_XdrVec_unbounded_Value) XdrPointer() interface{}       { return (*[]Value)(v) }
func (v _XdrVec_unbounded_Value) XdrValue() interface{}          { return ([]Value)(v) }
func (v *_XdrVec_unbounded_Value) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCPNomination = *SCPNomination

func (v *SCPNomination) XdrPointer() interface{}       { return v }
func (SCPNomination) XdrTypeName() string              { return "SCPNomination" }
func (v SCPNomination) XdrValue() interface{}          { return v }
func (v *SCPNomination) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPNomination) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%squorumSetHash", name), XDR_Hash(&v.QuorumSetHash))
	x.Marshal(x.Sprintf("%svotes", name), (*_XdrVec_unbounded_Value)(&v.Votes))
	x.Marshal(x.Sprintf("%saccepted", name), (*_XdrVec_unbounded_Value)(&v.Accepted))
}
func XDR_SCPNomination(v *SCPNomination) *SCPNomination { return v }

type _XdrPtr_SCPBallot struct {
	p **SCPBallot
}
type _ptrflag_SCPBallot _XdrPtr_SCPBallot

func (v _ptrflag_SCPBallot) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SCPBallot) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SCPBallot flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SCPBallot) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SCPBallot) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SCPBallot)
		}
	default:
		XdrPanic("*SCPBallot present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SCPBallot) XdrTypeName() string             { return "SCPBallot?" }
func (v _ptrflag_SCPBallot) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SCPBallot) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SCPBallot) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SCPBallot) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SCPBallot) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SCPBallot)
	}
}
func (v _XdrPtr_SCPBallot) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SCPBallot(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SCPBallot) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SCPBallot(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SCPBallot) XdrTypeName() string       { return "SCPBallot*" }
func (v _XdrPtr_SCPBallot) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SCPBallot) XdrValue() interface{}   { return *v.p }

type XdrType_XdrAnon_SCPStatement_Pledges_Prepare = *XdrAnon_SCPStatement_Pledges_Prepare

func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrPointer() interface{} { return v }
func (XdrAnon_SCPStatement_Pledges_Prepare) XdrTypeName() string {
	return "XdrAnon_SCPStatement_Pledges_Prepare"
}
func (v XdrAnon_SCPStatement_Pledges_Prepare) XdrValue() interface{}          { return v }
func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%squorumSetHash", name), XDR_Hash(&v.QuorumSetHash))
	x.Marshal(x.Sprintf("%sballot", name), XDR_SCPBallot(&v.Ballot))
	x.Marshal(x.Sprintf("%sprepared", name), _XdrPtr_SCPBallot{&v.Prepared})
	x.Marshal(x.Sprintf("%spreparedPrime", name), _XdrPtr_SCPBallot{&v.PreparedPrime})
	x.Marshal(x.Sprintf("%snC", name), XDR_Uint32(&v.NC))
	x.Marshal(x.Sprintf("%snH", name), XDR_Uint32(&v.NH))
}
func XDR_XdrAnon_SCPStatement_Pledges_Prepare(v *XdrAnon_SCPStatement_Pledges_Prepare) *XdrAnon_SCPStatement_Pledges_Prepare {
	return v
}

type XdrType_XdrAnon_SCPStatement_Pledges_Confirm = *XdrAnon_SCPStatement_Pledges_Confirm

func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrPointer() interface{} { return v }
func (XdrAnon_SCPStatement_Pledges_Confirm) XdrTypeName() string {
	return "XdrAnon_SCPStatement_Pledges_Confirm"
}
func (v XdrAnon_SCPStatement_Pledges_Confirm) XdrValue() interface{}          { return v }
func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sballot", name), XDR_SCPBallot(&v.Ballot))
	x.Marshal(x.Sprintf("%snPrepared", name), XDR_Uint32(&v.NPrepared))
	x.Marshal(x.Sprintf("%snCommit", name), XDR_Uint32(&v.NCommit))
	x.Marshal(x.Sprintf("%snH", name), XDR_Uint32(&v.NH))
	x.Marshal(x.Sprintf("%squorumSetHash", name), XDR_Hash(&v.QuorumSetHash))
}
func XDR_XdrAnon_SCPStatement_Pledges_Confirm(v *XdrAnon_SCPStatement_Pledges_Confirm) *XdrAnon_SCPStatement_Pledges_Confirm {
	return v
}

type XdrType_XdrAnon_SCPStatement_Pledges_Externalize = *XdrAnon_SCPStatement_Pledges_Externalize

func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrPointer() interface{} { return v }
func (XdrAnon_SCPStatement_Pledges_Externalize) XdrTypeName() string {
	return "XdrAnon_SCPStatement_Pledges_Externalize"
}
func (v XdrAnon_SCPStatement_Pledges_Externalize) XdrValue() interface{}          { return v }
func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scommit", name), XDR_SCPBallot(&v.Commit))
	x.Marshal(x.Sprintf("%snH", name), XDR_Uint32(&v.NH))
	x.Marshal(x.Sprintf("%scommitQuorumSetHash", name), XDR_Hash(&v.CommitQuorumSetHash))
}
func XDR_XdrAnon_SCPStatement_Pledges_Externalize(v *XdrAnon_SCPStatement_Pledges_Externalize) *XdrAnon_SCPStatement_Pledges_Externalize {
	return v
}

var _XdrTags_XdrAnon_SCPStatement_Pledges = map[int32]bool{
	XdrToI32(SCP_ST_PREPARE):     true,
	XdrToI32(SCP_ST_CONFIRM):     true,
	XdrToI32(SCP_ST_EXTERNALIZE): true,
	XdrToI32(SCP_ST_NOMINATE):    true,
}

func (_ XdrAnon_SCPStatement_Pledges) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_SCPStatement_Pledges
}
func (u *XdrAnon_SCPStatement_Pledges) Prepare() *XdrAnon_SCPStatement_Pledges_Prepare {
	switch u.Type {
	case SCP_ST_PREPARE:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Prepare); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Prepare
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Prepare accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Confirm() *XdrAnon_SCPStatement_Pledges_Confirm {
	switch u.Type {
	case SCP_ST_CONFIRM:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Confirm); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Confirm
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Confirm accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Externalize() *XdrAnon_SCPStatement_Pledges_Externalize {
	switch u.Type {
	case SCP_ST_EXTERNALIZE:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Externalize); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Externalize
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Externalize accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Nominate() *SCPNomination {
	switch u.Type {
	case SCP_ST_NOMINATE:
		if v, ok := u._u.(*SCPNomination); ok {
			return v
		} else {
			var zero SCPNomination
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Nominate accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_SCPStatement_Pledges) XdrValid() bool {
	switch u.Type {
	case SCP_ST_PREPARE, SCP_ST_CONFIRM, SCP_ST_EXTERNALIZE, SCP_ST_NOMINATE:
		return true
	}
	return false
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionTag() XdrNum32 {
	return XDR_SCPStatementType(&u.Type)
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionBody() XdrType {
	switch u.Type {
	case SCP_ST_PREPARE:
		return XDR_XdrAnon_SCPStatement_Pledges_Prepare(u.Prepare())
	case SCP_ST_CONFIRM:
		return XDR_XdrAnon_SCPStatement_Pledges_Confirm(u.Confirm())
	case SCP_ST_EXTERNALIZE:
		return XDR_XdrAnon_SCPStatement_Pledges_Externalize(u.Externalize())
	case SCP_ST_NOMINATE:
		return XDR_SCPNomination(u.Nominate())
	}
	return nil
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionBodyName() string {
	switch u.Type {
	case SCP_ST_PREPARE:
		return "Prepare"
	case SCP_ST_CONFIRM:
		return "Confirm"
	case SCP_ST_EXTERNALIZE:
		return "Externalize"
	case SCP_ST_NOMINATE:
		return "Nominate"
	}
	return ""
}

type XdrType_XdrAnon_SCPStatement_Pledges = *XdrAnon_SCPStatement_Pledges

func (v *XdrAnon_SCPStatement_Pledges) XdrPointer() interface{}       { return v }
func (XdrAnon_SCPStatement_Pledges) XdrTypeName() string              { return "XdrAnon_SCPStatement_Pledges" }
func (v XdrAnon_SCPStatement_Pledges) XdrValue() interface{}          { return v }
func (v *XdrAnon_SCPStatement_Pledges) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_SCPStatement_Pledges) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPStatementType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SCP_ST_PREPARE:
		x.Marshal(x.Sprintf("%sprepare", name), XDR_XdrAnon_SCPStatement_Pledges_Prepare(u.Prepare()))
		return
	case SCP_ST_CONFIRM:
		x.Marshal(x.Sprintf("%sconfirm", name), XDR_XdrAnon_SCPStatement_Pledges_Confirm(u.Confirm()))
		return
	case SCP_ST_EXTERNALIZE:
		x.Marshal(x.Sprintf("%sexternalize", name), XDR_XdrAnon_SCPStatement_Pledges_Externalize(u.Externalize()))
		return
	case SCP_ST_NOMINATE:
		x.Marshal(x.Sprintf("%snominate", name), XDR_SCPNomination(u.Nominate()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_SCPStatement_Pledges", u.Type)
}
func XDR_XdrAnon_SCPStatement_Pledges(v *XdrAnon_SCPStatement_Pledges) *XdrAnon_SCPStatement_Pledges {
	return v
}

type XdrType_SCPStatement = *SCPStatement

func (v *SCPStatement) XdrPointer() interface{}       { return v }
func (SCPStatement) XdrTypeName() string              { return "SCPStatement" }
func (v SCPStatement) XdrValue() interface{}          { return v }
func (v *SCPStatement) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPStatement) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snodeID", name), XDR_NodeID(&v.NodeID))
	x.Marshal(x.Sprintf("%sslotIndex", name), XDR_Uint64(&v.SlotIndex))
	x.Marshal(x.Sprintf("%spledges", name), XDR_XdrAnon_SCPStatement_Pledges(&v.Pledges))
}
func XDR_SCPStatement(v *SCPStatement) *SCPStatement { return v }

type XdrType_SCPEnvelope = *SCPEnvelope

func (v *SCPEnvelope) XdrPointer() interface{}       { return v }
func (SCPEnvelope) XdrTypeName() string              { return "SCPEnvelope" }
func (v SCPEnvelope) XdrValue() interface{}          { return v }
func (v *SCPEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPEnvelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatement", name), XDR_SCPStatement(&v.Statement))
	x.Marshal(x.Sprintf("%ssignature", name), XDR_Signature(&v.Signature))
}
func XDR_SCPEnvelope(v *SCPEnvelope) *SCPEnvelope { return v }

type _XdrVec_unbounded_NodeID []NodeID

func (_XdrVec_unbounded_NodeID) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_NodeID) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_NodeID length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_NodeID length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_NodeID) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_NodeID) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]NodeID, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_NodeID) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_NodeID(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_NodeID) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_NodeID) XdrTypeName() string              { return "NodeID<>" }
func (v *_XdrVec_unbounded_NodeID) XdrPointer() interface{}       { return (*[]NodeID)(v) }
func (v _XdrVec_unbounded_NodeID) XdrValue() interface{}          { return ([]NodeID)(v) }
func (v *_XdrVec_unbounded_NodeID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_unbounded_SCPQuorumSet []SCPQuorumSet

func (_XdrVec_unbounded_SCPQuorumSet) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCPQuorumSet) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCPQuorumSet length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCPQuorumSet length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCPQuorumSet) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCPQuorumSet) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPQuorumSet, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCPQuorumSet(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SCPQuorumSet) XdrTypeName() string              { return "SCPQuorumSet<>" }
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrPointer() interface{}       { return (*[]SCPQuorumSet)(v) }
func (v _XdrVec_unbounded_SCPQuorumSet) XdrValue() interface{}          { return ([]SCPQuorumSet)(v) }
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCPQuorumSet = *SCPQuorumSet

func (v *SCPQuorumSet) XdrPointer() interface{}       { return v }
func (SCPQuorumSet) XdrTypeName() string              { return "SCPQuorumSet" }
func (v SCPQuorumSet) XdrValue() interface{}          { return v }
func (v *SCPQuorumSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPQuorumSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sthreshold", name), XDR_Uint32(&v.Threshold))
	x.Marshal(x.Sprintf("%svalidators", name), (*_XdrVec_unbounded_NodeID)(&v.Validators))
	x.Marshal(x.Sprintf("%sinnerSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.InnerSets))
}
func XDR_SCPQuorumSet(v *SCPQuorumSet) *SCPQuorumSet { return v }

type _XdrArray_4_opaque [4]byte

func (v *_XdrArray_4_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_4_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_4_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_4_opaque) XdrPointer() interface{}       { return (*[4]byte)(v) }
func (v *_XdrArray_4_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_4_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_4_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_4_opaque) XdrArraySize() uint32 {
	const bound uint32 = 4 // Force error if not const or doesn't fit
	return bound
}

type XdrType_Thresholds struct {
	*_XdrArray_4_opaque
}

func XDR_Thresholds(v *Thresholds) XdrType_Thresholds {
	return XdrType_Thresholds{(*_XdrArray_4_opaque)(v)}
}
func (XdrType_Thresholds) XdrTypeName() string  { return "Thresholds" }
func (v XdrType_Thresholds) XdrUnwrap() XdrType { return v._XdrArray_4_opaque }

type XdrType_String32 struct {
	XdrString
}

func XDR_String32(v *String32) XdrType_String32 {
	return XdrType_String32{XdrString{v, 32}}
}
func (XdrType_String32) XdrTypeName() string  { return "String32" }
func (v XdrType_String32) XdrUnwrap() XdrType { return v.XdrString }

type XdrType_String64 struct {
	XdrString
}

func XDR_String64(v *String64) XdrType_String64 {
	return XdrType_String64{XdrString{v, 64}}
}
func (XdrType_String64) XdrTypeName() string  { return "String64" }
func (v XdrType_String64) XdrUnwrap() XdrType { return v.XdrString }

type XdrType_SequenceNumber struct {
	XdrType_Int64
}

func XDR_SequenceNumber(v *SequenceNumber) XdrType_SequenceNumber {
	return XdrType_SequenceNumber{XDR_Int64(v)}
}
func (XdrType_SequenceNumber) XdrTypeName() string  { return "SequenceNumber" }
func (v XdrType_SequenceNumber) XdrUnwrap() XdrType { return v.XdrType_Int64 }

type XdrType_DataValue struct {
	XdrVecOpaque
}

func XDR_DataValue(v *DataValue) XdrType_DataValue {
	return XdrType_DataValue{XdrVecOpaque{v, 64}}
}
func (XdrType_DataValue) XdrTypeName() string  { return "DataValue" }
func (v XdrType_DataValue) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_PoolID struct {
	XdrType_Hash
}

func XDR_PoolID(v *PoolID) XdrType_PoolID {
	return XdrType_PoolID{XDR_Hash(v)}
}
func (XdrType_PoolID) XdrTypeName() string  { return "PoolID" }
func (v XdrType_PoolID) XdrUnwrap() XdrType { return v.XdrType_Hash }

type XdrType_AssetCode4 struct {
	*_XdrArray_4_opaque
}

func XDR_AssetCode4(v *AssetCode4) XdrType_AssetCode4 {
	return XdrType_AssetCode4{(*_XdrArray_4_opaque)(v)}
}
func (XdrType_AssetCode4) XdrTypeName() string  { return "AssetCode4" }
func (v XdrType_AssetCode4) XdrUnwrap() XdrType { return v._XdrArray_4_opaque }

type _XdrArray_12_opaque [12]byte

func (v *_XdrArray_12_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_12_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_12_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_12_opaque) XdrPointer() interface{}       { return (*[12]byte)(v) }
func (v *_XdrArray_12_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_12_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_12_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_12_opaque) XdrArraySize() uint32 {
	const bound uint32 = 12 // Force error if not const or doesn't fit
	return bound
}

type XdrType_AssetCode12 struct {
	*_XdrArray_12_opaque
}

func XDR_AssetCode12(v *AssetCode12) XdrType_AssetCode12 {
	return XdrType_AssetCode12{(*_XdrArray_12_opaque)(v)}
}
func (XdrType_AssetCode12) XdrTypeName() string  { return "AssetCode12" }
func (v XdrType_AssetCode12) XdrUnwrap() XdrType { return v._XdrArray_12_opaque }

var _XdrNames_AssetType = map[int32]string{
	int32(ASSET_TYPE_NATIVE):            "ASSET_TYPE_NATIVE",
	int32(ASSET_TYPE_CREDIT_ALPHANUM4):  "ASSET_TYPE_CREDIT_ALPHANUM4",
	int32(ASSET_TYPE_CREDIT_ALPHANUM12): "ASSET_TYPE_CREDIT_ALPHANUM12",
	int32(ASSET_TYPE_POOL_SHARE):        "ASSET_TYPE_POOL_SHARE",
}
var _XdrValues_AssetType = map[string]int32{
	"ASSET_TYPE_NATIVE":            int32(ASSET_TYPE_NATIVE),
	"ASSET_TYPE_CREDIT_ALPHANUM4":  int32(ASSET_TYPE_CREDIT_ALPHANUM4),
	"ASSET_TYPE_CREDIT_ALPHANUM12": int32(ASSET_TYPE_CREDIT_ALPHANUM12),
	"ASSET_TYPE_POOL_SHARE":        int32(ASSET_TYPE_POOL_SHARE),
}

func (AssetType) XdrEnumNames() map[int32]string {
	return _XdrNames_AssetType
}
func (v AssetType) String() string {
	if s, ok := _XdrNames_AssetType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AssetType#%d", v)
}
func (v *AssetType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AssetType[stok]; ok {
			*v = AssetType(val)
			return nil
		} else if stok == "AssetType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AssetType.", stok))
	}
}
func (v AssetType) GetU32() uint32                 { return uint32(v) }
func (v *AssetType) SetU32(n uint32)               { *v = AssetType(n) }
func (v *AssetType) XdrPointer() interface{}       { return v }
func (AssetType) XdrTypeName() string              { return "AssetType" }
func (v AssetType) XdrValue() interface{}          { return v }
func (v *AssetType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AssetType = *AssetType

func XDR_AssetType(v *AssetType) *AssetType { return v }

var _XdrTags_AssetCode = map[int32]bool{
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM4):  true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM12): true,
}

func (_ AssetCode) XdrValidTags() map[int32]bool {
	return _XdrTags_AssetCode
}
func (u *AssetCode) AssetCode4() *AssetCode4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AssetCode4); ok {
			return v
		} else {
			var zero AssetCode4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AssetCode.AssetCode4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *AssetCode) AssetCode12() *AssetCode12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AssetCode12); ok {
			return v
		} else {
			var zero AssetCode12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AssetCode.AssetCode12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u AssetCode) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12:
		return true
	}
	return false
}
func (u *AssetCode) XdrUnionTag() XdrNum32 {
	return XDR_AssetType(&u.Type)
}
func (u *AssetCode) XdrUnionTagName() string {
	return "Type"
}
func (u *AssetCode) XdrUnionBody() XdrType {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return XDR_AssetCode4(u.AssetCode4())
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return XDR_AssetCode12(u.AssetCode12())
	}
	return nil
}
func (u *AssetCode) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AssetCode4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AssetCode12"
	}
	return ""
}

type XdrType_AssetCode = *AssetCode

func (v *AssetCode) XdrPointer() interface{}       { return v }
func (AssetCode) XdrTypeName() string              { return "AssetCode" }
func (v AssetCode) XdrValue() interface{}          { return v }
func (v *AssetCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AssetCode) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		x.Marshal(x.Sprintf("%sassetCode4", name), XDR_AssetCode4(u.AssetCode4()))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		x.Marshal(x.Sprintf("%sassetCode12", name), XDR_AssetCode12(u.AssetCode12()))
		return
	}
	XdrPanic("invalid Type (%v) in AssetCode", u.Type)
}
func (v *AssetCode) XdrInitialize() {
	var zero AssetType
	switch zero {
	case ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12:
	default:
		if v.Type == zero {
			v.Type = ASSET_TYPE_CREDIT_ALPHANUM4
		}
	}
}
func XDR_AssetCode(v *AssetCode) *AssetCode { return v }

type XdrType_AlphaNum4 = *AlphaNum4

func (v *AlphaNum4) XdrPointer() interface{}       { return v }
func (AlphaNum4) XdrTypeName() string              { return "AlphaNum4" }
func (v AlphaNum4) XdrValue() interface{}          { return v }
func (v *AlphaNum4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AlphaNum4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sassetCode", name), XDR_AssetCode4(&v.AssetCode))
	x.Marshal(x.Sprintf("%sissuer", name), XDR_AccountID(&v.Issuer))
}
func XDR_AlphaNum4(v *AlphaNum4) *AlphaNum4 { return v }

type XdrType_AlphaNum12 = *AlphaNum12

func (v *AlphaNum12) XdrPointer() interface{}       { return v }
func (AlphaNum12) XdrTypeName() string              { return "AlphaNum12" }
func (v AlphaNum12) XdrValue() interface{}          { return v }
func (v *AlphaNum12) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AlphaNum12) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sassetCode", name), XDR_AssetCode12(&v.AssetCode))
	x.Marshal(x.Sprintf("%sissuer", name), XDR_AccountID(&v.Issuer))
}
func XDR_AlphaNum12(v *AlphaNum12) *AlphaNum12 { return v }

var _XdrTags_Asset = map[int32]bool{
	XdrToI32(ASSET_TYPE_NATIVE):            true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM4):  true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM12): true,
}

func (_ Asset) XdrValidTags() map[int32]bool {
	return _XdrTags_Asset
}
func (u *Asset) AlphaNum4() *AlphaNum4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AlphaNum4); ok {
			return v
		} else {
			var zero AlphaNum4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Asset.AlphaNum4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Asset) AlphaNum12() *AlphaNum12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AlphaNum12); ok {
			return v
		} else {
			var zero AlphaNum12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Asset.AlphaNum12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Asset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_NATIVE, ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12:
		return true
	}
	return false
}
func (u *Asset) XdrUnionTag() XdrNum32 {
	return XDR_AssetType(&u.Type)
}
func (u *Asset) XdrUnionTagName() string {
	return "Type"
}
func (u *Asset) XdrUnionBody() XdrType {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return nil
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return XDR_AlphaNum4(u.AlphaNum4())
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return XDR_AlphaNum12(u.AlphaNum12())
	}
	return nil
}
func (u *Asset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return ""
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AlphaNum4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AlphaNum12"
	}
	return ""
}

type XdrType_Asset = *Asset

func (v *Asset) XdrPointer() interface{}       { return v }
func (Asset) XdrTypeName() string              { return "Asset" }
func (v Asset) XdrValue() interface{}          { return v }
func (v *Asset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Asset) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		x.Marshal(x.Sprintf("%salphaNum4", name), XDR_AlphaNum4(u.AlphaNum4()))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		x.Marshal(x.Sprintf("%salphaNum12", name), XDR_AlphaNum12(u.AlphaNum12()))
		return
	}
	XdrPanic("invalid Type (%v) in Asset", u.Type)
}
func XDR_Asset(v *Asset) *Asset { return v }

type XdrType_Price = *Price

func (v *Price) XdrPointer() interface{}       { return v }
func (Price) XdrTypeName() string              { return "Price" }
func (v Price) XdrValue() interface{}          { return v }
func (v *Price) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Price) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sn", name), XDR_Int32(&v.N))
	x.Marshal(x.Sprintf("%sd", name), XDR_Int32(&v.D))
}
func XDR_Price(v *Price) *Price { return v }

type XdrType_Liabilities = *Liabilities

func (v *Liabilities) XdrPointer() interface{}       { return v }
func (Liabilities) XdrTypeName() string              { return "Liabilities" }
func (v Liabilities) XdrValue() interface{}          { return v }
func (v *Liabilities) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Liabilities) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Int64(&v.Buying))
	x.Marshal(x.Sprintf("%sselling", name), XDR_Int64(&v.Selling))
}
func XDR_Liabilities(v *Liabilities) *Liabilities { return v }

var _XdrNames_ThresholdIndexes = map[int32]string{
	int32(THRESHOLD_MASTER_WEIGHT): "THRESHOLD_MASTER_WEIGHT",
	int32(THRESHOLD_LOW):           "THRESHOLD_LOW",
	int32(THRESHOLD_MED):           "THRESHOLD_MED",
	int32(THRESHOLD_HIGH):          "THRESHOLD_HIGH",
}
var _XdrValues_ThresholdIndexes = map[string]int32{
	"THRESHOLD_MASTER_WEIGHT": int32(THRESHOLD_MASTER_WEIGHT),
	"THRESHOLD_LOW":           int32(THRESHOLD_LOW),
	"THRESHOLD_MED":           int32(THRESHOLD_MED),
	"THRESHOLD_HIGH":          int32(THRESHOLD_HIGH),
}

func (ThresholdIndexes) XdrEnumNames() map[int32]string {
	return _XdrNames_ThresholdIndexes
}
func (v ThresholdIndexes) String() string {
	if s, ok := _XdrNames_ThresholdIndexes[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ThresholdIndexes#%d", v)
}
func (v *ThresholdIndexes) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ThresholdIndexes[stok]; ok {
			*v = ThresholdIndexes(val)
			return nil
		} else if stok == "ThresholdIndexes" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ThresholdIndexes.", stok))
	}
}
func (v ThresholdIndexes) GetU32() uint32                 { return uint32(v) }
func (v *ThresholdIndexes) SetU32(n uint32)               { *v = ThresholdIndexes(n) }
func (v *ThresholdIndexes) XdrPointer() interface{}       { return v }
func (ThresholdIndexes) XdrTypeName() string              { return "ThresholdIndexes" }
func (v ThresholdIndexes) XdrValue() interface{}          { return v }
func (v *ThresholdIndexes) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ThresholdIndexes = *ThresholdIndexes

func XDR_ThresholdIndexes(v *ThresholdIndexes) *ThresholdIndexes { return v }

var _XdrNames_LedgerEntryType = map[int32]string{
	int32(ACCOUNT):           "ACCOUNT",
	int32(TRUSTLINE):         "TRUSTLINE",
	int32(OFFER):             "OFFER",
	int32(DATA):              "DATA",
	int32(CLAIMABLE_BALANCE): "CLAIMABLE_BALANCE",
	int32(LIQUIDITY_POOL):    "LIQUIDITY_POOL",
	int32(CONTRACT_DATA):     "CONTRACT_DATA",
	int32(CONTRACT_CODE):     "CONTRACT_CODE",
	int32(CONFIG_SETTING):    "CONFIG_SETTING",
	int32(TTL):               "TTL",
}
var _XdrValues_LedgerEntryType = map[string]int32{
	"ACCOUNT":           int32(ACCOUNT),
	"TRUSTLINE":         int32(TRUSTLINE),
	"OFFER":             int32(OFFER),
	"DATA":              int32(DATA),
	"CLAIMABLE_BALANCE": int32(CLAIMABLE_BALANCE),
	"LIQUIDITY_POOL":    int32(LIQUIDITY_POOL),
	"CONTRACT_DATA":     int32(CONTRACT_DATA),
	"CONTRACT_CODE":     int32(CONTRACT_CODE),
	"CONFIG_SETTING":    int32(CONFIG_SETTING),
	"TTL":               int32(TTL),
}

func (LedgerEntryType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerEntryType
}
func (v LedgerEntryType) String() string {
	if s, ok := _XdrNames_LedgerEntryType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerEntryType#%d", v)
}
func (v *LedgerEntryType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerEntryType[stok]; ok {
			*v = LedgerEntryType(val)
			return nil
		} else if stok == "LedgerEntryType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerEntryType.", stok))
	}
}
func (v LedgerEntryType) GetU32() uint32                 { return uint32(v) }
func (v *LedgerEntryType) SetU32(n uint32)               { *v = LedgerEntryType(n) }
func (v *LedgerEntryType) XdrPointer() interface{}       { return v }
func (LedgerEntryType) XdrTypeName() string              { return "LedgerEntryType" }
func (v LedgerEntryType) XdrValue() interface{}          { return v }
func (v *LedgerEntryType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerEntryType = *LedgerEntryType

func XDR_LedgerEntryType(v *LedgerEntryType) *LedgerEntryType { return v }

type XdrType_Signer = *Signer

func (v *Signer) XdrPointer() interface{}       { return v }
func (Signer) XdrTypeName() string              { return "Signer" }
func (v Signer) XdrValue() interface{}          { return v }
func (v *Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Signer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XDR_SignerKey(&v.Key))
	x.Marshal(x.Sprintf("%sweight", name), XDR_Uint32(&v.Weight))
}
func XDR_Signer(v *Signer) *Signer { return v }

var _XdrNames_AccountFlags = map[int32]string{
	int32(AUTH_REQUIRED_FLAG):         "AUTH_REQUIRED_FLAG",
	int32(AUTH_REVOCABLE_FLAG):        "AUTH_REVOCABLE_FLAG",
	int32(AUTH_IMMUTABLE_FLAG):        "AUTH_IMMUTABLE_FLAG",
	int32(AUTH_CLAWBACK_ENABLED_FLAG): "AUTH_CLAWBACK_ENABLED_FLAG",
}
var _XdrValues_AccountFlags = map[string]int32{
	"AUTH_REQUIRED_FLAG":         int32(AUTH_REQUIRED_FLAG),
	"AUTH_REVOCABLE_FLAG":        int32(AUTH_REVOCABLE_FLAG),
	"AUTH_IMMUTABLE_FLAG":        int32(AUTH_IMMUTABLE_FLAG),
	"AUTH_CLAWBACK_ENABLED_FLAG": int32(AUTH_CLAWBACK_ENABLED_FLAG),
}

func (AccountFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_AccountFlags
}
func (v AccountFlags) String() string {
	if s, ok := _XdrNames_AccountFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AccountFlags#%d", v)
}
func (v *AccountFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AccountFlags[stok]; ok {
			*v = AccountFlags(val)
			return nil
		} else if stok == "AccountFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AccountFlags.", stok))
	}
}
func (v AccountFlags) GetU32() uint32                 { return uint32(v) }
func (v *AccountFlags) SetU32(n uint32)               { *v = AccountFlags(n) }
func (v *AccountFlags) XdrPointer() interface{}       { return v }
func (AccountFlags) XdrTypeName() string              { return "AccountFlags" }
func (v AccountFlags) XdrValue() interface{}          { return v }
func (v *AccountFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AccountFlags = *AccountFlags

func XDR_AccountFlags(v *AccountFlags) *AccountFlags { return v }

var _XdrComments_AccountFlags = map[int32]string{
	int32(AUTH_REQUIRED_FLAG):         "Flags set on issuer accounts TrustLines are created with authorized set to \"false\" requiring the issuer to set it for each TrustLine",
	int32(AUTH_REVOCABLE_FLAG):        "If set, the authorized flag in TrustLines can be cleared otherwise, authorization cannot be revoked",
	int32(AUTH_IMMUTABLE_FLAG):        "Once set, causes all AUTH_* flags to be read-only",
	int32(AUTH_CLAWBACK_ENABLED_FLAG): "Trustlines are created with clawback enabled set to \"true\", and claimable balances created from those trustlines are created with clawback enabled set to \"true\"",
}

func (e AccountFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_AccountFlags
}
func (v *AccountFlags) XdrInitialize() {
	switch AccountFlags(0) {
	case AUTH_REQUIRED_FLAG, AUTH_REVOCABLE_FLAG, AUTH_IMMUTABLE_FLAG, AUTH_CLAWBACK_ENABLED_FLAG:
	default:
		if *v == AccountFlags(0) {
			*v = AUTH_REQUIRED_FLAG
		}
	}
}

type _XdrPtr_AccountID struct {
	p **AccountID
}
type _ptrflag_AccountID _XdrPtr_AccountID

func (v _ptrflag_AccountID) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_AccountID) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("AccountID flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_AccountID) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_AccountID) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(AccountID)
		}
	default:
		XdrPanic("*AccountID present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_AccountID) XdrTypeName() string             { return "AccountID?" }
func (v _ptrflag_AccountID) XdrPointer() interface{}       { return nil }
func (v _ptrflag_AccountID) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_AccountID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_AccountID) XdrBound() uint32              { return 1 }
func (v _XdrPtr_AccountID) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_AccountID) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(AccountID)
	}
}
func (v _XdrPtr_AccountID) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_AccountID(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_AccountID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_AccountID) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_AccountID(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_AccountID) XdrTypeName() string       { return "AccountID*" }
func (v _XdrPtr_AccountID) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_AccountID) XdrValue() interface{}   { return *v.p }

type XdrType_SponsorshipDescriptor struct {
	_XdrPtr_AccountID
}

func XDR_SponsorshipDescriptor(v *SponsorshipDescriptor) XdrType_SponsorshipDescriptor {
	return XdrType_SponsorshipDescriptor{_XdrPtr_AccountID{v}}
}
func (XdrType_SponsorshipDescriptor) XdrTypeName() string  { return "SponsorshipDescriptor" }
func (v XdrType_SponsorshipDescriptor) XdrUnwrap() XdrType { return v._XdrPtr_AccountID }

type XdrType_AccountEntryExtensionV3 = *AccountEntryExtensionV3

func (v *AccountEntryExtensionV3) XdrPointer() interface{}       { return v }
func (AccountEntryExtensionV3) XdrTypeName() string              { return "AccountEntryExtensionV3" }
func (v AccountEntryExtensionV3) XdrValue() interface{}          { return v }
func (v *AccountEntryExtensionV3) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntryExtensionV3) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%sseqLedger", name), XDR_Uint32(&v.SeqLedger))
	x.Marshal(x.Sprintf("%sseqTime", name), XDR_TimePoint(&v.SeqTime))
}
func XDR_AccountEntryExtensionV3(v *AccountEntryExtensionV3) *AccountEntryExtensionV3 { return v }

var _XdrTags_XdrAnon_AccountEntryExtensionV2_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(3): true,
}

func (_ XdrAnon_AccountEntryExtensionV2_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_AccountEntryExtensionV2_Ext
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) V3() *AccountEntryExtensionV3 {
	switch u.V {
	case 3:
		if v, ok := u._u.(*AccountEntryExtensionV3); ok {
			return v
		} else {
			var zero AccountEntryExtensionV3
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AccountEntryExtensionV2_Ext.V3 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_AccountEntryExtensionV2_Ext) XdrValid() bool {
	switch u.V {
	case 0, 3:
		return true
	}
	return false
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 3:
		return XDR_AccountEntryExtensionV3(u.V3())
	}
	return nil
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 3:
		return "V3"
	}
	return ""
}

type XdrType_XdrAnon_AccountEntryExtensionV2_Ext = *XdrAnon_AccountEntryExtensionV2_Ext

func (v *XdrAnon_AccountEntryExtensionV2_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_AccountEntryExtensionV2_Ext) XdrTypeName() string {
	return "XdrAnon_AccountEntryExtensionV2_Ext"
}
func (v XdrAnon_AccountEntryExtensionV2_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_AccountEntryExtensionV2_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 3:
		x.Marshal(x.Sprintf("%sv3", name), XDR_AccountEntryExtensionV3(u.V3()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_AccountEntryExtensionV2_Ext", u.V)
}
func XDR_XdrAnon_AccountEntryExtensionV2_Ext(v *XdrAnon_AccountEntryExtensionV2_Ext) *XdrAnon_AccountEntryExtensionV2_Ext {
	return v
}

type _XdrVec_20_SponsorshipDescriptor []SponsorshipDescriptor

func (_XdrVec_20_SponsorshipDescriptor) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_20_SponsorshipDescriptor) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		XdrPanic("_XdrVec_20_SponsorshipDescriptor length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_20_SponsorshipDescriptor length %d exceeds max int", length)
	}
}
func (v _XdrVec_20_SponsorshipDescriptor) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_20_SponsorshipDescriptor) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SponsorshipDescriptor, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_20_SponsorshipDescriptor) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SponsorshipDescriptor(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_20_SponsorshipDescriptor) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 20}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_20_SponsorshipDescriptor) XdrTypeName() string { return "SponsorshipDescriptor<>" }
func (v *_XdrVec_20_SponsorshipDescriptor) XdrPointer() interface{} {
	return (*[]SponsorshipDescriptor)(v)
}
func (v _XdrVec_20_SponsorshipDescriptor) XdrValue() interface{}          { return ([]SponsorshipDescriptor)(v) }
func (v *_XdrVec_20_SponsorshipDescriptor) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AccountEntryExtensionV2 = *AccountEntryExtensionV2

func (v *AccountEntryExtensionV2) XdrPointer() interface{}       { return v }
func (AccountEntryExtensionV2) XdrTypeName() string              { return "AccountEntryExtensionV2" }
func (v AccountEntryExtensionV2) XdrValue() interface{}          { return v }
func (v *AccountEntryExtensionV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntryExtensionV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snumSponsored", name), XDR_Uint32(&v.NumSponsored))
	x.Marshal(x.Sprintf("%snumSponsoring", name), XDR_Uint32(&v.NumSponsoring))
	x.Marshal(x.Sprintf("%ssignerSponsoringIDs", name), (*_XdrVec_20_SponsorshipDescriptor)(&v.SignerSponsoringIDs))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_AccountEntryExtensionV2_Ext(&v.Ext))
}
func XDR_AccountEntryExtensionV2(v *AccountEntryExtensionV2) *AccountEntryExtensionV2 { return v }

var _XdrTags_XdrAnon_AccountEntryExtensionV1_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(2): true,
}

func (_ XdrAnon_AccountEntryExtensionV1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_AccountEntryExtensionV1_Ext
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) V2() *AccountEntryExtensionV2 {
	switch u.V {
	case 2:
		if v, ok := u._u.(*AccountEntryExtensionV2); ok {
			return v
		} else {
			var zero AccountEntryExtensionV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AccountEntryExtensionV1_Ext.V2 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_AccountEntryExtensionV1_Ext) XdrValid() bool {
	switch u.V {
	case 0, 2:
		return true
	}
	return false
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 2:
		return XDR_AccountEntryExtensionV2(u.V2())
	}
	return nil
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 2:
		return "V2"
	}
	return ""
}

type XdrType_XdrAnon_AccountEntryExtensionV1_Ext = *XdrAnon_AccountEntryExtensionV1_Ext

func (v *XdrAnon_AccountEntryExtensionV1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_AccountEntryExtensionV1_Ext) XdrTypeName() string {
	return "XdrAnon_AccountEntryExtensionV1_Ext"
}
func (v XdrAnon_AccountEntryExtensionV1_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_AccountEntryExtensionV1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_AccountEntryExtensionV2(u.V2()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_AccountEntryExtensionV1_Ext", u.V)
}
func XDR_XdrAnon_AccountEntryExtensionV1_Ext(v *XdrAnon_AccountEntryExtensionV1_Ext) *XdrAnon_AccountEntryExtensionV1_Ext {
	return v
}

type XdrType_AccountEntryExtensionV1 = *AccountEntryExtensionV1

func (v *AccountEntryExtensionV1) XdrPointer() interface{}       { return v }
func (AccountEntryExtensionV1) XdrTypeName() string              { return "AccountEntryExtensionV1" }
func (v AccountEntryExtensionV1) XdrValue() interface{}          { return v }
func (v *AccountEntryExtensionV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntryExtensionV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliabilities", name), XDR_Liabilities(&v.Liabilities))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_AccountEntryExtensionV1_Ext(&v.Ext))
}
func XDR_AccountEntryExtensionV1(v *AccountEntryExtensionV1) *AccountEntryExtensionV1 { return v }

var _XdrTags_XdrAnon_AccountEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_AccountEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_AccountEntry_Ext
}
func (u *XdrAnon_AccountEntry_Ext) V1() *AccountEntryExtensionV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*AccountEntryExtensionV1); ok {
			return v
		} else {
			var zero AccountEntryExtensionV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AccountEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_AccountEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_AccountEntryExtensionV1(u.V1())
	}
	return nil
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_AccountEntry_Ext = *XdrAnon_AccountEntry_Ext

func (v *XdrAnon_AccountEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_AccountEntry_Ext) XdrTypeName() string              { return "XdrAnon_AccountEntry_Ext" }
func (v XdrAnon_AccountEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_AccountEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AccountEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_AccountEntryExtensionV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_AccountEntry_Ext", u.V)
}
func XDR_XdrAnon_AccountEntry_Ext(v *XdrAnon_AccountEntry_Ext) *XdrAnon_AccountEntry_Ext { return v }

type _XdrVec_20_Signer []Signer

func (_XdrVec_20_Signer) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_20_Signer) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		XdrPanic("_XdrVec_20_Signer length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_20_Signer length %d exceeds max int", length)
	}
}
func (v _XdrVec_20_Signer) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_20_Signer) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Signer, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_20_Signer) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Signer(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_20_Signer) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 20}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_20_Signer) XdrTypeName() string              { return "Signer<>" }
func (v *_XdrVec_20_Signer) XdrPointer() interface{}       { return (*[]Signer)(v) }
func (v _XdrVec_20_Signer) XdrValue() interface{}          { return ([]Signer)(v) }
func (v *_XdrVec_20_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AccountEntry = *AccountEntry

func (v *AccountEntry) XdrPointer() interface{}       { return v }
func (AccountEntry) XdrTypeName() string              { return "AccountEntry" }
func (v AccountEntry) XdrValue() interface{}          { return v }
func (v *AccountEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sbalance", name), XDR_Int64(&v.Balance))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%snumSubEntries", name), XDR_Uint32(&v.NumSubEntries))
	x.Marshal(x.Sprintf("%sinflationDest", name), _XdrPtr_AccountID{&v.InflationDest})
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
	x.Marshal(x.Sprintf("%shomeDomain", name), XDR_String32(&v.HomeDomain))
	x.Marshal(x.Sprintf("%sthresholds", name), XDR_Thresholds(&v.Thresholds))
	x.Marshal(x.Sprintf("%ssigners", name), (*_XdrVec_20_Signer)(&v.Signers))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_AccountEntry_Ext(&v.Ext))
}
func XDR_AccountEntry(v *AccountEntry) *AccountEntry { return v }

var _XdrNames_TrustLineFlags = map[int32]string{
	int32(AUTHORIZED_FLAG):                         "AUTHORIZED_FLAG",
	int32(AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG): "AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG",
	int32(TRUSTLINE_CLAWBACK_ENABLED_FLAG):         "TRUSTLINE_CLAWBACK_ENABLED_FLAG",
}
var _XdrValues_TrustLineFlags = map[string]int32{
	"AUTHORIZED_FLAG":                         int32(AUTHORIZED_FLAG),
	"AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG": int32(AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG),
	"TRUSTLINE_CLAWBACK_ENABLED_FLAG":         int32(TRUSTLINE_CLAWBACK_ENABLED_FLAG),
}

func (TrustLineFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_TrustLineFlags
}
func (v TrustLineFlags) String() string {
	if s, ok := _XdrNames_TrustLineFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("TrustLineFlags#%d", v)
}
func (v *TrustLineFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TrustLineFlags[stok]; ok {
			*v = TrustLineFlags(val)
			return nil
		} else if stok == "TrustLineFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid TrustLineFlags.", stok))
	}
}
func (v TrustLineFlags) GetU32() uint32                 { return uint32(v) }
func (v *TrustLineFlags) SetU32(n uint32)               { *v = TrustLineFlags(n) }
func (v *TrustLineFlags) XdrPointer() interface{}       { return v }
func (TrustLineFlags) XdrTypeName() string              { return "TrustLineFlags" }
func (v TrustLineFlags) XdrValue() interface{}          { return v }
func (v *TrustLineFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TrustLineFlags = *TrustLineFlags

func XDR_TrustLineFlags(v *TrustLineFlags) *TrustLineFlags { return v }

var _XdrComments_TrustLineFlags = map[int32]string{
	int32(AUTHORIZED_FLAG):                         "issuer has authorized account to perform transactions with its credit",
	int32(AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG): "issuer has authorized account to maintain and reduce liabilities for its credit",
	int32(TRUSTLINE_CLAWBACK_ENABLED_FLAG):         "issuer has specified that it may clawback its credit, and that claimable balances created with its credit may also be clawed back",
}

func (e TrustLineFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_TrustLineFlags
}
func (v *TrustLineFlags) XdrInitialize() {
	switch TrustLineFlags(0) {
	case AUTHORIZED_FLAG, AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG, TRUSTLINE_CLAWBACK_ENABLED_FLAG:
	default:
		if *v == TrustLineFlags(0) {
			*v = AUTHORIZED_FLAG
		}
	}
}

var _XdrNames_LiquidityPoolType = map[int32]string{
	int32(LIQUIDITY_POOL_CONSTANT_PRODUCT): "LIQUIDITY_POOL_CONSTANT_PRODUCT",
}
var _XdrValues_LiquidityPoolType = map[string]int32{
	"LIQUIDITY_POOL_CONSTANT_PRODUCT": int32(LIQUIDITY_POOL_CONSTANT_PRODUCT),
}

func (LiquidityPoolType) XdrEnumNames() map[int32]string {
	return _XdrNames_LiquidityPoolType
}
func (v LiquidityPoolType) String() string {
	if s, ok := _XdrNames_LiquidityPoolType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LiquidityPoolType#%d", v)
}
func (v *LiquidityPoolType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LiquidityPoolType[stok]; ok {
			*v = LiquidityPoolType(val)
			return nil
		} else if stok == "LiquidityPoolType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LiquidityPoolType.", stok))
	}
}
func (v LiquidityPoolType) GetU32() uint32                 { return uint32(v) }
func (v *LiquidityPoolType) SetU32(n uint32)               { *v = LiquidityPoolType(n) }
func (v *LiquidityPoolType) XdrPointer() interface{}       { return v }
func (LiquidityPoolType) XdrTypeName() string              { return "LiquidityPoolType" }
func (v LiquidityPoolType) XdrValue() interface{}          { return v }
func (v *LiquidityPoolType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LiquidityPoolType = *LiquidityPoolType

func XDR_LiquidityPoolType(v *LiquidityPoolType) *LiquidityPoolType { return v }

var _XdrTags_TrustLineAsset = map[int32]bool{
	XdrToI32(ASSET_TYPE_NATIVE):            true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM4):  true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM12): true,
	XdrToI32(ASSET_TYPE_POOL_SHARE):        true,
}

func (_ TrustLineAsset) XdrValidTags() map[int32]bool {
	return _XdrTags_TrustLineAsset
}
func (u *TrustLineAsset) AlphaNum4() *AlphaNum4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AlphaNum4); ok {
			return v
		} else {
			var zero AlphaNum4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TrustLineAsset.AlphaNum4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *TrustLineAsset) AlphaNum12() *AlphaNum12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AlphaNum12); ok {
			return v
		} else {
			var zero AlphaNum12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TrustLineAsset.AlphaNum12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *TrustLineAsset) LiquidityPoolID() *PoolID {
	switch u.Type {
	case ASSET_TYPE_POOL_SHARE:
		if v, ok := u._u.(*PoolID); ok {
			return v
		} else {
			var zero PoolID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TrustLineAsset.LiquidityPoolID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u TrustLineAsset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_NATIVE, ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12, ASSET_TYPE_POOL_SHARE:
		return true
	}
	return false
}
func (u *TrustLineAsset) XdrUnionTag() XdrNum32 {
	return XDR_AssetType(&u.Type)
}
func (u *TrustLineAsset) XdrUnionTagName() string {
	return "Type"
}
func (u *TrustLineAsset) XdrUnionBody() XdrType {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return nil
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return XDR_AlphaNum4(u.AlphaNum4())
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return XDR_AlphaNum12(u.AlphaNum12())
	case ASSET_TYPE_POOL_SHARE:
		return XDR_PoolID(u.LiquidityPoolID())
	}
	return nil
}
func (u *TrustLineAsset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return ""
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AlphaNum4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AlphaNum12"
	case ASSET_TYPE_POOL_SHARE:
		return "LiquidityPoolID"
	}
	return ""
}

type XdrType_TrustLineAsset = *TrustLineAsset

func (v *TrustLineAsset) XdrPointer() interface{}       { return v }
func (TrustLineAsset) XdrTypeName() string              { return "TrustLineAsset" }
func (v TrustLineAsset) XdrValue() interface{}          { return v }
func (v *TrustLineAsset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TrustLineAsset) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		x.Marshal(x.Sprintf("%salphaNum4", name), XDR_AlphaNum4(u.AlphaNum4()))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		x.Marshal(x.Sprintf("%salphaNum12", name), XDR_AlphaNum12(u.AlphaNum12()))
		return
	case ASSET_TYPE_POOL_SHARE:
		x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(u.LiquidityPoolID()))
		return
	}
	XdrPanic("invalid Type (%v) in TrustLineAsset", u.Type)
}
func XDR_TrustLineAsset(v *TrustLineAsset) *TrustLineAsset { return v }

var _XdrTags_XdrAnon_TrustLineEntryExtensionV2_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TrustLineEntryExtensionV2_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TrustLineEntryExtensionV2_Ext
}
func (u XdrAnon_TrustLineEntryExtensionV2_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TrustLineEntryExtensionV2_Ext = *XdrAnon_TrustLineEntryExtensionV2_Ext

func (v *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TrustLineEntryExtensionV2_Ext) XdrTypeName() string {
	return "XdrAnon_TrustLineEntryExtensionV2_Ext"
}
func (v XdrAnon_TrustLineEntryExtensionV2_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TrustLineEntryExtensionV2_Ext", u.V)
}
func XDR_XdrAnon_TrustLineEntryExtensionV2_Ext(v *XdrAnon_TrustLineEntryExtensionV2_Ext) *XdrAnon_TrustLineEntryExtensionV2_Ext {
	return v
}

type XdrType_TrustLineEntryExtensionV2 = *TrustLineEntryExtensionV2

func (v *TrustLineEntryExtensionV2) XdrPointer() interface{}       { return v }
func (TrustLineEntryExtensionV2) XdrTypeName() string              { return "TrustLineEntryExtensionV2" }
func (v TrustLineEntryExtensionV2) XdrValue() interface{}          { return v }
func (v *TrustLineEntryExtensionV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TrustLineEntryExtensionV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolUseCount", name), XDR_Int32(&v.LiquidityPoolUseCount))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TrustLineEntryExtensionV2_Ext(&v.Ext))
}
func XDR_TrustLineEntryExtensionV2(v *TrustLineEntryExtensionV2) *TrustLineEntryExtensionV2 { return v }

var _XdrTags_XdrAnon_TrustLineEntry_Ext_V1_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(2): true,
}

func (_ XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TrustLineEntry_Ext_V1_Ext
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) V2() *TrustLineEntryExtensionV2 {
	switch u.V {
	case 2:
		if v, ok := u._u.(*TrustLineEntryExtensionV2); ok {
			return v
		} else {
			var zero TrustLineEntryExtensionV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TrustLineEntry_Ext_V1_Ext.V2 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrValid() bool {
	switch u.V {
	case 0, 2:
		return true
	}
	return false
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 2:
		return XDR_TrustLineEntryExtensionV2(u.V2())
	}
	return nil
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 2:
		return "V2"
	}
	return ""
}

type XdrType_XdrAnon_TrustLineEntry_Ext_V1_Ext = *XdrAnon_TrustLineEntry_Ext_V1_Ext

func (v *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrTypeName() string {
	return "XdrAnon_TrustLineEntry_Ext_V1_Ext"
}
func (v XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_TrustLineEntryExtensionV2(u.V2()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TrustLineEntry_Ext_V1_Ext", u.V)
}
func XDR_XdrAnon_TrustLineEntry_Ext_V1_Ext(v *XdrAnon_TrustLineEntry_Ext_V1_Ext) *XdrAnon_TrustLineEntry_Ext_V1_Ext {
	return v
}

type XdrType_XdrAnon_TrustLineEntry_Ext_V1 = *XdrAnon_TrustLineEntry_Ext_V1

func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrPointer() interface{}       { return v }
func (XdrAnon_TrustLineEntry_Ext_V1) XdrTypeName() string              { return "XdrAnon_TrustLineEntry_Ext_V1" }
func (v XdrAnon_TrustLineEntry_Ext_V1) XdrValue() interface{}          { return v }
func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliabilities", name), XDR_Liabilities(&v.Liabilities))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TrustLineEntry_Ext_V1_Ext(&v.Ext))
}
func XDR_XdrAnon_TrustLineEntry_Ext_V1(v *XdrAnon_TrustLineEntry_Ext_V1) *XdrAnon_TrustLineEntry_Ext_V1 {
	return v
}

var _XdrTags_XdrAnon_TrustLineEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_TrustLineEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TrustLineEntry_Ext
}
func (u *XdrAnon_TrustLineEntry_Ext) V1() *XdrAnon_TrustLineEntry_Ext_V1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*XdrAnon_TrustLineEntry_Ext_V1); ok {
			return v
		} else {
			var zero XdrAnon_TrustLineEntry_Ext_V1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TrustLineEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_TrustLineEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_XdrAnon_TrustLineEntry_Ext_V1(u.V1())
	}
	return nil
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_TrustLineEntry_Ext = *XdrAnon_TrustLineEntry_Ext

func (v *XdrAnon_TrustLineEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_TrustLineEntry_Ext) XdrTypeName() string              { return "XdrAnon_TrustLineEntry_Ext" }
func (v XdrAnon_TrustLineEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TrustLineEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TrustLineEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_XdrAnon_TrustLineEntry_Ext_V1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TrustLineEntry_Ext", u.V)
}
func XDR_XdrAnon_TrustLineEntry_Ext(v *XdrAnon_TrustLineEntry_Ext) *XdrAnon_TrustLineEntry_Ext {
	return v
}

type XdrType_TrustLineEntry = *TrustLineEntry

func (v *TrustLineEntry) XdrPointer() interface{}       { return v }
func (TrustLineEntry) XdrTypeName() string              { return "TrustLineEntry" }
func (v TrustLineEntry) XdrValue() interface{}          { return v }
func (v *TrustLineEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TrustLineEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sasset", name), XDR_TrustLineAsset(&v.Asset))
	x.Marshal(x.Sprintf("%sbalance", name), XDR_Int64(&v.Balance))
	x.Marshal(x.Sprintf("%slimit", name), XDR_Int64(&v.Limit))
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TrustLineEntry_Ext(&v.Ext))
}
func XDR_TrustLineEntry(v *TrustLineEntry) *TrustLineEntry { return v }

var _XdrNames_OfferEntryFlags = map[int32]string{
	int32(PASSIVE_FLAG): "PASSIVE_FLAG",
}
var _XdrValues_OfferEntryFlags = map[string]int32{
	"PASSIVE_FLAG": int32(PASSIVE_FLAG),
}

func (OfferEntryFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_OfferEntryFlags
}
func (v OfferEntryFlags) String() string {
	if s, ok := _XdrNames_OfferEntryFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OfferEntryFlags#%d", v)
}
func (v *OfferEntryFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OfferEntryFlags[stok]; ok {
			*v = OfferEntryFlags(val)
			return nil
		} else if stok == "OfferEntryFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OfferEntryFlags.", stok))
	}
}
func (v OfferEntryFlags) GetU32() uint32                 { return uint32(v) }
func (v *OfferEntryFlags) SetU32(n uint32)               { *v = OfferEntryFlags(n) }
func (v *OfferEntryFlags) XdrPointer() interface{}       { return v }
func (OfferEntryFlags) XdrTypeName() string              { return "OfferEntryFlags" }
func (v OfferEntryFlags) XdrValue() interface{}          { return v }
func (v *OfferEntryFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_OfferEntryFlags = *OfferEntryFlags

func XDR_OfferEntryFlags(v *OfferEntryFlags) *OfferEntryFlags { return v }

var _XdrComments_OfferEntryFlags = map[int32]string{
	int32(PASSIVE_FLAG): "an offer with this flag will not act on and take a reverse offer of equal price",
}

func (e OfferEntryFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_OfferEntryFlags
}
func (v *OfferEntryFlags) XdrInitialize() {
	switch OfferEntryFlags(0) {
	case PASSIVE_FLAG:
	default:
		if *v == OfferEntryFlags(0) {
			*v = PASSIVE_FLAG
		}
	}
}

var _XdrTags_XdrAnon_OfferEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_OfferEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_OfferEntry_Ext
}
func (u XdrAnon_OfferEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_OfferEntry_Ext = *XdrAnon_OfferEntry_Ext

func (v *XdrAnon_OfferEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_OfferEntry_Ext) XdrTypeName() string              { return "XdrAnon_OfferEntry_Ext" }
func (v XdrAnon_OfferEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_OfferEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_OfferEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_OfferEntry_Ext", u.V)
}
func XDR_XdrAnon_OfferEntry_Ext(v *XdrAnon_OfferEntry_Ext) *XdrAnon_OfferEntry_Ext { return v }

type XdrType_OfferEntry = *OfferEntry

func (v *OfferEntry) XdrPointer() interface{}       { return v }
func (OfferEntry) XdrTypeName() string              { return "OfferEntry" }
func (v OfferEntry) XdrValue() interface{}          { return v }
func (v *OfferEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OfferEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssellerID", name), XDR_AccountID(&v.SellerID))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
	x.Marshal(x.Sprintf("%sselling", name), XDR_Asset(&v.Selling))
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Asset(&v.Buying))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sprice", name), XDR_Price(&v.Price))
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_OfferEntry_Ext(&v.Ext))
}
func XDR_OfferEntry(v *OfferEntry) *OfferEntry { return v }

var _XdrTags_XdrAnon_DataEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_DataEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_DataEntry_Ext
}
func (u XdrAnon_DataEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_DataEntry_Ext = *XdrAnon_DataEntry_Ext

func (v *XdrAnon_DataEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_DataEntry_Ext) XdrTypeName() string              { return "XdrAnon_DataEntry_Ext" }
func (v XdrAnon_DataEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_DataEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_DataEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_DataEntry_Ext", u.V)
}
func XDR_XdrAnon_DataEntry_Ext(v *XdrAnon_DataEntry_Ext) *XdrAnon_DataEntry_Ext { return v }

type XdrType_DataEntry = *DataEntry

func (v *DataEntry) XdrPointer() interface{}       { return v }
func (DataEntry) XdrTypeName() string              { return "DataEntry" }
func (v DataEntry) XdrValue() interface{}          { return v }
func (v *DataEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DataEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sdataName", name), XDR_String64(&v.DataName))
	x.Marshal(x.Sprintf("%sdataValue", name), XDR_DataValue(&v.DataValue))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_DataEntry_Ext(&v.Ext))
}
func XDR_DataEntry(v *DataEntry) *DataEntry { return v }

var _XdrNames_ClaimPredicateType = map[int32]string{
	int32(CLAIM_PREDICATE_UNCONDITIONAL):        "CLAIM_PREDICATE_UNCONDITIONAL",
	int32(CLAIM_PREDICATE_AND):                  "CLAIM_PREDICATE_AND",
	int32(CLAIM_PREDICATE_OR):                   "CLAIM_PREDICATE_OR",
	int32(CLAIM_PREDICATE_NOT):                  "CLAIM_PREDICATE_NOT",
	int32(CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME): "CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME",
	int32(CLAIM_PREDICATE_BEFORE_RELATIVE_TIME): "CLAIM_PREDICATE_BEFORE_RELATIVE_TIME",
}
var _XdrValues_ClaimPredicateType = map[string]int32{
	"CLAIM_PREDICATE_UNCONDITIONAL":        int32(CLAIM_PREDICATE_UNCONDITIONAL),
	"CLAIM_PREDICATE_AND":                  int32(CLAIM_PREDICATE_AND),
	"CLAIM_PREDICATE_OR":                   int32(CLAIM_PREDICATE_OR),
	"CLAIM_PREDICATE_NOT":                  int32(CLAIM_PREDICATE_NOT),
	"CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME": int32(CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME),
	"CLAIM_PREDICATE_BEFORE_RELATIVE_TIME": int32(CLAIM_PREDICATE_BEFORE_RELATIVE_TIME),
}

func (ClaimPredicateType) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimPredicateType
}
func (v ClaimPredicateType) String() string {
	if s, ok := _XdrNames_ClaimPredicateType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimPredicateType#%d", v)
}
func (v *ClaimPredicateType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimPredicateType[stok]; ok {
			*v = ClaimPredicateType(val)
			return nil
		} else if stok == "ClaimPredicateType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimPredicateType.", stok))
	}
}
func (v ClaimPredicateType) GetU32() uint32                 { return uint32(v) }
func (v *ClaimPredicateType) SetU32(n uint32)               { *v = ClaimPredicateType(n) }
func (v *ClaimPredicateType) XdrPointer() interface{}       { return v }
func (ClaimPredicateType) XdrTypeName() string              { return "ClaimPredicateType" }
func (v ClaimPredicateType) XdrValue() interface{}          { return v }
func (v *ClaimPredicateType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimPredicateType = *ClaimPredicateType

func XDR_ClaimPredicateType(v *ClaimPredicateType) *ClaimPredicateType { return v }

type _XdrVec_2_ClaimPredicate []ClaimPredicate

func (_XdrVec_2_ClaimPredicate) XdrBound() uint32 {
	const bound uint32 = 2 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_2_ClaimPredicate) XdrCheckLen(length uint32) {
	if length > uint32(2) {
		XdrPanic("_XdrVec_2_ClaimPredicate length %d exceeds bound 2", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_2_ClaimPredicate length %d exceeds max int", length)
	}
}
func (v _XdrVec_2_ClaimPredicate) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_2_ClaimPredicate) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(2); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ClaimPredicate, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_2_ClaimPredicate) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_ClaimPredicate(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_2_ClaimPredicate) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 2}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_2_ClaimPredicate) XdrTypeName() string              { return "ClaimPredicate<>" }
func (v *_XdrVec_2_ClaimPredicate) XdrPointer() interface{}       { return (*[]ClaimPredicate)(v) }
func (v _XdrVec_2_ClaimPredicate) XdrValue() interface{}          { return ([]ClaimPredicate)(v) }
func (v *_XdrVec_2_ClaimPredicate) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrPtr_ClaimPredicate struct {
	p **ClaimPredicate
}
type _ptrflag_ClaimPredicate _XdrPtr_ClaimPredicate

func (v _ptrflag_ClaimPredicate) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_ClaimPredicate) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("ClaimPredicate flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_ClaimPredicate) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_ClaimPredicate) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(ClaimPredicate)
		}
	default:
		XdrPanic("*ClaimPredicate present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_ClaimPredicate) XdrTypeName() string             { return "ClaimPredicate?" }
func (v _ptrflag_ClaimPredicate) XdrPointer() interface{}       { return nil }
func (v _ptrflag_ClaimPredicate) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_ClaimPredicate) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_ClaimPredicate) XdrBound() uint32              { return 1 }
func (v _XdrPtr_ClaimPredicate) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_ClaimPredicate) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(ClaimPredicate)
	}
}
func (v _XdrPtr_ClaimPredicate) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_ClaimPredicate(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_ClaimPredicate) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_ClaimPredicate) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_ClaimPredicate(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_ClaimPredicate) XdrTypeName() string       { return "ClaimPredicate*" }
func (v _XdrPtr_ClaimPredicate) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_ClaimPredicate) XdrValue() interface{}   { return *v.p }

var _XdrTags_ClaimPredicate = map[int32]bool{
	XdrToI32(CLAIM_PREDICATE_UNCONDITIONAL):        true,
	XdrToI32(CLAIM_PREDICATE_AND):                  true,
	XdrToI32(CLAIM_PREDICATE_OR):                   true,
	XdrToI32(CLAIM_PREDICATE_NOT):                  true,
	XdrToI32(CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME): true,
	XdrToI32(CLAIM_PREDICATE_BEFORE_RELATIVE_TIME): true,
}

func (_ ClaimPredicate) XdrValidTags() map[int32]bool {
	return _XdrTags_ClaimPredicate
}
func (u *ClaimPredicate) AndPredicates() *[]ClaimPredicate {
	switch u.Type {
	case CLAIM_PREDICATE_AND:
		if v, ok := u._u.(*[]ClaimPredicate); ok {
			return v
		} else {
			var zero []ClaimPredicate
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.AndPredicates accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ClaimPredicate) OrPredicates() *[]ClaimPredicate {
	switch u.Type {
	case CLAIM_PREDICATE_OR:
		if v, ok := u._u.(*[]ClaimPredicate); ok {
			return v
		} else {
			var zero []ClaimPredicate
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.OrPredicates accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ClaimPredicate) NotPredicate() **ClaimPredicate {
	switch u.Type {
	case CLAIM_PREDICATE_NOT:
		if v, ok := u._u.(**ClaimPredicate); ok {
			return v
		} else {
			var zero *ClaimPredicate
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.NotPredicate accessed when Type == %v", u.Type)
		return nil
	}
}

// Predicate will be true if closeTime < absBefore
func (u *ClaimPredicate) AbsBefore() *Int64 {
	switch u.Type {
	case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.AbsBefore accessed when Type == %v", u.Type)
		return nil
	}
}

// Seconds since closeTime of the ledger in which the
func (u *ClaimPredicate) RelBefore() *Int64 {
	switch u.Type {
	case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.RelBefore accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ClaimPredicate) XdrValid() bool {
	switch u.Type {
	case CLAIM_PREDICATE_UNCONDITIONAL, CLAIM_PREDICATE_AND, CLAIM_PREDICATE_OR, CLAIM_PREDICATE_NOT, CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME, CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		return true
	}
	return false
}
func (u *ClaimPredicate) XdrUnionTag() XdrNum32 {
	return XDR_ClaimPredicateType(&u.Type)
}
func (u *ClaimPredicate) XdrUnionTagName() string {
	return "Type"
}
func (u *ClaimPredicate) XdrUnionBody() XdrType {
	switch u.Type {
	case CLAIM_PREDICATE_UNCONDITIONAL:
		return nil
	case CLAIM_PREDICATE_AND:
		return (*_XdrVec_2_ClaimPredicate)(u.AndPredicates())
	case CLAIM_PREDICATE_OR:
		return (*_XdrVec_2_ClaimPredicate)(u.OrPredicates())
	case CLAIM_PREDICATE_NOT:
		return _XdrPtr_ClaimPredicate{u.NotPredicate()}
	case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
		return XDR_Int64(u.AbsBefore())
	case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		return XDR_Int64(u.RelBefore())
	}
	return nil
}
func (u *ClaimPredicate) XdrUnionBodyName() string {
	switch u.Type {
	case CLAIM_PREDICATE_UNCONDITIONAL:
		return ""
	case CLAIM_PREDICATE_AND:
		return "AndPredicates"
	case CLAIM_PREDICATE_OR:
		return "OrPredicates"
	case CLAIM_PREDICATE_NOT:
		return "NotPredicate"
	case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
		return "AbsBefore"
	case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		return "RelBefore"
	}
	return ""
}

type XdrType_ClaimPredicate = *ClaimPredicate

func (v *ClaimPredicate) XdrPointer() interface{}       { return v }
func (ClaimPredicate) XdrTypeName() string              { return "ClaimPredicate" }
func (v ClaimPredicate) XdrValue() interface{}          { return v }
func (v *ClaimPredicate) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClaimPredicate) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimPredicateType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CLAIM_PREDICATE_UNCONDITIONAL:
		return
	case CLAIM_PREDICATE_AND:
		x.Marshal(x.Sprintf("%sandPredicates", name), (*_XdrVec_2_ClaimPredicate)(u.AndPredicates()))
		return
	case CLAIM_PREDICATE_OR:
		x.Marshal(x.Sprintf("%sorPredicates", name), (*_XdrVec_2_ClaimPredicate)(u.OrPredicates()))
		return
	case CLAIM_PREDICATE_NOT:
		x.Marshal(x.Sprintf("%snotPredicate", name), _XdrPtr_ClaimPredicate{u.NotPredicate()})
		return
	case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
		x.Marshal(x.Sprintf("%sabsBefore", name), XDR_Int64(u.AbsBefore()))
		return
	case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		x.Marshal(x.Sprintf("%srelBefore", name), XDR_Int64(u.RelBefore()))
		return
	}
	XdrPanic("invalid Type (%v) in ClaimPredicate", u.Type)
}
func XDR_ClaimPredicate(v *ClaimPredicate) *ClaimPredicate { return v }

var _XdrNames_ClaimantType = map[int32]string{
	int32(CLAIMANT_TYPE_V0): "CLAIMANT_TYPE_V0",
}
var _XdrValues_ClaimantType = map[string]int32{
	"CLAIMANT_TYPE_V0": int32(CLAIMANT_TYPE_V0),
}

func (ClaimantType) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimantType
}
func (v ClaimantType) String() string {
	if s, ok := _XdrNames_ClaimantType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimantType#%d", v)
}
func (v *ClaimantType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimantType[stok]; ok {
			*v = ClaimantType(val)
			return nil
		} else if stok == "ClaimantType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimantType.", stok))
	}
}
func (v ClaimantType) GetU32() uint32                 { return uint32(v) }
func (v *ClaimantType) SetU32(n uint32)               { *v = ClaimantType(n) }
func (v *ClaimantType) XdrPointer() interface{}       { return v }
func (ClaimantType) XdrTypeName() string              { return "ClaimantType" }
func (v ClaimantType) XdrValue() interface{}          { return v }
func (v *ClaimantType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimantType = *ClaimantType

func XDR_ClaimantType(v *ClaimantType) *ClaimantType { return v }

type XdrType_XdrAnon_Claimant_V0 = *XdrAnon_Claimant_V0

func (v *XdrAnon_Claimant_V0) XdrPointer() interface{}       { return v }
func (XdrAnon_Claimant_V0) XdrTypeName() string              { return "XdrAnon_Claimant_V0" }
func (v XdrAnon_Claimant_V0) XdrValue() interface{}          { return v }
func (v *XdrAnon_Claimant_V0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_Claimant_V0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_AccountID(&v.Destination))
	x.Marshal(x.Sprintf("%spredicate", name), XDR_ClaimPredicate(&v.Predicate))
}
func XDR_XdrAnon_Claimant_V0(v *XdrAnon_Claimant_V0) *XdrAnon_Claimant_V0 { return v }

var _XdrTags_Claimant = map[int32]bool{
	XdrToI32(CLAIMANT_TYPE_V0): true,
}

func (_ Claimant) XdrValidTags() map[int32]bool {
	return _XdrTags_Claimant
}
func (u *Claimant) V0() *XdrAnon_Claimant_V0 {
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		if v, ok := u._u.(*XdrAnon_Claimant_V0); ok {
			return v
		} else {
			var zero XdrAnon_Claimant_V0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Claimant.V0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Claimant) XdrValid() bool {
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		return true
	}
	return false
}
func (u *Claimant) XdrUnionTag() XdrNum32 {
	return XDR_ClaimantType(&u.Type)
}
func (u *Claimant) XdrUnionTagName() string {
	return "Type"
}
func (u *Claimant) XdrUnionBody() XdrType {
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		return XDR_XdrAnon_Claimant_V0(u.V0())
	}
	return nil
}
func (u *Claimant) XdrUnionBodyName() string {
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		return "V0"
	}
	return ""
}

type XdrType_Claimant = *Claimant

func (v *Claimant) XdrPointer() interface{}       { return v }
func (Claimant) XdrTypeName() string              { return "Claimant" }
func (v Claimant) XdrValue() interface{}          { return v }
func (v *Claimant) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Claimant) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimantType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_XdrAnon_Claimant_V0(u.V0()))
		return
	}
	XdrPanic("invalid Type (%v) in Claimant", u.Type)
}
func XDR_Claimant(v *Claimant) *Claimant { return v }

var _XdrNames_ClaimableBalanceIDType = map[int32]string{
	int32(CLAIMABLE_BALANCE_ID_TYPE_V0): "CLAIMABLE_BALANCE_ID_TYPE_V0",
}
var _XdrValues_ClaimableBalanceIDType = map[string]int32{
	"CLAIMABLE_BALANCE_ID_TYPE_V0": int32(CLAIMABLE_BALANCE_ID_TYPE_V0),
}

func (ClaimableBalanceIDType) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimableBalanceIDType
}
func (v ClaimableBalanceIDType) String() string {
	if s, ok := _XdrNames_ClaimableBalanceIDType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimableBalanceIDType#%d", v)
}
func (v *ClaimableBalanceIDType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimableBalanceIDType[stok]; ok {
			*v = ClaimableBalanceIDType(val)
			return nil
		} else if stok == "ClaimableBalanceIDType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimableBalanceIDType.", stok))
	}
}
func (v ClaimableBalanceIDType) GetU32() uint32                 { return uint32(v) }
func (v *ClaimableBalanceIDType) SetU32(n uint32)               { *v = ClaimableBalanceIDType(n) }
func (v *ClaimableBalanceIDType) XdrPointer() interface{}       { return v }
func (ClaimableBalanceIDType) XdrTypeName() string              { return "ClaimableBalanceIDType" }
func (v ClaimableBalanceIDType) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceIDType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimableBalanceIDType = *ClaimableBalanceIDType

func XDR_ClaimableBalanceIDType(v *ClaimableBalanceIDType) *ClaimableBalanceIDType { return v }

var _XdrTags_ClaimableBalanceID = map[int32]bool{
	XdrToI32(CLAIMABLE_BALANCE_ID_TYPE_V0): true,
}

func (_ ClaimableBalanceID) XdrValidTags() map[int32]bool {
	return _XdrTags_ClaimableBalanceID
}
func (u *ClaimableBalanceID) V0() *Hash {
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimableBalanceID.V0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ClaimableBalanceID) XdrValid() bool {
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		return true
	}
	return false
}
func (u *ClaimableBalanceID) XdrUnionTag() XdrNum32 {
	return XDR_ClaimableBalanceIDType(&u.Type)
}
func (u *ClaimableBalanceID) XdrUnionTagName() string {
	return "Type"
}
func (u *ClaimableBalanceID) XdrUnionBody() XdrType {
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		return XDR_Hash(u.V0())
	}
	return nil
}
func (u *ClaimableBalanceID) XdrUnionBodyName() string {
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		return "V0"
	}
	return ""
}

type XdrType_ClaimableBalanceID = *ClaimableBalanceID

func (v *ClaimableBalanceID) XdrPointer() interface{}       { return v }
func (ClaimableBalanceID) XdrTypeName() string              { return "ClaimableBalanceID" }
func (v ClaimableBalanceID) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClaimableBalanceID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimableBalanceIDType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_Hash(u.V0()))
		return
	}
	XdrPanic("invalid Type (%v) in ClaimableBalanceID", u.Type)
}
func XDR_ClaimableBalanceID(v *ClaimableBalanceID) *ClaimableBalanceID { return v }

var _XdrNames_ClaimableBalanceFlags = map[int32]string{
	int32(CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG): "CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG",
}
var _XdrValues_ClaimableBalanceFlags = map[string]int32{
	"CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG": int32(CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG),
}

func (ClaimableBalanceFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimableBalanceFlags
}
func (v ClaimableBalanceFlags) String() string {
	if s, ok := _XdrNames_ClaimableBalanceFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimableBalanceFlags#%d", v)
}
func (v *ClaimableBalanceFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimableBalanceFlags[stok]; ok {
			*v = ClaimableBalanceFlags(val)
			return nil
		} else if stok == "ClaimableBalanceFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimableBalanceFlags.", stok))
	}
}
func (v ClaimableBalanceFlags) GetU32() uint32                 { return uint32(v) }
func (v *ClaimableBalanceFlags) SetU32(n uint32)               { *v = ClaimableBalanceFlags(n) }
func (v *ClaimableBalanceFlags) XdrPointer() interface{}       { return v }
func (ClaimableBalanceFlags) XdrTypeName() string              { return "ClaimableBalanceFlags" }
func (v ClaimableBalanceFlags) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimableBalanceFlags = *ClaimableBalanceFlags

func XDR_ClaimableBalanceFlags(v *ClaimableBalanceFlags) *ClaimableBalanceFlags { return v }

var _XdrComments_ClaimableBalanceFlags = map[int32]string{
	int32(CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG): "If set, the issuer account of the asset held by the claimable balance may clawback the claimable balance",
}

func (e ClaimableBalanceFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_ClaimableBalanceFlags
}
func (v *ClaimableBalanceFlags) XdrInitialize() {
	switch ClaimableBalanceFlags(0) {
	case CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG:
	default:
		if *v == ClaimableBalanceFlags(0) {
			*v = CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG
		}
	}
}

var _XdrTags_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext
}
func (u XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext = *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext

func (v *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrTypeName() string {
	return "XdrAnon_ClaimableBalanceEntryExtensionV1_Ext"
}
func (v XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_ClaimableBalanceEntryExtensionV1_Ext", u.V)
}
func XDR_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext(v *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext {
	return v
}

type XdrType_ClaimableBalanceEntryExtensionV1 = *ClaimableBalanceEntryExtensionV1

func (v *ClaimableBalanceEntryExtensionV1) XdrPointer() interface{} { return v }
func (ClaimableBalanceEntryExtensionV1) XdrTypeName() string {
	return "ClaimableBalanceEntryExtensionV1"
}
func (v ClaimableBalanceEntryExtensionV1) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceEntryExtensionV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimableBalanceEntryExtensionV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext(&v.Ext))
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
}
func XDR_ClaimableBalanceEntryExtensionV1(v *ClaimableBalanceEntryExtensionV1) *ClaimableBalanceEntryExtensionV1 {
	return v
}

var _XdrTags_XdrAnon_ClaimableBalanceEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_ClaimableBalanceEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ClaimableBalanceEntry_Ext
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) V1() *ClaimableBalanceEntryExtensionV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*ClaimableBalanceEntryExtensionV1); ok {
			return v
		} else {
			var zero ClaimableBalanceEntryExtensionV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_ClaimableBalanceEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_ClaimableBalanceEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_ClaimableBalanceEntryExtensionV1(u.V1())
	}
	return nil
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_ClaimableBalanceEntry_Ext = *XdrAnon_ClaimableBalanceEntry_Ext

func (v *XdrAnon_ClaimableBalanceEntry_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_ClaimableBalanceEntry_Ext) XdrTypeName() string {
	return "XdrAnon_ClaimableBalanceEntry_Ext"
}
func (v XdrAnon_ClaimableBalanceEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_ClaimableBalanceEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_ClaimableBalanceEntryExtensionV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_ClaimableBalanceEntry_Ext", u.V)
}
func XDR_XdrAnon_ClaimableBalanceEntry_Ext(v *XdrAnon_ClaimableBalanceEntry_Ext) *XdrAnon_ClaimableBalanceEntry_Ext {
	return v
}

type _XdrVec_10_Claimant []Claimant

func (_XdrVec_10_Claimant) XdrBound() uint32 {
	const bound uint32 = 10 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_10_Claimant) XdrCheckLen(length uint32) {
	if length > uint32(10) {
		XdrPanic("_XdrVec_10_Claimant length %d exceeds bound 10", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_10_Claimant length %d exceeds max int", length)
	}
}
func (v _XdrVec_10_Claimant) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_10_Claimant) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(10); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Claimant, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_10_Claimant) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Claimant(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_10_Claimant) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 10}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_10_Claimant) XdrTypeName() string              { return "Claimant<>" }
func (v *_XdrVec_10_Claimant) XdrPointer() interface{}       { return (*[]Claimant)(v) }
func (v _XdrVec_10_Claimant) XdrValue() interface{}          { return ([]Claimant)(v) }
func (v *_XdrVec_10_Claimant) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimableBalanceEntry = *ClaimableBalanceEntry

func (v *ClaimableBalanceEntry) XdrPointer() interface{}       { return v }
func (ClaimableBalanceEntry) XdrTypeName() string              { return "ClaimableBalanceEntry" }
func (v ClaimableBalanceEntry) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimableBalanceEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(&v.BalanceID))
	x.Marshal(x.Sprintf("%sclaimants", name), (*_XdrVec_10_Claimant)(&v.Claimants))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_ClaimableBalanceEntry_Ext(&v.Ext))
}
func XDR_ClaimableBalanceEntry(v *ClaimableBalanceEntry) *ClaimableBalanceEntry { return v }

type XdrType_LiquidityPoolConstantProductParameters = *LiquidityPoolConstantProductParameters

func (v *LiquidityPoolConstantProductParameters) XdrPointer() interface{} { return v }
func (LiquidityPoolConstantProductParameters) XdrTypeName() string {
	return "LiquidityPoolConstantProductParameters"
}
func (v LiquidityPoolConstantProductParameters) XdrValue() interface{}          { return v }
func (v *LiquidityPoolConstantProductParameters) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LiquidityPoolConstantProductParameters) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sassetA", name), XDR_Asset(&v.AssetA))
	x.Marshal(x.Sprintf("%sassetB", name), XDR_Asset(&v.AssetB))
	x.Marshal(x.Sprintf("%sfee", name), XDR_Int32(&v.Fee))
}
func XDR_LiquidityPoolConstantProductParameters(v *LiquidityPoolConstantProductParameters) *LiquidityPoolConstantProductParameters {
	return v
}

type XdrType_XdrAnon_LiquidityPoolEntry_Body_ConstantProduct = *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct

func (v *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrPointer() interface{} { return v }
func (XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrTypeName() string {
	return "XdrAnon_LiquidityPoolEntry_Body_ConstantProduct"
}
func (v XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrValue() interface{} { return v }
func (v *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sparams", name), XDR_LiquidityPoolConstantProductParameters(&v.Params))
	x.Marshal(x.Sprintf("%sreserveA", name), XDR_Int64(&v.ReserveA))
	x.Marshal(x.Sprintf("%sreserveB", name), XDR_Int64(&v.ReserveB))
	x.Marshal(x.Sprintf("%stotalPoolShares", name), XDR_Int64(&v.TotalPoolShares))
	x.Marshal(x.Sprintf("%spoolSharesTrustLineCount", name), XDR_Int64(&v.PoolSharesTrustLineCount))
}
func XDR_XdrAnon_LiquidityPoolEntry_Body_ConstantProduct(v *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct {
	return v
}

var _XdrTags_XdrAnon_LiquidityPoolEntry_Body = map[int32]bool{
	XdrToI32(LIQUIDITY_POOL_CONSTANT_PRODUCT): true,
}

func (_ XdrAnon_LiquidityPoolEntry_Body) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LiquidityPoolEntry_Body
}
func (u *XdrAnon_LiquidityPoolEntry_Body) ConstantProduct() *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		if v, ok := u._u.(*XdrAnon_LiquidityPoolEntry_Body_ConstantProduct); ok {
			return v
		} else {
			var zero XdrAnon_LiquidityPoolEntry_Body_ConstantProduct
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LiquidityPoolEntry_Body.ConstantProduct accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_LiquidityPoolEntry_Body) XdrValid() bool {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return true
	}
	return false
}
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrUnionTag() XdrNum32 {
	return XDR_LiquidityPoolType(&u.Type)
}
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrUnionBody() XdrType {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return XDR_XdrAnon_LiquidityPoolEntry_Body_ConstantProduct(u.ConstantProduct())
	}
	return nil
}
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrUnionBodyName() string {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return "ConstantProduct"
	}
	return ""
}

type XdrType_XdrAnon_LiquidityPoolEntry_Body = *XdrAnon_LiquidityPoolEntry_Body

func (v *XdrAnon_LiquidityPoolEntry_Body) XdrPointer() interface{}       { return v }
func (XdrAnon_LiquidityPoolEntry_Body) XdrTypeName() string              { return "XdrAnon_LiquidityPoolEntry_Body" }
func (v XdrAnon_LiquidityPoolEntry_Body) XdrValue() interface{}          { return v }
func (v *XdrAnon_LiquidityPoolEntry_Body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LiquidityPoolType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		x.Marshal(x.Sprintf("%sconstantProduct", name), XDR_XdrAnon_LiquidityPoolEntry_Body_ConstantProduct(u.ConstantProduct()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_LiquidityPoolEntry_Body", u.Type)
}
func XDR_XdrAnon_LiquidityPoolEntry_Body(v *XdrAnon_LiquidityPoolEntry_Body) *XdrAnon_LiquidityPoolEntry_Body {
	return v
}

type XdrType_LiquidityPoolEntry = *LiquidityPoolEntry

func (v *LiquidityPoolEntry) XdrPointer() interface{}       { return v }
func (LiquidityPoolEntry) XdrTypeName() string              { return "LiquidityPoolEntry" }
func (v LiquidityPoolEntry) XdrValue() interface{}          { return v }
func (v *LiquidityPoolEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LiquidityPoolEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%sbody", name), XDR_XdrAnon_LiquidityPoolEntry_Body(&v.Body))
}
func XDR_LiquidityPoolEntry(v *LiquidityPoolEntry) *LiquidityPoolEntry { return v }

var _XdrNames_ContractDataDurability = map[int32]string{
	int32(TEMPORARY):  "TEMPORARY",
	int32(PERSISTENT): "PERSISTENT",
}
var _XdrValues_ContractDataDurability = map[string]int32{
	"TEMPORARY":  int32(TEMPORARY),
	"PERSISTENT": int32(PERSISTENT),
}

func (ContractDataDurability) XdrEnumNames() map[int32]string {
	return _XdrNames_ContractDataDurability
}
func (v ContractDataDurability) String() string {
	if s, ok := _XdrNames_ContractDataDurability[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ContractDataDurability#%d", v)
}
func (v *ContractDataDurability) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ContractDataDurability[stok]; ok {
			*v = ContractDataDurability(val)
			return nil
		} else if stok == "ContractDataDurability" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ContractDataDurability.", stok))
	}
}
func (v ContractDataDurability) GetU32() uint32                 { return uint32(v) }
func (v *ContractDataDurability) SetU32(n uint32)               { *v = ContractDataDurability(n) }
func (v *ContractDataDurability) XdrPointer() interface{}       { return v }
func (ContractDataDurability) XdrTypeName() string              { return "ContractDataDurability" }
func (v ContractDataDurability) XdrValue() interface{}          { return v }
func (v *ContractDataDurability) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ContractDataDurability = *ContractDataDurability

func XDR_ContractDataDurability(v *ContractDataDurability) *ContractDataDurability { return v }

type XdrType_ContractDataEntry = *ContractDataEntry

func (v *ContractDataEntry) XdrPointer() interface{}       { return v }
func (ContractDataEntry) XdrTypeName() string              { return "ContractDataEntry" }
func (v ContractDataEntry) XdrValue() interface{}          { return v }
func (v *ContractDataEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ContractDataEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%scontract", name), XDR_SCAddress(&v.Contract))
	x.Marshal(x.Sprintf("%skey", name), XDR_SCVal(&v.Key))
	x.Marshal(x.Sprintf("%sdurability", name), XDR_ContractDataDurability(&v.Durability))
	x.Marshal(x.Sprintf("%sval", name), XDR_SCVal(&v.Val))
}
func XDR_ContractDataEntry(v *ContractDataEntry) *ContractDataEntry { return v }

type XdrType_ContractCodeCostInputs = *ContractCodeCostInputs

func (v *ContractCodeCostInputs) XdrPointer() interface{}       { return v }
func (ContractCodeCostInputs) XdrTypeName() string              { return "ContractCodeCostInputs" }
func (v ContractCodeCostInputs) XdrValue() interface{}          { return v }
func (v *ContractCodeCostInputs) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ContractCodeCostInputs) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%snInstructions", name), XDR_Uint32(&v.NInstructions))
	x.Marshal(x.Sprintf("%snFunctions", name), XDR_Uint32(&v.NFunctions))
	x.Marshal(x.Sprintf("%snGlobals", name), XDR_Uint32(&v.NGlobals))
	x.Marshal(x.Sprintf("%snTableEntries", name), XDR_Uint32(&v.NTableEntries))
	x.Marshal(x.Sprintf("%snTypes", name), XDR_Uint32(&v.NTypes))
	x.Marshal(x.Sprintf("%snDataSegments", name), XDR_Uint32(&v.NDataSegments))
	x.Marshal(x.Sprintf("%snElemSegments", name), XDR_Uint32(&v.NElemSegments))
	x.Marshal(x.Sprintf("%snImports", name), XDR_Uint32(&v.NImports))
	x.Marshal(x.Sprintf("%snExports", name), XDR_Uint32(&v.NExports))
	x.Marshal(x.Sprintf("%snDataSegmentBytes", name), XDR_Uint32(&v.NDataSegmentBytes))
}
func XDR_ContractCodeCostInputs(v *ContractCodeCostInputs) *ContractCodeCostInputs { return v }

type XdrType_XdrAnon_ContractCodeEntry_Ext_V1 = *XdrAnon_ContractCodeEntry_Ext_V1

func (v *XdrAnon_ContractCodeEntry_Ext_V1) XdrPointer() interface{} { return v }
func (XdrAnon_ContractCodeEntry_Ext_V1) XdrTypeName() string {
	return "XdrAnon_ContractCodeEntry_Ext_V1"
}
func (v XdrAnon_ContractCodeEntry_Ext_V1) XdrValue() interface{}          { return v }
func (v *XdrAnon_ContractCodeEntry_Ext_V1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_ContractCodeEntry_Ext_V1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%scostInputs", name), XDR_ContractCodeCostInputs(&v.CostInputs))
}
func XDR_XdrAnon_ContractCodeEntry_Ext_V1(v *XdrAnon_ContractCodeEntry_Ext_V1) *XdrAnon_ContractCodeEntry_Ext_V1 {
	return v
}

var _XdrTags_XdrAnon_ContractCodeEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_ContractCodeEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ContractCodeEntry_Ext
}
func (u *XdrAnon_ContractCodeEntry_Ext) V1() *XdrAnon_ContractCodeEntry_Ext_V1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*XdrAnon_ContractCodeEntry_Ext_V1); ok {
			return v
		} else {
			var zero XdrAnon_ContractCodeEntry_Ext_V1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_ContractCodeEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_ContractCodeEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_ContractCodeEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_ContractCodeEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_ContractCodeEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_XdrAnon_ContractCodeEntry_Ext_V1(u.V1())
	}
	return nil
}
func (u *XdrAnon_ContractCodeEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_ContractCodeEntry_Ext = *XdrAnon_ContractCodeEntry_Ext

func (v *XdrAnon_ContractCodeEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_ContractCodeEntry_Ext) XdrTypeName() string              { return "XdrAnon_ContractCodeEntry_Ext" }
func (v XdrAnon_ContractCodeEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_ContractCodeEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ContractCodeEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_XdrAnon_ContractCodeEntry_Ext_V1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_ContractCodeEntry_Ext", u.V)
}
func XDR_XdrAnon_ContractCodeEntry_Ext(v *XdrAnon_ContractCodeEntry_Ext) *XdrAnon_ContractCodeEntry_Ext {
	return v
}

type XdrType_ContractCodeEntry = *ContractCodeEntry

func (v *ContractCodeEntry) XdrPointer() interface{}       { return v }
func (ContractCodeEntry) XdrTypeName() string              { return "ContractCodeEntry" }
func (v ContractCodeEntry) XdrValue() interface{}          { return v }
func (v *ContractCodeEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ContractCodeEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_ContractCodeEntry_Ext(&v.Ext))
	x.Marshal(x.Sprintf("%shash", name), XDR_Hash(&v.Hash))
	x.Marshal(x.Sprintf("%scode", name), XdrVecOpaque{&v.Code, 0xffffffff})
}
func XDR_ContractCodeEntry(v *ContractCodeEntry) *ContractCodeEntry { return v }

type XdrType_TTLEntry = *TTLEntry

func (v *TTLEntry) XdrPointer() interface{}       { return v }
func (TTLEntry) XdrTypeName() string              { return "TTLEntry" }
func (v TTLEntry) XdrValue() interface{}          { return v }
func (v *TTLEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TTLEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skeyHash", name), XDR_Hash(&v.KeyHash))
	x.Marshal(x.Sprintf("%sliveUntilLedgerSeq", name), XDR_Uint32(&v.LiveUntilLedgerSeq))
}
func XDR_TTLEntry(v *TTLEntry) *TTLEntry { return v }

var _XdrTags_XdrAnon_LedgerEntryExtensionV1_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_LedgerEntryExtensionV1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerEntryExtensionV1_Ext
}
func (u XdrAnon_LedgerEntryExtensionV1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_LedgerEntryExtensionV1_Ext = *XdrAnon_LedgerEntryExtensionV1_Ext

func (v *XdrAnon_LedgerEntryExtensionV1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerEntryExtensionV1_Ext) XdrTypeName() string {
	return "XdrAnon_LedgerEntryExtensionV1_Ext"
}
func (v XdrAnon_LedgerEntryExtensionV1_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerEntryExtensionV1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerEntryExtensionV1_Ext", u.V)
}
func XDR_XdrAnon_LedgerEntryExtensionV1_Ext(v *XdrAnon_LedgerEntryExtensionV1_Ext) *XdrAnon_LedgerEntryExtensionV1_Ext {
	return v
}

type XdrType_LedgerEntryExtensionV1 = *LedgerEntryExtensionV1

func (v *LedgerEntryExtensionV1) XdrPointer() interface{}       { return v }
func (LedgerEntryExtensionV1) XdrTypeName() string              { return "LedgerEntryExtensionV1" }
func (v LedgerEntryExtensionV1) XdrValue() interface{}          { return v }
func (v *LedgerEntryExtensionV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerEntryExtensionV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssponsoringID", name), XDR_SponsorshipDescriptor(&v.SponsoringID))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerEntryExtensionV1_Ext(&v.Ext))
}
func XDR_LedgerEntryExtensionV1(v *LedgerEntryExtensionV1) *LedgerEntryExtensionV1 { return v }

var _XdrTags_XdrAnon_LedgerEntry_Data = map[int32]bool{
	XdrToI32(ACCOUNT):           true,
	XdrToI32(TRUSTLINE):         true,
	XdrToI32(OFFER):             true,
	XdrToI32(DATA):              true,
	XdrToI32(CLAIMABLE_BALANCE): true,
	XdrToI32(LIQUIDITY_POOL):    true,
	XdrToI32(CONTRACT_DATA):     true,
	XdrToI32(CONTRACT_CODE):     true,
	XdrToI32(CONFIG_SETTING):    true,
	XdrToI32(TTL):               true,
}

func (_ XdrAnon_LedgerEntry_Data) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerEntry_Data
}
func (u *XdrAnon_LedgerEntry_Data) Account() *AccountEntry {
	switch u.Type {
	case ACCOUNT:
		if v, ok := u._u.(*AccountEntry); ok {
			return v
		} else {
			var zero AccountEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Account accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) TrustLine() *TrustLineEntry {
	switch u.Type {
	case TRUSTLINE:
		if v, ok := u._u.(*TrustLineEntry); ok {
			return v
		} else {
			var zero TrustLineEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.TrustLine accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) Offer() *OfferEntry {
	switch u.Type {
	case OFFER:
		if v, ok := u._u.(*OfferEntry); ok {
			return v
		} else {
			var zero OfferEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Offer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) Data() *DataEntry {
	switch u.Type {
	case DATA:
		if v, ok := u._u.(*DataEntry); ok {
			return v
		} else {
			var zero DataEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Data accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) ClaimableBalance() *ClaimableBalanceEntry {
	switch u.Type {
	case CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClaimableBalanceEntry); ok {
			return v
		} else {
			var zero ClaimableBalanceEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.ClaimableBalance accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) LiquidityPool() *LiquidityPoolEntry {
	switch u.Type {
	case LIQUIDITY_POOL:
		if v, ok := u._u.(*LiquidityPoolEntry); ok {
			return v
		} else {
			var zero LiquidityPoolEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.LiquidityPool accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) ContractData() *ContractDataEntry {
	switch u.Type {
	case CONTRACT_DATA:
		if v, ok := u._u.(*ContractDataEntry); ok {
			return v
		} else {
			var zero ContractDataEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.ContractData accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) ContractCode() *ContractCodeEntry {
	switch u.Type {
	case CONTRACT_CODE:
		if v, ok := u._u.(*ContractCodeEntry); ok {
			return v
		} else {
			var zero ContractCodeEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.ContractCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) ConfigSetting() *ConfigSettingEntry {
	switch u.Type {
	case CONFIG_SETTING:
		if v, ok := u._u.(*ConfigSettingEntry); ok {
			return v
		} else {
			var zero ConfigSettingEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.ConfigSetting accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) Ttl() *TTLEntry {
	switch u.Type {
	case TTL:
		if v, ok := u._u.(*TTLEntry); ok {
			return v
		} else {
			var zero TTLEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Ttl accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_LedgerEntry_Data) XdrValid() bool {
	switch u.Type {
	case ACCOUNT, TRUSTLINE, OFFER, DATA, CLAIMABLE_BALANCE, LIQUIDITY_POOL, CONTRACT_DATA, CONTRACT_CODE, CONFIG_SETTING, TTL:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionTag() XdrNum32 {
	return XDR_LedgerEntryType(&u.Type)
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionBody() XdrType {
	switch u.Type {
	case ACCOUNT:
		return XDR_AccountEntry(u.Account())
	case TRUSTLINE:
		return XDR_TrustLineEntry(u.TrustLine())
	case OFFER:
		return XDR_OfferEntry(u.Offer())
	case DATA:
		return XDR_DataEntry(u.Data())
	case CLAIMABLE_BALANCE:
		return XDR_ClaimableBalanceEntry(u.ClaimableBalance())
	case LIQUIDITY_POOL:
		return XDR_LiquidityPoolEntry(u.LiquidityPool())
	case CONTRACT_DATA:
		return XDR_ContractDataEntry(u.ContractData())
	case CONTRACT_CODE:
		return XDR_ContractCodeEntry(u.ContractCode())
	case CONFIG_SETTING:
		return XDR_ConfigSettingEntry(u.ConfigSetting())
	case TTL:
		return XDR_TTLEntry(u.Ttl())
	}
	return nil
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionBodyName() string {
	switch u.Type {
	case ACCOUNT:
		return "Account"
	case TRUSTLINE:
		return "TrustLine"
	case OFFER:
		return "Offer"
	case DATA:
		return "Data"
	case CLAIMABLE_BALANCE:
		return "ClaimableBalance"
	case LIQUIDITY_POOL:
		return "LiquidityPool"
	case CONTRACT_DATA:
		return "ContractData"
	case CONTRACT_CODE:
		return "ContractCode"
	case CONFIG_SETTING:
		return "ConfigSetting"
	case TTL:
		return "Ttl"
	}
	return ""
}

type XdrType_XdrAnon_LedgerEntry_Data = *XdrAnon_LedgerEntry_Data

func (v *XdrAnon_LedgerEntry_Data) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerEntry_Data) XdrTypeName() string              { return "XdrAnon_LedgerEntry_Data" }
func (v XdrAnon_LedgerEntry_Data) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerEntry_Data) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerEntry_Data) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ACCOUNT:
		x.Marshal(x.Sprintf("%saccount", name), XDR_AccountEntry(u.Account()))
		return
	case TRUSTLINE:
		x.Marshal(x.Sprintf("%strustLine", name), XDR_TrustLineEntry(u.TrustLine()))
		return
	case OFFER:
		x.Marshal(x.Sprintf("%soffer", name), XDR_OfferEntry(u.Offer()))
		return
	case DATA:
		x.Marshal(x.Sprintf("%sdata", name), XDR_DataEntry(u.Data()))
		return
	case CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclaimableBalance", name), XDR_ClaimableBalanceEntry(u.ClaimableBalance()))
		return
	case LIQUIDITY_POOL:
		x.Marshal(x.Sprintf("%sliquidityPool", name), XDR_LiquidityPoolEntry(u.LiquidityPool()))
		return
	case CONTRACT_DATA:
		x.Marshal(x.Sprintf("%scontractData", name), XDR_ContractDataEntry(u.ContractData()))
		return
	case CONTRACT_CODE:
		x.Marshal(x.Sprintf("%scontractCode", name), XDR_ContractCodeEntry(u.ContractCode()))
		return
	case CONFIG_SETTING:
		x.Marshal(x.Sprintf("%sconfigSetting", name), XDR_ConfigSettingEntry(u.ConfigSetting()))
		return
	case TTL:
		x.Marshal(x.Sprintf("%sttl", name), XDR_TTLEntry(u.Ttl()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_LedgerEntry_Data", u.Type)
}
func XDR_XdrAnon_LedgerEntry_Data(v *XdrAnon_LedgerEntry_Data) *XdrAnon_LedgerEntry_Data { return v }

var _XdrTags_XdrAnon_LedgerEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_LedgerEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerEntry_Ext
}
func (u *XdrAnon_LedgerEntry_Ext) V1() *LedgerEntryExtensionV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*LedgerEntryExtensionV1); ok {
			return v
		} else {
			var zero LedgerEntryExtensionV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_LedgerEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_LedgerEntryExtensionV1(u.V1())
	}
	return nil
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_LedgerEntry_Ext = *XdrAnon_LedgerEntry_Ext

func (v *XdrAnon_LedgerEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerEntry_Ext) XdrTypeName() string              { return "XdrAnon_LedgerEntry_Ext" }
func (v XdrAnon_LedgerEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_LedgerEntryExtensionV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerEntry_Ext", u.V)
}
func XDR_XdrAnon_LedgerEntry_Ext(v *XdrAnon_LedgerEntry_Ext) *XdrAnon_LedgerEntry_Ext { return v }

type XdrType_LedgerEntry = *LedgerEntry

func (v *LedgerEntry) XdrPointer() interface{}       { return v }
func (LedgerEntry) XdrTypeName() string              { return "LedgerEntry" }
func (v LedgerEntry) XdrValue() interface{}          { return v }
func (v *LedgerEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slastModifiedLedgerSeq", name), XDR_Uint32(&v.LastModifiedLedgerSeq))
	x.Marshal(x.Sprintf("%sdata", name), XDR_XdrAnon_LedgerEntry_Data(&v.Data))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerEntry_Ext(&v.Ext))
}
func XDR_LedgerEntry(v *LedgerEntry) *LedgerEntry { return v }

type XdrType_XdrAnon_LedgerKey_Account = *XdrAnon_LedgerKey_Account

func (v *XdrAnon_LedgerKey_Account) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_Account) XdrTypeName() string              { return "XdrAnon_LedgerKey_Account" }
func (v XdrAnon_LedgerKey_Account) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_Account) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Account) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
}
func XDR_XdrAnon_LedgerKey_Account(v *XdrAnon_LedgerKey_Account) *XdrAnon_LedgerKey_Account { return v }

type XdrType_XdrAnon_LedgerKey_TrustLine = *XdrAnon_LedgerKey_TrustLine

func (v *XdrAnon_LedgerKey_TrustLine) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_TrustLine) XdrTypeName() string              { return "XdrAnon_LedgerKey_TrustLine" }
func (v XdrAnon_LedgerKey_TrustLine) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_TrustLine) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_TrustLine) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sasset", name), XDR_TrustLineAsset(&v.Asset))
}
func XDR_XdrAnon_LedgerKey_TrustLine(v *XdrAnon_LedgerKey_TrustLine) *XdrAnon_LedgerKey_TrustLine {
	return v
}

type XdrType_XdrAnon_LedgerKey_Offer = *XdrAnon_LedgerKey_Offer

func (v *XdrAnon_LedgerKey_Offer) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_Offer) XdrTypeName() string              { return "XdrAnon_LedgerKey_Offer" }
func (v XdrAnon_LedgerKey_Offer) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_Offer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Offer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssellerID", name), XDR_AccountID(&v.SellerID))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
}
func XDR_XdrAnon_LedgerKey_Offer(v *XdrAnon_LedgerKey_Offer) *XdrAnon_LedgerKey_Offer { return v }

type XdrType_XdrAnon_LedgerKey_Data = *XdrAnon_LedgerKey_Data

func (v *XdrAnon_LedgerKey_Data) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_Data) XdrTypeName() string              { return "XdrAnon_LedgerKey_Data" }
func (v XdrAnon_LedgerKey_Data) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_Data) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Data) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sdataName", name), XDR_String64(&v.DataName))
}
func XDR_XdrAnon_LedgerKey_Data(v *XdrAnon_LedgerKey_Data) *XdrAnon_LedgerKey_Data { return v }

type XdrType_XdrAnon_LedgerKey_ClaimableBalance = *XdrAnon_LedgerKey_ClaimableBalance

func (v *XdrAnon_LedgerKey_ClaimableBalance) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerKey_ClaimableBalance) XdrTypeName() string {
	return "XdrAnon_LedgerKey_ClaimableBalance"
}
func (v XdrAnon_LedgerKey_ClaimableBalance) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_ClaimableBalance) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_ClaimableBalance) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(&v.BalanceID))
}
func XDR_XdrAnon_LedgerKey_ClaimableBalance(v *XdrAnon_LedgerKey_ClaimableBalance) *XdrAnon_LedgerKey_ClaimableBalance {
	return v
}

type XdrType_XdrAnon_LedgerKey_LiquidityPool = *XdrAnon_LedgerKey_LiquidityPool

func (v *XdrAnon_LedgerKey_LiquidityPool) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_LiquidityPool) XdrTypeName() string              { return "XdrAnon_LedgerKey_LiquidityPool" }
func (v XdrAnon_LedgerKey_LiquidityPool) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_LiquidityPool) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_LiquidityPool) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
}
func XDR_XdrAnon_LedgerKey_LiquidityPool(v *XdrAnon_LedgerKey_LiquidityPool) *XdrAnon_LedgerKey_LiquidityPool {
	return v
}

type XdrType_XdrAnon_LedgerKey_ContractData = *XdrAnon_LedgerKey_ContractData

func (v *XdrAnon_LedgerKey_ContractData) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_ContractData) XdrTypeName() string              { return "XdrAnon_LedgerKey_ContractData" }
func (v XdrAnon_LedgerKey_ContractData) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_ContractData) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_ContractData) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scontract", name), XDR_SCAddress(&v.Contract))
	x.Marshal(x.Sprintf("%skey", name), XDR_SCVal(&v.Key))
	x.Marshal(x.Sprintf("%sdurability", name), XDR_ContractDataDurability(&v.Durability))
}
func XDR_XdrAnon_LedgerKey_ContractData(v *XdrAnon_LedgerKey_ContractData) *XdrAnon_LedgerKey_ContractData {
	return v
}

type XdrType_XdrAnon_LedgerKey_ContractCode = *XdrAnon_LedgerKey_ContractCode

func (v *XdrAnon_LedgerKey_ContractCode) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_ContractCode) XdrTypeName() string              { return "XdrAnon_LedgerKey_ContractCode" }
func (v XdrAnon_LedgerKey_ContractCode) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_ContractCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_ContractCode) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shash", name), XDR_Hash(&v.Hash))
}
func XDR_XdrAnon_LedgerKey_ContractCode(v *XdrAnon_LedgerKey_ContractCode) *XdrAnon_LedgerKey_ContractCode {
	return v
}

type XdrType_XdrAnon_LedgerKey_ConfigSetting = *XdrAnon_LedgerKey_ConfigSetting

func (v *XdrAnon_LedgerKey_ConfigSetting) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_ConfigSetting) XdrTypeName() string              { return "XdrAnon_LedgerKey_ConfigSetting" }
func (v XdrAnon_LedgerKey_ConfigSetting) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_ConfigSetting) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_ConfigSetting) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sconfigSettingID", name), XDR_ConfigSettingID(&v.ConfigSettingID))
}
func XDR_XdrAnon_LedgerKey_ConfigSetting(v *XdrAnon_LedgerKey_ConfigSetting) *XdrAnon_LedgerKey_ConfigSetting {
	return v
}

type XdrType_XdrAnon_LedgerKey_Ttl = *XdrAnon_LedgerKey_Ttl

func (v *XdrAnon_LedgerKey_Ttl) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_Ttl) XdrTypeName() string              { return "XdrAnon_LedgerKey_Ttl" }
func (v XdrAnon_LedgerKey_Ttl) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_Ttl) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Ttl) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skeyHash", name), XDR_Hash(&v.KeyHash))
}
func XDR_XdrAnon_LedgerKey_Ttl(v *XdrAnon_LedgerKey_Ttl) *XdrAnon_LedgerKey_Ttl { return v }

var _XdrTags_LedgerKey = map[int32]bool{
	XdrToI32(ACCOUNT):           true,
	XdrToI32(TRUSTLINE):         true,
	XdrToI32(OFFER):             true,
	XdrToI32(DATA):              true,
	XdrToI32(CLAIMABLE_BALANCE): true,
	XdrToI32(LIQUIDITY_POOL):    true,
	XdrToI32(CONTRACT_DATA):     true,
	XdrToI32(CONTRACT_CODE):     true,
	XdrToI32(CONFIG_SETTING):    true,
	XdrToI32(TTL):               true,
}

func (_ LedgerKey) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerKey
}
func (u *LedgerKey) Account() *XdrAnon_LedgerKey_Account {
	switch u.Type {
	case ACCOUNT:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Account); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Account
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Account accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) TrustLine() *XdrAnon_LedgerKey_TrustLine {
	switch u.Type {
	case TRUSTLINE:
		if v, ok := u._u.(*XdrAnon_LedgerKey_TrustLine); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_TrustLine
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.TrustLine accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Offer() *XdrAnon_LedgerKey_Offer {
	switch u.Type {
	case OFFER:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Offer); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Offer
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Offer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Data() *XdrAnon_LedgerKey_Data {
	switch u.Type {
	case DATA:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Data); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Data
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Data accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) ClaimableBalance() *XdrAnon_LedgerKey_ClaimableBalance {
	switch u.Type {
	case CLAIMABLE_BALANCE:
		if v, ok := u._u.(*XdrAnon_LedgerKey_ClaimableBalance); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_ClaimableBalance
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.ClaimableBalance accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) LiquidityPool() *XdrAnon_LedgerKey_LiquidityPool {
	switch u.Type {
	case LIQUIDITY_POOL:
		if v, ok := u._u.(*XdrAnon_LedgerKey_LiquidityPool); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_LiquidityPool
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.LiquidityPool accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) ContractData() *XdrAnon_LedgerKey_ContractData {
	switch u.Type {
	case CONTRACT_DATA:
		if v, ok := u._u.(*XdrAnon_LedgerKey_ContractData); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_ContractData
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.ContractData accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) ContractCode() *XdrAnon_LedgerKey_ContractCode {
	switch u.Type {
	case CONTRACT_CODE:
		if v, ok := u._u.(*XdrAnon_LedgerKey_ContractCode); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_ContractCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.ContractCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) ConfigSetting() *XdrAnon_LedgerKey_ConfigSetting {
	switch u.Type {
	case CONFIG_SETTING:
		if v, ok := u._u.(*XdrAnon_LedgerKey_ConfigSetting); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_ConfigSetting
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.ConfigSetting accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Ttl() *XdrAnon_LedgerKey_Ttl {
	switch u.Type {
	case TTL:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Ttl); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Ttl
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Ttl accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerKey) XdrValid() bool {
	switch u.Type {
	case ACCOUNT, TRUSTLINE, OFFER, DATA, CLAIMABLE_BALANCE, LIQUIDITY_POOL, CONTRACT_DATA, CONTRACT_CODE, CONFIG_SETTING, TTL:
		return true
	}
	return false
}
func (u *LedgerKey) XdrUnionTag() XdrNum32 {
	return XDR_LedgerEntryType(&u.Type)
}
func (u *LedgerKey) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerKey) XdrUnionBody() XdrType {
	switch u.Type {
	case ACCOUNT:
		return XDR_XdrAnon_LedgerKey_Account(u.Account())
	case TRUSTLINE:
		return XDR_XdrAnon_LedgerKey_TrustLine(u.TrustLine())
	case OFFER:
		return XDR_XdrAnon_LedgerKey_Offer(u.Offer())
	case DATA:
		return XDR_XdrAnon_LedgerKey_Data(u.Data())
	case CLAIMABLE_BALANCE:
		return XDR_XdrAnon_LedgerKey_ClaimableBalance(u.ClaimableBalance())
	case LIQUIDITY_POOL:
		return XDR_XdrAnon_LedgerKey_LiquidityPool(u.LiquidityPool())
	case CONTRACT_DATA:
		return XDR_XdrAnon_LedgerKey_ContractData(u.ContractData())
	case CONTRACT_CODE:
		return XDR_XdrAnon_LedgerKey_ContractCode(u.ContractCode())
	case CONFIG_SETTING:
		return XDR_XdrAnon_LedgerKey_ConfigSetting(u.ConfigSetting())
	case TTL:
		return XDR_XdrAnon_LedgerKey_Ttl(u.Ttl())
	}
	return nil
}
func (u *LedgerKey) XdrUnionBodyName() string {
	switch u.Type {
	case ACCOUNT:
		return "Account"
	case TRUSTLINE:
		return "TrustLine"
	case OFFER:
		return "Offer"
	case DATA:
		return "Data"
	case CLAIMABLE_BALANCE:
		return "ClaimableBalance"
	case LIQUIDITY_POOL:
		return "LiquidityPool"
	case CONTRACT_DATA:
		return "ContractData"
	case CONTRACT_CODE:
		return "ContractCode"
	case CONFIG_SETTING:
		return "ConfigSetting"
	case TTL:
		return "Ttl"
	}
	return ""
}

type XdrType_LedgerKey = *LedgerKey

func (v *LedgerKey) XdrPointer() interface{}       { return v }
func (LedgerKey) XdrTypeName() string              { return "LedgerKey" }
func (v LedgerKey) XdrValue() interface{}          { return v }
func (v *LedgerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ACCOUNT:
		x.Marshal(x.Sprintf("%saccount", name), XDR_XdrAnon_LedgerKey_Account(u.Account()))
		return
	case TRUSTLINE:
		x.Marshal(x.Sprintf("%strustLine", name), XDR_XdrAnon_LedgerKey_TrustLine(u.TrustLine()))
		return
	case OFFER:
		x.Marshal(x.Sprintf("%soffer", name), XDR_XdrAnon_LedgerKey_Offer(u.Offer()))
		return
	case DATA:
		x.Marshal(x.Sprintf("%sdata", name), XDR_XdrAnon_LedgerKey_Data(u.Data()))
		return
	case CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclaimableBalance", name), XDR_XdrAnon_LedgerKey_ClaimableBalance(u.ClaimableBalance()))
		return
	case LIQUIDITY_POOL:
		x.Marshal(x.Sprintf("%sliquidityPool", name), XDR_XdrAnon_LedgerKey_LiquidityPool(u.LiquidityPool()))
		return
	case CONTRACT_DATA:
		x.Marshal(x.Sprintf("%scontractData", name), XDR_XdrAnon_LedgerKey_ContractData(u.ContractData()))
		return
	case CONTRACT_CODE:
		x.Marshal(x.Sprintf("%scontractCode", name), XDR_XdrAnon_LedgerKey_ContractCode(u.ContractCode()))
		return
	case CONFIG_SETTING:
		x.Marshal(x.Sprintf("%sconfigSetting", name), XDR_XdrAnon_LedgerKey_ConfigSetting(u.ConfigSetting()))
		return
	case TTL:
		x.Marshal(x.Sprintf("%sttl", name), XDR_XdrAnon_LedgerKey_Ttl(u.Ttl()))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerKey", u.Type)
}
func XDR_LedgerKey(v *LedgerKey) *LedgerKey { return v }

var _XdrNames_EnvelopeType = map[int32]string{
	int32(ENVELOPE_TYPE_TX_V0):                 "ENVELOPE_TYPE_TX_V0",
	int32(ENVELOPE_TYPE_SCP):                   "ENVELOPE_TYPE_SCP",
	int32(ENVELOPE_TYPE_TX):                    "ENVELOPE_TYPE_TX",
	int32(ENVELOPE_TYPE_AUTH):                  "ENVELOPE_TYPE_AUTH",
	int32(ENVELOPE_TYPE_SCPVALUE):              "ENVELOPE_TYPE_SCPVALUE",
	int32(ENVELOPE_TYPE_TX_FEE_BUMP):           "ENVELOPE_TYPE_TX_FEE_BUMP",
	int32(ENVELOPE_TYPE_OP_ID):                 "ENVELOPE_TYPE_OP_ID",
	int32(ENVELOPE_TYPE_POOL_REVOKE_OP_ID):     "ENVELOPE_TYPE_POOL_REVOKE_OP_ID",
	int32(ENVELOPE_TYPE_CONTRACT_ID):           "ENVELOPE_TYPE_CONTRACT_ID",
	int32(ENVELOPE_TYPE_SOROBAN_AUTHORIZATION): "ENVELOPE_TYPE_SOROBAN_AUTHORIZATION",
}
var _XdrValues_EnvelopeType = map[string]int32{
	"ENVELOPE_TYPE_TX_V0":                 int32(ENVELOPE_TYPE_TX_V0),
	"ENVELOPE_TYPE_SCP":                   int32(ENVELOPE_TYPE_SCP),
	"ENVELOPE_TYPE_TX":                    int32(ENVELOPE_TYPE_TX),
	"ENVELOPE_TYPE_AUTH":                  int32(ENVELOPE_TYPE_AUTH),
	"ENVELOPE_TYPE_SCPVALUE":              int32(ENVELOPE_TYPE_SCPVALUE),
	"ENVELOPE_TYPE_TX_FEE_BUMP":           int32(ENVELOPE_TYPE_TX_FEE_BUMP),
	"ENVELOPE_TYPE_OP_ID":                 int32(ENVELOPE_TYPE_OP_ID),
	"ENVELOPE_TYPE_POOL_REVOKE_OP_ID":     int32(ENVELOPE_TYPE_POOL_REVOKE_OP_ID),
	"ENVELOPE_TYPE_CONTRACT_ID":           int32(ENVELOPE_TYPE_CONTRACT_ID),
	"ENVELOPE_TYPE_SOROBAN_AUTHORIZATION": int32(ENVELOPE_TYPE_SOROBAN_AUTHORIZATION),
}

func (EnvelopeType) XdrEnumNames() map[int32]string {
	return _XdrNames_EnvelopeType
}
func (v EnvelopeType) String() string {
	if s, ok := _XdrNames_EnvelopeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("EnvelopeType#%d", v)
}
func (v *EnvelopeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_EnvelopeType[stok]; ok {
			*v = EnvelopeType(val)
			return nil
		} else if stok == "EnvelopeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid EnvelopeType.", stok))
	}
}
func (v EnvelopeType) GetU32() uint32                 { return uint32(v) }
func (v *EnvelopeType) SetU32(n uint32)               { *v = EnvelopeType(n) }
func (v *EnvelopeType) XdrPointer() interface{}       { return v }
func (EnvelopeType) XdrTypeName() string              { return "EnvelopeType" }
func (v EnvelopeType) XdrValue() interface{}          { return v }
func (v *EnvelopeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_EnvelopeType = *EnvelopeType

func XDR_EnvelopeType(v *EnvelopeType) *EnvelopeType { return v }

type XdrType_UpgradeType struct {
	XdrVecOpaque
}

func XDR_UpgradeType(v *UpgradeType) XdrType_UpgradeType {
	return XdrType_UpgradeType{XdrVecOpaque{v, 128}}
}
func (XdrType_UpgradeType) XdrTypeName() string  { return "UpgradeType" }
func (v XdrType_UpgradeType) XdrUnwrap() XdrType { return v.XdrVecOpaque }

var _XdrNames_StellarValueType = map[int32]string{
	int32(STELLAR_VALUE_BASIC):  "STELLAR_VALUE_BASIC",
	int32(STELLAR_VALUE_SIGNED): "STELLAR_VALUE_SIGNED",
}
var _XdrValues_StellarValueType = map[string]int32{
	"STELLAR_VALUE_BASIC":  int32(STELLAR_VALUE_BASIC),
	"STELLAR_VALUE_SIGNED": int32(STELLAR_VALUE_SIGNED),
}

func (StellarValueType) XdrEnumNames() map[int32]string {
	return _XdrNames_StellarValueType
}
func (v StellarValueType) String() string {
	if s, ok := _XdrNames_StellarValueType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("StellarValueType#%d", v)
}
func (v *StellarValueType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_StellarValueType[stok]; ok {
			*v = StellarValueType(val)
			return nil
		} else if stok == "StellarValueType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid StellarValueType.", stok))
	}
}
func (v StellarValueType) GetU32() uint32                 { return uint32(v) }
func (v *StellarValueType) SetU32(n uint32)               { *v = StellarValueType(n) }
func (v *StellarValueType) XdrPointer() interface{}       { return v }
func (StellarValueType) XdrTypeName() string              { return "StellarValueType" }
func (v StellarValueType) XdrValue() interface{}          { return v }
func (v *StellarValueType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_StellarValueType = *StellarValueType

func XDR_StellarValueType(v *StellarValueType) *StellarValueType { return v }

type XdrType_LedgerCloseValueSignature = *LedgerCloseValueSignature

func (v *LedgerCloseValueSignature) XdrPointer() interface{}       { return v }
func (LedgerCloseValueSignature) XdrTypeName() string              { return "LedgerCloseValueSignature" }
func (v LedgerCloseValueSignature) XdrValue() interface{}          { return v }
func (v *LedgerCloseValueSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseValueSignature) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snodeID", name), XDR_NodeID(&v.NodeID))
	x.Marshal(x.Sprintf("%ssignature", name), XDR_Signature(&v.Signature))
}
func XDR_LedgerCloseValueSignature(v *LedgerCloseValueSignature) *LedgerCloseValueSignature { return v }

var _XdrTags_XdrAnon_StellarValue_Ext = map[int32]bool{
	XdrToI32(STELLAR_VALUE_BASIC):  true,
	XdrToI32(STELLAR_VALUE_SIGNED): true,
}

func (_ XdrAnon_StellarValue_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_StellarValue_Ext
}
func (u *XdrAnon_StellarValue_Ext) LcValueSignature() *LedgerCloseValueSignature {
	switch u.V {
	case STELLAR_VALUE_SIGNED:
		if v, ok := u._u.(*LedgerCloseValueSignature); ok {
			return v
		} else {
			var zero LedgerCloseValueSignature
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_StellarValue_Ext.LcValueSignature accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_StellarValue_Ext) XdrValid() bool {
	switch u.V {
	case STELLAR_VALUE_BASIC, STELLAR_VALUE_SIGNED:
		return true
	}
	return false
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionTag() XdrNum32 {
	return XDR_StellarValueType(&u.V)
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return nil
	case STELLAR_VALUE_SIGNED:
		return XDR_LedgerCloseValueSignature(u.LcValueSignature())
	}
	return nil
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionBodyName() string {
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return ""
	case STELLAR_VALUE_SIGNED:
		return "LcValueSignature"
	}
	return ""
}

type XdrType_XdrAnon_StellarValue_Ext = *XdrAnon_StellarValue_Ext

func (v *XdrAnon_StellarValue_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_StellarValue_Ext) XdrTypeName() string              { return "XdrAnon_StellarValue_Ext" }
func (v XdrAnon_StellarValue_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_StellarValue_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_StellarValue_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_StellarValueType(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return
	case STELLAR_VALUE_SIGNED:
		x.Marshal(x.Sprintf("%slcValueSignature", name), XDR_LedgerCloseValueSignature(u.LcValueSignature()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_StellarValue_Ext", u.V)
}
func XDR_XdrAnon_StellarValue_Ext(v *XdrAnon_StellarValue_Ext) *XdrAnon_StellarValue_Ext { return v }

type _XdrVec_6_UpgradeType []UpgradeType

func (_XdrVec_6_UpgradeType) XdrBound() uint32 {
	const bound uint32 = 6 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_6_UpgradeType) XdrCheckLen(length uint32) {
	if length > uint32(6) {
		XdrPanic("_XdrVec_6_UpgradeType length %d exceeds bound 6", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_6_UpgradeType length %d exceeds max int", length)
	}
}
func (v _XdrVec_6_UpgradeType) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_6_UpgradeType) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(6); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]UpgradeType, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_6_UpgradeType) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_UpgradeType(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_6_UpgradeType) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 6}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_6_UpgradeType) XdrTypeName() string              { return "UpgradeType<>" }
func (v *_XdrVec_6_UpgradeType) XdrPointer() interface{}       { return (*[]UpgradeType)(v) }
func (v _XdrVec_6_UpgradeType) XdrValue() interface{}          { return ([]UpgradeType)(v) }
func (v *_XdrVec_6_UpgradeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_StellarValue = *StellarValue

func (v *StellarValue) XdrPointer() interface{}       { return v }
func (StellarValue) XdrTypeName() string              { return "StellarValue" }
func (v StellarValue) XdrValue() interface{}          { return v }
func (v *StellarValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *StellarValue) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxSetHash", name), XDR_Hash(&v.TxSetHash))
	x.Marshal(x.Sprintf("%scloseTime", name), XDR_TimePoint(&v.CloseTime))
	x.Marshal(x.Sprintf("%supgrades", name), (*_XdrVec_6_UpgradeType)(&v.Upgrades))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_StellarValue_Ext(&v.Ext))
}
func XDR_StellarValue(v *StellarValue) *StellarValue { return v }

var _XdrNames_LedgerHeaderFlags = map[int32]string{
	int32(DISABLE_LIQUIDITY_POOL_TRADING_FLAG):    "DISABLE_LIQUIDITY_POOL_TRADING_FLAG",
	int32(DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG):    "DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG",
	int32(DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG): "DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG",
}
var _XdrValues_LedgerHeaderFlags = map[string]int32{
	"DISABLE_LIQUIDITY_POOL_TRADING_FLAG":    int32(DISABLE_LIQUIDITY_POOL_TRADING_FLAG),
	"DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG":    int32(DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG),
	"DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG": int32(DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG),
}

func (LedgerHeaderFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerHeaderFlags
}
func (v LedgerHeaderFlags) String() string {
	if s, ok := _XdrNames_LedgerHeaderFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerHeaderFlags#%d", v)
}
func (v *LedgerHeaderFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerHeaderFlags[stok]; ok {
			*v = LedgerHeaderFlags(val)
			return nil
		} else if stok == "LedgerHeaderFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerHeaderFlags.", stok))
	}
}
func (v LedgerHeaderFlags) GetU32() uint32                 { return uint32(v) }
func (v *LedgerHeaderFlags) SetU32(n uint32)               { *v = LedgerHeaderFlags(n) }
func (v *LedgerHeaderFlags) XdrPointer() interface{}       { return v }
func (LedgerHeaderFlags) XdrTypeName() string              { return "LedgerHeaderFlags" }
func (v LedgerHeaderFlags) XdrValue() interface{}          { return v }
func (v *LedgerHeaderFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerHeaderFlags = *LedgerHeaderFlags

func XDR_LedgerHeaderFlags(v *LedgerHeaderFlags) *LedgerHeaderFlags { return v }
func (v *LedgerHeaderFlags) XdrInitialize() {
	switch LedgerHeaderFlags(0) {
	case DISABLE_LIQUIDITY_POOL_TRADING_FLAG, DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG, DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG:
	default:
		if *v == LedgerHeaderFlags(0) {
			*v = DISABLE_LIQUIDITY_POOL_TRADING_FLAG
		}
	}
}

var _XdrTags_XdrAnon_LedgerHeaderExtensionV1_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_LedgerHeaderExtensionV1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerHeaderExtensionV1_Ext
}
func (u XdrAnon_LedgerHeaderExtensionV1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_LedgerHeaderExtensionV1_Ext = *XdrAnon_LedgerHeaderExtensionV1_Ext

func (v *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerHeaderExtensionV1_Ext) XdrTypeName() string {
	return "XdrAnon_LedgerHeaderExtensionV1_Ext"
}
func (v XdrAnon_LedgerHeaderExtensionV1_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerHeaderExtensionV1_Ext", u.V)
}
func XDR_XdrAnon_LedgerHeaderExtensionV1_Ext(v *XdrAnon_LedgerHeaderExtensionV1_Ext) *XdrAnon_LedgerHeaderExtensionV1_Ext {
	return v
}

type XdrType_LedgerHeaderExtensionV1 = *LedgerHeaderExtensionV1

func (v *LedgerHeaderExtensionV1) XdrPointer() interface{}       { return v }
func (LedgerHeaderExtensionV1) XdrTypeName() string              { return "LedgerHeaderExtensionV1" }
func (v LedgerHeaderExtensionV1) XdrValue() interface{}          { return v }
func (v *LedgerHeaderExtensionV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeaderExtensionV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerHeaderExtensionV1_Ext(&v.Ext))
}
func XDR_LedgerHeaderExtensionV1(v *LedgerHeaderExtensionV1) *LedgerHeaderExtensionV1 { return v }

var _XdrTags_XdrAnon_LedgerHeader_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_LedgerHeader_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerHeader_Ext
}
func (u *XdrAnon_LedgerHeader_Ext) V1() *LedgerHeaderExtensionV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*LedgerHeaderExtensionV1); ok {
			return v
		} else {
			var zero LedgerHeaderExtensionV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerHeader_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_LedgerHeader_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_LedgerHeaderExtensionV1(u.V1())
	}
	return nil
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_LedgerHeader_Ext = *XdrAnon_LedgerHeader_Ext

func (v *XdrAnon_LedgerHeader_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerHeader_Ext) XdrTypeName() string              { return "XdrAnon_LedgerHeader_Ext" }
func (v XdrAnon_LedgerHeader_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerHeader_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerHeader_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_LedgerHeaderExtensionV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerHeader_Ext", u.V)
}
func XDR_XdrAnon_LedgerHeader_Ext(v *XdrAnon_LedgerHeader_Ext) *XdrAnon_LedgerHeader_Ext { return v }

type _XdrArray_4_Hash [4]Hash

func (_XdrArray_4_Hash) XdrArraySize() uint32 {
	const bound uint32 = 4 // Force error if not const or doesn't fit
	return bound
}
func (v *_XdrArray_4_Hash) XdrRecurse(x XDR, name string) {
	for i := 0; i < len(*v); i++ {
		XDR_Hash(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
}
func (v *_XdrArray_4_Hash) XdrPointer() interface{}       { return (*[4]Hash)(v) }
func (_XdrArray_4_Hash) XdrTypeName() string              { return "Hash[]" }
func (v *_XdrArray_4_Hash) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_4_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerHeader = *LedgerHeader

func (v *LedgerHeader) XdrPointer() interface{}       { return v }
func (LedgerHeader) XdrTypeName() string              { return "LedgerHeader" }
func (v LedgerHeader) XdrValue() interface{}          { return v }
func (v *LedgerHeader) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeader) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerVersion", name), XDR_Uint32(&v.LedgerVersion))
	x.Marshal(x.Sprintf("%spreviousLedgerHash", name), XDR_Hash(&v.PreviousLedgerHash))
	x.Marshal(x.Sprintf("%sscpValue", name), XDR_StellarValue(&v.ScpValue))
	x.Marshal(x.Sprintf("%stxSetResultHash", name), XDR_Hash(&v.TxSetResultHash))
	x.Marshal(x.Sprintf("%sbucketListHash", name), XDR_Hash(&v.BucketListHash))
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%stotalCoins", name), XDR_Int64(&v.TotalCoins))
	x.Marshal(x.Sprintf("%sfeePool", name), XDR_Int64(&v.FeePool))
	x.Marshal(x.Sprintf("%sinflationSeq", name), XDR_Uint32(&v.InflationSeq))
	x.Marshal(x.Sprintf("%sidPool", name), XDR_Uint64(&v.IdPool))
	x.Marshal(x.Sprintf("%sbaseFee", name), XDR_Uint32(&v.BaseFee))
	x.Marshal(x.Sprintf("%sbaseReserve", name), XDR_Uint32(&v.BaseReserve))
	x.Marshal(x.Sprintf("%smaxTxSetSize", name), XDR_Uint32(&v.MaxTxSetSize))
	x.Marshal(x.Sprintf("%sskipList", name), (*_XdrArray_4_Hash)(&v.SkipList))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerHeader_Ext(&v.Ext))
}
func XDR_LedgerHeader(v *LedgerHeader) *LedgerHeader { return v }

var _XdrNames_LedgerUpgradeType = map[int32]string{
	int32(LEDGER_UPGRADE_VERSION):                 "LEDGER_UPGRADE_VERSION",
	int32(LEDGER_UPGRADE_BASE_FEE):                "LEDGER_UPGRADE_BASE_FEE",
	int32(LEDGER_UPGRADE_MAX_TX_SET_SIZE):         "LEDGER_UPGRADE_MAX_TX_SET_SIZE",
	int32(LEDGER_UPGRADE_BASE_RESERVE):            "LEDGER_UPGRADE_BASE_RESERVE",
	int32(LEDGER_UPGRADE_FLAGS):                   "LEDGER_UPGRADE_FLAGS",
	int32(LEDGER_UPGRADE_CONFIG):                  "LEDGER_UPGRADE_CONFIG",
	int32(LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE): "LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE",
}
var _XdrValues_LedgerUpgradeType = map[string]int32{
	"LEDGER_UPGRADE_VERSION":                 int32(LEDGER_UPGRADE_VERSION),
	"LEDGER_UPGRADE_BASE_FEE":                int32(LEDGER_UPGRADE_BASE_FEE),
	"LEDGER_UPGRADE_MAX_TX_SET_SIZE":         int32(LEDGER_UPGRADE_MAX_TX_SET_SIZE),
	"LEDGER_UPGRADE_BASE_RESERVE":            int32(LEDGER_UPGRADE_BASE_RESERVE),
	"LEDGER_UPGRADE_FLAGS":                   int32(LEDGER_UPGRADE_FLAGS),
	"LEDGER_UPGRADE_CONFIG":                  int32(LEDGER_UPGRADE_CONFIG),
	"LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE": int32(LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE),
}

func (LedgerUpgradeType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerUpgradeType
}
func (v LedgerUpgradeType) String() string {
	if s, ok := _XdrNames_LedgerUpgradeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerUpgradeType#%d", v)
}
func (v *LedgerUpgradeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerUpgradeType[stok]; ok {
			*v = LedgerUpgradeType(val)
			return nil
		} else if stok == "LedgerUpgradeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerUpgradeType.", stok))
	}
}
func (v LedgerUpgradeType) GetU32() uint32                 { return uint32(v) }
func (v *LedgerUpgradeType) SetU32(n uint32)               { *v = LedgerUpgradeType(n) }
func (v *LedgerUpgradeType) XdrPointer() interface{}       { return v }
func (LedgerUpgradeType) XdrTypeName() string              { return "LedgerUpgradeType" }
func (v LedgerUpgradeType) XdrValue() interface{}          { return v }
func (v *LedgerUpgradeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerUpgradeType = *LedgerUpgradeType

func XDR_LedgerUpgradeType(v *LedgerUpgradeType) *LedgerUpgradeType { return v }
func (v *LedgerUpgradeType) XdrInitialize() {
	switch LedgerUpgradeType(0) {
	case LEDGER_UPGRADE_VERSION, LEDGER_UPGRADE_BASE_FEE, LEDGER_UPGRADE_MAX_TX_SET_SIZE, LEDGER_UPGRADE_BASE_RESERVE, LEDGER_UPGRADE_FLAGS, LEDGER_UPGRADE_CONFIG, LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
	default:
		if *v == LedgerUpgradeType(0) {
			*v = LEDGER_UPGRADE_VERSION
		}
	}
}

type XdrType_ConfigUpgradeSetKey = *ConfigUpgradeSetKey

func (v *ConfigUpgradeSetKey) XdrPointer() interface{}       { return v }
func (ConfigUpgradeSetKey) XdrTypeName() string              { return "ConfigUpgradeSetKey" }
func (v ConfigUpgradeSetKey) XdrValue() interface{}          { return v }
func (v *ConfigUpgradeSetKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigUpgradeSetKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scontractID", name), XDR_Hash(&v.ContractID))
	x.Marshal(x.Sprintf("%scontentHash", name), XDR_Hash(&v.ContentHash))
}
func XDR_ConfigUpgradeSetKey(v *ConfigUpgradeSetKey) *ConfigUpgradeSetKey { return v }

var _XdrTags_LedgerUpgrade = map[int32]bool{
	XdrToI32(LEDGER_UPGRADE_VERSION):                 true,
	XdrToI32(LEDGER_UPGRADE_BASE_FEE):                true,
	XdrToI32(LEDGER_UPGRADE_MAX_TX_SET_SIZE):         true,
	XdrToI32(LEDGER_UPGRADE_BASE_RESERVE):            true,
	XdrToI32(LEDGER_UPGRADE_FLAGS):                   true,
	XdrToI32(LEDGER_UPGRADE_CONFIG):                  true,
	XdrToI32(LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE): true,
}

func (_ LedgerUpgrade) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerUpgrade
}

// update ledgerVersion
func (u *LedgerUpgrade) NewLedgerVersion() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewLedgerVersion accessed when Type == %v", u.Type)
		return nil
	}
}

// update baseFee
func (u *LedgerUpgrade) NewBaseFee() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_BASE_FEE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewBaseFee accessed when Type == %v", u.Type)
		return nil
	}
}

// update maxTxSetSize
func (u *LedgerUpgrade) NewMaxTxSetSize() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewMaxTxSetSize accessed when Type == %v", u.Type)
		return nil
	}
}

// update baseReserve
func (u *LedgerUpgrade) NewBaseReserve() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_BASE_RESERVE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewBaseReserve accessed when Type == %v", u.Type)
		return nil
	}
}

// update flags
func (u *LedgerUpgrade) NewFlags() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_FLAGS:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewFlags accessed when Type == %v", u.Type)
		return nil
	}
}

// Update arbitrary `ConfigSetting` entries identified by the key.
func (u *LedgerUpgrade) NewConfig() *ConfigUpgradeSetKey {
	switch u.Type {
	case LEDGER_UPGRADE_CONFIG:
		if v, ok := u._u.(*ConfigUpgradeSetKey); ok {
			return v
		} else {
			var zero ConfigUpgradeSetKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewConfig accessed when Type == %v", u.Type)
		return nil
	}
}

// Update ConfigSettingContractExecutionLanesV0.ledgerMaxTxCount without
// using `LEDGER_UPGRADE_CONFIG`.
func (u *LedgerUpgrade) NewMaxSorobanTxSetSize() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewMaxSorobanTxSetSize accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerUpgrade) XdrValid() bool {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION, LEDGER_UPGRADE_BASE_FEE, LEDGER_UPGRADE_MAX_TX_SET_SIZE, LEDGER_UPGRADE_BASE_RESERVE, LEDGER_UPGRADE_FLAGS, LEDGER_UPGRADE_CONFIG, LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
		return true
	}
	return false
}
func (u *LedgerUpgrade) XdrUnionTag() XdrNum32 {
	return XDR_LedgerUpgradeType(&u.Type)
}
func (u *LedgerUpgrade) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerUpgrade) XdrUnionBody() XdrType {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		return XDR_Uint32(u.NewLedgerVersion())
	case LEDGER_UPGRADE_BASE_FEE:
		return XDR_Uint32(u.NewBaseFee())
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		return XDR_Uint32(u.NewMaxTxSetSize())
	case LEDGER_UPGRADE_BASE_RESERVE:
		return XDR_Uint32(u.NewBaseReserve())
	case LEDGER_UPGRADE_FLAGS:
		return XDR_Uint32(u.NewFlags())
	case LEDGER_UPGRADE_CONFIG:
		return XDR_ConfigUpgradeSetKey(u.NewConfig())
	case LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
		return XDR_Uint32(u.NewMaxSorobanTxSetSize())
	}
	return nil
}
func (u *LedgerUpgrade) XdrUnionBodyName() string {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		return "NewLedgerVersion"
	case LEDGER_UPGRADE_BASE_FEE:
		return "NewBaseFee"
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		return "NewMaxTxSetSize"
	case LEDGER_UPGRADE_BASE_RESERVE:
		return "NewBaseReserve"
	case LEDGER_UPGRADE_FLAGS:
		return "NewFlags"
	case LEDGER_UPGRADE_CONFIG:
		return "NewConfig"
	case LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
		return "NewMaxSorobanTxSetSize"
	}
	return ""
}

type XdrType_LedgerUpgrade = *LedgerUpgrade

func (v *LedgerUpgrade) XdrPointer() interface{}       { return v }
func (LedgerUpgrade) XdrTypeName() string              { return "LedgerUpgrade" }
func (v LedgerUpgrade) XdrValue() interface{}          { return v }
func (v *LedgerUpgrade) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerUpgrade) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerUpgradeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		x.Marshal(x.Sprintf("%snewLedgerVersion", name), XDR_Uint32(u.NewLedgerVersion()))
		return
	case LEDGER_UPGRADE_BASE_FEE:
		x.Marshal(x.Sprintf("%snewBaseFee", name), XDR_Uint32(u.NewBaseFee()))
		return
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		x.Marshal(x.Sprintf("%snewMaxTxSetSize", name), XDR_Uint32(u.NewMaxTxSetSize()))
		return
	case LEDGER_UPGRADE_BASE_RESERVE:
		x.Marshal(x.Sprintf("%snewBaseReserve", name), XDR_Uint32(u.NewBaseReserve()))
		return
	case LEDGER_UPGRADE_FLAGS:
		x.Marshal(x.Sprintf("%snewFlags", name), XDR_Uint32(u.NewFlags()))
		return
	case LEDGER_UPGRADE_CONFIG:
		x.Marshal(x.Sprintf("%snewConfig", name), XDR_ConfigUpgradeSetKey(u.NewConfig()))
		return
	case LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
		x.Marshal(x.Sprintf("%snewMaxSorobanTxSetSize", name), XDR_Uint32(u.NewMaxSorobanTxSetSize()))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerUpgrade", u.Type)
}
func (v *LedgerUpgrade) XdrInitialize() {
	var zero LedgerUpgradeType
	switch zero {
	case LEDGER_UPGRADE_VERSION, LEDGER_UPGRADE_BASE_FEE, LEDGER_UPGRADE_MAX_TX_SET_SIZE, LEDGER_UPGRADE_BASE_RESERVE, LEDGER_UPGRADE_FLAGS, LEDGER_UPGRADE_CONFIG, LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
	default:
		if v.Type == zero {
			v.Type = LEDGER_UPGRADE_VERSION
		}
	}
}
func XDR_LedgerUpgrade(v *LedgerUpgrade) *LedgerUpgrade { return v }

type _XdrVec_unbounded_ConfigSettingEntry []ConfigSettingEntry

func (_XdrVec_unbounded_ConfigSettingEntry) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_ConfigSettingEntry) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_ConfigSettingEntry length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_ConfigSettingEntry length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_ConfigSettingEntry) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_ConfigSettingEntry) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ConfigSettingEntry, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_ConfigSettingEntry) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_ConfigSettingEntry(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_ConfigSettingEntry) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_ConfigSettingEntry) XdrTypeName() string { return "ConfigSettingEntry<>" }
func (v *_XdrVec_unbounded_ConfigSettingEntry) XdrPointer() interface{} {
	return (*[]ConfigSettingEntry)(v)
}
func (v _XdrVec_unbounded_ConfigSettingEntry) XdrValue() interface{} {
	return ([]ConfigSettingEntry)(v)
}
func (v *_XdrVec_unbounded_ConfigSettingEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ConfigUpgradeSet = *ConfigUpgradeSet

func (v *ConfigUpgradeSet) XdrPointer() interface{}       { return v }
func (ConfigUpgradeSet) XdrTypeName() string              { return "ConfigUpgradeSet" }
func (v ConfigUpgradeSet) XdrValue() interface{}          { return v }
func (v *ConfigUpgradeSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigUpgradeSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%supdatedEntry", name), (*_XdrVec_unbounded_ConfigSettingEntry)(&v.UpdatedEntry))
}
func XDR_ConfigUpgradeSet(v *ConfigUpgradeSet) *ConfigUpgradeSet { return v }

var _XdrNames_BucketEntryType = map[int32]string{
	int32(METAENTRY): "METAENTRY",
	int32(LIVEENTRY): "LIVEENTRY",
	int32(DEADENTRY): "DEADENTRY",
	int32(INITENTRY): "INITENTRY",
}
var _XdrValues_BucketEntryType = map[string]int32{
	"METAENTRY": int32(METAENTRY),
	"LIVEENTRY": int32(LIVEENTRY),
	"DEADENTRY": int32(DEADENTRY),
	"INITENTRY": int32(INITENTRY),
}

func (BucketEntryType) XdrEnumNames() map[int32]string {
	return _XdrNames_BucketEntryType
}
func (v BucketEntryType) String() string {
	if s, ok := _XdrNames_BucketEntryType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("BucketEntryType#%d", v)
}
func (v *BucketEntryType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BucketEntryType[stok]; ok {
			*v = BucketEntryType(val)
			return nil
		} else if stok == "BucketEntryType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid BucketEntryType.", stok))
	}
}
func (v BucketEntryType) GetU32() uint32                 { return uint32(v) }
func (v *BucketEntryType) SetU32(n uint32)               { *v = BucketEntryType(n) }
func (v *BucketEntryType) XdrPointer() interface{}       { return v }
func (BucketEntryType) XdrTypeName() string              { return "BucketEntryType" }
func (v BucketEntryType) XdrValue() interface{}          { return v }
func (v *BucketEntryType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_BucketEntryType = *BucketEntryType

func XDR_BucketEntryType(v *BucketEntryType) *BucketEntryType { return v }

var _XdrComments_BucketEntryType = map[int32]string{
	int32(METAENTRY): "At-and-after protocol 11: bucket metadata, should come first.",
	int32(LIVEENTRY): "Before protocol 11: created-or-updated;",
	int32(DEADENTRY): "At-and-after protocol 11: only updated.",
	int32(INITENTRY): "At-and-after protocol 11: only created.",
}

func (e BucketEntryType) XdrEnumComments() map[int32]string {
	return _XdrComments_BucketEntryType
}

var _XdrTags_XdrAnon_BucketMetadata_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_BucketMetadata_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_BucketMetadata_Ext
}
func (u XdrAnon_BucketMetadata_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_BucketMetadata_Ext = *XdrAnon_BucketMetadata_Ext

func (v *XdrAnon_BucketMetadata_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_BucketMetadata_Ext) XdrTypeName() string              { return "XdrAnon_BucketMetadata_Ext" }
func (v XdrAnon_BucketMetadata_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_BucketMetadata_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_BucketMetadata_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_BucketMetadata_Ext", u.V)
}
func XDR_XdrAnon_BucketMetadata_Ext(v *XdrAnon_BucketMetadata_Ext) *XdrAnon_BucketMetadata_Ext {
	return v
}

type XdrType_BucketMetadata = *BucketMetadata

func (v *BucketMetadata) XdrPointer() interface{}       { return v }
func (BucketMetadata) XdrTypeName() string              { return "BucketMetadata" }
func (v BucketMetadata) XdrValue() interface{}          { return v }
func (v *BucketMetadata) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BucketMetadata) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerVersion", name), XDR_Uint32(&v.LedgerVersion))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_BucketMetadata_Ext(&v.Ext))
}
func XDR_BucketMetadata(v *BucketMetadata) *BucketMetadata { return v }

var _XdrTags_BucketEntry = map[int32]bool{
	XdrToI32(LIVEENTRY): true,
	XdrToI32(INITENTRY): true,
	XdrToI32(DEADENTRY): true,
	XdrToI32(METAENTRY): true,
}

func (_ BucketEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_BucketEntry
}
func (u *BucketEntry) LiveEntry() *LedgerEntry {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.LiveEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *BucketEntry) DeadEntry() *LedgerKey {
	switch u.Type {
	case DEADENTRY:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.DeadEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *BucketEntry) MetaEntry() *BucketMetadata {
	switch u.Type {
	case METAENTRY:
		if v, ok := u._u.(*BucketMetadata); ok {
			return v
		} else {
			var zero BucketMetadata
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.MetaEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u BucketEntry) XdrValid() bool {
	switch u.Type {
	case LIVEENTRY, INITENTRY, DEADENTRY, METAENTRY:
		return true
	}
	return false
}
func (u *BucketEntry) XdrUnionTag() XdrNum32 {
	return XDR_BucketEntryType(&u.Type)
}
func (u *BucketEntry) XdrUnionTagName() string {
	return "Type"
}
func (u *BucketEntry) XdrUnionBody() XdrType {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		return XDR_LedgerEntry(u.LiveEntry())
	case DEADENTRY:
		return XDR_LedgerKey(u.DeadEntry())
	case METAENTRY:
		return XDR_BucketMetadata(u.MetaEntry())
	}
	return nil
}
func (u *BucketEntry) XdrUnionBodyName() string {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		return "LiveEntry"
	case DEADENTRY:
		return "DeadEntry"
	case METAENTRY:
		return "MetaEntry"
	}
	return ""
}

type XdrType_BucketEntry = *BucketEntry

func (v *BucketEntry) XdrPointer() interface{}       { return v }
func (BucketEntry) XdrTypeName() string              { return "BucketEntry" }
func (v BucketEntry) XdrValue() interface{}          { return v }
func (v *BucketEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *BucketEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BucketEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		x.Marshal(x.Sprintf("%sliveEntry", name), XDR_LedgerEntry(u.LiveEntry()))
		return
	case DEADENTRY:
		x.Marshal(x.Sprintf("%sdeadEntry", name), XDR_LedgerKey(u.DeadEntry()))
		return
	case METAENTRY:
		x.Marshal(x.Sprintf("%smetaEntry", name), XDR_BucketMetadata(u.MetaEntry()))
		return
	}
	XdrPanic("invalid Type (%v) in BucketEntry", u.Type)
}
func XDR_BucketEntry(v *BucketEntry) *BucketEntry { return v }

var _XdrNames_TxSetComponentType = map[int32]string{
	int32(TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE): "TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE",
}
var _XdrValues_TxSetComponentType = map[string]int32{
	"TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE": int32(TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE),
}

func (TxSetComponentType) XdrEnumNames() map[int32]string {
	return _XdrNames_TxSetComponentType
}
func (v TxSetComponentType) String() string {
	if s, ok := _XdrNames_TxSetComponentType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("TxSetComponentType#%d", v)
}
func (v *TxSetComponentType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TxSetComponentType[stok]; ok {
			*v = TxSetComponentType(val)
			return nil
		} else if stok == "TxSetComponentType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid TxSetComponentType.", stok))
	}
}
func (v TxSetComponentType) GetU32() uint32                 { return uint32(v) }
func (v *TxSetComponentType) SetU32(n uint32)               { *v = TxSetComponentType(n) }
func (v *TxSetComponentType) XdrPointer() interface{}       { return v }
func (TxSetComponentType) XdrTypeName() string              { return "TxSetComponentType" }
func (v TxSetComponentType) XdrValue() interface{}          { return v }
func (v *TxSetComponentType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TxSetComponentType = *TxSetComponentType

func XDR_TxSetComponentType(v *TxSetComponentType) *TxSetComponentType { return v }

var _XdrComments_TxSetComponentType = map[int32]string{
	int32(TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE): "txs with effective fee <= bid derived from a base fee (if any). If base fee is not specified, no discount is applied.",
}

func (e TxSetComponentType) XdrEnumComments() map[int32]string {
	return _XdrComments_TxSetComponentType
}

type _XdrPtr_Int64 struct {
	p **Int64
}
type _ptrflag_Int64 _XdrPtr_Int64

func (v _ptrflag_Int64) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Int64) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Int64 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Int64) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Int64) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Int64)
		}
	default:
		XdrPanic("*Int64 present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Int64) XdrTypeName() string             { return "Int64?" }
func (v _ptrflag_Int64) XdrPointer() interface{}       { return nil }
func (v _ptrflag_Int64) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_Int64) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Int64) XdrBound() uint32              { return 1 }
func (v _XdrPtr_Int64) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_Int64) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Int64)
	}
}
func (v _XdrPtr_Int64) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Int64(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Int64) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Int64) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Int64(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Int64) XdrTypeName() string       { return "Int64*" }
func (v _XdrPtr_Int64) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Int64) XdrValue() interface{}   { return *v.p }

type _XdrVec_unbounded_TransactionEnvelope []TransactionEnvelope

func (_XdrVec_unbounded_TransactionEnvelope) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionEnvelope) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionEnvelope length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionEnvelope length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionEnvelope) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionEnvelope) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionEnvelope, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionEnvelope(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionEnvelope) XdrTypeName() string { return "TransactionEnvelope<>" }
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrPointer() interface{} {
	return (*[]TransactionEnvelope)(v)
}
func (v _XdrVec_unbounded_TransactionEnvelope) XdrValue() interface{} {
	return ([]TransactionEnvelope)(v)
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_XdrAnon_TxSetComponent_TxsMaybeDiscountedFee = *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee

func (v *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrPointer() interface{} { return v }
func (XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrTypeName() string {
	return "XdrAnon_TxSetComponent_TxsMaybeDiscountedFee"
}
func (v XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrValue() interface{} { return v }
func (v *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbaseFee", name), _XdrPtr_Int64{&v.BaseFee})
	x.Marshal(x.Sprintf("%stxs", name), (*_XdrVec_unbounded_TransactionEnvelope)(&v.Txs))
}
func XDR_XdrAnon_TxSetComponent_TxsMaybeDiscountedFee(v *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee {
	return v
}

var _XdrTags_TxSetComponent = map[int32]bool{
	XdrToI32(TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE): true,
}

func (_ TxSetComponent) XdrValidTags() map[int32]bool {
	return _XdrTags_TxSetComponent
}
func (u *TxSetComponent) TxsMaybeDiscountedFee() *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee {
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		if v, ok := u._u.(*XdrAnon_TxSetComponent_TxsMaybeDiscountedFee); ok {
			return v
		} else {
			var zero XdrAnon_TxSetComponent_TxsMaybeDiscountedFee
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TxSetComponent.TxsMaybeDiscountedFee accessed when Type == %v", u.Type)
		return nil
	}
}
func (u TxSetComponent) XdrValid() bool {
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		return true
	}
	return false
}
func (u *TxSetComponent) XdrUnionTag() XdrNum32 {
	return XDR_TxSetComponentType(&u.Type)
}
func (u *TxSetComponent) XdrUnionTagName() string {
	return "Type"
}
func (u *TxSetComponent) XdrUnionBody() XdrType {
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		return XDR_XdrAnon_TxSetComponent_TxsMaybeDiscountedFee(u.TxsMaybeDiscountedFee())
	}
	return nil
}
func (u *TxSetComponent) XdrUnionBodyName() string {
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		return "TxsMaybeDiscountedFee"
	}
	return ""
}

type XdrType_TxSetComponent = *TxSetComponent

func (v *TxSetComponent) XdrPointer() interface{}       { return v }
func (TxSetComponent) XdrTypeName() string              { return "TxSetComponent" }
func (v TxSetComponent) XdrValue() interface{}          { return v }
func (v *TxSetComponent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TxSetComponent) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TxSetComponentType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		x.Marshal(x.Sprintf("%stxsMaybeDiscountedFee", name), XDR_XdrAnon_TxSetComponent_TxsMaybeDiscountedFee(u.TxsMaybeDiscountedFee()))
		return
	}
	XdrPanic("invalid Type (%v) in TxSetComponent", u.Type)
}
func XDR_TxSetComponent(v *TxSetComponent) *TxSetComponent { return v }

type _XdrVec_unbounded_TxSetComponent []TxSetComponent

func (_XdrVec_unbounded_TxSetComponent) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TxSetComponent) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TxSetComponent length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TxSetComponent length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TxSetComponent) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TxSetComponent) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TxSetComponent, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TxSetComponent) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TxSetComponent(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TxSetComponent) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TxSetComponent) XdrTypeName() string              { return "TxSetComponent<>" }
func (v *_XdrVec_unbounded_TxSetComponent) XdrPointer() interface{}       { return (*[]TxSetComponent)(v) }
func (v _XdrVec_unbounded_TxSetComponent) XdrValue() interface{}          { return ([]TxSetComponent)(v) }
func (v *_XdrVec_unbounded_TxSetComponent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_TransactionPhase = map[int32]bool{
	XdrToI32(0): true,
}

func (_ TransactionPhase) XdrValidTags() map[int32]bool {
	return _XdrTags_TransactionPhase
}
func (u *TransactionPhase) V0Components() *[]TxSetComponent {
	switch u.V {
	case 0:
		if v, ok := u._u.(*[]TxSetComponent); ok {
			return v
		} else {
			var zero []TxSetComponent
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionPhase.V0Components accessed when V == %v", u.V)
		return nil
	}
}
func (u TransactionPhase) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *TransactionPhase) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *TransactionPhase) XdrUnionTagName() string {
	return "V"
}
func (u *TransactionPhase) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return (*_XdrVec_unbounded_TxSetComponent)(u.V0Components())
	}
	return nil
}
func (u *TransactionPhase) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0Components"
	}
	return ""
}

type XdrType_TransactionPhase = *TransactionPhase

func (v *TransactionPhase) XdrPointer() interface{}       { return v }
func (TransactionPhase) XdrTypeName() string              { return "TransactionPhase" }
func (v TransactionPhase) XdrValue() interface{}          { return v }
func (v *TransactionPhase) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TransactionPhase) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0Components", name), (*_XdrVec_unbounded_TxSetComponent)(u.V0Components()))
		return
	}
	XdrPanic("invalid V (%v) in TransactionPhase", u.V)
}
func XDR_TransactionPhase(v *TransactionPhase) *TransactionPhase { return v }

type XdrType_TransactionSet = *TransactionSet

func (v *TransactionSet) XdrPointer() interface{}       { return v }
func (TransactionSet) XdrTypeName() string              { return "TransactionSet" }
func (v TransactionSet) XdrValue() interface{}          { return v }
func (v *TransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%spreviousLedgerHash", name), XDR_Hash(&v.PreviousLedgerHash))
	x.Marshal(x.Sprintf("%stxs", name), (*_XdrVec_unbounded_TransactionEnvelope)(&v.Txs))
}
func XDR_TransactionSet(v *TransactionSet) *TransactionSet { return v }

type _XdrVec_unbounded_TransactionPhase []TransactionPhase

func (_XdrVec_unbounded_TransactionPhase) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionPhase) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionPhase length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionPhase length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionPhase) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionPhase) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionPhase, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionPhase) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionPhase(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionPhase) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionPhase) XdrTypeName() string { return "TransactionPhase<>" }
func (v *_XdrVec_unbounded_TransactionPhase) XdrPointer() interface{} {
	return (*[]TransactionPhase)(v)
}
func (v _XdrVec_unbounded_TransactionPhase) XdrValue() interface{}          { return ([]TransactionPhase)(v) }
func (v *_XdrVec_unbounded_TransactionPhase) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionSetV1 = *TransactionSetV1

func (v *TransactionSetV1) XdrPointer() interface{}       { return v }
func (TransactionSetV1) XdrTypeName() string              { return "TransactionSetV1" }
func (v TransactionSetV1) XdrValue() interface{}          { return v }
func (v *TransactionSetV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSetV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%spreviousLedgerHash", name), XDR_Hash(&v.PreviousLedgerHash))
	x.Marshal(x.Sprintf("%sphases", name), (*_XdrVec_unbounded_TransactionPhase)(&v.Phases))
}
func XDR_TransactionSetV1(v *TransactionSetV1) *TransactionSetV1 { return v }

var _XdrTags_GeneralizedTransactionSet = map[int32]bool{
	XdrToI32(1): true,
}

func (_ GeneralizedTransactionSet) XdrValidTags() map[int32]bool {
	return _XdrTags_GeneralizedTransactionSet
}
func (u *GeneralizedTransactionSet) V1TxSet() *TransactionSetV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*TransactionSetV1); ok {
			return v
		} else {
			var zero TransactionSetV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("GeneralizedTransactionSet.V1TxSet accessed when V == %v", u.V)
		return nil
	}
}
func (u GeneralizedTransactionSet) XdrValid() bool {
	switch u.V {
	case 1:
		return true
	}
	return false
}
func (u *GeneralizedTransactionSet) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *GeneralizedTransactionSet) XdrUnionTagName() string {
	return "V"
}
func (u *GeneralizedTransactionSet) XdrUnionBody() XdrType {
	switch u.V {
	case 1:
		return XDR_TransactionSetV1(u.V1TxSet())
	}
	return nil
}
func (u *GeneralizedTransactionSet) XdrUnionBodyName() string {
	switch u.V {
	case 1:
		return "V1TxSet"
	}
	return ""
}

type XdrType_GeneralizedTransactionSet = *GeneralizedTransactionSet

func (v *GeneralizedTransactionSet) XdrPointer() interface{}       { return v }
func (GeneralizedTransactionSet) XdrTypeName() string              { return "GeneralizedTransactionSet" }
func (v GeneralizedTransactionSet) XdrValue() interface{}          { return v }
func (v *GeneralizedTransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *GeneralizedTransactionSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 1:
		x.Marshal(x.Sprintf("%sv1TxSet", name), XDR_TransactionSetV1(u.V1TxSet()))
		return
	}
	XdrPanic("invalid V (%v) in GeneralizedTransactionSet", u.V)
}
func (v *GeneralizedTransactionSet) XdrInitialize() {
	var zero int32
	switch zero {
	case 1:
	default:
		if v.V == zero {
			v.V = 1
		}
	}
}
func XDR_GeneralizedTransactionSet(v *GeneralizedTransactionSet) *GeneralizedTransactionSet { return v }

type XdrType_TransactionResultPair = *TransactionResultPair

func (v *TransactionResultPair) XdrPointer() interface{}       { return v }
func (TransactionResultPair) XdrTypeName() string              { return "TransactionResultPair" }
func (v TransactionResultPair) XdrValue() interface{}          { return v }
func (v *TransactionResultPair) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultPair) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stransactionHash", name), XDR_Hash(&v.TransactionHash))
	x.Marshal(x.Sprintf("%sresult", name), XDR_TransactionResult(&v.Result))
}
func XDR_TransactionResultPair(v *TransactionResultPair) *TransactionResultPair { return v }

type _XdrVec_unbounded_TransactionResultPair []TransactionResultPair

func (_XdrVec_unbounded_TransactionResultPair) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionResultPair) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionResultPair length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionResultPair length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionResultPair) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionResultPair) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionResultPair, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionResultPair(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionResultPair) XdrTypeName() string { return "TransactionResultPair<>" }
func (v *_XdrVec_unbounded_TransactionResultPair) XdrPointer() interface{} {
	return (*[]TransactionResultPair)(v)
}
func (v _XdrVec_unbounded_TransactionResultPair) XdrValue() interface{} {
	return ([]TransactionResultPair)(v)
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionResultSet = *TransactionResultSet

func (v *TransactionResultSet) XdrPointer() interface{}       { return v }
func (TransactionResultSet) XdrTypeName() string              { return "TransactionResultSet" }
func (v TransactionResultSet) XdrValue() interface{}          { return v }
func (v *TransactionResultSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_TransactionResultPair)(&v.Results))
}
func XDR_TransactionResultSet(v *TransactionResultSet) *TransactionResultSet { return v }

var _XdrTags_XdrAnon_TransactionHistoryEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_TransactionHistoryEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionHistoryEntry_Ext
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) GeneralizedTxSet() *GeneralizedTransactionSet {
	switch u.V {
	case 1:
		if v, ok := u._u.(*GeneralizedTransactionSet); ok {
			return v
		} else {
			var zero GeneralizedTransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionHistoryEntry_Ext.GeneralizedTxSet accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_TransactionHistoryEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_GeneralizedTransactionSet(u.GeneralizedTxSet())
	}
	return nil
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "GeneralizedTxSet"
	}
	return ""
}

type XdrType_XdrAnon_TransactionHistoryEntry_Ext = *XdrAnon_TransactionHistoryEntry_Ext

func (v *XdrAnon_TransactionHistoryEntry_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionHistoryEntry_Ext) XdrTypeName() string {
	return "XdrAnon_TransactionHistoryEntry_Ext"
}
func (v XdrAnon_TransactionHistoryEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TransactionHistoryEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sgeneralizedTxSet", name), XDR_GeneralizedTransactionSet(u.GeneralizedTxSet()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionHistoryEntry_Ext", u.V)
}
func XDR_XdrAnon_TransactionHistoryEntry_Ext(v *XdrAnon_TransactionHistoryEntry_Ext) *XdrAnon_TransactionHistoryEntry_Ext {
	return v
}

type XdrType_TransactionHistoryEntry = *TransactionHistoryEntry

func (v *TransactionHistoryEntry) XdrPointer() interface{}       { return v }
func (TransactionHistoryEntry) XdrTypeName() string              { return "TransactionHistoryEntry" }
func (v TransactionHistoryEntry) XdrValue() interface{}          { return v }
func (v *TransactionHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%stxSet", name), XDR_TransactionSet(&v.TxSet))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionHistoryEntry_Ext(&v.Ext))
}
func XDR_TransactionHistoryEntry(v *TransactionHistoryEntry) *TransactionHistoryEntry { return v }

var _XdrTags_XdrAnon_TransactionHistoryResultEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TransactionHistoryResultEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionHistoryResultEntry_Ext
}
func (u XdrAnon_TransactionHistoryResultEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionHistoryResultEntry_Ext = *XdrAnon_TransactionHistoryResultEntry_Ext

func (v *XdrAnon_TransactionHistoryResultEntry_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionHistoryResultEntry_Ext) XdrTypeName() string {
	return "XdrAnon_TransactionHistoryResultEntry_Ext"
}
func (v XdrAnon_TransactionHistoryResultEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionHistoryResultEntry_Ext) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionHistoryResultEntry_Ext", u.V)
}
func XDR_XdrAnon_TransactionHistoryResultEntry_Ext(v *XdrAnon_TransactionHistoryResultEntry_Ext) *XdrAnon_TransactionHistoryResultEntry_Ext {
	return v
}

type XdrType_TransactionHistoryResultEntry = *TransactionHistoryResultEntry

func (v *TransactionHistoryResultEntry) XdrPointer() interface{}       { return v }
func (TransactionHistoryResultEntry) XdrTypeName() string              { return "TransactionHistoryResultEntry" }
func (v TransactionHistoryResultEntry) XdrValue() interface{}          { return v }
func (v *TransactionHistoryResultEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionHistoryResultEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%stxResultSet", name), XDR_TransactionResultSet(&v.TxResultSet))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionHistoryResultEntry_Ext(&v.Ext))
}
func XDR_TransactionHistoryResultEntry(v *TransactionHistoryResultEntry) *TransactionHistoryResultEntry {
	return v
}

var _XdrTags_XdrAnon_LedgerHeaderHistoryEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerHeaderHistoryEntry_Ext
}
func (u XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_LedgerHeaderHistoryEntry_Ext = *XdrAnon_LedgerHeaderHistoryEntry_Ext

func (v *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrTypeName() string {
	return "XdrAnon_LedgerHeaderHistoryEntry_Ext"
}
func (v XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerHeaderHistoryEntry_Ext", u.V)
}
func XDR_XdrAnon_LedgerHeaderHistoryEntry_Ext(v *XdrAnon_LedgerHeaderHistoryEntry_Ext) *XdrAnon_LedgerHeaderHistoryEntry_Ext {
	return v
}

type XdrType_LedgerHeaderHistoryEntry = *LedgerHeaderHistoryEntry

func (v *LedgerHeaderHistoryEntry) XdrPointer() interface{}       { return v }
func (LedgerHeaderHistoryEntry) XdrTypeName() string              { return "LedgerHeaderHistoryEntry" }
func (v LedgerHeaderHistoryEntry) XdrValue() interface{}          { return v }
func (v *LedgerHeaderHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeaderHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shash", name), XDR_Hash(&v.Hash))
	x.Marshal(x.Sprintf("%sheader", name), XDR_LedgerHeader(&v.Header))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerHeaderHistoryEntry_Ext(&v.Ext))
}
func XDR_LedgerHeaderHistoryEntry(v *LedgerHeaderHistoryEntry) *LedgerHeaderHistoryEntry { return v }

type _XdrVec_unbounded_SCPEnvelope []SCPEnvelope

func (_XdrVec_unbounded_SCPEnvelope) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCPEnvelope) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCPEnvelope length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCPEnvelope length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCPEnvelope) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCPEnvelope) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPEnvelope, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCPEnvelope) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCPEnvelope(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCPEnvelope) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SCPEnvelope) XdrTypeName() string              { return "SCPEnvelope<>" }
func (v *_XdrVec_unbounded_SCPEnvelope) XdrPointer() interface{}       { return (*[]SCPEnvelope)(v) }
func (v _XdrVec_unbounded_SCPEnvelope) XdrValue() interface{}          { return ([]SCPEnvelope)(v) }
func (v *_XdrVec_unbounded_SCPEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerSCPMessages = *LedgerSCPMessages

func (v *LedgerSCPMessages) XdrPointer() interface{}       { return v }
func (LedgerSCPMessages) XdrTypeName() string              { return "LedgerSCPMessages" }
func (v LedgerSCPMessages) XdrValue() interface{}          { return v }
func (v *LedgerSCPMessages) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerSCPMessages) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%smessages", name), (*_XdrVec_unbounded_SCPEnvelope)(&v.Messages))
}
func XDR_LedgerSCPMessages(v *LedgerSCPMessages) *LedgerSCPMessages { return v }

type XdrType_SCPHistoryEntryV0 = *SCPHistoryEntryV0

func (v *SCPHistoryEntryV0) XdrPointer() interface{}       { return v }
func (SCPHistoryEntryV0) XdrTypeName() string              { return "SCPHistoryEntryV0" }
func (v SCPHistoryEntryV0) XdrValue() interface{}          { return v }
func (v *SCPHistoryEntryV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPHistoryEntryV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%squorumSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.QuorumSets))
	x.Marshal(x.Sprintf("%sledgerMessages", name), XDR_LedgerSCPMessages(&v.LedgerMessages))
}
func XDR_SCPHistoryEntryV0(v *SCPHistoryEntryV0) *SCPHistoryEntryV0 { return v }

var _XdrTags_SCPHistoryEntry = map[int32]bool{
	XdrToI32(0): true,
}

func (_ SCPHistoryEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_SCPHistoryEntry
}
func (u *SCPHistoryEntry) V0() *SCPHistoryEntryV0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*SCPHistoryEntryV0); ok {
			return v
		} else {
			var zero SCPHistoryEntryV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCPHistoryEntry.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u SCPHistoryEntry) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *SCPHistoryEntry) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *SCPHistoryEntry) XdrUnionTagName() string {
	return "V"
}
func (u *SCPHistoryEntry) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_SCPHistoryEntryV0(u.V0())
	}
	return nil
}
func (u *SCPHistoryEntry) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}

type XdrType_SCPHistoryEntry = *SCPHistoryEntry

func (v *SCPHistoryEntry) XdrPointer() interface{}       { return v }
func (SCPHistoryEntry) XdrTypeName() string              { return "SCPHistoryEntry" }
func (v SCPHistoryEntry) XdrValue() interface{}          { return v }
func (v *SCPHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCPHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_SCPHistoryEntryV0(u.V0()))
		return
	}
	XdrPanic("invalid V (%v) in SCPHistoryEntry", u.V)
}
func XDR_SCPHistoryEntry(v *SCPHistoryEntry) *SCPHistoryEntry { return v }

var _XdrNames_LedgerEntryChangeType = map[int32]string{
	int32(LEDGER_ENTRY_CREATED): "LEDGER_ENTRY_CREATED",
	int32(LEDGER_ENTRY_UPDATED): "LEDGER_ENTRY_UPDATED",
	int32(LEDGER_ENTRY_REMOVED): "LEDGER_ENTRY_REMOVED",
	int32(LEDGER_ENTRY_STATE):   "LEDGER_ENTRY_STATE",
}
var _XdrValues_LedgerEntryChangeType = map[string]int32{
	"LEDGER_ENTRY_CREATED": int32(LEDGER_ENTRY_CREATED),
	"LEDGER_ENTRY_UPDATED": int32(LEDGER_ENTRY_UPDATED),
	"LEDGER_ENTRY_REMOVED": int32(LEDGER_ENTRY_REMOVED),
	"LEDGER_ENTRY_STATE":   int32(LEDGER_ENTRY_STATE),
}

func (LedgerEntryChangeType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerEntryChangeType
}
func (v LedgerEntryChangeType) String() string {
	if s, ok := _XdrNames_LedgerEntryChangeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerEntryChangeType#%d", v)
}
func (v *LedgerEntryChangeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerEntryChangeType[stok]; ok {
			*v = LedgerEntryChangeType(val)
			return nil
		} else if stok == "LedgerEntryChangeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerEntryChangeType.", stok))
	}
}
func (v LedgerEntryChangeType) GetU32() uint32                 { return uint32(v) }
func (v *LedgerEntryChangeType) SetU32(n uint32)               { *v = LedgerEntryChangeType(n) }
func (v *LedgerEntryChangeType) XdrPointer() interface{}       { return v }
func (LedgerEntryChangeType) XdrTypeName() string              { return "LedgerEntryChangeType" }
func (v LedgerEntryChangeType) XdrValue() interface{}          { return v }
func (v *LedgerEntryChangeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerEntryChangeType = *LedgerEntryChangeType

func XDR_LedgerEntryChangeType(v *LedgerEntryChangeType) *LedgerEntryChangeType { return v }

var _XdrComments_LedgerEntryChangeType = map[int32]string{
	int32(LEDGER_ENTRY_CREATED): "entry was added to the ledger",
	int32(LEDGER_ENTRY_UPDATED): "entry was modified in the ledger",
	int32(LEDGER_ENTRY_REMOVED): "entry was removed from the ledger",
	int32(LEDGER_ENTRY_STATE):   "value of the entry",
}

func (e LedgerEntryChangeType) XdrEnumComments() map[int32]string {
	return _XdrComments_LedgerEntryChangeType
}

var _XdrTags_LedgerEntryChange = map[int32]bool{
	XdrToI32(LEDGER_ENTRY_CREATED): true,
	XdrToI32(LEDGER_ENTRY_UPDATED): true,
	XdrToI32(LEDGER_ENTRY_REMOVED): true,
	XdrToI32(LEDGER_ENTRY_STATE):   true,
}

func (_ LedgerEntryChange) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerEntryChange
}
func (u *LedgerEntryChange) Created() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Created accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) Updated() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_UPDATED:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Updated accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) Removed() *LedgerKey {
	switch u.Type {
	case LEDGER_ENTRY_REMOVED:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Removed accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) State() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_STATE:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.State accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerEntryChange) XdrValid() bool {
	switch u.Type {
	case LEDGER_ENTRY_CREATED, LEDGER_ENTRY_UPDATED, LEDGER_ENTRY_REMOVED, LEDGER_ENTRY_STATE:
		return true
	}
	return false
}
func (u *LedgerEntryChange) XdrUnionTag() XdrNum32 {
	return XDR_LedgerEntryChangeType(&u.Type)
}
func (u *LedgerEntryChange) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerEntryChange) XdrUnionBody() XdrType {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		return XDR_LedgerEntry(u.Created())
	case LEDGER_ENTRY_UPDATED:
		return XDR_LedgerEntry(u.Updated())
	case LEDGER_ENTRY_REMOVED:
		return XDR_LedgerKey(u.Removed())
	case LEDGER_ENTRY_STATE:
		return XDR_LedgerEntry(u.State())
	}
	return nil
}
func (u *LedgerEntryChange) XdrUnionBodyName() string {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		return "Created"
	case LEDGER_ENTRY_UPDATED:
		return "Updated"
	case LEDGER_ENTRY_REMOVED:
		return "Removed"
	case LEDGER_ENTRY_STATE:
		return "State"
	}
	return ""
}

type XdrType_LedgerEntryChange = *LedgerEntryChange

func (v *LedgerEntryChange) XdrPointer() interface{}       { return v }
func (LedgerEntryChange) XdrTypeName() string              { return "LedgerEntryChange" }
func (v LedgerEntryChange) XdrValue() interface{}          { return v }
func (v *LedgerEntryChange) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerEntryChange) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChangeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		x.Marshal(x.Sprintf("%screated", name), XDR_LedgerEntry(u.Created()))
		return
	case LEDGER_ENTRY_UPDATED:
		x.Marshal(x.Sprintf("%supdated", name), XDR_LedgerEntry(u.Updated()))
		return
	case LEDGER_ENTRY_REMOVED:
		x.Marshal(x.Sprintf("%sremoved", name), XDR_LedgerKey(u.Removed()))
		return
	case LEDGER_ENTRY_STATE:
		x.Marshal(x.Sprintf("%sstate", name), XDR_LedgerEntry(u.State()))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerEntryChange", u.Type)
}
func XDR_LedgerEntryChange(v *LedgerEntryChange) *LedgerEntryChange { return v }

type _XdrVec_unbounded_LedgerEntryChange []LedgerEntryChange

func (_XdrVec_unbounded_LedgerEntryChange) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_LedgerEntryChange) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_LedgerEntryChange length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_LedgerEntryChange length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_LedgerEntryChange) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_LedgerEntryChange) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]LedgerEntryChange, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_LedgerEntryChange(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_LedgerEntryChange) XdrTypeName() string { return "LedgerEntryChange<>" }
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrPointer() interface{} {
	return (*[]LedgerEntryChange)(v)
}
func (v _XdrVec_unbounded_LedgerEntryChange) XdrValue() interface{}          { return ([]LedgerEntryChange)(v) }
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerEntryChanges struct {
	*_XdrVec_unbounded_LedgerEntryChange
}

func XDR_LedgerEntryChanges(v *LedgerEntryChanges) XdrType_LedgerEntryChanges {
	return XdrType_LedgerEntryChanges{(*_XdrVec_unbounded_LedgerEntryChange)(v)}
}
func (XdrType_LedgerEntryChanges) XdrTypeName() string  { return "LedgerEntryChanges" }
func (v XdrType_LedgerEntryChanges) XdrUnwrap() XdrType { return v._XdrVec_unbounded_LedgerEntryChange }

type XdrType_OperationMeta = *OperationMeta

func (v *OperationMeta) XdrPointer() interface{}       { return v }
func (OperationMeta) XdrTypeName() string              { return "OperationMeta" }
func (v OperationMeta) XdrValue() interface{}          { return v }
func (v *OperationMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OperationMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%schanges", name), XDR_LedgerEntryChanges(&v.Changes))
}
func XDR_OperationMeta(v *OperationMeta) *OperationMeta { return v }

type _XdrVec_unbounded_OperationMeta []OperationMeta

func (_XdrVec_unbounded_OperationMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_OperationMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_OperationMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_OperationMeta length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_OperationMeta) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_OperationMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]OperationMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_OperationMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_OperationMeta(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_OperationMeta) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_OperationMeta) XdrTypeName() string              { return "OperationMeta<>" }
func (v *_XdrVec_unbounded_OperationMeta) XdrPointer() interface{}       { return (*[]OperationMeta)(v) }
func (v _XdrVec_unbounded_OperationMeta) XdrValue() interface{}          { return ([]OperationMeta)(v) }
func (v *_XdrVec_unbounded_OperationMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionMetaV1 = *TransactionMetaV1

func (v *TransactionMetaV1) XdrPointer() interface{}       { return v }
func (TransactionMetaV1) XdrTypeName() string              { return "TransactionMetaV1" }
func (v TransactionMetaV1) XdrValue() interface{}          { return v }
func (v *TransactionMetaV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxChanges", name), XDR_LedgerEntryChanges(&v.TxChanges))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(&v.Operations))
}
func XDR_TransactionMetaV1(v *TransactionMetaV1) *TransactionMetaV1 { return v }

type XdrType_TransactionMetaV2 = *TransactionMetaV2

func (v *TransactionMetaV2) XdrPointer() interface{}       { return v }
func (TransactionMetaV2) XdrTypeName() string              { return "TransactionMetaV2" }
func (v TransactionMetaV2) XdrValue() interface{}          { return v }
func (v *TransactionMetaV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxChangesBefore", name), XDR_LedgerEntryChanges(&v.TxChangesBefore))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(&v.Operations))
	x.Marshal(x.Sprintf("%stxChangesAfter", name), XDR_LedgerEntryChanges(&v.TxChangesAfter))
}
func XDR_TransactionMetaV2(v *TransactionMetaV2) *TransactionMetaV2 { return v }

var _XdrNames_ContractEventType = map[int32]string{
	int32(SYSTEM):     "SYSTEM",
	int32(CONTRACT):   "CONTRACT",
	int32(DIAGNOSTIC): "DIAGNOSTIC",
}
var _XdrValues_ContractEventType = map[string]int32{
	"SYSTEM":     int32(SYSTEM),
	"CONTRACT":   int32(CONTRACT),
	"DIAGNOSTIC": int32(DIAGNOSTIC),
}

func (ContractEventType) XdrEnumNames() map[int32]string {
	return _XdrNames_ContractEventType
}
func (v ContractEventType) String() string {
	if s, ok := _XdrNames_ContractEventType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ContractEventType#%d", v)
}
func (v *ContractEventType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ContractEventType[stok]; ok {
			*v = ContractEventType(val)
			return nil
		} else if stok == "ContractEventType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ContractEventType.", stok))
	}
}
func (v ContractEventType) GetU32() uint32                 { return uint32(v) }
func (v *ContractEventType) SetU32(n uint32)               { *v = ContractEventType(n) }
func (v *ContractEventType) XdrPointer() interface{}       { return v }
func (ContractEventType) XdrTypeName() string              { return "ContractEventType" }
func (v ContractEventType) XdrValue() interface{}          { return v }
func (v *ContractEventType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ContractEventType = *ContractEventType

func XDR_ContractEventType(v *ContractEventType) *ContractEventType { return v }

type _XdrVec_unbounded_SCVal []SCVal

func (_XdrVec_unbounded_SCVal) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCVal) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCVal length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCVal length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCVal) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCVal) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCVal, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCVal) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCVal(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCVal) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SCVal) XdrTypeName() string              { return "SCVal<>" }
func (v *_XdrVec_unbounded_SCVal) XdrPointer() interface{}       { return (*[]SCVal)(v) }
func (v _XdrVec_unbounded_SCVal) XdrValue() interface{}          { return ([]SCVal)(v) }
func (v *_XdrVec_unbounded_SCVal) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_XdrAnon_ContractEvent_Body_V0 = *XdrAnon_ContractEvent_Body_V0

func (v *XdrAnon_ContractEvent_Body_V0) XdrPointer() interface{}       { return v }
func (XdrAnon_ContractEvent_Body_V0) XdrTypeName() string              { return "XdrAnon_ContractEvent_Body_V0" }
func (v XdrAnon_ContractEvent_Body_V0) XdrValue() interface{}          { return v }
func (v *XdrAnon_ContractEvent_Body_V0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_ContractEvent_Body_V0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stopics", name), (*_XdrVec_unbounded_SCVal)(&v.Topics))
	x.Marshal(x.Sprintf("%sdata", name), XDR_SCVal(&v.Data))
}
func XDR_XdrAnon_ContractEvent_Body_V0(v *XdrAnon_ContractEvent_Body_V0) *XdrAnon_ContractEvent_Body_V0 {
	return v
}

var _XdrTags_XdrAnon_ContractEvent_Body = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_ContractEvent_Body) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ContractEvent_Body
}
func (u *XdrAnon_ContractEvent_Body) V0() *XdrAnon_ContractEvent_Body_V0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*XdrAnon_ContractEvent_Body_V0); ok {
			return v
		} else {
			var zero XdrAnon_ContractEvent_Body_V0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_ContractEvent_Body.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_ContractEvent_Body) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_ContractEvent_Body) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_ContractEvent_Body) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_ContractEvent_Body) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_XdrAnon_ContractEvent_Body_V0(u.V0())
	}
	return nil
}
func (u *XdrAnon_ContractEvent_Body) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}

type XdrType_XdrAnon_ContractEvent_Body = *XdrAnon_ContractEvent_Body

func (v *XdrAnon_ContractEvent_Body) XdrPointer() interface{}       { return v }
func (XdrAnon_ContractEvent_Body) XdrTypeName() string              { return "XdrAnon_ContractEvent_Body" }
func (v XdrAnon_ContractEvent_Body) XdrValue() interface{}          { return v }
func (v *XdrAnon_ContractEvent_Body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ContractEvent_Body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_XdrAnon_ContractEvent_Body_V0(u.V0()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_ContractEvent_Body", u.V)
}
func XDR_XdrAnon_ContractEvent_Body(v *XdrAnon_ContractEvent_Body) *XdrAnon_ContractEvent_Body {
	return v
}

type _XdrPtr_Hash struct {
	p **Hash
}
type _ptrflag_Hash _XdrPtr_Hash

func (v _ptrflag_Hash) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Hash) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Hash flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Hash) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Hash) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Hash)
		}
	default:
		XdrPanic("*Hash present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Hash) XdrTypeName() string             { return "Hash?" }
func (v _ptrflag_Hash) XdrPointer() interface{}       { return nil }
func (v _ptrflag_Hash) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Hash) XdrBound() uint32              { return 1 }
func (v _XdrPtr_Hash) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_Hash) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Hash)
	}
}
func (v _XdrPtr_Hash) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Hash(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Hash) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Hash(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Hash) XdrTypeName() string       { return "Hash*" }
func (v _XdrPtr_Hash) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Hash) XdrValue() interface{}   { return *v.p }

type XdrType_ContractEvent = *ContractEvent

func (v *ContractEvent) XdrPointer() interface{}       { return v }
func (ContractEvent) XdrTypeName() string              { return "ContractEvent" }
func (v ContractEvent) XdrValue() interface{}          { return v }
func (v *ContractEvent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ContractEvent) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%scontractID", name), _XdrPtr_Hash{&v.ContractID})
	x.Marshal(x.Sprintf("%stype", name), XDR_ContractEventType(&v.Type))
	x.Marshal(x.Sprintf("%sbody", name), XDR_XdrAnon_ContractEvent_Body(&v.Body))
}
func XDR_ContractEvent(v *ContractEvent) *ContractEvent { return v }

type XdrType_DiagnosticEvent = *DiagnosticEvent

func (v *DiagnosticEvent) XdrPointer() interface{}       { return v }
func (DiagnosticEvent) XdrTypeName() string              { return "DiagnosticEvent" }
func (v DiagnosticEvent) XdrValue() interface{}          { return v }
func (v *DiagnosticEvent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DiagnosticEvent) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sinSuccessfulContractCall", name), XDR_bool(&v.InSuccessfulContractCall))
	x.Marshal(x.Sprintf("%sevent", name), XDR_ContractEvent(&v.Event))
}
func XDR_DiagnosticEvent(v *DiagnosticEvent) *DiagnosticEvent { return v }

type XdrType_SorobanTransactionMetaExtV1 = *SorobanTransactionMetaExtV1

func (v *SorobanTransactionMetaExtV1) XdrPointer() interface{}       { return v }
func (SorobanTransactionMetaExtV1) XdrTypeName() string              { return "SorobanTransactionMetaExtV1" }
func (v SorobanTransactionMetaExtV1) XdrValue() interface{}          { return v }
func (v *SorobanTransactionMetaExtV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SorobanTransactionMetaExtV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%stotalNonRefundableResourceFeeCharged", name), XDR_Int64(&v.TotalNonRefundableResourceFeeCharged))
	x.Marshal(x.Sprintf("%stotalRefundableResourceFeeCharged", name), XDR_Int64(&v.TotalRefundableResourceFeeCharged))
	x.Marshal(x.Sprintf("%srentFeeCharged", name), XDR_Int64(&v.RentFeeCharged))
}
func XDR_SorobanTransactionMetaExtV1(v *SorobanTransactionMetaExtV1) *SorobanTransactionMetaExtV1 {
	return v
}

var _XdrTags_SorobanTransactionMetaExt = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ SorobanTransactionMetaExt) XdrValidTags() map[int32]bool {
	return _XdrTags_SorobanTransactionMetaExt
}
func (u *SorobanTransactionMetaExt) V1() *SorobanTransactionMetaExtV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*SorobanTransactionMetaExtV1); ok {
			return v
		} else {
			var zero SorobanTransactionMetaExtV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SorobanTransactionMetaExt.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u SorobanTransactionMetaExt) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *SorobanTransactionMetaExt) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *SorobanTransactionMetaExt) XdrUnionTagName() string {
	return "V"
}
func (u *SorobanTransactionMetaExt) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_SorobanTransactionMetaExtV1(u.V1())
	}
	return nil
}
func (u *SorobanTransactionMetaExt) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_SorobanTransactionMetaExt = *SorobanTransactionMetaExt

func (v *SorobanTransactionMetaExt) XdrPointer() interface{}       { return v }
func (SorobanTransactionMetaExt) XdrTypeName() string              { return "SorobanTransactionMetaExt" }
func (v SorobanTransactionMetaExt) XdrValue() interface{}          { return v }
func (v *SorobanTransactionMetaExt) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SorobanTransactionMetaExt) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_SorobanTransactionMetaExtV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in SorobanTransactionMetaExt", u.V)
}
func XDR_SorobanTransactionMetaExt(v *SorobanTransactionMetaExt) *SorobanTransactionMetaExt { return v }

type _XdrVec_unbounded_ContractEvent []ContractEvent

func (_XdrVec_unbounded_ContractEvent) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_ContractEvent) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_ContractEvent length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_ContractEvent length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_ContractEvent) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_ContractEvent) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ContractEvent, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_ContractEvent) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_ContractEvent(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_ContractEvent) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_ContractEvent) XdrTypeName() string              { return "ContractEvent<>" }
func (v *_XdrVec_unbounded_ContractEvent) XdrPointer() interface{}       { return (*[]ContractEvent)(v) }
func (v _XdrVec_unbounded_ContractEvent) XdrValue() interface{}          { return ([]ContractEvent)(v) }
func (v *_XdrVec_unbounded_ContractEvent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_unbounded_DiagnosticEvent []DiagnosticEvent

func (_XdrVec_unbounded_DiagnosticEvent) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_DiagnosticEvent) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_DiagnosticEvent length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_DiagnosticEvent length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_DiagnosticEvent) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_DiagnosticEvent) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]DiagnosticEvent, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_DiagnosticEvent) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_DiagnosticEvent(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_DiagnosticEvent) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_DiagnosticEvent) XdrTypeName() string              { return "DiagnosticEvent<>" }
func (v *_XdrVec_unbounded_DiagnosticEvent) XdrPointer() interface{}       { return (*[]DiagnosticEvent)(v) }
func (v _XdrVec_unbounded_DiagnosticEvent) XdrValue() interface{}          { return ([]DiagnosticEvent)(v) }
func (v *_XdrVec_unbounded_DiagnosticEvent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SorobanTransactionMeta = *SorobanTransactionMeta

func (v *SorobanTransactionMeta) XdrPointer() interface{}       { return v }
func (SorobanTransactionMeta) XdrTypeName() string              { return "SorobanTransactionMeta" }
func (v SorobanTransactionMeta) XdrValue() interface{}          { return v }
func (v *SorobanTransactionMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SorobanTransactionMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_SorobanTransactionMetaExt(&v.Ext))
	x.Marshal(x.Sprintf("%sevents", name), (*_XdrVec_unbounded_ContractEvent)(&v.Events))
	x.Marshal(x.Sprintf("%sreturnValue", name), XDR_SCVal(&v.ReturnValue))
	x.Marshal(x.Sprintf("%sdiagnosticEvents", name), (*_XdrVec_unbounded_DiagnosticEvent)(&v.DiagnosticEvents))
}
func XDR_SorobanTransactionMeta(v *SorobanTransactionMeta) *SorobanTransactionMeta { return v }

type _XdrPtr_SorobanTransactionMeta struct {
	p **SorobanTransactionMeta
}
type _ptrflag_SorobanTransactionMeta _XdrPtr_SorobanTransactionMeta

func (v _ptrflag_SorobanTransactionMeta) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SorobanTransactionMeta) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SorobanTransactionMeta flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SorobanTransactionMeta) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SorobanTransactionMeta) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SorobanTransactionMeta)
		}
	default:
		XdrPanic("*SorobanTransactionMeta present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SorobanTransactionMeta) XdrTypeName() string             { return "SorobanTransactionMeta?" }
func (v _ptrflag_SorobanTransactionMeta) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SorobanTransactionMeta) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SorobanTransactionMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SorobanTransactionMeta) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SorobanTransactionMeta) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SorobanTransactionMeta) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SorobanTransactionMeta)
	}
}
func (v _XdrPtr_SorobanTransactionMeta) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SorobanTransactionMeta(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SorobanTransactionMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SorobanTransactionMeta) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SorobanTransactionMeta(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SorobanTransactionMeta) XdrTypeName() string       { return "SorobanTransactionMeta*" }
func (v _XdrPtr_SorobanTransactionMeta) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SorobanTransactionMeta) XdrValue() interface{}   { return *v.p }

type XdrType_TransactionMetaV3 = *TransactionMetaV3

func (v *TransactionMetaV3) XdrPointer() interface{}       { return v }
func (TransactionMetaV3) XdrTypeName() string              { return "TransactionMetaV3" }
func (v TransactionMetaV3) XdrValue() interface{}          { return v }
func (v *TransactionMetaV3) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV3) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%stxChangesBefore", name), XDR_LedgerEntryChanges(&v.TxChangesBefore))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(&v.Operations))
	x.Marshal(x.Sprintf("%stxChangesAfter", name), XDR_LedgerEntryChanges(&v.TxChangesAfter))
	x.Marshal(x.Sprintf("%ssorobanMeta", name), _XdrPtr_SorobanTransactionMeta{&v.SorobanMeta})
}
func XDR_TransactionMetaV3(v *TransactionMetaV3) *TransactionMetaV3 { return v }

type XdrType_InvokeHostFunctionSuccessPreImage = *InvokeHostFunctionSuccessPreImage

func (v *InvokeHostFunctionSuccessPreImage) XdrPointer() interface{} { return v }
func (InvokeHostFunctionSuccessPreImage) XdrTypeName() string {
	return "InvokeHostFunctionSuccessPreImage"
}
func (v InvokeHostFunctionSuccessPreImage) XdrValue() interface{}          { return v }
func (v *InvokeHostFunctionSuccessPreImage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InvokeHostFunctionSuccessPreImage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sreturnValue", name), XDR_SCVal(&v.ReturnValue))
	x.Marshal(x.Sprintf("%sevents", name), (*_XdrVec_unbounded_ContractEvent)(&v.Events))
}
func XDR_InvokeHostFunctionSuccessPreImage(v *InvokeHostFunctionSuccessPreImage) *InvokeHostFunctionSuccessPreImage {
	return v
}

var _XdrTags_TransactionMeta = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
	XdrToI32(2): true,
	XdrToI32(3): true,
}

func (_ TransactionMeta) XdrValidTags() map[int32]bool {
	return _XdrTags_TransactionMeta
}
func (u *TransactionMeta) Operations() *[]OperationMeta {
	switch u.V {
	case 0:
		if v, ok := u._u.(*[]OperationMeta); ok {
			return v
		} else {
			var zero []OperationMeta
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.Operations accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V1() *TransactionMetaV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*TransactionMetaV1); ok {
			return v
		} else {
			var zero TransactionMetaV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V2() *TransactionMetaV2 {
	switch u.V {
	case 2:
		if v, ok := u._u.(*TransactionMetaV2); ok {
			return v
		} else {
			var zero TransactionMetaV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.V2 accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V3() *TransactionMetaV3 {
	switch u.V {
	case 3:
		if v, ok := u._u.(*TransactionMetaV3); ok {
			return v
		} else {
			var zero TransactionMetaV3
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.V3 accessed when V == %v", u.V)
		return nil
	}
}
func (u TransactionMeta) XdrValid() bool {
	switch u.V {
	case 0, 1, 2, 3:
		return true
	}
	return false
}
func (u *TransactionMeta) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *TransactionMeta) XdrUnionTagName() string {
	return "V"
}
func (u *TransactionMeta) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return (*_XdrVec_unbounded_OperationMeta)(u.Operations())
	case 1:
		return XDR_TransactionMetaV1(u.V1())
	case 2:
		return XDR_TransactionMetaV2(u.V2())
	case 3:
		return XDR_TransactionMetaV3(u.V3())
	}
	return nil
}
func (u *TransactionMeta) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "Operations"
	case 1:
		return "V1"
	case 2:
		return "V2"
	case 3:
		return "V3"
	}
	return ""
}

type XdrType_TransactionMeta = *TransactionMeta

func (v *TransactionMeta) XdrPointer() interface{}       { return v }
func (TransactionMeta) XdrTypeName() string              { return "TransactionMeta" }
func (v TransactionMeta) XdrValue() interface{}          { return v }
func (v *TransactionMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TransactionMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(u.Operations()))
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_TransactionMetaV1(u.V1()))
		return
	case 2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_TransactionMetaV2(u.V2()))
		return
	case 3:
		x.Marshal(x.Sprintf("%sv3", name), XDR_TransactionMetaV3(u.V3()))
		return
	}
	XdrPanic("invalid V (%v) in TransactionMeta", u.V)
}
func XDR_TransactionMeta(v *TransactionMeta) *TransactionMeta { return v }

type XdrType_TransactionResultMeta = *TransactionResultMeta

func (v *TransactionResultMeta) XdrPointer() interface{}       { return v }
func (TransactionResultMeta) XdrTypeName() string              { return "TransactionResultMeta" }
func (v TransactionResultMeta) XdrValue() interface{}          { return v }
func (v *TransactionResultMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresult", name), XDR_TransactionResultPair(&v.Result))
	x.Marshal(x.Sprintf("%sfeeProcessing", name), XDR_LedgerEntryChanges(&v.FeeProcessing))
	x.Marshal(x.Sprintf("%stxApplyProcessing", name), XDR_TransactionMeta(&v.TxApplyProcessing))
}
func XDR_TransactionResultMeta(v *TransactionResultMeta) *TransactionResultMeta { return v }

type XdrType_UpgradeEntryMeta = *UpgradeEntryMeta

func (v *UpgradeEntryMeta) XdrPointer() interface{}       { return v }
func (UpgradeEntryMeta) XdrTypeName() string              { return "UpgradeEntryMeta" }
func (v UpgradeEntryMeta) XdrValue() interface{}          { return v }
func (v *UpgradeEntryMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *UpgradeEntryMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%supgrade", name), XDR_LedgerUpgrade(&v.Upgrade))
	x.Marshal(x.Sprintf("%schanges", name), XDR_LedgerEntryChanges(&v.Changes))
}
func XDR_UpgradeEntryMeta(v *UpgradeEntryMeta) *UpgradeEntryMeta { return v }

type _XdrVec_unbounded_TransactionResultMeta []TransactionResultMeta

func (_XdrVec_unbounded_TransactionResultMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionResultMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionResultMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionResultMeta length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionResultMeta) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionResultMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionResultMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionResultMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionResultMeta(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionResultMeta) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionResultMeta) XdrTypeName() string { return "TransactionResultMeta<>" }
func (v *_XdrVec_unbounded_TransactionResultMeta) XdrPointer() interface{} {
	return (*[]TransactionResultMeta)(v)
}
func (v _XdrVec_unbounded_TransactionResultMeta) XdrValue() interface{} {
	return ([]TransactionResultMeta)(v)
}
func (v *_XdrVec_unbounded_TransactionResultMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_unbounded_UpgradeEntryMeta []UpgradeEntryMeta

func (_XdrVec_unbounded_UpgradeEntryMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_UpgradeEntryMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_UpgradeEntryMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_UpgradeEntryMeta length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_UpgradeEntryMeta) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_UpgradeEntryMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]UpgradeEntryMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_UpgradeEntryMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_UpgradeEntryMeta(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_UpgradeEntryMeta) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_UpgradeEntryMeta) XdrTypeName() string { return "UpgradeEntryMeta<>" }
func (v *_XdrVec_unbounded_UpgradeEntryMeta) XdrPointer() interface{} {
	return (*[]UpgradeEntryMeta)(v)
}
func (v _XdrVec_unbounded_UpgradeEntryMeta) XdrValue() interface{}          { return ([]UpgradeEntryMeta)(v) }
func (v *_XdrVec_unbounded_UpgradeEntryMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_unbounded_SCPHistoryEntry []SCPHistoryEntry

func (_XdrVec_unbounded_SCPHistoryEntry) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCPHistoryEntry) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCPHistoryEntry length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCPHistoryEntry length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCPHistoryEntry) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCPHistoryEntry) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPHistoryEntry, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCPHistoryEntry) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCPHistoryEntry(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCPHistoryEntry) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SCPHistoryEntry) XdrTypeName() string              { return "SCPHistoryEntry<>" }
func (v *_XdrVec_unbounded_SCPHistoryEntry) XdrPointer() interface{}       { return (*[]SCPHistoryEntry)(v) }
func (v _XdrVec_unbounded_SCPHistoryEntry) XdrValue() interface{}          { return ([]SCPHistoryEntry)(v) }
func (v *_XdrVec_unbounded_SCPHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerCloseMetaV0 = *LedgerCloseMetaV0

func (v *LedgerCloseMetaV0) XdrPointer() interface{}       { return v }
func (LedgerCloseMetaV0) XdrTypeName() string              { return "LedgerCloseMetaV0" }
func (v LedgerCloseMetaV0) XdrValue() interface{}          { return v }
func (v *LedgerCloseMetaV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseMetaV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerHeader", name), XDR_LedgerHeaderHistoryEntry(&v.LedgerHeader))
	x.Marshal(x.Sprintf("%stxSet", name), XDR_TransactionSet(&v.TxSet))
	x.Marshal(x.Sprintf("%stxProcessing", name), (*_XdrVec_unbounded_TransactionResultMeta)(&v.TxProcessing))
	x.Marshal(x.Sprintf("%supgradesProcessing", name), (*_XdrVec_unbounded_UpgradeEntryMeta)(&v.UpgradesProcessing))
	x.Marshal(x.Sprintf("%sscpInfo", name), (*_XdrVec_unbounded_SCPHistoryEntry)(&v.ScpInfo))
}
func XDR_LedgerCloseMetaV0(v *LedgerCloseMetaV0) *LedgerCloseMetaV0 { return v }

type XdrType_LedgerCloseMetaExtV1 = *LedgerCloseMetaExtV1

func (v *LedgerCloseMetaExtV1) XdrPointer() interface{}       { return v }
func (LedgerCloseMetaExtV1) XdrTypeName() string              { return "LedgerCloseMetaExtV1" }
func (v LedgerCloseMetaExtV1) XdrValue() interface{}          { return v }
func (v *LedgerCloseMetaExtV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseMetaExtV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%ssorobanFeeWrite1KB", name), XDR_Int64(&v.SorobanFeeWrite1KB))
}
func XDR_LedgerCloseMetaExtV1(v *LedgerCloseMetaExtV1) *LedgerCloseMetaExtV1 { return v }

var _XdrTags_LedgerCloseMetaExt = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ LedgerCloseMetaExt) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerCloseMetaExt
}
func (u *LedgerCloseMetaExt) V1() *LedgerCloseMetaExtV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*LedgerCloseMetaExtV1); ok {
			return v
		} else {
			var zero LedgerCloseMetaExtV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerCloseMetaExt.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u LedgerCloseMetaExt) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *LedgerCloseMetaExt) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *LedgerCloseMetaExt) XdrUnionTagName() string {
	return "V"
}
func (u *LedgerCloseMetaExt) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_LedgerCloseMetaExtV1(u.V1())
	}
	return nil
}
func (u *LedgerCloseMetaExt) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_LedgerCloseMetaExt = *LedgerCloseMetaExt

func (v *LedgerCloseMetaExt) XdrPointer() interface{}       { return v }
func (LedgerCloseMetaExt) XdrTypeName() string              { return "LedgerCloseMetaExt" }
func (v LedgerCloseMetaExt) XdrValue() interface{}          { return v }
func (v *LedgerCloseMetaExt) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerCloseMetaExt) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_LedgerCloseMetaExtV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in LedgerCloseMetaExt", u.V)
}
func XDR_LedgerCloseMetaExt(v *LedgerCloseMetaExt) *LedgerCloseMetaExt { return v }

type _XdrVec_unbounded_LedgerKey []LedgerKey

func (_XdrVec_unbounded_LedgerKey) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_LedgerKey) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_LedgerKey length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_LedgerKey length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_LedgerKey) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_LedgerKey) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]LedgerKey, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_LedgerKey) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_LedgerKey(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_LedgerKey) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_LedgerKey) XdrTypeName() string              { return "LedgerKey<>" }
func (v *_XdrVec_unbounded_LedgerKey) XdrPointer() interface{}       { return (*[]LedgerKey)(v) }
func (v _XdrVec_unbounded_LedgerKey) XdrValue() interface{}          { return ([]LedgerKey)(v) }
func (v *_XdrVec_unbounded_LedgerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_unbounded_LedgerEntry []LedgerEntry

func (_XdrVec_unbounded_LedgerEntry) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_LedgerEntry) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_LedgerEntry length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_LedgerEntry length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_LedgerEntry) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_LedgerEntry) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]LedgerEntry, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_LedgerEntry) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_LedgerEntry(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_LedgerEntry) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_LedgerEntry) XdrTypeName() string              { return "LedgerEntry<>" }
func (v *_XdrVec_unbounded_LedgerEntry) XdrPointer() interface{}       { return (*[]LedgerEntry)(v) }
func (v _XdrVec_unbounded_LedgerEntry) XdrValue() interface{}          { return ([]LedgerEntry)(v) }
func (v *_XdrVec_unbounded_LedgerEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerCloseMetaV1 = *LedgerCloseMetaV1

func (v *LedgerCloseMetaV1) XdrPointer() interface{}       { return v }
func (LedgerCloseMetaV1) XdrTypeName() string              { return "LedgerCloseMetaV1" }
func (v LedgerCloseMetaV1) XdrValue() interface{}          { return v }
func (v *LedgerCloseMetaV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseMetaV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_LedgerCloseMetaExt(&v.Ext))
	x.Marshal(x.Sprintf("%sledgerHeader", name), XDR_LedgerHeaderHistoryEntry(&v.LedgerHeader))
	x.Marshal(x.Sprintf("%stxSet", name), XDR_GeneralizedTransactionSet(&v.TxSet))
	x.Marshal(x.Sprintf("%stxProcessing", name), (*_XdrVec_unbounded_TransactionResultMeta)(&v.TxProcessing))
	x.Marshal(x.Sprintf("%supgradesProcessing", name), (*_XdrVec_unbounded_UpgradeEntryMeta)(&v.UpgradesProcessing))
	x.Marshal(x.Sprintf("%sscpInfo", name), (*_XdrVec_unbounded_SCPHistoryEntry)(&v.ScpInfo))
	x.Marshal(x.Sprintf("%stotalByteSizeOfBucketList", name), XDR_Uint64(&v.TotalByteSizeOfBucketList))
	x.Marshal(x.Sprintf("%sevictedTemporaryLedgerKeys", name), (*_XdrVec_unbounded_LedgerKey)(&v.EvictedTemporaryLedgerKeys))
	x.Marshal(x.Sprintf("%sevictedPersistentLedgerEntries", name), (*_XdrVec_unbounded_LedgerEntry)(&v.EvictedPersistentLedgerEntries))
}
func XDR_LedgerCloseMetaV1(v *LedgerCloseMetaV1) *LedgerCloseMetaV1 { return v }

var _XdrTags_LedgerCloseMeta = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ LedgerCloseMeta) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerCloseMeta
}
func (u *LedgerCloseMeta) V0() *LedgerCloseMetaV0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*LedgerCloseMetaV0); ok {
			return v
		} else {
			var zero LedgerCloseMetaV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerCloseMeta.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u *LedgerCloseMeta) V1() *LedgerCloseMetaV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*LedgerCloseMetaV1); ok {
			return v
		} else {
			var zero LedgerCloseMetaV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerCloseMeta.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u LedgerCloseMeta) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *LedgerCloseMeta) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *LedgerCloseMeta) XdrUnionTagName() string {
	return "V"
}
func (u *LedgerCloseMeta) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_LedgerCloseMetaV0(u.V0())
	case 1:
		return XDR_LedgerCloseMetaV1(u.V1())
	}
	return nil
}
func (u *LedgerCloseMeta) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_LedgerCloseMeta = *LedgerCloseMeta

func (v *LedgerCloseMeta) XdrPointer() interface{}       { return v }
func (LedgerCloseMeta) XdrTypeName() string              { return "LedgerCloseMeta" }
func (v LedgerCloseMeta) XdrValue() interface{}          { return v }
func (v *LedgerCloseMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerCloseMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_LedgerCloseMetaV0(u.V0()))
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_LedgerCloseMetaV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in LedgerCloseMeta", u.V)
}
func XDR_LedgerCloseMeta(v *LedgerCloseMeta) *LedgerCloseMeta { return v }

var _XdrNames_ErrorCode = map[int32]string{
	int32(ERR_MISC): "ERR_MISC",
	int32(ERR_DATA): "ERR_DATA",
	int32(ERR_CONF): "ERR_CONF",
	int32(ERR_AUTH): "ERR_AUTH",
	int32(ERR_LOAD): "ERR_LOAD",
}
var _XdrValues_ErrorCode = map[string]int32{
	"ERR_MISC": int32(ERR_MISC),
	"ERR_DATA": int32(ERR_DATA),
	"ERR_CONF": int32(ERR_CONF),
	"ERR_AUTH": int32(ERR_AUTH),
	"ERR_LOAD": int32(ERR_LOAD),
}

func (ErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ErrorCode
}
func (v ErrorCode) String() string {
	if s, ok := _XdrNames_ErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ErrorCode#%d", v)
}
func (v *ErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ErrorCode[stok]; ok {
			*v = ErrorCode(val)
			return nil
		} else if stok == "ErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ErrorCode.", stok))
	}
}
func (v ErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *ErrorCode) SetU32(n uint32)               { *v = ErrorCode(n) }
func (v *ErrorCode) XdrPointer() interface{}       { return v }
func (ErrorCode) XdrTypeName() string              { return "ErrorCode" }
func (v ErrorCode) XdrValue() interface{}          { return v }
func (v *ErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ErrorCode = *ErrorCode

func XDR_ErrorCode(v *ErrorCode) *ErrorCode { return v }

var _XdrComments_ErrorCode = map[int32]string{
	int32(ERR_MISC): "Unspecific error",
	int32(ERR_DATA): "Malformed data",
	int32(ERR_CONF): "Misconfiguration error",
	int32(ERR_AUTH): "Authentication failure",
	int32(ERR_LOAD): "System overloaded",
}

func (e ErrorCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ErrorCode
}

type XdrType_Error = *Error

func (v *Error) XdrPointer() interface{}       { return v }
func (Error) XdrTypeName() string              { return "Error" }
func (v Error) XdrValue() interface{}          { return v }
func (v *Error) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Error) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scode", name), XDR_ErrorCode(&v.Code))
	x.Marshal(x.Sprintf("%smsg", name), XdrString{&v.Msg, 100})
}
func XDR_Error(v *Error) *Error { return v }

type XdrType_SendMore = *SendMore

func (v *SendMore) XdrPointer() interface{}       { return v }
func (SendMore) XdrTypeName() string              { return "SendMore" }
func (v SendMore) XdrValue() interface{}          { return v }
func (v *SendMore) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SendMore) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snumMessages", name), XDR_Uint32(&v.NumMessages))
}
func XDR_SendMore(v *SendMore) *SendMore { return v }

type XdrType_SendMoreExtended = *SendMoreExtended

func (v *SendMoreExtended) XdrPointer() interface{}       { return v }
func (SendMoreExtended) XdrTypeName() string              { return "SendMoreExtended" }
func (v SendMoreExtended) XdrValue() interface{}          { return v }
func (v *SendMoreExtended) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SendMoreExtended) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snumMessages", name), XDR_Uint32(&v.NumMessages))
	x.Marshal(x.Sprintf("%snumBytes", name), XDR_Uint32(&v.NumBytes))
}
func XDR_SendMoreExtended(v *SendMoreExtended) *SendMoreExtended { return v }

type XdrType_AuthCert = *AuthCert

func (v *AuthCert) XdrPointer() interface{}       { return v }
func (AuthCert) XdrTypeName() string              { return "AuthCert" }
func (v AuthCert) XdrValue() interface{}          { return v }
func (v *AuthCert) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AuthCert) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%spubkey", name), XDR_Curve25519Public(&v.Pubkey))
	x.Marshal(x.Sprintf("%sexpiration", name), XDR_Uint64(&v.Expiration))
	x.Marshal(x.Sprintf("%ssig", name), XDR_Signature(&v.Sig))
}
func XDR_AuthCert(v *AuthCert) *AuthCert { return v }

type XdrType_Hello = *Hello

func (v *Hello) XdrPointer() interface{}       { return v }
func (Hello) XdrTypeName() string              { return "Hello" }
func (v Hello) XdrValue() interface{}          { return v }
func (v *Hello) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Hello) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerVersion", name), XDR_Uint32(&v.LedgerVersion))
	x.Marshal(x.Sprintf("%soverlayVersion", name), XDR_Uint32(&v.OverlayVersion))
	x.Marshal(x.Sprintf("%soverlayMinVersion", name), XDR_Uint32(&v.OverlayMinVersion))
	x.Marshal(x.Sprintf("%snetworkID", name), XDR_Hash(&v.NetworkID))
	x.Marshal(x.Sprintf("%sversionStr", name), XdrString{&v.VersionStr, 100})
	x.Marshal(x.Sprintf("%slisteningPort", name), XDR_int32(&v.ListeningPort))
	x.Marshal(x.Sprintf("%speerID", name), XDR_NodeID(&v.PeerID))
	x.Marshal(x.Sprintf("%scert", name), XDR_AuthCert(&v.Cert))
	x.Marshal(x.Sprintf("%snonce", name), XDR_Uint256(&v.Nonce))
}
func XDR_Hello(v *Hello) *Hello { return v }

type XdrType_Auth = *Auth

func (v *Auth) XdrPointer() interface{}       { return v }
func (Auth) XdrTypeName() string              { return "Auth" }
func (v Auth) XdrValue() interface{}          { return v }
func (v *Auth) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Auth) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sflags", name), XDR_int32(&v.Flags))
}
func XDR_Auth(v *Auth) *Auth { return v }

var _XdrNames_IPAddrType = map[int32]string{
	int32(IPv4): "IPv4",
	int32(IPv6): "IPv6",
}
var _XdrValues_IPAddrType = map[string]int32{
	"IPv4": int32(IPv4),
	"IPv6": int32(IPv6),
}

func (IPAddrType) XdrEnumNames() map[int32]string {
	return _XdrNames_IPAddrType
}
func (v IPAddrType) String() string {
	if s, ok := _XdrNames_IPAddrType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("IPAddrType#%d", v)
}
func (v *IPAddrType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_IPAddrType[stok]; ok {
			*v = IPAddrType(val)
			return nil
		} else if stok == "IPAddrType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid IPAddrType.", stok))
	}
}
func (v IPAddrType) GetU32() uint32                 { return uint32(v) }
func (v *IPAddrType) SetU32(n uint32)               { *v = IPAddrType(n) }
func (v *IPAddrType) XdrPointer() interface{}       { return v }
func (IPAddrType) XdrTypeName() string              { return "IPAddrType" }
func (v IPAddrType) XdrValue() interface{}          { return v }
func (v *IPAddrType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_IPAddrType = *IPAddrType

func XDR_IPAddrType(v *IPAddrType) *IPAddrType { return v }

type _XdrArray_16_opaque [16]byte

func (v *_XdrArray_16_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_16_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_16_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_16_opaque) XdrPointer() interface{}       { return (*[16]byte)(v) }
func (v *_XdrArray_16_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_16_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_16_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_16_opaque) XdrArraySize() uint32 {
	const bound uint32 = 16 // Force error if not const or doesn't fit
	return bound
}

var _XdrTags_XdrAnon_PeerAddress_Ip = map[int32]bool{
	XdrToI32(IPv4): true,
	XdrToI32(IPv6): true,
}

func (_ XdrAnon_PeerAddress_Ip) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_PeerAddress_Ip
}
func (u *XdrAnon_PeerAddress_Ip) Ipv4() *[4]byte {
	switch u.Type {
	case IPv4:
		if v, ok := u._u.(*[4]byte); ok {
			return v
		} else {
			var zero [4]byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_PeerAddress_Ip.Ipv4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_PeerAddress_Ip) Ipv6() *[16]byte {
	switch u.Type {
	case IPv6:
		if v, ok := u._u.(*[16]byte); ok {
			return v
		} else {
			var zero [16]byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_PeerAddress_Ip.Ipv6 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_PeerAddress_Ip) XdrValid() bool {
	switch u.Type {
	case IPv4, IPv6:
		return true
	}
	return false
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionTag() XdrNum32 {
	return XDR_IPAddrType(&u.Type)
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionBody() XdrType {
	switch u.Type {
	case IPv4:
		return (*_XdrArray_4_opaque)(u.Ipv4())
	case IPv6:
		return (*_XdrArray_16_opaque)(u.Ipv6())
	}
	return nil
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionBodyName() string {
	switch u.Type {
	case IPv4:
		return "Ipv4"
	case IPv6:
		return "Ipv6"
	}
	return ""
}

type XdrType_XdrAnon_PeerAddress_Ip = *XdrAnon_PeerAddress_Ip

func (v *XdrAnon_PeerAddress_Ip) XdrPointer() interface{}       { return v }
func (XdrAnon_PeerAddress_Ip) XdrTypeName() string              { return "XdrAnon_PeerAddress_Ip" }
func (v XdrAnon_PeerAddress_Ip) XdrValue() interface{}          { return v }
func (v *XdrAnon_PeerAddress_Ip) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_PeerAddress_Ip) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_IPAddrType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case IPv4:
		x.Marshal(x.Sprintf("%sipv4", name), (*_XdrArray_4_opaque)(u.Ipv4()))
		return
	case IPv6:
		x.Marshal(x.Sprintf("%sipv6", name), (*_XdrArray_16_opaque)(u.Ipv6()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_PeerAddress_Ip", u.Type)
}
func XDR_XdrAnon_PeerAddress_Ip(v *XdrAnon_PeerAddress_Ip) *XdrAnon_PeerAddress_Ip { return v }

type XdrType_PeerAddress = *PeerAddress

func (v *PeerAddress) XdrPointer() interface{}       { return v }
func (PeerAddress) XdrTypeName() string              { return "PeerAddress" }
func (v PeerAddress) XdrValue() interface{}          { return v }
func (v *PeerAddress) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PeerAddress) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sip", name), XDR_XdrAnon_PeerAddress_Ip(&v.Ip))
	x.Marshal(x.Sprintf("%sport", name), XDR_Uint32(&v.Port))
	x.Marshal(x.Sprintf("%snumFailures", name), XDR_Uint32(&v.NumFailures))
}
func XDR_PeerAddress(v *PeerAddress) *PeerAddress { return v }

var _XdrNames_MessageType = map[int32]string{
	int32(ERROR_MSG):          "ERROR_MSG",
	int32(AUTH):               "AUTH",
	int32(DONT_HAVE):          "DONT_HAVE",
	int32(GET_PEERS):          "GET_PEERS",
	int32(PEERS):              "PEERS",
	int32(GET_TX_SET):         "GET_TX_SET",
	int32(TX_SET):             "TX_SET",
	int32(GENERALIZED_TX_SET): "GENERALIZED_TX_SET",
	int32(TRANSACTION):        "TRANSACTION",
	int32(GET_SCP_QUORUMSET):  "GET_SCP_QUORUMSET",
	int32(SCP_QUORUMSET):      "SCP_QUORUMSET",
	int32(SCP_MESSAGE):        "SCP_MESSAGE",
	int32(GET_SCP_STATE):      "GET_SCP_STATE",
	int32(HELLO):              "HELLO",
	int32(SURVEY_REQUEST):     "SURVEY_REQUEST",
	int32(SURVEY_RESPONSE):    "SURVEY_RESPONSE",
	int32(SEND_MORE):          "SEND_MORE",
	int32(SEND_MORE_EXTENDED): "SEND_MORE_EXTENDED",
	int32(FLOOD_ADVERT):       "FLOOD_ADVERT",
	int32(FLOOD_DEMAND):       "FLOOD_DEMAND",
}
var _XdrValues_MessageType = map[string]int32{
	"ERROR_MSG":          int32(ERROR_MSG),
	"AUTH":               int32(AUTH),
	"DONT_HAVE":          int32(DONT_HAVE),
	"GET_PEERS":          int32(GET_PEERS),
	"PEERS":              int32(PEERS),
	"GET_TX_SET":         int32(GET_TX_SET),
	"TX_SET":             int32(TX_SET),
	"GENERALIZED_TX_SET": int32(GENERALIZED_TX_SET),
	"TRANSACTION":        int32(TRANSACTION),
	"GET_SCP_QUORUMSET":  int32(GET_SCP_QUORUMSET),
	"SCP_QUORUMSET":      int32(SCP_QUORUMSET),
	"SCP_MESSAGE":        int32(SCP_MESSAGE),
	"GET_SCP_STATE":      int32(GET_SCP_STATE),
	"HELLO":              int32(HELLO),
	"SURVEY_REQUEST":     int32(SURVEY_REQUEST),
	"SURVEY_RESPONSE":    int32(SURVEY_RESPONSE),
	"SEND_MORE":          int32(SEND_MORE),
	"SEND_MORE_EXTENDED": int32(SEND_MORE_EXTENDED),
	"FLOOD_ADVERT":       int32(FLOOD_ADVERT),
	"FLOOD_DEMAND":       int32(FLOOD_DEMAND),
}

func (MessageType) XdrEnumNames() map[int32]string {
	return _XdrNames_MessageType
}
func (v MessageType) String() string {
	if s, ok := _XdrNames_MessageType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("MessageType#%d", v)
}
func (v *MessageType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_MessageType[stok]; ok {
			*v = MessageType(val)
			return nil
		} else if stok == "MessageType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid MessageType.", stok))
	}
}
func (v MessageType) GetU32() uint32                 { return uint32(v) }
func (v *MessageType) SetU32(n uint32)               { *v = MessageType(n) }
func (v *MessageType) XdrPointer() interface{}       { return v }
func (MessageType) XdrTypeName() string              { return "MessageType" }
func (v MessageType) XdrValue() interface{}          { return v }
func (v *MessageType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_MessageType = *MessageType

func XDR_MessageType(v *MessageType) *MessageType { return v }

var _XdrComments_MessageType = map[int32]string{
	int32(GET_PEERS):         "gets a list of peers this guy knows about",
	int32(GET_TX_SET):        "gets a particular txset by hash",
	int32(TRANSACTION):       "pass on a tx you have heard about",
	int32(GET_SCP_QUORUMSET): "SCP",
	int32(HELLO):             "new messages",
}

func (e MessageType) XdrEnumComments() map[int32]string {
	return _XdrComments_MessageType
}

type XdrType_DontHave = *DontHave

func (v *DontHave) XdrPointer() interface{}       { return v }
func (DontHave) XdrTypeName() string              { return "DontHave" }
func (v DontHave) XdrValue() interface{}          { return v }
func (v *DontHave) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DontHave) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stype", name), XDR_MessageType(&v.Type))
	x.Marshal(x.Sprintf("%sreqHash", name), XDR_Uint256(&v.ReqHash))
}
func XDR_DontHave(v *DontHave) *DontHave { return v }

var _XdrNames_SurveyMessageCommandType = map[int32]string{
	int32(SURVEY_TOPOLOGY): "SURVEY_TOPOLOGY",
}
var _XdrValues_SurveyMessageCommandType = map[string]int32{
	"SURVEY_TOPOLOGY": int32(SURVEY_TOPOLOGY),
}

func (SurveyMessageCommandType) XdrEnumNames() map[int32]string {
	return _XdrNames_SurveyMessageCommandType
}
func (v SurveyMessageCommandType) String() string {
	if s, ok := _XdrNames_SurveyMessageCommandType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SurveyMessageCommandType#%d", v)
}
func (v *SurveyMessageCommandType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SurveyMessageCommandType[stok]; ok {
			*v = SurveyMessageCommandType(val)
			return nil
		} else if stok == "SurveyMessageCommandType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SurveyMessageCommandType.", stok))
	}
}
func (v SurveyMessageCommandType) GetU32() uint32                 { return uint32(v) }
func (v *SurveyMessageCommandType) SetU32(n uint32)               { *v = SurveyMessageCommandType(n) }
func (v *SurveyMessageCommandType) XdrPointer() interface{}       { return v }
func (SurveyMessageCommandType) XdrTypeName() string              { return "SurveyMessageCommandType" }
func (v SurveyMessageCommandType) XdrValue() interface{}          { return v }
func (v *SurveyMessageCommandType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SurveyMessageCommandType = *SurveyMessageCommandType

func XDR_SurveyMessageCommandType(v *SurveyMessageCommandType) *SurveyMessageCommandType { return v }

var _XdrNames_SurveyMessageResponseType = map[int32]string{
	int32(SURVEY_TOPOLOGY_RESPONSE_V0): "SURVEY_TOPOLOGY_RESPONSE_V0",
	int32(SURVEY_TOPOLOGY_RESPONSE_V1): "SURVEY_TOPOLOGY_RESPONSE_V1",
}
var _XdrValues_SurveyMessageResponseType = map[string]int32{
	"SURVEY_TOPOLOGY_RESPONSE_V0": int32(SURVEY_TOPOLOGY_RESPONSE_V0),
	"SURVEY_TOPOLOGY_RESPONSE_V1": int32(SURVEY_TOPOLOGY_RESPONSE_V1),
}

func (SurveyMessageResponseType) XdrEnumNames() map[int32]string {
	return _XdrNames_SurveyMessageResponseType
}
func (v SurveyMessageResponseType) String() string {
	if s, ok := _XdrNames_SurveyMessageResponseType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SurveyMessageResponseType#%d", v)
}
func (v *SurveyMessageResponseType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SurveyMessageResponseType[stok]; ok {
			*v = SurveyMessageResponseType(val)
			return nil
		} else if stok == "SurveyMessageResponseType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SurveyMessageResponseType.", stok))
	}
}
func (v SurveyMessageResponseType) GetU32() uint32                 { return uint32(v) }
func (v *SurveyMessageResponseType) SetU32(n uint32)               { *v = SurveyMessageResponseType(n) }
func (v *SurveyMessageResponseType) XdrPointer() interface{}       { return v }
func (SurveyMessageResponseType) XdrTypeName() string              { return "SurveyMessageResponseType" }
func (v SurveyMessageResponseType) XdrValue() interface{}          { return v }
func (v *SurveyMessageResponseType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SurveyMessageResponseType = *SurveyMessageResponseType

func XDR_SurveyMessageResponseType(v *SurveyMessageResponseType) *SurveyMessageResponseType { return v }

type XdrType_SurveyRequestMessage = *SurveyRequestMessage

func (v *SurveyRequestMessage) XdrPointer() interface{}       { return v }
func (SurveyRequestMessage) XdrTypeName() string              { return "SurveyRequestMessage" }
func (v SurveyRequestMessage) XdrValue() interface{}          { return v }
func (v *SurveyRequestMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SurveyRequestMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssurveyorPeerID", name), XDR_NodeID(&v.SurveyorPeerID))
	x.Marshal(x.Sprintf("%ssurveyedPeerID", name), XDR_NodeID(&v.SurveyedPeerID))
	x.Marshal(x.Sprintf("%sledgerNum", name), XDR_Uint32(&v.LedgerNum))
	x.Marshal(x.Sprintf("%sencryptionKey", name), XDR_Curve25519Public(&v.EncryptionKey))
	x.Marshal(x.Sprintf("%scommandType", name), XDR_SurveyMessageCommandType(&v.CommandType))
}
func XDR_SurveyRequestMessage(v *SurveyRequestMessage) *SurveyRequestMessage { return v }

type XdrType_SignedSurveyRequestMessage = *SignedSurveyRequestMessage

func (v *SignedSurveyRequestMessage) XdrPointer() interface{}       { return v }
func (SignedSurveyRequestMessage) XdrTypeName() string              { return "SignedSurveyRequestMessage" }
func (v SignedSurveyRequestMessage) XdrValue() interface{}          { return v }
func (v *SignedSurveyRequestMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SignedSurveyRequestMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%srequestSignature", name), XDR_Signature(&v.RequestSignature))
	x.Marshal(x.Sprintf("%srequest", name), XDR_SurveyRequestMessage(&v.Request))
}
func XDR_SignedSurveyRequestMessage(v *SignedSurveyRequestMessage) *SignedSurveyRequestMessage {
	return v
}

type XdrType_EncryptedBody struct {
	XdrVecOpaque
}

func XDR_EncryptedBody(v *EncryptedBody) XdrType_EncryptedBody {
	return XdrType_EncryptedBody{XdrVecOpaque{v, 64000}}
}
func (XdrType_EncryptedBody) XdrTypeName() string  { return "EncryptedBody" }
func (v XdrType_EncryptedBody) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_SurveyResponseMessage = *SurveyResponseMessage

func (v *SurveyResponseMessage) XdrPointer() interface{}       { return v }
func (SurveyResponseMessage) XdrTypeName() string              { return "SurveyResponseMessage" }
func (v SurveyResponseMessage) XdrValue() interface{}          { return v }
func (v *SurveyResponseMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SurveyResponseMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssurveyorPeerID", name), XDR_NodeID(&v.SurveyorPeerID))
	x.Marshal(x.Sprintf("%ssurveyedPeerID", name), XDR_NodeID(&v.SurveyedPeerID))
	x.Marshal(x.Sprintf("%sledgerNum", name), XDR_Uint32(&v.LedgerNum))
	x.Marshal(x.Sprintf("%scommandType", name), XDR_SurveyMessageCommandType(&v.CommandType))
	x.Marshal(x.Sprintf("%sencryptedBody", name), XDR_EncryptedBody(&v.EncryptedBody))
}
func XDR_SurveyResponseMessage(v *SurveyResponseMessage) *SurveyResponseMessage { return v }

type XdrType_SignedSurveyResponseMessage = *SignedSurveyResponseMessage

func (v *SignedSurveyResponseMessage) XdrPointer() interface{}       { return v }
func (SignedSurveyResponseMessage) XdrTypeName() string              { return "SignedSurveyResponseMessage" }
func (v SignedSurveyResponseMessage) XdrValue() interface{}          { return v }
func (v *SignedSurveyResponseMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SignedSurveyResponseMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresponseSignature", name), XDR_Signature(&v.ResponseSignature))
	x.Marshal(x.Sprintf("%sresponse", name), XDR_SurveyResponseMessage(&v.Response))
}
func XDR_SignedSurveyResponseMessage(v *SignedSurveyResponseMessage) *SignedSurveyResponseMessage {
	return v
}

type XdrType_PeerStats = *PeerStats

func (v *PeerStats) XdrPointer() interface{}       { return v }
func (PeerStats) XdrTypeName() string              { return "PeerStats" }
func (v PeerStats) XdrValue() interface{}          { return v }
func (v *PeerStats) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PeerStats) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sid", name), XDR_NodeID(&v.Id))
	x.Marshal(x.Sprintf("%sversionStr", name), XdrString{&v.VersionStr, 100})
	x.Marshal(x.Sprintf("%smessagesRead", name), XDR_Uint64(&v.MessagesRead))
	x.Marshal(x.Sprintf("%smessagesWritten", name), XDR_Uint64(&v.MessagesWritten))
	x.Marshal(x.Sprintf("%sbytesRead", name), XDR_Uint64(&v.BytesRead))
	x.Marshal(x.Sprintf("%sbytesWritten", name), XDR_Uint64(&v.BytesWritten))
	x.Marshal(x.Sprintf("%ssecondsConnected", name), XDR_Uint64(&v.SecondsConnected))
	x.Marshal(x.Sprintf("%suniqueFloodBytesRecv", name), XDR_Uint64(&v.UniqueFloodBytesRecv))
	x.Marshal(x.Sprintf("%sduplicateFloodBytesRecv", name), XDR_Uint64(&v.DuplicateFloodBytesRecv))
	x.Marshal(x.Sprintf("%suniqueFetchBytesRecv", name), XDR_Uint64(&v.UniqueFetchBytesRecv))
	x.Marshal(x.Sprintf("%sduplicateFetchBytesRecv", name), XDR_Uint64(&v.DuplicateFetchBytesRecv))
	x.Marshal(x.Sprintf("%suniqueFloodMessageRecv", name), XDR_Uint64(&v.UniqueFloodMessageRecv))
	x.Marshal(x.Sprintf("%sduplicateFloodMessageRecv", name), XDR_Uint64(&v.DuplicateFloodMessageRecv))
	x.Marshal(x.Sprintf("%suniqueFetchMessageRecv", name), XDR_Uint64(&v.UniqueFetchMessageRecv))
	x.Marshal(x.Sprintf("%sduplicateFetchMessageRecv", name), XDR_Uint64(&v.DuplicateFetchMessageRecv))
}
func XDR_PeerStats(v *PeerStats) *PeerStats { return v }

type _XdrVec_25_PeerStats []PeerStats

func (_XdrVec_25_PeerStats) XdrBound() uint32 {
	const bound uint32 = 25 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_25_PeerStats) XdrCheckLen(length uint32) {
	if length > uint32(25) {
		XdrPanic("_XdrVec_25_PeerStats length %d exceeds bound 25", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_25_PeerStats length %d exceeds max int", length)
	}
}
func (v _XdrVec_25_PeerStats) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_25_PeerStats) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(25); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]PeerStats, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_25_PeerStats) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_PeerStats(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_25_PeerStats) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 25}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_25_PeerStats) XdrTypeName() string              { return "PeerStats<>" }
func (v *_XdrVec_25_PeerStats) XdrPointer() interface{}       { return (*[]PeerStats)(v) }
func (v _XdrVec_25_PeerStats) XdrValue() interface{}          { return ([]PeerStats)(v) }
func (v *_XdrVec_25_PeerStats) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PeerStatList struct {
	*_XdrVec_25_PeerStats
}

func XDR_PeerStatList(v *PeerStatList) XdrType_PeerStatList {
	return XdrType_PeerStatList{(*_XdrVec_25_PeerStats)(v)}
}
func (XdrType_PeerStatList) XdrTypeName() string  { return "PeerStatList" }
func (v XdrType_PeerStatList) XdrUnwrap() XdrType { return v._XdrVec_25_PeerStats }

type XdrType_TopologyResponseBodyV0 = *TopologyResponseBodyV0

func (v *TopologyResponseBodyV0) XdrPointer() interface{}       { return v }
func (TopologyResponseBodyV0) XdrTypeName() string              { return "TopologyResponseBodyV0" }
func (v TopologyResponseBodyV0) XdrValue() interface{}          { return v }
func (v *TopologyResponseBodyV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TopologyResponseBodyV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sinboundPeers", name), XDR_PeerStatList(&v.InboundPeers))
	x.Marshal(x.Sprintf("%soutboundPeers", name), XDR_PeerStatList(&v.OutboundPeers))
	x.Marshal(x.Sprintf("%stotalInboundPeerCount", name), XDR_Uint32(&v.TotalInboundPeerCount))
	x.Marshal(x.Sprintf("%stotalOutboundPeerCount", name), XDR_Uint32(&v.TotalOutboundPeerCount))
}
func XDR_TopologyResponseBodyV0(v *TopologyResponseBodyV0) *TopologyResponseBodyV0 { return v }

type XdrType_TopologyResponseBodyV1 = *TopologyResponseBodyV1

func (v *TopologyResponseBodyV1) XdrPointer() interface{}       { return v }
func (TopologyResponseBodyV1) XdrTypeName() string              { return "TopologyResponseBodyV1" }
func (v TopologyResponseBodyV1) XdrValue() interface{}          { return v }
func (v *TopologyResponseBodyV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TopologyResponseBodyV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sinboundPeers", name), XDR_PeerStatList(&v.InboundPeers))
	x.Marshal(x.Sprintf("%soutboundPeers", name), XDR_PeerStatList(&v.OutboundPeers))
	x.Marshal(x.Sprintf("%stotalInboundPeerCount", name), XDR_Uint32(&v.TotalInboundPeerCount))
	x.Marshal(x.Sprintf("%stotalOutboundPeerCount", name), XDR_Uint32(&v.TotalOutboundPeerCount))
	x.Marshal(x.Sprintf("%smaxInboundPeerCount", name), XDR_Uint32(&v.MaxInboundPeerCount))
	x.Marshal(x.Sprintf("%smaxOutboundPeerCount", name), XDR_Uint32(&v.MaxOutboundPeerCount))
}
func XDR_TopologyResponseBodyV1(v *TopologyResponseBodyV1) *TopologyResponseBodyV1 { return v }

var _XdrTags_SurveyResponseBody = map[int32]bool{
	XdrToI32(SURVEY_TOPOLOGY_RESPONSE_V0): true,
	XdrToI32(SURVEY_TOPOLOGY_RESPONSE_V1): true,
}

func (_ SurveyResponseBody) XdrValidTags() map[int32]bool {
	return _XdrTags_SurveyResponseBody
}
func (u *SurveyResponseBody) TopologyResponseBodyV0() *TopologyResponseBodyV0 {
	switch u.Type {
	case SURVEY_TOPOLOGY_RESPONSE_V0:
		if v, ok := u._u.(*TopologyResponseBodyV0); ok {
			return v
		} else {
			var zero TopologyResponseBodyV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SurveyResponseBody.TopologyResponseBodyV0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SurveyResponseBody) TopologyResponseBodyV1() *TopologyResponseBodyV1 {
	switch u.Type {
	case SURVEY_TOPOLOGY_RESPONSE_V1:
		if v, ok := u._u.(*TopologyResponseBodyV1); ok {
			return v
		} else {
			var zero TopologyResponseBodyV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SurveyResponseBody.TopologyResponseBodyV1 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SurveyResponseBody) XdrValid() bool {
	switch u.Type {
	case SURVEY_TOPOLOGY_RESPONSE_V0, SURVEY_TOPOLOGY_RESPONSE_V1:
		return true
	}
	return false
}
func (u *SurveyResponseBody) XdrUnionTag() XdrNum32 {
	return XDR_SurveyMessageResponseType(&u.Type)
}
func (u *SurveyResponseBody) XdrUnionTagName() string {
	return "Type"
}
func (u *SurveyResponseBody) XdrUnionBody() XdrType {
	switch u.Type {
	case SURVEY_TOPOLOGY_RESPONSE_V0:
		return XDR_TopologyResponseBodyV0(u.TopologyResponseBodyV0())
	case SURVEY_TOPOLOGY_RESPONSE_V1:
		return XDR_TopologyResponseBodyV1(u.TopologyResponseBodyV1())
	}
	return nil
}
func (u *SurveyResponseBody) XdrUnionBodyName() string {
	switch u.Type {
	case SURVEY_TOPOLOGY_RESPONSE_V0:
		return "TopologyResponseBodyV0"
	case SURVEY_TOPOLOGY_RESPONSE_V1:
		return "TopologyResponseBodyV1"
	}
	return ""
}

type XdrType_SurveyResponseBody = *SurveyResponseBody

func (v *SurveyResponseBody) XdrPointer() interface{}       { return v }
func (SurveyResponseBody) XdrTypeName() string              { return "SurveyResponseBody" }
func (v SurveyResponseBody) XdrValue() interface{}          { return v }
func (v *SurveyResponseBody) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SurveyResponseBody) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SurveyMessageResponseType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SURVEY_TOPOLOGY_RESPONSE_V0:
		x.Marshal(x.Sprintf("%stopologyResponseBodyV0", name), XDR_TopologyResponseBodyV0(u.TopologyResponseBodyV0()))
		return
	case SURVEY_TOPOLOGY_RESPONSE_V1:
		x.Marshal(x.Sprintf("%stopologyResponseBodyV1", name), XDR_TopologyResponseBodyV1(u.TopologyResponseBodyV1()))
		return
	}
	XdrPanic("invalid Type (%v) in SurveyResponseBody", u.Type)
}
func XDR_SurveyResponseBody(v *SurveyResponseBody) *SurveyResponseBody { return v }

type _XdrVec_1000_Hash []Hash

func (_XdrVec_1000_Hash) XdrBound() uint32 {
	const bound uint32 = 1000 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_1000_Hash) XdrCheckLen(length uint32) {
	if length > uint32(1000) {
		XdrPanic("_XdrVec_1000_Hash length %d exceeds bound 1000", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_1000_Hash length %d exceeds max int", length)
	}
}
func (v _XdrVec_1000_Hash) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_1000_Hash) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(1000); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Hash, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_1000_Hash) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Hash(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_1000_Hash) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 1000}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_1000_Hash) XdrTypeName() string              { return "Hash<>" }
func (v *_XdrVec_1000_Hash) XdrPointer() interface{}       { return (*[]Hash)(v) }
func (v _XdrVec_1000_Hash) XdrValue() interface{}          { return ([]Hash)(v) }
func (v *_XdrVec_1000_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TxAdvertVector struct {
	*_XdrVec_1000_Hash
}

func XDR_TxAdvertVector(v *TxAdvertVector) XdrType_TxAdvertVector {
	return XdrType_TxAdvertVector{(*_XdrVec_1000_Hash)(v)}
}
func (XdrType_TxAdvertVector) XdrTypeName() string  { return "TxAdvertVector" }
func (v XdrType_TxAdvertVector) XdrUnwrap() XdrType { return v._XdrVec_1000_Hash }

type XdrType_FloodAdvert = *FloodAdvert

func (v *FloodAdvert) XdrPointer() interface{}       { return v }
func (FloodAdvert) XdrTypeName() string              { return "FloodAdvert" }
func (v FloodAdvert) XdrValue() interface{}          { return v }
func (v *FloodAdvert) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FloodAdvert) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxHashes", name), XDR_TxAdvertVector(&v.TxHashes))
}
func XDR_FloodAdvert(v *FloodAdvert) *FloodAdvert { return v }

type XdrType_TxDemandVector struct {
	*_XdrVec_1000_Hash
}

func XDR_TxDemandVector(v *TxDemandVector) XdrType_TxDemandVector {
	return XdrType_TxDemandVector{(*_XdrVec_1000_Hash)(v)}
}
func (XdrType_TxDemandVector) XdrTypeName() string  { return "TxDemandVector" }
func (v XdrType_TxDemandVector) XdrUnwrap() XdrType { return v._XdrVec_1000_Hash }

type XdrType_FloodDemand = *FloodDemand

func (v *FloodDemand) XdrPointer() interface{}       { return v }
func (FloodDemand) XdrTypeName() string              { return "FloodDemand" }
func (v FloodDemand) XdrValue() interface{}          { return v }
func (v *FloodDemand) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FloodDemand) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxHashes", name), XDR_TxDemandVector(&v.TxHashes))
}
func XDR_FloodDemand(v *FloodDemand) *FloodDemand { return v }

type _XdrVec_100_PeerAddress []PeerAddress

func (_XdrVec_100_PeerAddress) XdrBound() uint32 {
	const bound uint32 = 100 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_100_PeerAddress) XdrCheckLen(length uint32) {
	if length > uint32(100) {
		XdrPanic("_XdrVec_100_PeerAddress length %d exceeds bound 100", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_100_PeerAddress length %d exceeds max int", length)
	}
}
func (v _XdrVec_100_PeerAddress) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_100_PeerAddress) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(100); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]PeerAddress, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_100_PeerAddress) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_PeerAddress(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_100_PeerAddress) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 100}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_100_PeerAddress) XdrTypeName() string              { return "PeerAddress<>" }
func (v *_XdrVec_100_PeerAddress) XdrPointer() interface{}       { return (*[]PeerAddress)(v) }
func (v _XdrVec_100_PeerAddress) XdrValue() interface{}          { return ([]PeerAddress)(v) }
func (v *_XdrVec_100_PeerAddress) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_StellarMessage = map[int32]bool{
	XdrToI32(ERROR_MSG):          true,
	XdrToI32(HELLO):              true,
	XdrToI32(AUTH):               true,
	XdrToI32(DONT_HAVE):          true,
	XdrToI32(GET_PEERS):          true,
	XdrToI32(PEERS):              true,
	XdrToI32(GET_TX_SET):         true,
	XdrToI32(TX_SET):             true,
	XdrToI32(GENERALIZED_TX_SET): true,
	XdrToI32(TRANSACTION):        true,
	XdrToI32(SURVEY_REQUEST):     true,
	XdrToI32(SURVEY_RESPONSE):    true,
	XdrToI32(GET_SCP_QUORUMSET):  true,
	XdrToI32(SCP_QUORUMSET):      true,
	XdrToI32(SCP_MESSAGE):        true,
	XdrToI32(GET_SCP_STATE):      true,
	XdrToI32(SEND_MORE):          true,
	XdrToI32(SEND_MORE_EXTENDED): true,
	XdrToI32(FLOOD_ADVERT):       true,
	XdrToI32(FLOOD_DEMAND):       true,
}

func (_ StellarMessage) XdrValidTags() map[int32]bool {
	return _XdrTags_StellarMessage
}
func (u *StellarMessage) Error() *Error {
	switch u.Type {
	case ERROR_MSG:
		if v, ok := u._u.(*Error); ok {
			return v
		} else {
			var zero Error
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Error accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Hello() *Hello {
	switch u.Type {
	case HELLO:
		if v, ok := u._u.(*Hello); ok {
			return v
		} else {
			var zero Hello
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Hello accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Auth() *Auth {
	switch u.Type {
	case AUTH:
		if v, ok := u._u.(*Auth); ok {
			return v
		} else {
			var zero Auth
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Auth accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) DontHave() *DontHave {
	switch u.Type {
	case DONT_HAVE:
		if v, ok := u._u.(*DontHave); ok {
			return v
		} else {
			var zero DontHave
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.DontHave accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Peers() *[]PeerAddress {
	switch u.Type {
	case PEERS:
		if v, ok := u._u.(*[]PeerAddress); ok {
			return v
		} else {
			var zero []PeerAddress
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Peers accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) TxSetHash() *Uint256 {
	switch u.Type {
	case GET_TX_SET:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.TxSetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) TxSet() *TransactionSet {
	switch u.Type {
	case TX_SET:
		if v, ok := u._u.(*TransactionSet); ok {
			return v
		} else {
			var zero TransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.TxSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) GeneralizedTxSet() *GeneralizedTransactionSet {
	switch u.Type {
	case GENERALIZED_TX_SET:
		if v, ok := u._u.(*GeneralizedTransactionSet); ok {
			return v
		} else {
			var zero GeneralizedTransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.GeneralizedTxSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Transaction() *TransactionEnvelope {
	switch u.Type {
	case TRANSACTION:
		if v, ok := u._u.(*TransactionEnvelope); ok {
			return v
		} else {
			var zero TransactionEnvelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Transaction accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) SignedSurveyRequestMessage() *SignedSurveyRequestMessage {
	switch u.Type {
	case SURVEY_REQUEST:
		if v, ok := u._u.(*SignedSurveyRequestMessage); ok {
			return v
		} else {
			var zero SignedSurveyRequestMessage
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.SignedSurveyRequestMessage accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) SignedSurveyResponseMessage() *SignedSurveyResponseMessage {
	switch u.Type {
	case SURVEY_RESPONSE:
		if v, ok := u._u.(*SignedSurveyResponseMessage); ok {
			return v
		} else {
			var zero SignedSurveyResponseMessage
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.SignedSurveyResponseMessage accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) QSetHash() *Uint256 {
	switch u.Type {
	case GET_SCP_QUORUMSET:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.QSetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) QSet() *SCPQuorumSet {
	switch u.Type {
	case SCP_QUORUMSET:
		if v, ok := u._u.(*SCPQuorumSet); ok {
			return v
		} else {
			var zero SCPQuorumSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.QSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Envelope() *SCPEnvelope {
	switch u.Type {
	case SCP_MESSAGE:
		if v, ok := u._u.(*SCPEnvelope); ok {
			return v
		} else {
			var zero SCPEnvelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Envelope accessed when Type == %v", u.Type)
		return nil
	}
}

// ledger seq requested ; if 0, requests the latest
func (u *StellarMessage) GetSCPLedgerSeq() *Uint32 {
	switch u.Type {
	case GET_SCP_STATE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.GetSCPLedgerSeq accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) SendMoreMessage() *SendMore {
	switch u.Type {
	case SEND_MORE:
		if v, ok := u._u.(*SendMore); ok {
			return v
		} else {
			var zero SendMore
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.SendMoreMessage accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) SendMoreExtendedMessage() *SendMoreExtended {
	switch u.Type {
	case SEND_MORE_EXTENDED:
		if v, ok := u._u.(*SendMoreExtended); ok {
			return v
		} else {
			var zero SendMoreExtended
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.SendMoreExtendedMessage accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) FloodAdvert() *FloodAdvert {
	switch u.Type {
	case FLOOD_ADVERT:
		if v, ok := u._u.(*FloodAdvert); ok {
			return v
		} else {
			var zero FloodAdvert
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.FloodAdvert accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) FloodDemand() *FloodDemand {
	switch u.Type {
	case FLOOD_DEMAND:
		if v, ok := u._u.(*FloodDemand); ok {
			return v
		} else {
			var zero FloodDemand
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.FloodDemand accessed when Type == %v", u.Type)
		return nil
	}
}
func (u StellarMessage) XdrValid() bool {
	switch u.Type {
	case ERROR_MSG, HELLO, AUTH, DONT_HAVE, GET_PEERS, PEERS, GET_TX_SET, TX_SET, GENERALIZED_TX_SET, TRANSACTION, SURVEY_REQUEST, SURVEY_RESPONSE, GET_SCP_QUORUMSET, SCP_QUORUMSET, SCP_MESSAGE, GET_SCP_STATE, SEND_MORE, SEND_MORE_EXTENDED, FLOOD_ADVERT, FLOOD_DEMAND:
		return true
	}
	return false
}
func (u *StellarMessage) XdrUnionTag() XdrNum32 {
	return XDR_MessageType(&u.Type)
}
func (u *StellarMessage) XdrUnionTagName() string {
	return "Type"
}
func (u *StellarMessage) XdrUnionBody() XdrType {
	switch u.Type {
	case ERROR_MSG:
		return XDR_Error(u.Error())
	case HELLO:
		return XDR_Hello(u.Hello())
	case AUTH:
		return XDR_Auth(u.Auth())
	case DONT_HAVE:
		return XDR_DontHave(u.DontHave())
	case GET_PEERS:
		return nil
	case PEERS:
		return (*_XdrVec_100_PeerAddress)(u.Peers())
	case GET_TX_SET:
		return XDR_Uint256(u.TxSetHash())
	case TX_SET:
		return XDR_TransactionSet(u.TxSet())
	case GENERALIZED_TX_SET:
		return XDR_GeneralizedTransactionSet(u.GeneralizedTxSet())
	case TRANSACTION:
		return XDR_TransactionEnvelope(u.Transaction())
	case SURVEY_REQUEST:
		return XDR_SignedSurveyRequestMessage(u.SignedSurveyRequestMessage())
	case SURVEY_RESPONSE:
		return XDR_SignedSurveyResponseMessage(u.SignedSurveyResponseMessage())
	case GET_SCP_QUORUMSET:
		return XDR_Uint256(u.QSetHash())
	case SCP_QUORUMSET:
		return XDR_SCPQuorumSet(u.QSet())
	case SCP_MESSAGE:
		return XDR_SCPEnvelope(u.Envelope())
	case GET_SCP_STATE:
		return XDR_Uint32(u.GetSCPLedgerSeq())
	case SEND_MORE:
		return XDR_SendMore(u.SendMoreMessage())
	case SEND_MORE_EXTENDED:
		return XDR_SendMoreExtended(u.SendMoreExtendedMessage())
	case FLOOD_ADVERT:
		return XDR_FloodAdvert(u.FloodAdvert())
	case FLOOD_DEMAND:
		return XDR_FloodDemand(u.FloodDemand())
	}
	return nil
}
func (u *StellarMessage) XdrUnionBodyName() string {
	switch u.Type {
	case ERROR_MSG:
		return "Error"
	case HELLO:
		return "Hello"
	case AUTH:
		return "Auth"
	case DONT_HAVE:
		return "DontHave"
	case GET_PEERS:
		return ""
	case PEERS:
		return "Peers"
	case GET_TX_SET:
		return "TxSetHash"
	case TX_SET:
		return "TxSet"
	case GENERALIZED_TX_SET:
		return "GeneralizedTxSet"
	case TRANSACTION:
		return "Transaction"
	case SURVEY_REQUEST:
		return "SignedSurveyRequestMessage"
	case SURVEY_RESPONSE:
		return "SignedSurveyResponseMessage"
	case GET_SCP_QUORUMSET:
		return "QSetHash"
	case SCP_QUORUMSET:
		return "QSet"
	case SCP_MESSAGE:
		return "Envelope"
	case GET_SCP_STATE:
		return "GetSCPLedgerSeq"
	case SEND_MORE:
		return "SendMoreMessage"
	case SEND_MORE_EXTENDED:
		return "SendMoreExtendedMessage"
	case FLOOD_ADVERT:
		return "FloodAdvert"
	case FLOOD_DEMAND:
		return "FloodDemand"
	}
	return ""
}

type XdrType_StellarMessage = *StellarMessage

func (v *StellarMessage) XdrPointer() interface{}       { return v }
func (StellarMessage) XdrTypeName() string              { return "StellarMessage" }
func (v StellarMessage) XdrValue() interface{}          { return v }
func (v *StellarMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *StellarMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MessageType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ERROR_MSG:
		x.Marshal(x.Sprintf("%serror", name), XDR_Error(u.Error()))
		return
	case HELLO:
		x.Marshal(x.Sprintf("%shello", name), XDR_Hello(u.Hello()))
		return
	case AUTH:
		x.Marshal(x.Sprintf("%sauth", name), XDR_Auth(u.Auth()))
		return
	case DONT_HAVE:
		x.Marshal(x.Sprintf("%sdontHave", name), XDR_DontHave(u.DontHave()))
		return
	case GET_PEERS:
		return
	case PEERS:
		x.Marshal(x.Sprintf("%speers", name), (*_XdrVec_100_PeerAddress)(u.Peers()))
		return
	case GET_TX_SET:
		x.Marshal(x.Sprintf("%stxSetHash", name), XDR_Uint256(u.TxSetHash()))
		return
	case TX_SET:
		x.Marshal(x.Sprintf("%stxSet", name), XDR_TransactionSet(u.TxSet()))
		return
	case GENERALIZED_TX_SET:
		x.Marshal(x.Sprintf("%sgeneralizedTxSet", name), XDR_GeneralizedTransactionSet(u.GeneralizedTxSet()))
		return
	case TRANSACTION:
		x.Marshal(x.Sprintf("%stransaction", name), XDR_TransactionEnvelope(u.Transaction()))
		return
	case SURVEY_REQUEST:
		x.Marshal(x.Sprintf("%ssignedSurveyRequestMessage", name), XDR_SignedSurveyRequestMessage(u.SignedSurveyRequestMessage()))
		return
	case SURVEY_RESPONSE:
		x.Marshal(x.Sprintf("%ssignedSurveyResponseMessage", name), XDR_SignedSurveyResponseMessage(u.SignedSurveyResponseMessage()))
		return
	case GET_SCP_QUORUMSET:
		x.Marshal(x.Sprintf("%sqSetHash", name), XDR_Uint256(u.QSetHash()))
		return
	case SCP_QUORUMSET:
		x.Marshal(x.Sprintf("%sqSet", name), XDR_SCPQuorumSet(u.QSet()))
		return
	case SCP_MESSAGE:
		x.Marshal(x.Sprintf("%senvelope", name), XDR_SCPEnvelope(u.Envelope()))
		return
	case GET_SCP_STATE:
		x.Marshal(x.Sprintf("%sgetSCPLedgerSeq", name), XDR_Uint32(u.GetSCPLedgerSeq()))
		return
	case SEND_MORE:
		x.Marshal(x.Sprintf("%ssendMoreMessage", name), XDR_SendMore(u.SendMoreMessage()))
		return
	case SEND_MORE_EXTENDED:
		x.Marshal(x.Sprintf("%ssendMoreExtendedMessage", name), XDR_SendMoreExtended(u.SendMoreExtendedMessage()))
		return
	case FLOOD_ADVERT:
		x.Marshal(x.Sprintf("%sfloodAdvert", name), XDR_FloodAdvert(u.FloodAdvert()))
		return
	case FLOOD_DEMAND:
		x.Marshal(x.Sprintf("%sfloodDemand", name), XDR_FloodDemand(u.FloodDemand()))
		return
	}
	XdrPanic("invalid Type (%v) in StellarMessage", u.Type)
}
func XDR_StellarMessage(v *StellarMessage) *StellarMessage { return v }

type XdrType_XdrAnon_AuthenticatedMessage_V0 = *XdrAnon_AuthenticatedMessage_V0

func (v *XdrAnon_AuthenticatedMessage_V0) XdrPointer() interface{}       { return v }
func (XdrAnon_AuthenticatedMessage_V0) XdrTypeName() string              { return "XdrAnon_AuthenticatedMessage_V0" }
func (v XdrAnon_AuthenticatedMessage_V0) XdrValue() interface{}          { return v }
func (v *XdrAnon_AuthenticatedMessage_V0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_AuthenticatedMessage_V0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssequence", name), XDR_Uint64(&v.Sequence))
	x.Marshal(x.Sprintf("%smessage", name), XDR_StellarMessage(&v.Message))
	x.Marshal(x.Sprintf("%smac", name), XDR_HmacSha256Mac(&v.Mac))
}
func XDR_XdrAnon_AuthenticatedMessage_V0(v *XdrAnon_AuthenticatedMessage_V0) *XdrAnon_AuthenticatedMessage_V0 {
	return v
}

var _XdrTags_AuthenticatedMessage = map[int32]bool{
	XdrToI32(0): true,
}

func (_ AuthenticatedMessage) XdrValidTags() map[int32]bool {
	return _XdrTags_AuthenticatedMessage
}
func (u *AuthenticatedMessage) V0() *XdrAnon_AuthenticatedMessage_V0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*XdrAnon_AuthenticatedMessage_V0); ok {
			return v
		} else {
			var zero XdrAnon_AuthenticatedMessage_V0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AuthenticatedMessage.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u AuthenticatedMessage) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *AuthenticatedMessage) XdrUnionTag() XdrNum32 {
	return XDR_Uint32(&u.V)
}
func (u *AuthenticatedMessage) XdrUnionTagName() string {
	return "V"
}
func (u *AuthenticatedMessage) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_XdrAnon_AuthenticatedMessage_V0(u.V0())
	}
	return nil
}
func (u *AuthenticatedMessage) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}

type XdrType_AuthenticatedMessage = *AuthenticatedMessage

func (v *AuthenticatedMessage) XdrPointer() interface{}       { return v }
func (AuthenticatedMessage) XdrTypeName() string              { return "AuthenticatedMessage" }
func (v AuthenticatedMessage) XdrValue() interface{}          { return v }
func (v *AuthenticatedMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AuthenticatedMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_XdrAnon_AuthenticatedMessage_V0(u.V0()))
		return
	}
	XdrPanic("invalid V (%v) in AuthenticatedMessage", u.V)
}
func XDR_AuthenticatedMessage(v *AuthenticatedMessage) *AuthenticatedMessage { return v }

var _XdrTags_LiquidityPoolParameters = map[int32]bool{
	XdrToI32(LIQUIDITY_POOL_CONSTANT_PRODUCT): true,
}

func (_ LiquidityPoolParameters) XdrValidTags() map[int32]bool {
	return _XdrTags_LiquidityPoolParameters
}
func (u *LiquidityPoolParameters) ConstantProduct() *LiquidityPoolConstantProductParameters {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		if v, ok := u._u.(*LiquidityPoolConstantProductParameters); ok {
			return v
		} else {
			var zero LiquidityPoolConstantProductParameters
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LiquidityPoolParameters.ConstantProduct accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LiquidityPoolParameters) XdrValid() bool {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return true
	}
	return false
}
func (u *LiquidityPoolParameters) XdrUnionTag() XdrNum32 {
	return XDR_LiquidityPoolType(&u.Type)
}
func (u *LiquidityPoolParameters) XdrUnionTagName() string {
	return "Type"
}
func (u *LiquidityPoolParameters) XdrUnionBody() XdrType {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return XDR_LiquidityPoolConstantProductParameters(u.ConstantProduct())
	}
	return nil
}
func (u *LiquidityPoolParameters) XdrUnionBodyName() string {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return "ConstantProduct"
	}
	return ""
}

type XdrType_LiquidityPoolParameters = *LiquidityPoolParameters

func (v *LiquidityPoolParameters) XdrPointer() interface{}       { return v }
func (LiquidityPoolParameters) XdrTypeName() string              { return "LiquidityPoolParameters" }
func (v LiquidityPoolParameters) XdrValue() interface{}          { return v }
func (v *LiquidityPoolParameters) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LiquidityPoolParameters) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LiquidityPoolType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		x.Marshal(x.Sprintf("%sconstantProduct", name), XDR_LiquidityPoolConstantProductParameters(u.ConstantProduct()))
		return
	}
	XdrPanic("invalid Type (%v) in LiquidityPoolParameters", u.Type)
}
func XDR_LiquidityPoolParameters(v *LiquidityPoolParameters) *LiquidityPoolParameters { return v }

type XdrType_XdrAnon_MuxedAccount_Med25519 = *XdrAnon_MuxedAccount_Med25519

func (v *XdrAnon_MuxedAccount_Med25519) XdrPointer() interface{}       { return v }
func (XdrAnon_MuxedAccount_Med25519) XdrTypeName() string              { return "XdrAnon_MuxedAccount_Med25519" }
func (v XdrAnon_MuxedAccount_Med25519) XdrValue() interface{}          { return v }
func (v *XdrAnon_MuxedAccount_Med25519) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_MuxedAccount_Med25519) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sid", name), XDR_Uint64(&v.Id))
	x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(&v.Ed25519))
}
func XDR_XdrAnon_MuxedAccount_Med25519(v *XdrAnon_MuxedAccount_Med25519) *XdrAnon_MuxedAccount_Med25519 {
	return v
}

var _XdrTags_MuxedAccount = map[int32]bool{
	XdrToI32(KEY_TYPE_ED25519):       true,
	XdrToI32(KEY_TYPE_MUXED_ED25519): true,
}

func (_ MuxedAccount) XdrValidTags() map[int32]bool {
	return _XdrTags_MuxedAccount
}
func (u *MuxedAccount) Ed25519() *Uint256 {
	switch u.Type {
	case KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("MuxedAccount.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *MuxedAccount) Med25519() *XdrAnon_MuxedAccount_Med25519 {
	switch u.Type {
	case KEY_TYPE_MUXED_ED25519:
		if v, ok := u._u.(*XdrAnon_MuxedAccount_Med25519); ok {
			return v
		} else {
			var zero XdrAnon_MuxedAccount_Med25519
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("MuxedAccount.Med25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u MuxedAccount) XdrValid() bool {
	switch u.Type {
	case KEY_TYPE_ED25519, KEY_TYPE_MUXED_ED25519:
		return true
	}
	return false
}
func (u *MuxedAccount) XdrUnionTag() XdrNum32 {
	return XDR_CryptoKeyType(&u.Type)
}
func (u *MuxedAccount) XdrUnionTagName() string {
	return "Type"
}
func (u *MuxedAccount) XdrUnionBody() XdrType {
	switch u.Type {
	case KEY_TYPE_ED25519:
		return XDR_Uint256(u.Ed25519())
	case KEY_TYPE_MUXED_ED25519:
		return XDR_XdrAnon_MuxedAccount_Med25519(u.Med25519())
	}
	return nil
}
func (u *MuxedAccount) XdrUnionBodyName() string {
	switch u.Type {
	case KEY_TYPE_ED25519:
		return "Ed25519"
	case KEY_TYPE_MUXED_ED25519:
		return "Med25519"
	}
	return ""
}

type XdrType_MuxedAccount = *MuxedAccount

func (v *MuxedAccount) XdrPointer() interface{}       { return v }
func (MuxedAccount) XdrTypeName() string              { return "MuxedAccount" }
func (v MuxedAccount) XdrValue() interface{}          { return v }
func (v *MuxedAccount) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *MuxedAccount) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_CryptoKeyType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case KEY_TYPE_ED25519:
		x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(u.Ed25519()))
		return
	case KEY_TYPE_MUXED_ED25519:
		x.Marshal(x.Sprintf("%smed25519", name), XDR_XdrAnon_MuxedAccount_Med25519(u.Med25519()))
		return
	}
	XdrPanic("invalid Type (%v) in MuxedAccount", u.Type)
}
func XDR_MuxedAccount(v *MuxedAccount) *MuxedAccount { return v }

type XdrType_DecoratedSignature = *DecoratedSignature

func (v *DecoratedSignature) XdrPointer() interface{}       { return v }
func (DecoratedSignature) XdrTypeName() string              { return "DecoratedSignature" }
func (v DecoratedSignature) XdrValue() interface{}          { return v }
func (v *DecoratedSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DecoratedSignature) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shint", name), XDR_SignatureHint(&v.Hint))
	x.Marshal(x.Sprintf("%ssignature", name), XDR_Signature(&v.Signature))
}
func XDR_DecoratedSignature(v *DecoratedSignature) *DecoratedSignature { return v }

var _XdrNames_OperationType = map[int32]string{
	int32(CREATE_ACCOUNT):                   "CREATE_ACCOUNT",
	int32(PAYMENT):                          "PAYMENT",
	int32(PATH_PAYMENT_STRICT_RECEIVE):      "PATH_PAYMENT_STRICT_RECEIVE",
	int32(MANAGE_SELL_OFFER):                "MANAGE_SELL_OFFER",
	int32(CREATE_PASSIVE_SELL_OFFER):        "CREATE_PASSIVE_SELL_OFFER",
	int32(SET_OPTIONS):                      "SET_OPTIONS",
	int32(CHANGE_TRUST):                     "CHANGE_TRUST",
	int32(ALLOW_TRUST):                      "ALLOW_TRUST",
	int32(ACCOUNT_MERGE):                    "ACCOUNT_MERGE",
	int32(INFLATION):                        "INFLATION",
	int32(MANAGE_DATA):                      "MANAGE_DATA",
	int32(BUMP_SEQUENCE):                    "BUMP_SEQUENCE",
	int32(MANAGE_BUY_OFFER):                 "MANAGE_BUY_OFFER",
	int32(PATH_PAYMENT_STRICT_SEND):         "PATH_PAYMENT_STRICT_SEND",
	int32(CREATE_CLAIMABLE_BALANCE):         "CREATE_CLAIMABLE_BALANCE",
	int32(CLAIM_CLAIMABLE_BALANCE):          "CLAIM_CLAIMABLE_BALANCE",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES): "BEGIN_SPONSORING_FUTURE_RESERVES",
	int32(END_SPONSORING_FUTURE_RESERVES):   "END_SPONSORING_FUTURE_RESERVES",
	int32(REVOKE_SPONSORSHIP):               "REVOKE_SPONSORSHIP",
	int32(CLAWBACK):                         "CLAWBACK",
	int32(CLAWBACK_CLAIMABLE_BALANCE):       "CLAWBACK_CLAIMABLE_BALANCE",
	int32(SET_TRUST_LINE_FLAGS):             "SET_TRUST_LINE_FLAGS",
	int32(LIQUIDITY_POOL_DEPOSIT):           "LIQUIDITY_POOL_DEPOSIT",
	int32(LIQUIDITY_POOL_WITHDRAW):          "LIQUIDITY_POOL_WITHDRAW",
	int32(INVOKE_HOST_FUNCTION):             "INVOKE_HOST_FUNCTION",
	int32(EXTEND_FOOTPRINT_TTL):             "EXTEND_FOOTPRINT_TTL",
	int32(RESTORE_FOOTPRINT):                "RESTORE_FOOTPRINT",
}
var _XdrValues_OperationType = map[string]int32{
	"CREATE_ACCOUNT":                   int32(CREATE_ACCOUNT),
	"PAYMENT":                          int32(PAYMENT),
	"PATH_PAYMENT_STRICT_RECEIVE":      int32(PATH_PAYMENT_STRICT_RECEIVE),
	"MANAGE_SELL_OFFER":                int32(MANAGE_SELL_OFFER),
	"CREATE_PASSIVE_SELL_OFFER":        int32(CREATE_PASSIVE_SELL_OFFER),
	"SET_OPTIONS":                      int32(SET_OPTIONS),
	"CHANGE_TRUST":                     int32(CHANGE_TRUST),
	"ALLOW_TRUST":                      int32(ALLOW_TRUST),
	"ACCOUNT_MERGE":                    int32(ACCOUNT_MERGE),
	"INFLATION":                        int32(INFLATION),
	"MANAGE_DATA":                      int32(MANAGE_DATA),
	"BUMP_SEQUENCE":                    int32(BUMP_SEQUENCE),
	"MANAGE_BUY_OFFER":                 int32(MANAGE_BUY_OFFER),
	"PATH_PAYMENT_STRICT_SEND":         int32(PATH_PAYMENT_STRICT_SEND),
	"CREATE_CLAIMABLE_BALANCE":         int32(CREATE_CLAIMABLE_BALANCE),
	"CLAIM_CLAIMABLE_BALANCE":          int32(CLAIM_CLAIMABLE_BALANCE),
	"BEGIN_SPONSORING_FUTURE_RESERVES": int32(BEGIN_SPONSORING_FUTURE_RESERVES),
	"END_SPONSORING_FUTURE_RESERVES":   int32(END_SPONSORING_FUTURE_RESERVES),
	"REVOKE_SPONSORSHIP":               int32(REVOKE_SPONSORSHIP),
	"CLAWBACK":                         int32(CLAWBACK),
	"CLAWBACK_CLAIMABLE_BALANCE":       int32(CLAWBACK_CLAIMABLE_BALANCE),
	"SET_TRUST_LINE_FLAGS":             int32(SET_TRUST_LINE_FLAGS),
	"LIQUIDITY_POOL_DEPOSIT":           int32(LIQUIDITY_POOL_DEPOSIT),
	"LIQUIDITY_POOL_WITHDRAW":          int32(LIQUIDITY_POOL_WITHDRAW),
	"INVOKE_HOST_FUNCTION":             int32(INVOKE_HOST_FUNCTION),
	"EXTEND_FOOTPRINT_TTL":             int32(EXTEND_FOOTPRINT_TTL),
	"RESTORE_FOOTPRINT":                int32(RESTORE_FOOTPRINT),
}

func (OperationType) XdrEnumNames() map[int32]string {
	return _XdrNames_OperationType
}
func (v OperationType) String() string {
	if s, ok := _XdrNames_OperationType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OperationType#%d", v)
}
func (v *OperationType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OperationType[stok]; ok {
			*v = OperationType(val)
			return nil
		} else if stok == "OperationType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OperationType.", stok))
	}
}
func (v OperationType) GetU32() uint32                 { return uint32(v) }
func (v *OperationType) SetU32(n uint32)               { *v = OperationType(n) }
func (v *OperationType) XdrPointer() interface{}       { return v }
func (OperationType) XdrTypeName() string              { return "OperationType" }
func (v OperationType) XdrValue() interface{}          { return v }
func (v *OperationType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_OperationType = *OperationType

func XDR_OperationType(v *OperationType) *OperationType { return v }

type XdrType_CreateAccountOp = *CreateAccountOp

func (v *CreateAccountOp) XdrPointer() interface{}       { return v }
func (CreateAccountOp) XdrTypeName() string              { return "CreateAccountOp" }
func (v CreateAccountOp) XdrValue() interface{}          { return v }
func (v *CreateAccountOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreateAccountOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_AccountID(&v.Destination))
	x.Marshal(x.Sprintf("%sstartingBalance", name), XDR_Int64(&v.StartingBalance))
}
func XDR_CreateAccountOp(v *CreateAccountOp) *CreateAccountOp { return v }

type XdrType_PaymentOp = *PaymentOp

func (v *PaymentOp) XdrPointer() interface{}       { return v }
func (PaymentOp) XdrTypeName() string              { return "PaymentOp" }
func (v PaymentOp) XdrValue() interface{}          { return v }
func (v *PaymentOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PaymentOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_MuxedAccount(&v.Destination))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
}
func XDR_PaymentOp(v *PaymentOp) *PaymentOp { return v }

type _XdrVec_5_Asset []Asset

func (_XdrVec_5_Asset) XdrBound() uint32 {
	const bound uint32 = 5 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_5_Asset) XdrCheckLen(length uint32) {
	if length > uint32(5) {
		XdrPanic("_XdrVec_5_Asset length %d exceeds bound 5", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_5_Asset length %d exceeds max int", length)
	}
}
func (v _XdrVec_5_Asset) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_5_Asset) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(5); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Asset, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_5_Asset) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Asset(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_5_Asset) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 5}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_5_Asset) XdrTypeName() string              { return "Asset<>" }
func (v *_XdrVec_5_Asset) XdrPointer() interface{}       { return (*[]Asset)(v) }
func (v _XdrVec_5_Asset) XdrValue() interface{}          { return ([]Asset)(v) }
func (v *_XdrVec_5_Asset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PathPaymentStrictReceiveOp = *PathPaymentStrictReceiveOp

func (v *PathPaymentStrictReceiveOp) XdrPointer() interface{}       { return v }
func (PathPaymentStrictReceiveOp) XdrTypeName() string              { return "PathPaymentStrictReceiveOp" }
func (v PathPaymentStrictReceiveOp) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictReceiveOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PathPaymentStrictReceiveOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssendAsset", name), XDR_Asset(&v.SendAsset))
	x.Marshal(x.Sprintf("%ssendMax", name), XDR_Int64(&v.SendMax))
	x.Marshal(x.Sprintf("%sdestination", name), XDR_MuxedAccount(&v.Destination))
	x.Marshal(x.Sprintf("%sdestAsset", name), XDR_Asset(&v.DestAsset))
	x.Marshal(x.Sprintf("%sdestAmount", name), XDR_Int64(&v.DestAmount))
	x.Marshal(x.Sprintf("%spath", name), (*_XdrVec_5_Asset)(&v.Path))
}
func XDR_PathPaymentStrictReceiveOp(v *PathPaymentStrictReceiveOp) *PathPaymentStrictReceiveOp {
	return v
}

type XdrType_PathPaymentStrictSendOp = *PathPaymentStrictSendOp

func (v *PathPaymentStrictSendOp) XdrPointer() interface{}       { return v }
func (PathPaymentStrictSendOp) XdrTypeName() string              { return "PathPaymentStrictSendOp" }
func (v PathPaymentStrictSendOp) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictSendOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PathPaymentStrictSendOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssendAsset", name), XDR_Asset(&v.SendAsset))
	x.Marshal(x.Sprintf("%ssendAmount", name), XDR_Int64(&v.SendAmount))
	x.Marshal(x.Sprintf("%sdestination", name), XDR_MuxedAccount(&v.Destination))
	x.Marshal(x.Sprintf("%sdestAsset", name), XDR_Asset(&v.DestAsset))
	x.Marshal(x.Sprintf("%sdestMin", name), XDR_Int64(&v.DestMin))
	x.Marshal(x.Sprintf("%spath", name), (*_XdrVec_5_Asset)(&v.Path))
}
func XDR_PathPaymentStrictSendOp(v *PathPaymentStrictSendOp) *PathPaymentStrictSendOp { return v }

type XdrType_ManageSellOfferOp = *ManageSellOfferOp

func (v *ManageSellOfferOp) XdrPointer() interface{}       { return v }
func (ManageSellOfferOp) XdrTypeName() string              { return "ManageSellOfferOp" }
func (v ManageSellOfferOp) XdrValue() interface{}          { return v }
func (v *ManageSellOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageSellOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sselling", name), XDR_Asset(&v.Selling))
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Asset(&v.Buying))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sprice", name), XDR_Price(&v.Price))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
}
func XDR_ManageSellOfferOp(v *ManageSellOfferOp) *ManageSellOfferOp { return v }

type XdrType_ManageBuyOfferOp = *ManageBuyOfferOp

func (v *ManageBuyOfferOp) XdrPointer() interface{}       { return v }
func (ManageBuyOfferOp) XdrTypeName() string              { return "ManageBuyOfferOp" }
func (v ManageBuyOfferOp) XdrValue() interface{}          { return v }
func (v *ManageBuyOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageBuyOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sselling", name), XDR_Asset(&v.Selling))
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Asset(&v.Buying))
	x.Marshal(x.Sprintf("%sbuyAmount", name), XDR_Int64(&v.BuyAmount))
	x.Marshal(x.Sprintf("%sprice", name), XDR_Price(&v.Price))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
}
func XDR_ManageBuyOfferOp(v *ManageBuyOfferOp) *ManageBuyOfferOp { return v }

type XdrType_CreatePassiveSellOfferOp = *CreatePassiveSellOfferOp

func (v *CreatePassiveSellOfferOp) XdrPointer() interface{}       { return v }
func (CreatePassiveSellOfferOp) XdrTypeName() string              { return "CreatePassiveSellOfferOp" }
func (v CreatePassiveSellOfferOp) XdrValue() interface{}          { return v }
func (v *CreatePassiveSellOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreatePassiveSellOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sselling", name), XDR_Asset(&v.Selling))
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Asset(&v.Buying))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sprice", name), XDR_Price(&v.Price))
}
func XDR_CreatePassiveSellOfferOp(v *CreatePassiveSellOfferOp) *CreatePassiveSellOfferOp { return v }

type _XdrPtr_Uint32 struct {
	p **Uint32
}
type _ptrflag_Uint32 _XdrPtr_Uint32

func (v _ptrflag_Uint32) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Uint32) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Uint32 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Uint32) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Uint32) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Uint32)
		}
	default:
		XdrPanic("*Uint32 present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Uint32) XdrTypeName() string             { return "Uint32?" }
func (v _ptrflag_Uint32) XdrPointer() interface{}       { return nil }
func (v _ptrflag_Uint32) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_Uint32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Uint32) XdrBound() uint32              { return 1 }
func (v _XdrPtr_Uint32) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_Uint32) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Uint32)
	}
}
func (v _XdrPtr_Uint32) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Uint32(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Uint32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Uint32) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Uint32(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Uint32) XdrTypeName() string       { return "Uint32*" }
func (v _XdrPtr_Uint32) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Uint32) XdrValue() interface{}   { return *v.p }

type _XdrPtr_String32 struct {
	p **String32
}
type _ptrflag_String32 _XdrPtr_String32

func (v _ptrflag_String32) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_String32) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("String32 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_String32) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_String32) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(String32)
		}
	default:
		XdrPanic("*String32 present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_String32) XdrTypeName() string             { return "String32?" }
func (v _ptrflag_String32) XdrPointer() interface{}       { return nil }
func (v _ptrflag_String32) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_String32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_String32) XdrBound() uint32              { return 1 }
func (v _XdrPtr_String32) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_String32) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(String32)
	}
}
func (v _XdrPtr_String32) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_String32(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_String32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_String32) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_String32(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_String32) XdrTypeName() string       { return "String32*" }
func (v _XdrPtr_String32) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_String32) XdrValue() interface{}   { return *v.p }

type _XdrPtr_Signer struct {
	p **Signer
}
type _ptrflag_Signer _XdrPtr_Signer

func (v _ptrflag_Signer) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Signer) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Signer flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Signer) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Signer) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Signer)
		}
	default:
		XdrPanic("*Signer present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Signer) XdrTypeName() string             { return "Signer?" }
func (v _ptrflag_Signer) XdrPointer() interface{}       { return nil }
func (v _ptrflag_Signer) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Signer) XdrBound() uint32              { return 1 }
func (v _XdrPtr_Signer) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_Signer) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Signer)
	}
}
func (v _XdrPtr_Signer) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Signer(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Signer) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Signer(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Signer) XdrTypeName() string       { return "Signer*" }
func (v _XdrPtr_Signer) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Signer) XdrValue() interface{}   { return *v.p }

type XdrType_SetOptionsOp = *SetOptionsOp

func (v *SetOptionsOp) XdrPointer() interface{}       { return v }
func (SetOptionsOp) XdrTypeName() string              { return "SetOptionsOp" }
func (v SetOptionsOp) XdrValue() interface{}          { return v }
func (v *SetOptionsOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SetOptionsOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sinflationDest", name), _XdrPtr_AccountID{&v.InflationDest})
	x.Marshal(x.Sprintf("%sclearFlags", name), _XdrPtr_Uint32{&v.ClearFlags})
	x.Marshal(x.Sprintf("%ssetFlags", name), _XdrPtr_Uint32{&v.SetFlags})
	x.Marshal(x.Sprintf("%smasterWeight", name), _XdrPtr_Uint32{&v.MasterWeight})
	x.Marshal(x.Sprintf("%slowThreshold", name), _XdrPtr_Uint32{&v.LowThreshold})
	x.Marshal(x.Sprintf("%smedThreshold", name), _XdrPtr_Uint32{&v.MedThreshold})
	x.Marshal(x.Sprintf("%shighThreshold", name), _XdrPtr_Uint32{&v.HighThreshold})
	x.Marshal(x.Sprintf("%shomeDomain", name), _XdrPtr_String32{&v.HomeDomain})
	x.Marshal(x.Sprintf("%ssigner", name), _XdrPtr_Signer{&v.Signer})
}
func XDR_SetOptionsOp(v *SetOptionsOp) *SetOptionsOp { return v }

var _XdrTags_ChangeTrustAsset = map[int32]bool{
	XdrToI32(ASSET_TYPE_NATIVE):            true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM4):  true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM12): true,
	XdrToI32(ASSET_TYPE_POOL_SHARE):        true,
}

func (_ ChangeTrustAsset) XdrValidTags() map[int32]bool {
	return _XdrTags_ChangeTrustAsset
}
func (u *ChangeTrustAsset) AlphaNum4() *AlphaNum4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AlphaNum4); ok {
			return v
		} else {
			var zero AlphaNum4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ChangeTrustAsset.AlphaNum4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ChangeTrustAsset) AlphaNum12() *AlphaNum12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AlphaNum12); ok {
			return v
		} else {
			var zero AlphaNum12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ChangeTrustAsset.AlphaNum12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ChangeTrustAsset) LiquidityPool() *LiquidityPoolParameters {
	switch u.Type {
	case ASSET_TYPE_POOL_SHARE:
		if v, ok := u._u.(*LiquidityPoolParameters); ok {
			return v
		} else {
			var zero LiquidityPoolParameters
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ChangeTrustAsset.LiquidityPool accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ChangeTrustAsset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_NATIVE, ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12, ASSET_TYPE_POOL_SHARE:
		return true
	}
	return false
}
func (u *ChangeTrustAsset) XdrUnionTag() XdrNum32 {
	return XDR_AssetType(&u.Type)
}
func (u *ChangeTrustAsset) XdrUnionTagName() string {
	return "Type"
}
func (u *ChangeTrustAsset) XdrUnionBody() XdrType {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return nil
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return XDR_AlphaNum4(u.AlphaNum4())
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return XDR_AlphaNum12(u.AlphaNum12())
	case ASSET_TYPE_POOL_SHARE:
		return XDR_LiquidityPoolParameters(u.LiquidityPool())
	}
	return nil
}
func (u *ChangeTrustAsset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return ""
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AlphaNum4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AlphaNum12"
	case ASSET_TYPE_POOL_SHARE:
		return "LiquidityPool"
	}
	return ""
}

type XdrType_ChangeTrustAsset = *ChangeTrustAsset

func (v *ChangeTrustAsset) XdrPointer() interface{}       { return v }
func (ChangeTrustAsset) XdrTypeName() string              { return "ChangeTrustAsset" }
func (v ChangeTrustAsset) XdrValue() interface{}          { return v }
func (v *ChangeTrustAsset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ChangeTrustAsset) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		x.Marshal(x.Sprintf("%salphaNum4", name), XDR_AlphaNum4(u.AlphaNum4()))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		x.Marshal(x.Sprintf("%salphaNum12", name), XDR_AlphaNum12(u.AlphaNum12()))
		return
	case ASSET_TYPE_POOL_SHARE:
		x.Marshal(x.Sprintf("%sliquidityPool", name), XDR_LiquidityPoolParameters(u.LiquidityPool()))
		return
	}
	XdrPanic("invalid Type (%v) in ChangeTrustAsset", u.Type)
}
func XDR_ChangeTrustAsset(v *ChangeTrustAsset) *ChangeTrustAsset { return v }

type XdrType_ChangeTrustOp = *ChangeTrustOp

func (v *ChangeTrustOp) XdrPointer() interface{}       { return v }
func (ChangeTrustOp) XdrTypeName() string              { return "ChangeTrustOp" }
func (v ChangeTrustOp) XdrValue() interface{}          { return v }
func (v *ChangeTrustOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ChangeTrustOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sline", name), XDR_ChangeTrustAsset(&v.Line))
	x.Marshal(x.Sprintf("%slimit", name), XDR_Int64(&v.Limit))
}
func XDR_ChangeTrustOp(v *ChangeTrustOp) *ChangeTrustOp { return v }

type XdrType_AllowTrustOp = *AllowTrustOp

func (v *AllowTrustOp) XdrPointer() interface{}       { return v }
func (AllowTrustOp) XdrTypeName() string              { return "AllowTrustOp" }
func (v AllowTrustOp) XdrValue() interface{}          { return v }
func (v *AllowTrustOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AllowTrustOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%strustor", name), XDR_AccountID(&v.Trustor))
	x.Marshal(x.Sprintf("%sasset", name), XDR_AssetCode(&v.Asset))
	x.Marshal(x.Sprintf("%sauthorize", name), XDR_Uint32(&v.Authorize))
}
func XDR_AllowTrustOp(v *AllowTrustOp) *AllowTrustOp { return v }

type _XdrPtr_DataValue struct {
	p **DataValue
}
type _ptrflag_DataValue _XdrPtr_DataValue

func (v _ptrflag_DataValue) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_DataValue) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("DataValue flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_DataValue) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_DataValue) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(DataValue)
		}
	default:
		XdrPanic("*DataValue present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_DataValue) XdrTypeName() string             { return "DataValue?" }
func (v _ptrflag_DataValue) XdrPointer() interface{}       { return nil }
func (v _ptrflag_DataValue) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_DataValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_DataValue) XdrBound() uint32              { return 1 }
func (v _XdrPtr_DataValue) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_DataValue) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(DataValue)
	}
}
func (v _XdrPtr_DataValue) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_DataValue(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_DataValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_DataValue) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_DataValue(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_DataValue) XdrTypeName() string       { return "DataValue*" }
func (v _XdrPtr_DataValue) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_DataValue) XdrValue() interface{}   { return *v.p }

type XdrType_ManageDataOp = *ManageDataOp

func (v *ManageDataOp) XdrPointer() interface{}       { return v }
func (ManageDataOp) XdrTypeName() string              { return "ManageDataOp" }
func (v ManageDataOp) XdrValue() interface{}          { return v }
func (v *ManageDataOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageDataOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdataName", name), XDR_String64(&v.DataName))
	x.Marshal(x.Sprintf("%sdataValue", name), _XdrPtr_DataValue{&v.DataValue})
}
func XDR_ManageDataOp(v *ManageDataOp) *ManageDataOp { return v }

type XdrType_BumpSequenceOp = *BumpSequenceOp

func (v *BumpSequenceOp) XdrPointer() interface{}       { return v }
func (BumpSequenceOp) XdrTypeName() string              { return "BumpSequenceOp" }
func (v BumpSequenceOp) XdrValue() interface{}          { return v }
func (v *BumpSequenceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BumpSequenceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbumpTo", name), XDR_SequenceNumber(&v.BumpTo))
}
func XDR_BumpSequenceOp(v *BumpSequenceOp) *BumpSequenceOp { return v }

type XdrType_CreateClaimableBalanceOp = *CreateClaimableBalanceOp

func (v *CreateClaimableBalanceOp) XdrPointer() interface{}       { return v }
func (CreateClaimableBalanceOp) XdrTypeName() string              { return "CreateClaimableBalanceOp" }
func (v CreateClaimableBalanceOp) XdrValue() interface{}          { return v }
func (v *CreateClaimableBalanceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreateClaimableBalanceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sclaimants", name), (*_XdrVec_10_Claimant)(&v.Claimants))
}
func XDR_CreateClaimableBalanceOp(v *CreateClaimableBalanceOp) *CreateClaimableBalanceOp { return v }

type XdrType_ClaimClaimableBalanceOp = *ClaimClaimableBalanceOp

func (v *ClaimClaimableBalanceOp) XdrPointer() interface{}       { return v }
func (ClaimClaimableBalanceOp) XdrTypeName() string              { return "ClaimClaimableBalanceOp" }
func (v ClaimClaimableBalanceOp) XdrValue() interface{}          { return v }
func (v *ClaimClaimableBalanceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimClaimableBalanceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(&v.BalanceID))
}
func XDR_ClaimClaimableBalanceOp(v *ClaimClaimableBalanceOp) *ClaimClaimableBalanceOp { return v }

type XdrType_BeginSponsoringFutureReservesOp = *BeginSponsoringFutureReservesOp

func (v *BeginSponsoringFutureReservesOp) XdrPointer() interface{}       { return v }
func (BeginSponsoringFutureReservesOp) XdrTypeName() string              { return "BeginSponsoringFutureReservesOp" }
func (v BeginSponsoringFutureReservesOp) XdrValue() interface{}          { return v }
func (v *BeginSponsoringFutureReservesOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BeginSponsoringFutureReservesOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssponsoredID", name), XDR_AccountID(&v.SponsoredID))
}
func XDR_BeginSponsoringFutureReservesOp(v *BeginSponsoringFutureReservesOp) *BeginSponsoringFutureReservesOp {
	return v
}

var _XdrNames_RevokeSponsorshipType = map[int32]string{
	int32(REVOKE_SPONSORSHIP_LEDGER_ENTRY): "REVOKE_SPONSORSHIP_LEDGER_ENTRY",
	int32(REVOKE_SPONSORSHIP_SIGNER):       "REVOKE_SPONSORSHIP_SIGNER",
}
var _XdrValues_RevokeSponsorshipType = map[string]int32{
	"REVOKE_SPONSORSHIP_LEDGER_ENTRY": int32(REVOKE_SPONSORSHIP_LEDGER_ENTRY),
	"REVOKE_SPONSORSHIP_SIGNER":       int32(REVOKE_SPONSORSHIP_SIGNER),
}

func (RevokeSponsorshipType) XdrEnumNames() map[int32]string {
	return _XdrNames_RevokeSponsorshipType
}
func (v RevokeSponsorshipType) String() string {
	if s, ok := _XdrNames_RevokeSponsorshipType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("RevokeSponsorshipType#%d", v)
}
func (v *RevokeSponsorshipType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_RevokeSponsorshipType[stok]; ok {
			*v = RevokeSponsorshipType(val)
			return nil
		} else if stok == "RevokeSponsorshipType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid RevokeSponsorshipType.", stok))
	}
}
func (v RevokeSponsorshipType) GetU32() uint32                 { return uint32(v) }
func (v *RevokeSponsorshipType) SetU32(n uint32)               { *v = RevokeSponsorshipType(n) }
func (v *RevokeSponsorshipType) XdrPointer() interface{}       { return v }
func (RevokeSponsorshipType) XdrTypeName() string              { return "RevokeSponsorshipType" }
func (v RevokeSponsorshipType) XdrValue() interface{}          { return v }
func (v *RevokeSponsorshipType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_RevokeSponsorshipType = *RevokeSponsorshipType

func XDR_RevokeSponsorshipType(v *RevokeSponsorshipType) *RevokeSponsorshipType { return v }

type XdrType_XdrAnon_RevokeSponsorshipOp_Signer = *XdrAnon_RevokeSponsorshipOp_Signer

func (v *XdrAnon_RevokeSponsorshipOp_Signer) XdrPointer() interface{} { return v }
func (XdrAnon_RevokeSponsorshipOp_Signer) XdrTypeName() string {
	return "XdrAnon_RevokeSponsorshipOp_Signer"
}
func (v XdrAnon_RevokeSponsorshipOp_Signer) XdrValue() interface{}          { return v }
func (v *XdrAnon_RevokeSponsorshipOp_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_RevokeSponsorshipOp_Signer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%ssignerKey", name), XDR_SignerKey(&v.SignerKey))
}
func XDR_XdrAnon_RevokeSponsorshipOp_Signer(v *XdrAnon_RevokeSponsorshipOp_Signer) *XdrAnon_RevokeSponsorshipOp_Signer {
	return v
}

var _XdrTags_RevokeSponsorshipOp = map[int32]bool{
	XdrToI32(REVOKE_SPONSORSHIP_LEDGER_ENTRY): true,
	XdrToI32(REVOKE_SPONSORSHIP_SIGNER):       true,
}

func (_ RevokeSponsorshipOp) XdrValidTags() map[int32]bool {
	return _XdrTags_RevokeSponsorshipOp
}
func (u *RevokeSponsorshipOp) LedgerKey() *LedgerKey {
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("RevokeSponsorshipOp.LedgerKey accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *RevokeSponsorshipOp) Signer() *XdrAnon_RevokeSponsorshipOp_Signer {
	switch u.Type {
	case REVOKE_SPONSORSHIP_SIGNER:
		if v, ok := u._u.(*XdrAnon_RevokeSponsorshipOp_Signer); ok {
			return v
		} else {
			var zero XdrAnon_RevokeSponsorshipOp_Signer
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("RevokeSponsorshipOp.Signer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u RevokeSponsorshipOp) XdrValid() bool {
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY, REVOKE_SPONSORSHIP_SIGNER:
		return true
	}
	return false
}
func (u *RevokeSponsorshipOp) XdrUnionTag() XdrNum32 {
	return XDR_RevokeSponsorshipType(&u.Type)
}
func (u *RevokeSponsorshipOp) XdrUnionTagName() string {
	return "Type"
}
func (u *RevokeSponsorshipOp) XdrUnionBody() XdrType {
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
		return XDR_LedgerKey(u.LedgerKey())
	case REVOKE_SPONSORSHIP_SIGNER:
		return XDR_XdrAnon_RevokeSponsorshipOp_Signer(u.Signer())
	}
	return nil
}
func (u *RevokeSponsorshipOp) XdrUnionBodyName() string {
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
		return "LedgerKey"
	case REVOKE_SPONSORSHIP_SIGNER:
		return "Signer"
	}
	return ""
}

type XdrType_RevokeSponsorshipOp = *RevokeSponsorshipOp

func (v *RevokeSponsorshipOp) XdrPointer() interface{}       { return v }
func (RevokeSponsorshipOp) XdrTypeName() string              { return "RevokeSponsorshipOp" }
func (v RevokeSponsorshipOp) XdrValue() interface{}          { return v }
func (v *RevokeSponsorshipOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *RevokeSponsorshipOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_RevokeSponsorshipType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
		x.Marshal(x.Sprintf("%sledgerKey", name), XDR_LedgerKey(u.LedgerKey()))
		return
	case REVOKE_SPONSORSHIP_SIGNER:
		x.Marshal(x.Sprintf("%ssigner", name), XDR_XdrAnon_RevokeSponsorshipOp_Signer(u.Signer()))
		return
	}
	XdrPanic("invalid Type (%v) in RevokeSponsorshipOp", u.Type)
}
func XDR_RevokeSponsorshipOp(v *RevokeSponsorshipOp) *RevokeSponsorshipOp { return v }

type XdrType_ClawbackOp = *ClawbackOp

func (v *ClawbackOp) XdrPointer() interface{}       { return v }
func (ClawbackOp) XdrTypeName() string              { return "ClawbackOp" }
func (v ClawbackOp) XdrValue() interface{}          { return v }
func (v *ClawbackOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClawbackOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%sfrom", name), XDR_MuxedAccount(&v.From))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
}
func XDR_ClawbackOp(v *ClawbackOp) *ClawbackOp { return v }

type XdrType_ClawbackClaimableBalanceOp = *ClawbackClaimableBalanceOp

func (v *ClawbackClaimableBalanceOp) XdrPointer() interface{}       { return v }
func (ClawbackClaimableBalanceOp) XdrTypeName() string              { return "ClawbackClaimableBalanceOp" }
func (v ClawbackClaimableBalanceOp) XdrValue() interface{}          { return v }
func (v *ClawbackClaimableBalanceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClawbackClaimableBalanceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(&v.BalanceID))
}
func XDR_ClawbackClaimableBalanceOp(v *ClawbackClaimableBalanceOp) *ClawbackClaimableBalanceOp {
	return v
}

type XdrType_SetTrustLineFlagsOp = *SetTrustLineFlagsOp

func (v *SetTrustLineFlagsOp) XdrPointer() interface{}       { return v }
func (SetTrustLineFlagsOp) XdrTypeName() string              { return "SetTrustLineFlagsOp" }
func (v SetTrustLineFlagsOp) XdrValue() interface{}          { return v }
func (v *SetTrustLineFlagsOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SetTrustLineFlagsOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%strustor", name), XDR_AccountID(&v.Trustor))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%sclearFlags", name), XDR_Uint32(&v.ClearFlags))
	x.Marshal(x.Sprintf("%ssetFlags", name), XDR_Uint32(&v.SetFlags))
}
func XDR_SetTrustLineFlagsOp(v *SetTrustLineFlagsOp) *SetTrustLineFlagsOp { return v }

type XdrType_LiquidityPoolDepositOp = *LiquidityPoolDepositOp

func (v *LiquidityPoolDepositOp) XdrPointer() interface{}       { return v }
func (LiquidityPoolDepositOp) XdrTypeName() string              { return "LiquidityPoolDepositOp" }
func (v LiquidityPoolDepositOp) XdrValue() interface{}          { return v }
func (v *LiquidityPoolDepositOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LiquidityPoolDepositOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%smaxAmountA", name), XDR_Int64(&v.MaxAmountA))
	x.Marshal(x.Sprintf("%smaxAmountB", name), XDR_Int64(&v.MaxAmountB))
	x.Marshal(x.Sprintf("%sminPrice", name), XDR_Price(&v.MinPrice))
	x.Marshal(x.Sprintf("%smaxPrice", name), XDR_Price(&v.MaxPrice))
}
func XDR_LiquidityPoolDepositOp(v *LiquidityPoolDepositOp) *LiquidityPoolDepositOp { return v }

type XdrType_LiquidityPoolWithdrawOp = *LiquidityPoolWithdrawOp

func (v *LiquidityPoolWithdrawOp) XdrPointer() interface{}       { return v }
func (LiquidityPoolWithdrawOp) XdrTypeName() string              { return "LiquidityPoolWithdrawOp" }
func (v LiquidityPoolWithdrawOp) XdrValue() interface{}          { return v }
func (v *LiquidityPoolWithdrawOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LiquidityPoolWithdrawOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sminAmountA", name), XDR_Int64(&v.MinAmountA))
	x.Marshal(x.Sprintf("%sminAmountB", name), XDR_Int64(&v.MinAmountB))
}
func XDR_LiquidityPoolWithdrawOp(v *LiquidityPoolWithdrawOp) *LiquidityPoolWithdrawOp { return v }

var _XdrNames_HostFunctionType = map[int32]string{
	int32(HOST_FUNCTION_TYPE_INVOKE_CONTRACT):      "HOST_FUNCTION_TYPE_INVOKE_CONTRACT",
	int32(HOST_FUNCTION_TYPE_CREATE_CONTRACT):      "HOST_FUNCTION_TYPE_CREATE_CONTRACT",
	int32(HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM): "HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM",
}
var _XdrValues_HostFunctionType = map[string]int32{
	"HOST_FUNCTION_TYPE_INVOKE_CONTRACT":      int32(HOST_FUNCTION_TYPE_INVOKE_CONTRACT),
	"HOST_FUNCTION_TYPE_CREATE_CONTRACT":      int32(HOST_FUNCTION_TYPE_CREATE_CONTRACT),
	"HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM": int32(HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM),
}

func (HostFunctionType) XdrEnumNames() map[int32]string {
	return _XdrNames_HostFunctionType
}
func (v HostFunctionType) String() string {
	if s, ok := _XdrNames_HostFunctionType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("HostFunctionType#%d", v)
}
func (v *HostFunctionType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_HostFunctionType[stok]; ok {
			*v = HostFunctionType(val)
			return nil
		} else if stok == "HostFunctionType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid HostFunctionType.", stok))
	}
}
func (v HostFunctionType) GetU32() uint32                 { return uint32(v) }
func (v *HostFunctionType) SetU32(n uint32)               { *v = HostFunctionType(n) }
func (v *HostFunctionType) XdrPointer() interface{}       { return v }
func (HostFunctionType) XdrTypeName() string              { return "HostFunctionType" }
func (v HostFunctionType) XdrValue() interface{}          { return v }
func (v *HostFunctionType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_HostFunctionType = *HostFunctionType

func XDR_HostFunctionType(v *HostFunctionType) *HostFunctionType { return v }

var _XdrNames_ContractIDPreimageType = map[int32]string{
	int32(CONTRACT_ID_PREIMAGE_FROM_ADDRESS): "CONTRACT_ID_PREIMAGE_FROM_ADDRESS",
	int32(CONTRACT_ID_PREIMAGE_FROM_ASSET):   "CONTRACT_ID_PREIMAGE_FROM_ASSET",
}
var _XdrValues_ContractIDPreimageType = map[string]int32{
	"CONTRACT_ID_PREIMAGE_FROM_ADDRESS": int32(CONTRACT_ID_PREIMAGE_FROM_ADDRESS),
	"CONTRACT_ID_PREIMAGE_FROM_ASSET":   int32(CONTRACT_ID_PREIMAGE_FROM_ASSET),
}

func (ContractIDPreimageType) XdrEnumNames() map[int32]string {
	return _XdrNames_ContractIDPreimageType
}
func (v ContractIDPreimageType) String() string {
	if s, ok := _XdrNames_ContractIDPreimageType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ContractIDPreimageType#%d", v)
}
func (v *ContractIDPreimageType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ContractIDPreimageType[stok]; ok {
			*v = ContractIDPreimageType(val)
			return nil
		} else if stok == "ContractIDPreimageType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ContractIDPreimageType.", stok))
	}
}
func (v ContractIDPreimageType) GetU32() uint32                 { return uint32(v) }
func (v *ContractIDPreimageType) SetU32(n uint32)               { *v = ContractIDPreimageType(n) }
func (v *ContractIDPreimageType) XdrPointer() interface{}       { return v }
func (ContractIDPreimageType) XdrTypeName() string              { return "ContractIDPreimageType" }
func (v ContractIDPreimageType) XdrValue() interface{}          { return v }
func (v *ContractIDPreimageType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ContractIDPreimageType = *ContractIDPreimageType

func XDR_ContractIDPreimageType(v *ContractIDPreimageType) *ContractIDPreimageType { return v }

type XdrType_XdrAnon_ContractIDPreimage_FromAddress = *XdrAnon_ContractIDPreimage_FromAddress

func (v *XdrAnon_ContractIDPreimage_FromAddress) XdrPointer() interface{} { return v }
func (XdrAnon_ContractIDPreimage_FromAddress) XdrTypeName() string {
	return "XdrAnon_ContractIDPreimage_FromAddress"
}
func (v XdrAnon_ContractIDPreimage_FromAddress) XdrValue() interface{}          { return v }
func (v *XdrAnon_ContractIDPreimage_FromAddress) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_ContractIDPreimage_FromAddress) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saddress", name), XDR_SCAddress(&v.Address))
	x.Marshal(x.Sprintf("%ssalt", name), XDR_Uint256(&v.Salt))
}
func XDR_XdrAnon_ContractIDPreimage_FromAddress(v *XdrAnon_ContractIDPreimage_FromAddress) *XdrAnon_ContractIDPreimage_FromAddress {
	return v
}

var _XdrTags_ContractIDPreimage = map[int32]bool{
	XdrToI32(CONTRACT_ID_PREIMAGE_FROM_ADDRESS): true,
	XdrToI32(CONTRACT_ID_PREIMAGE_FROM_ASSET):   true,
}

func (_ ContractIDPreimage) XdrValidTags() map[int32]bool {
	return _XdrTags_ContractIDPreimage
}
func (u *ContractIDPreimage) FromAddress() *XdrAnon_ContractIDPreimage_FromAddress {
	switch u.Type {
	case CONTRACT_ID_PREIMAGE_FROM_ADDRESS:
		if v, ok := u._u.(*XdrAnon_ContractIDPreimage_FromAddress); ok {
			return v
		} else {
			var zero XdrAnon_ContractIDPreimage_FromAddress
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ContractIDPreimage.FromAddress accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ContractIDPreimage) FromAsset() *Asset {
	switch u.Type {
	case CONTRACT_ID_PREIMAGE_FROM_ASSET:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ContractIDPreimage.FromAsset accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ContractIDPreimage) XdrValid() bool {
	switch u.Type {
	case CONTRACT_ID_PREIMAGE_FROM_ADDRESS, CONTRACT_ID_PREIMAGE_FROM_ASSET:
		return true
	}
	return false
}
func (u *ContractIDPreimage) XdrUnionTag() XdrNum32 {
	return XDR_ContractIDPreimageType(&u.Type)
}
func (u *ContractIDPreimage) XdrUnionTagName() string {
	return "Type"
}
func (u *ContractIDPreimage) XdrUnionBody() XdrType {
	switch u.Type {
	case CONTRACT_ID_PREIMAGE_FROM_ADDRESS:
		return XDR_XdrAnon_ContractIDPreimage_FromAddress(u.FromAddress())
	case CONTRACT_ID_PREIMAGE_FROM_ASSET:
		return XDR_Asset(u.FromAsset())
	}
	return nil
}
func (u *ContractIDPreimage) XdrUnionBodyName() string {
	switch u.Type {
	case CONTRACT_ID_PREIMAGE_FROM_ADDRESS:
		return "FromAddress"
	case CONTRACT_ID_PREIMAGE_FROM_ASSET:
		return "FromAsset"
	}
	return ""
}

type XdrType_ContractIDPreimage = *ContractIDPreimage

func (v *ContractIDPreimage) XdrPointer() interface{}       { return v }
func (ContractIDPreimage) XdrTypeName() string              { return "ContractIDPreimage" }
func (v ContractIDPreimage) XdrValue() interface{}          { return v }
func (v *ContractIDPreimage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ContractIDPreimage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ContractIDPreimageType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CONTRACT_ID_PREIMAGE_FROM_ADDRESS:
		x.Marshal(x.Sprintf("%sfromAddress", name), XDR_XdrAnon_ContractIDPreimage_FromAddress(u.FromAddress()))
		return
	case CONTRACT_ID_PREIMAGE_FROM_ASSET:
		x.Marshal(x.Sprintf("%sfromAsset", name), XDR_Asset(u.FromAsset()))
		return
	}
	XdrPanic("invalid Type (%v) in ContractIDPreimage", u.Type)
}
func XDR_ContractIDPreimage(v *ContractIDPreimage) *ContractIDPreimage { return v }

type XdrType_CreateContractArgs = *CreateContractArgs

func (v *CreateContractArgs) XdrPointer() interface{}       { return v }
func (CreateContractArgs) XdrTypeName() string              { return "CreateContractArgs" }
func (v CreateContractArgs) XdrValue() interface{}          { return v }
func (v *CreateContractArgs) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreateContractArgs) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scontractIDPreimage", name), XDR_ContractIDPreimage(&v.ContractIDPreimage))
	x.Marshal(x.Sprintf("%sexecutable", name), XDR_ContractExecutable(&v.Executable))
}
func XDR_CreateContractArgs(v *CreateContractArgs) *CreateContractArgs { return v }

type XdrType_InvokeContractArgs = *InvokeContractArgs

func (v *InvokeContractArgs) XdrPointer() interface{}       { return v }
func (InvokeContractArgs) XdrTypeName() string              { return "InvokeContractArgs" }
func (v InvokeContractArgs) XdrValue() interface{}          { return v }
func (v *InvokeContractArgs) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InvokeContractArgs) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scontractAddress", name), XDR_SCAddress(&v.ContractAddress))
	x.Marshal(x.Sprintf("%sfunctionName", name), XDR_SCSymbol(&v.FunctionName))
	x.Marshal(x.Sprintf("%sargs", name), (*_XdrVec_unbounded_SCVal)(&v.Args))
}
func XDR_InvokeContractArgs(v *InvokeContractArgs) *InvokeContractArgs { return v }

var _XdrTags_HostFunction = map[int32]bool{
	XdrToI32(HOST_FUNCTION_TYPE_INVOKE_CONTRACT):      true,
	XdrToI32(HOST_FUNCTION_TYPE_CREATE_CONTRACT):      true,
	XdrToI32(HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM): true,
}

func (_ HostFunction) XdrValidTags() map[int32]bool {
	return _XdrTags_HostFunction
}
func (u *HostFunction) InvokeContract() *InvokeContractArgs {
	switch u.Type {
	case HOST_FUNCTION_TYPE_INVOKE_CONTRACT:
		if v, ok := u._u.(*InvokeContractArgs); ok {
			return v
		} else {
			var zero InvokeContractArgs
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HostFunction.InvokeContract accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HostFunction) CreateContract() *CreateContractArgs {
	switch u.Type {
	case HOST_FUNCTION_TYPE_CREATE_CONTRACT:
		if v, ok := u._u.(*CreateContractArgs); ok {
			return v
		} else {
			var zero CreateContractArgs
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HostFunction.CreateContract accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HostFunction) Wasm() *[]byte {
	switch u.Type {
	case HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
		if v, ok := u._u.(*[]byte); ok {
			return v
		} else {
			var zero []byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HostFunction.Wasm accessed when Type == %v", u.Type)
		return nil
	}
}
func (u HostFunction) XdrValid() bool {
	switch u.Type {
	case HOST_FUNCTION_TYPE_INVOKE_CONTRACT, HOST_FUNCTION_TYPE_CREATE_CONTRACT, HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
		return true
	}
	return false
}
func (u *HostFunction) XdrUnionTag() XdrNum32 {
	return XDR_HostFunctionType(&u.Type)
}
func (u *HostFunction) XdrUnionTagName() string {
	return "Type"
}
func (u *HostFunction) XdrUnionBody() XdrType {
	switch u.Type {
	case HOST_FUNCTION_TYPE_INVOKE_CONTRACT:
		return XDR_InvokeContractArgs(u.InvokeContract())
	case HOST_FUNCTION_TYPE_CREATE_CONTRACT:
		return XDR_CreateContractArgs(u.CreateContract())
	case HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
		return XdrVecOpaque{u.Wasm(), 0xffffffff}
	}
	return nil
}
func (u *HostFunction) XdrUnionBodyName() string {
	switch u.Type {
	case HOST_FUNCTION_TYPE_INVOKE_CONTRACT:
		return "InvokeContract"
	case HOST_FUNCTION_TYPE_CREATE_CONTRACT:
		return "CreateContract"
	case HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
		return "Wasm"
	}
	return ""
}

type XdrType_HostFunction = *HostFunction

func (v *HostFunction) XdrPointer() interface{}       { return v }
func (HostFunction) XdrTypeName() string              { return "HostFunction" }
func (v HostFunction) XdrValue() interface{}          { return v }
func (v *HostFunction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *HostFunction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_HostFunctionType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case HOST_FUNCTION_TYPE_INVOKE_CONTRACT:
		x.Marshal(x.Sprintf("%sinvokeContract", name), XDR_InvokeContractArgs(u.InvokeContract()))
		return
	case HOST_FUNCTION_TYPE_CREATE_CONTRACT:
		x.Marshal(x.Sprintf("%screateContract", name), XDR_CreateContractArgs(u.CreateContract()))
		return
	case HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
		x.Marshal(x.Sprintf("%swasm", name), XdrVecOpaque{u.Wasm(), 0xffffffff})
		return
	}
	XdrPanic("invalid Type (%v) in HostFunction", u.Type)
}
func XDR_HostFunction(v *HostFunction) *HostFunction { return v }

var _XdrNames_SorobanAuthorizedFunctionType = map[int32]string{
	int32(SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN):             "SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN",
	int32(SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN): "SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN",
}
var _XdrValues_SorobanAuthorizedFunctionType = map[string]int32{
	"SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN":             int32(SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN),
	"SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN": int32(SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN),
}

func (SorobanAuthorizedFunctionType) XdrEnumNames() map[int32]string {
	return _XdrNames_SorobanAuthorizedFunctionType
}
func (v SorobanAuthorizedFunctionType) String() string {
	if s, ok := _XdrNames_SorobanAuthorizedFunctionType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SorobanAuthorizedFunctionType#%d", v)
}
func (v *SorobanAuthorizedFunctionType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SorobanAuthorizedFunctionType[stok]; ok {
			*v = SorobanAuthorizedFunctionType(val)
			return nil
		} else if stok == "SorobanAuthorizedFunctionType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SorobanAuthorizedFunctionType.", stok))
	}
}
func (v SorobanAuthorizedFunctionType) GetU32() uint32                 { return uint32(v) }
func (v *SorobanAuthorizedFunctionType) SetU32(n uint32)               { *v = SorobanAuthorizedFunctionType(n) }
func (v *SorobanAuthorizedFunctionType) XdrPointer() interface{}       { return v }
func (SorobanAuthorizedFunctionType) XdrTypeName() string              { return "SorobanAuthorizedFunctionType" }
func (v SorobanAuthorizedFunctionType) XdrValue() interface{}          { return v }
func (v *SorobanAuthorizedFunctionType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SorobanAuthorizedFunctionType = *SorobanAuthorizedFunctionType

func XDR_SorobanAuthorizedFunctionType(v *SorobanAuthorizedFunctionType) *SorobanAuthorizedFunctionType {
	return v
}

var _XdrTags_SorobanAuthorizedFunction = map[int32]bool{
	XdrToI32(SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN):             true,
	XdrToI32(SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN): true,
}

func (_ SorobanAuthorizedFunction) XdrValidTags() map[int32]bool {
	return _XdrTags_SorobanAuthorizedFunction
}
func (u *SorobanAuthorizedFunction) ContractFn() *InvokeContractArgs {
	switch u.Type {
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN:
		if v, ok := u._u.(*InvokeContractArgs); ok {
			return v
		} else {
			var zero InvokeContractArgs
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SorobanAuthorizedFunction.ContractFn accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SorobanAuthorizedFunction) CreateContractHostFn() *CreateContractArgs {
	switch u.Type {
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
		if v, ok := u._u.(*CreateContractArgs); ok {
			return v
		} else {
			var zero CreateContractArgs
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SorobanAuthorizedFunction.CreateContractHostFn accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SorobanAuthorizedFunction) XdrValid() bool {
	switch u.Type {
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN, SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
		return true
	}
	return false
}
func (u *SorobanAuthorizedFunction) XdrUnionTag() XdrNum32 {
	return XDR_SorobanAuthorizedFunctionType(&u.Type)
}
func (u *SorobanAuthorizedFunction) XdrUnionTagName() string {
	return "Type"
}
func (u *SorobanAuthorizedFunction) XdrUnionBody() XdrType {
	switch u.Type {
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN:
		return XDR_InvokeContractArgs(u.ContractFn())
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
		return XDR_CreateContractArgs(u.CreateContractHostFn())
	}
	return nil
}
func (u *SorobanAuthorizedFunction) XdrUnionBodyName() string {
	switch u.Type {
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN:
		return "ContractFn"
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
		return "CreateContractHostFn"
	}
	return ""
}

type XdrType_SorobanAuthorizedFunction = *SorobanAuthorizedFunction

func (v *SorobanAuthorizedFunction) XdrPointer() interface{}       { return v }
func (SorobanAuthorizedFunction) XdrTypeName() string              { return "SorobanAuthorizedFunction" }
func (v SorobanAuthorizedFunction) XdrValue() interface{}          { return v }
func (v *SorobanAuthorizedFunction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SorobanAuthorizedFunction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SorobanAuthorizedFunctionType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN:
		x.Marshal(x.Sprintf("%scontractFn", name), XDR_InvokeContractArgs(u.ContractFn()))
		return
	case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
		x.Marshal(x.Sprintf("%screateContractHostFn", name), XDR_CreateContractArgs(u.CreateContractHostFn()))
		return
	}
	XdrPanic("invalid Type (%v) in SorobanAuthorizedFunction", u.Type)
}
func XDR_SorobanAuthorizedFunction(v *SorobanAuthorizedFunction) *SorobanAuthorizedFunction { return v }

type _XdrVec_unbounded_SorobanAuthorizedInvocation []SorobanAuthorizedInvocation

func (_XdrVec_unbounded_SorobanAuthorizedInvocation) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SorobanAuthorizedInvocation) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SorobanAuthorizedInvocation length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SorobanAuthorizedInvocation length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SorobanAuthorizedInvocation) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SorobanAuthorizedInvocation) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SorobanAuthorizedInvocation, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SorobanAuthorizedInvocation) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SorobanAuthorizedInvocation(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SorobanAuthorizedInvocation) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SorobanAuthorizedInvocation) XdrTypeName() string {
	return "SorobanAuthorizedInvocation<>"
}
func (v *_XdrVec_unbounded_SorobanAuthorizedInvocation) XdrPointer() interface{} {
	return (*[]SorobanAuthorizedInvocation)(v)
}
func (v _XdrVec_unbounded_SorobanAuthorizedInvocation) XdrValue() interface{} {
	return ([]SorobanAuthorizedInvocation)(v)
}
func (v *_XdrVec_unbounded_SorobanAuthorizedInvocation) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}

type XdrType_SorobanAuthorizedInvocation = *SorobanAuthorizedInvocation

func (v *SorobanAuthorizedInvocation) XdrPointer() interface{}       { return v }
func (SorobanAuthorizedInvocation) XdrTypeName() string              { return "SorobanAuthorizedInvocation" }
func (v SorobanAuthorizedInvocation) XdrValue() interface{}          { return v }
func (v *SorobanAuthorizedInvocation) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SorobanAuthorizedInvocation) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfunction", name), XDR_SorobanAuthorizedFunction(&v.Function))
	x.Marshal(x.Sprintf("%ssubInvocations", name), (*_XdrVec_unbounded_SorobanAuthorizedInvocation)(&v.SubInvocations))
}
func XDR_SorobanAuthorizedInvocation(v *SorobanAuthorizedInvocation) *SorobanAuthorizedInvocation {
	return v
}

type XdrType_SorobanAddressCredentials = *SorobanAddressCredentials

func (v *SorobanAddressCredentials) XdrPointer() interface{}       { return v }
func (SorobanAddressCredentials) XdrTypeName() string              { return "SorobanAddressCredentials" }
func (v SorobanAddressCredentials) XdrValue() interface{}          { return v }
func (v *SorobanAddressCredentials) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SorobanAddressCredentials) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saddress", name), XDR_SCAddress(&v.Address))
	x.Marshal(x.Sprintf("%snonce", name), XDR_Int64(&v.Nonce))
	x.Marshal(x.Sprintf("%ssignatureExpirationLedger", name), XDR_Uint32(&v.SignatureExpirationLedger))
	x.Marshal(x.Sprintf("%ssignature", name), XDR_SCVal(&v.Signature))
}
func XDR_SorobanAddressCredentials(v *SorobanAddressCredentials) *SorobanAddressCredentials { return v }

var _XdrNames_SorobanCredentialsType = map[int32]string{
	int32(SOROBAN_CREDENTIALS_SOURCE_ACCOUNT): "SOROBAN_CREDENTIALS_SOURCE_ACCOUNT",
	int32(SOROBAN_CREDENTIALS_ADDRESS):        "SOROBAN_CREDENTIALS_ADDRESS",
}
var _XdrValues_SorobanCredentialsType = map[string]int32{
	"SOROBAN_CREDENTIALS_SOURCE_ACCOUNT": int32(SOROBAN_CREDENTIALS_SOURCE_ACCOUNT),
	"SOROBAN_CREDENTIALS_ADDRESS":        int32(SOROBAN_CREDENTIALS_ADDRESS),
}

func (SorobanCredentialsType) XdrEnumNames() map[int32]string {
	return _XdrNames_SorobanCredentialsType
}
func (v SorobanCredentialsType) String() string {
	if s, ok := _XdrNames_SorobanCredentialsType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SorobanCredentialsType#%d", v)
}
func (v *SorobanCredentialsType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SorobanCredentialsType[stok]; ok {
			*v = SorobanCredentialsType(val)
			return nil
		} else if stok == "SorobanCredentialsType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SorobanCredentialsType.", stok))
	}
}
func (v SorobanCredentialsType) GetU32() uint32                 { return uint32(v) }
func (v *SorobanCredentialsType) SetU32(n uint32)               { *v = SorobanCredentialsType(n) }
func (v *SorobanCredentialsType) XdrPointer() interface{}       { return v }
func (SorobanCredentialsType) XdrTypeName() string              { return "SorobanCredentialsType" }
func (v SorobanCredentialsType) XdrValue() interface{}          { return v }
func (v *SorobanCredentialsType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SorobanCredentialsType = *SorobanCredentialsType

func XDR_SorobanCredentialsType(v *SorobanCredentialsType) *SorobanCredentialsType { return v }

var _XdrTags_SorobanCredentials = map[int32]bool{
	XdrToI32(SOROBAN_CREDENTIALS_SOURCE_ACCOUNT): true,
	XdrToI32(SOROBAN_CREDENTIALS_ADDRESS):        true,
}

func (_ SorobanCredentials) XdrValidTags() map[int32]bool {
	return _XdrTags_SorobanCredentials
}
func (u *SorobanCredentials) Address() *SorobanAddressCredentials {
	switch u.Type {
	case SOROBAN_CREDENTIALS_ADDRESS:
		if v, ok := u._u.(*SorobanAddressCredentials); ok {
			return v
		} else {
			var zero SorobanAddressCredentials
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SorobanCredentials.Address accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SorobanCredentials) XdrValid() bool {
	switch u.Type {
	case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT, SOROBAN_CREDENTIALS_ADDRESS:
		return true
	}
	return false
}
func (u *SorobanCredentials) XdrUnionTag() XdrNum32 {
	return XDR_SorobanCredentialsType(&u.Type)
}
func (u *SorobanCredentials) XdrUnionTagName() string {
	return "Type"
}
func (u *SorobanCredentials) XdrUnionBody() XdrType {
	switch u.Type {
	case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT:
		return nil
	case SOROBAN_CREDENTIALS_ADDRESS:
		return XDR_SorobanAddressCredentials(u.Address())
	}
	return nil
}
func (u *SorobanCredentials) XdrUnionBodyName() string {
	switch u.Type {
	case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT:
		return ""
	case SOROBAN_CREDENTIALS_ADDRESS:
		return "Address"
	}
	return ""
}

type XdrType_SorobanCredentials = *SorobanCredentials

func (v *SorobanCredentials) XdrPointer() interface{}       { return v }
func (SorobanCredentials) XdrTypeName() string              { return "SorobanCredentials" }
func (v SorobanCredentials) XdrValue() interface{}          { return v }
func (v *SorobanCredentials) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SorobanCredentials) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SorobanCredentialsType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT:
		return
	case SOROBAN_CREDENTIALS_ADDRESS:
		x.Marshal(x.Sprintf("%saddress", name), XDR_SorobanAddressCredentials(u.Address()))
		return
	}
	XdrPanic("invalid Type (%v) in SorobanCredentials", u.Type)
}
func XDR_SorobanCredentials(v *SorobanCredentials) *SorobanCredentials { return v }

type XdrType_SorobanAuthorizationEntry = *SorobanAuthorizationEntry

func (v *SorobanAuthorizationEntry) XdrPointer() interface{}       { return v }
func (SorobanAuthorizationEntry) XdrTypeName() string              { return "SorobanAuthorizationEntry" }
func (v SorobanAuthorizationEntry) XdrValue() interface{}          { return v }
func (v *SorobanAuthorizationEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SorobanAuthorizationEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scredentials", name), XDR_SorobanCredentials(&v.Credentials))
	x.Marshal(x.Sprintf("%srootInvocation", name), XDR_SorobanAuthorizedInvocation(&v.RootInvocation))
}
func XDR_SorobanAuthorizationEntry(v *SorobanAuthorizationEntry) *SorobanAuthorizationEntry { return v }

type _XdrVec_unbounded_SorobanAuthorizationEntry []SorobanAuthorizationEntry

func (_XdrVec_unbounded_SorobanAuthorizationEntry) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SorobanAuthorizationEntry) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SorobanAuthorizationEntry length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SorobanAuthorizationEntry length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SorobanAuthorizationEntry) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SorobanAuthorizationEntry) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SorobanAuthorizationEntry, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SorobanAuthorizationEntry) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SorobanAuthorizationEntry(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SorobanAuthorizationEntry) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SorobanAuthorizationEntry) XdrTypeName() string {
	return "SorobanAuthorizationEntry<>"
}
func (v *_XdrVec_unbounded_SorobanAuthorizationEntry) XdrPointer() interface{} {
	return (*[]SorobanAuthorizationEntry)(v)
}
func (v _XdrVec_unbounded_SorobanAuthorizationEntry) XdrValue() interface{} {
	return ([]SorobanAuthorizationEntry)(v)
}
func (v *_XdrVec_unbounded_SorobanAuthorizationEntry) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}

type XdrType_InvokeHostFunctionOp = *InvokeHostFunctionOp

func (v *InvokeHostFunctionOp) XdrPointer() interface{}       { return v }
func (InvokeHostFunctionOp) XdrTypeName() string              { return "InvokeHostFunctionOp" }
func (v InvokeHostFunctionOp) XdrValue() interface{}          { return v }
func (v *InvokeHostFunctionOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InvokeHostFunctionOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shostFunction", name), XDR_HostFunction(&v.HostFunction))
	x.Marshal(x.Sprintf("%sauth", name), (*_XdrVec_unbounded_SorobanAuthorizationEntry)(&v.Auth))
}
func XDR_InvokeHostFunctionOp(v *InvokeHostFunctionOp) *InvokeHostFunctionOp { return v }

type XdrType_ExtendFootprintTTLOp = *ExtendFootprintTTLOp

func (v *ExtendFootprintTTLOp) XdrPointer() interface{}       { return v }
func (ExtendFootprintTTLOp) XdrTypeName() string              { return "ExtendFootprintTTLOp" }
func (v ExtendFootprintTTLOp) XdrValue() interface{}          { return v }
func (v *ExtendFootprintTTLOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ExtendFootprintTTLOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%sextendTo", name), XDR_Uint32(&v.ExtendTo))
}
func XDR_ExtendFootprintTTLOp(v *ExtendFootprintTTLOp) *ExtendFootprintTTLOp { return v }

type XdrType_RestoreFootprintOp = *RestoreFootprintOp

func (v *RestoreFootprintOp) XdrPointer() interface{}       { return v }
func (RestoreFootprintOp) XdrTypeName() string              { return "RestoreFootprintOp" }
func (v RestoreFootprintOp) XdrValue() interface{}          { return v }
func (v *RestoreFootprintOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RestoreFootprintOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
}
func XDR_RestoreFootprintOp(v *RestoreFootprintOp) *RestoreFootprintOp { return v }

var _XdrTags_XdrAnon_Operation_Body = map[int32]bool{
	XdrToI32(CREATE_ACCOUNT):                   true,
	XdrToI32(PAYMENT):                          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE):      true,
	XdrToI32(MANAGE_SELL_OFFER):                true,
	XdrToI32(CREATE_PASSIVE_SELL_OFFER):        true,
	XdrToI32(SET_OPTIONS):                      true,
	XdrToI32(CHANGE_TRUST):                     true,
	XdrToI32(ALLOW_TRUST):                      true,
	XdrToI32(ACCOUNT_MERGE):                    true,
	XdrToI32(INFLATION):                        true,
	XdrToI32(MANAGE_DATA):                      true,
	XdrToI32(BUMP_SEQUENCE):                    true,
	XdrToI32(MANAGE_BUY_OFFER):                 true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND):         true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE):         true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE):          true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES): true,
	XdrToI32(END_SPONSORING_FUTURE_RESERVES):   true,
	XdrToI32(REVOKE_SPONSORSHIP):               true,
	XdrToI32(CLAWBACK):                         true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE):       true,
	XdrToI32(SET_TRUST_LINE_FLAGS):             true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT):           true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW):          true,
	XdrToI32(INVOKE_HOST_FUNCTION):             true,
	XdrToI32(EXTEND_FOOTPRINT_TTL):             true,
	XdrToI32(RESTORE_FOOTPRINT):                true,
}

func (_ XdrAnon_Operation_Body) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_Operation_Body
}
func (u *XdrAnon_Operation_Body) CreateAccountOp() *CreateAccountOp {
	switch u.Type {
	case CREATE_ACCOUNT:
		if v, ok := u._u.(*CreateAccountOp); ok {
			return v
		} else {
			var zero CreateAccountOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.CreateAccountOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PaymentOp() *PaymentOp {
	switch u.Type {
	case PAYMENT:
		if v, ok := u._u.(*PaymentOp); ok {
			return v
		} else {
			var zero PaymentOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PaymentOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PathPaymentStrictReceiveOp() *PathPaymentStrictReceiveOp {
	switch u.Type {
	case PATH_PAYMENT_STRICT_RECEIVE:
		if v, ok := u._u.(*PathPaymentStrictReceiveOp); ok {
			return v
		} else {
			var zero PathPaymentStrictReceiveOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PathPaymentStrictReceiveOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageSellOfferOp() *ManageSellOfferOp {
	switch u.Type {
	case MANAGE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferOp); ok {
			return v
		} else {
			var zero ManageSellOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageSellOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) CreatePassiveSellOfferOp() *CreatePassiveSellOfferOp {
	switch u.Type {
	case CREATE_PASSIVE_SELL_OFFER:
		if v, ok := u._u.(*CreatePassiveSellOfferOp); ok {
			return v
		} else {
			var zero CreatePassiveSellOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.CreatePassiveSellOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) SetOptionsOp() *SetOptionsOp {
	switch u.Type {
	case SET_OPTIONS:
		if v, ok := u._u.(*SetOptionsOp); ok {
			return v
		} else {
			var zero SetOptionsOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.SetOptionsOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ChangeTrustOp() *ChangeTrustOp {
	switch u.Type {
	case CHANGE_TRUST:
		if v, ok := u._u.(*ChangeTrustOp); ok {
			return v
		} else {
			var zero ChangeTrustOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ChangeTrustOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) AllowTrustOp() *AllowTrustOp {
	switch u.Type {
	case ALLOW_TRUST:
		if v, ok := u._u.(*AllowTrustOp); ok {
			return v
		} else {
			var zero AllowTrustOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.AllowTrustOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) Destination() *MuxedAccount {
	switch u.Type {
	case ACCOUNT_MERGE:
		if v, ok := u._u.(*MuxedAccount); ok {
			return v
		} else {
			var zero MuxedAccount
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.Destination accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageDataOp() *ManageDataOp {
	switch u.Type {
	case MANAGE_DATA:
		if v, ok := u._u.(*ManageDataOp); ok {
			return v
		} else {
			var zero ManageDataOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageDataOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) BumpSequenceOp() *BumpSequenceOp {
	switch u.Type {
	case BUMP_SEQUENCE:
		if v, ok := u._u.(*BumpSequenceOp); ok {
			return v
		} else {
			var zero BumpSequenceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.BumpSequenceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageBuyOfferOp() *ManageBuyOfferOp {
	switch u.Type {
	case MANAGE_BUY_OFFER:
		if v, ok := u._u.(*ManageBuyOfferOp); ok {
			return v
		} else {
			var zero ManageBuyOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageBuyOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PathPaymentStrictSendOp() *PathPaymentStrictSendOp {
	switch u.Type {
	case PATH_PAYMENT_STRICT_SEND:
		if v, ok := u._u.(*PathPaymentStrictSendOp); ok {
			return v
		} else {
			var zero PathPaymentStrictSendOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PathPaymentStrictSendOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) CreateClaimableBalanceOp() *CreateClaimableBalanceOp {
	switch u.Type {
	case CREATE_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*CreateClaimableBalanceOp); ok {
			return v
		} else {
			var zero CreateClaimableBalanceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.CreateClaimableBalanceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ClaimClaimableBalanceOp() *ClaimClaimableBalanceOp {
	switch u.Type {
	case CLAIM_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClaimClaimableBalanceOp); ok {
			return v
		} else {
			var zero ClaimClaimableBalanceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ClaimClaimableBalanceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) BeginSponsoringFutureReservesOp() *BeginSponsoringFutureReservesOp {
	switch u.Type {
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		if v, ok := u._u.(*BeginSponsoringFutureReservesOp); ok {
			return v
		} else {
			var zero BeginSponsoringFutureReservesOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.BeginSponsoringFutureReservesOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) RevokeSponsorshipOp() *RevokeSponsorshipOp {
	switch u.Type {
	case REVOKE_SPONSORSHIP:
		if v, ok := u._u.(*RevokeSponsorshipOp); ok {
			return v
		} else {
			var zero RevokeSponsorshipOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.RevokeSponsorshipOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ClawbackOp() *ClawbackOp {
	switch u.Type {
	case CLAWBACK:
		if v, ok := u._u.(*ClawbackOp); ok {
			return v
		} else {
			var zero ClawbackOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ClawbackOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ClawbackClaimableBalanceOp() *ClawbackClaimableBalanceOp {
	switch u.Type {
	case CLAWBACK_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClawbackClaimableBalanceOp); ok {
			return v
		} else {
			var zero ClawbackClaimableBalanceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ClawbackClaimableBalanceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) SetTrustLineFlagsOp() *SetTrustLineFlagsOp {
	switch u.Type {
	case SET_TRUST_LINE_FLAGS:
		if v, ok := u._u.(*SetTrustLineFlagsOp); ok {
			return v
		} else {
			var zero SetTrustLineFlagsOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.SetTrustLineFlagsOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) LiquidityPoolDepositOp() *LiquidityPoolDepositOp {
	switch u.Type {
	case LIQUIDITY_POOL_DEPOSIT:
		if v, ok := u._u.(*LiquidityPoolDepositOp); ok {
			return v
		} else {
			var zero LiquidityPoolDepositOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.LiquidityPoolDepositOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) LiquidityPoolWithdrawOp() *LiquidityPoolWithdrawOp {
	switch u.Type {
	case LIQUIDITY_POOL_WITHDRAW:
		if v, ok := u._u.(*LiquidityPoolWithdrawOp); ok {
			return v
		} else {
			var zero LiquidityPoolWithdrawOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.LiquidityPoolWithdrawOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) InvokeHostFunctionOp() *InvokeHostFunctionOp {
	switch u.Type {
	case INVOKE_HOST_FUNCTION:
		if v, ok := u._u.(*InvokeHostFunctionOp); ok {
			return v
		} else {
			var zero InvokeHostFunctionOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.InvokeHostFunctionOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ExtendFootprintTTLOp() *ExtendFootprintTTLOp {
	switch u.Type {
	case EXTEND_FOOTPRINT_TTL:
		if v, ok := u._u.(*ExtendFootprintTTLOp); ok {
			return v
		} else {
			var zero ExtendFootprintTTLOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ExtendFootprintTTLOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) RestoreFootprintOp() *RestoreFootprintOp {
	switch u.Type {
	case RESTORE_FOOTPRINT:
		if v, ok := u._u.(*RestoreFootprintOp); ok {
			return v
		} else {
			var zero RestoreFootprintOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.RestoreFootprintOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_Operation_Body) XdrValid() bool {
	switch u.Type {
	case CREATE_ACCOUNT, PAYMENT, PATH_PAYMENT_STRICT_RECEIVE, MANAGE_SELL_OFFER, CREATE_PASSIVE_SELL_OFFER, SET_OPTIONS, CHANGE_TRUST, ALLOW_TRUST, ACCOUNT_MERGE, INFLATION, MANAGE_DATA, BUMP_SEQUENCE, MANAGE_BUY_OFFER, PATH_PAYMENT_STRICT_SEND, CREATE_CLAIMABLE_BALANCE, CLAIM_CLAIMABLE_BALANCE, BEGIN_SPONSORING_FUTURE_RESERVES, END_SPONSORING_FUTURE_RESERVES, REVOKE_SPONSORSHIP, CLAWBACK, CLAWBACK_CLAIMABLE_BALANCE, SET_TRUST_LINE_FLAGS, LIQUIDITY_POOL_DEPOSIT, LIQUIDITY_POOL_WITHDRAW, INVOKE_HOST_FUNCTION, EXTEND_FOOTPRINT_TTL, RESTORE_FOOTPRINT:
		return true
	}
	return false
}
func (u *XdrAnon_Operation_Body) XdrUnionTag() XdrNum32 {
	return XDR_OperationType(&u.Type)
}
func (u *XdrAnon_Operation_Body) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_Operation_Body) XdrUnionBody() XdrType {
	switch u.Type {
	case CREATE_ACCOUNT:
		return XDR_CreateAccountOp(u.CreateAccountOp())
	case PAYMENT:
		return XDR_PaymentOp(u.PaymentOp())
	case PATH_PAYMENT_STRICT_RECEIVE:
		return XDR_PathPaymentStrictReceiveOp(u.PathPaymentStrictReceiveOp())
	case MANAGE_SELL_OFFER:
		return XDR_ManageSellOfferOp(u.ManageSellOfferOp())
	case CREATE_PASSIVE_SELL_OFFER:
		return XDR_CreatePassiveSellOfferOp(u.CreatePassiveSellOfferOp())
	case SET_OPTIONS:
		return XDR_SetOptionsOp(u.SetOptionsOp())
	case CHANGE_TRUST:
		return XDR_ChangeTrustOp(u.ChangeTrustOp())
	case ALLOW_TRUST:
		return XDR_AllowTrustOp(u.AllowTrustOp())
	case ACCOUNT_MERGE:
		return XDR_MuxedAccount(u.Destination())
	case INFLATION:
		return nil
	case MANAGE_DATA:
		return XDR_ManageDataOp(u.ManageDataOp())
	case BUMP_SEQUENCE:
		return XDR_BumpSequenceOp(u.BumpSequenceOp())
	case MANAGE_BUY_OFFER:
		return XDR_ManageBuyOfferOp(u.ManageBuyOfferOp())
	case PATH_PAYMENT_STRICT_SEND:
		return XDR_PathPaymentStrictSendOp(u.PathPaymentStrictSendOp())
	case CREATE_CLAIMABLE_BALANCE:
		return XDR_CreateClaimableBalanceOp(u.CreateClaimableBalanceOp())
	case CLAIM_CLAIMABLE_BALANCE:
		return XDR_ClaimClaimableBalanceOp(u.ClaimClaimableBalanceOp())
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		return XDR_BeginSponsoringFutureReservesOp(u.BeginSponsoringFutureReservesOp())
	case END_SPONSORING_FUTURE_RESERVES:
		return nil
	case REVOKE_SPONSORSHIP:
		return XDR_RevokeSponsorshipOp(u.RevokeSponsorshipOp())
	case CLAWBACK:
		return XDR_ClawbackOp(u.ClawbackOp())
	case CLAWBACK_CLAIMABLE_BALANCE:
		return XDR_ClawbackClaimableBalanceOp(u.ClawbackClaimableBalanceOp())
	case SET_TRUST_LINE_FLAGS:
		return XDR_SetTrustLineFlagsOp(u.SetTrustLineFlagsOp())
	case LIQUIDITY_POOL_DEPOSIT:
		return XDR_LiquidityPoolDepositOp(u.LiquidityPoolDepositOp())
	case LIQUIDITY_POOL_WITHDRAW:
		return XDR_LiquidityPoolWithdrawOp(u.LiquidityPoolWithdrawOp())
	case INVOKE_HOST_FUNCTION:
		return XDR_InvokeHostFunctionOp(u.InvokeHostFunctionOp())
	case EXTEND_FOOTPRINT_TTL:
		return XDR_ExtendFootprintTTLOp(u.ExtendFootprintTTLOp())
	case RESTORE_FOOTPRINT:
		return XDR_RestoreFootprintOp(u.RestoreFootprintOp())
	}
	return nil
}
func (u *XdrAnon_Operation_Body) XdrUnionBodyName() string {
	switch u.Type {
	case CREATE_ACCOUNT:
		return "CreateAccountOp"
	case PAYMENT:
		return "PaymentOp"
	case PATH_PAYMENT_STRICT_RECEIVE:
		return "PathPaymentStrictReceiveOp"
	case MANAGE_SELL_OFFER:
		return "ManageSellOfferOp"
	case CREATE_PASSIVE_SELL_OFFER:
		return "CreatePassiveSellOfferOp"
	case SET_OPTIONS:
		return "SetOptionsOp"
	case CHANGE_TRUST:
		return "ChangeTrustOp"
	case ALLOW_TRUST:
		return "AllowTrustOp"
	case ACCOUNT_MERGE:
		return "Destination"
	case INFLATION:
		return ""
	case MANAGE_DATA:
		return "ManageDataOp"
	case BUMP_SEQUENCE:
		return "BumpSequenceOp"
	case MANAGE_BUY_OFFER:
		return "ManageBuyOfferOp"
	case PATH_PAYMENT_STRICT_SEND:
		return "PathPaymentStrictSendOp"
	case CREATE_CLAIMABLE_BALANCE:
		return "CreateClaimableBalanceOp"
	case CLAIM_CLAIMABLE_BALANCE:
		return "ClaimClaimableBalanceOp"
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		return "BeginSponsoringFutureReservesOp"
	case END_SPONSORING_FUTURE_RESERVES:
		return ""
	case REVOKE_SPONSORSHIP:
		return "RevokeSponsorshipOp"
	case CLAWBACK:
		return "ClawbackOp"
	case CLAWBACK_CLAIMABLE_BALANCE:
		return "ClawbackClaimableBalanceOp"
	case SET_TRUST_LINE_FLAGS:
		return "SetTrustLineFlagsOp"
	case LIQUIDITY_POOL_DEPOSIT:
		return "LiquidityPoolDepositOp"
	case LIQUIDITY_POOL_WITHDRAW:
		return "LiquidityPoolWithdrawOp"
	case INVOKE_HOST_FUNCTION:
		return "InvokeHostFunctionOp"
	case EXTEND_FOOTPRINT_TTL:
		return "ExtendFootprintTTLOp"
	case RESTORE_FOOTPRINT:
		return "RestoreFootprintOp"
	}
	return ""
}

type XdrType_XdrAnon_Operation_Body = *XdrAnon_Operation_Body

func (v *XdrAnon_Operation_Body) XdrPointer() interface{}       { return v }
func (XdrAnon_Operation_Body) XdrTypeName() string              { return "XdrAnon_Operation_Body" }
func (v XdrAnon_Operation_Body) XdrValue() interface{}          { return v }
func (v *XdrAnon_Operation_Body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_Operation_Body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CREATE_ACCOUNT:
		x.Marshal(x.Sprintf("%screateAccountOp", name), XDR_CreateAccountOp(u.CreateAccountOp()))
		return
	case PAYMENT:
		x.Marshal(x.Sprintf("%spaymentOp", name), XDR_PaymentOp(u.PaymentOp()))
		return
	case PATH_PAYMENT_STRICT_RECEIVE:
		x.Marshal(x.Sprintf("%spathPaymentStrictReceiveOp", name), XDR_PathPaymentStrictReceiveOp(u.PathPaymentStrictReceiveOp()))
		return
	case MANAGE_SELL_OFFER:
		x.Marshal(x.Sprintf("%smanageSellOfferOp", name), XDR_ManageSellOfferOp(u.ManageSellOfferOp()))
		return
	case CREATE_PASSIVE_SELL_OFFER:
		x.Marshal(x.Sprintf("%screatePassiveSellOfferOp", name), XDR_CreatePassiveSellOfferOp(u.CreatePassiveSellOfferOp()))
		return
	case SET_OPTIONS:
		x.Marshal(x.Sprintf("%ssetOptionsOp", name), XDR_SetOptionsOp(u.SetOptionsOp()))
		return
	case CHANGE_TRUST:
		x.Marshal(x.Sprintf("%schangeTrustOp", name), XDR_ChangeTrustOp(u.ChangeTrustOp()))
		return
	case ALLOW_TRUST:
		x.Marshal(x.Sprintf("%sallowTrustOp", name), XDR_AllowTrustOp(u.AllowTrustOp()))
		return
	case ACCOUNT_MERGE:
		x.Marshal(x.Sprintf("%sdestination", name), XDR_MuxedAccount(u.Destination()))
		return
	case INFLATION:
		return
	case MANAGE_DATA:
		x.Marshal(x.Sprintf("%smanageDataOp", name), XDR_ManageDataOp(u.ManageDataOp()))
		return
	case BUMP_SEQUENCE:
		x.Marshal(x.Sprintf("%sbumpSequenceOp", name), XDR_BumpSequenceOp(u.BumpSequenceOp()))
		return
	case MANAGE_BUY_OFFER:
		x.Marshal(x.Sprintf("%smanageBuyOfferOp", name), XDR_ManageBuyOfferOp(u.ManageBuyOfferOp()))
		return
	case PATH_PAYMENT_STRICT_SEND:
		x.Marshal(x.Sprintf("%spathPaymentStrictSendOp", name), XDR_PathPaymentStrictSendOp(u.PathPaymentStrictSendOp()))
		return
	case CREATE_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%screateClaimableBalanceOp", name), XDR_CreateClaimableBalanceOp(u.CreateClaimableBalanceOp()))
		return
	case CLAIM_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclaimClaimableBalanceOp", name), XDR_ClaimClaimableBalanceOp(u.ClaimClaimableBalanceOp()))
		return
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		x.Marshal(x.Sprintf("%sbeginSponsoringFutureReservesOp", name), XDR_BeginSponsoringFutureReservesOp(u.BeginSponsoringFutureReservesOp()))
		return
	case END_SPONSORING_FUTURE_RESERVES:
		return
	case REVOKE_SPONSORSHIP:
		x.Marshal(x.Sprintf("%srevokeSponsorshipOp", name), XDR_RevokeSponsorshipOp(u.RevokeSponsorshipOp()))
		return
	case CLAWBACK:
		x.Marshal(x.Sprintf("%sclawbackOp", name), XDR_ClawbackOp(u.ClawbackOp()))
		return
	case CLAWBACK_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclawbackClaimableBalanceOp", name), XDR_ClawbackClaimableBalanceOp(u.ClawbackClaimableBalanceOp()))
		return
	case SET_TRUST_LINE_FLAGS:
		x.Marshal(x.Sprintf("%ssetTrustLineFlagsOp", name), XDR_SetTrustLineFlagsOp(u.SetTrustLineFlagsOp()))
		return
	case LIQUIDITY_POOL_DEPOSIT:
		x.Marshal(x.Sprintf("%sliquidityPoolDepositOp", name), XDR_LiquidityPoolDepositOp(u.LiquidityPoolDepositOp()))
		return
	case LIQUIDITY_POOL_WITHDRAW:
		x.Marshal(x.Sprintf("%sliquidityPoolWithdrawOp", name), XDR_LiquidityPoolWithdrawOp(u.LiquidityPoolWithdrawOp()))
		return
	case INVOKE_HOST_FUNCTION:
		x.Marshal(x.Sprintf("%sinvokeHostFunctionOp", name), XDR_InvokeHostFunctionOp(u.InvokeHostFunctionOp()))
		return
	case EXTEND_FOOTPRINT_TTL:
		x.Marshal(x.Sprintf("%sextendFootprintTTLOp", name), XDR_ExtendFootprintTTLOp(u.ExtendFootprintTTLOp()))
		return
	case RESTORE_FOOTPRINT:
		x.Marshal(x.Sprintf("%srestoreFootprintOp", name), XDR_RestoreFootprintOp(u.RestoreFootprintOp()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_Operation_Body", u.Type)
}
func XDR_XdrAnon_Operation_Body(v *XdrAnon_Operation_Body) *XdrAnon_Operation_Body { return v }

type _XdrPtr_MuxedAccount struct {
	p **MuxedAccount
}
type _ptrflag_MuxedAccount _XdrPtr_MuxedAccount

func (v _ptrflag_MuxedAccount) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_MuxedAccount) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("MuxedAccount flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_MuxedAccount) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_MuxedAccount) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(MuxedAccount)
		}
	default:
		XdrPanic("*MuxedAccount present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_MuxedAccount) XdrTypeName() string             { return "MuxedAccount?" }
func (v _ptrflag_MuxedAccount) XdrPointer() interface{}       { return nil }
func (v _ptrflag_MuxedAccount) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_MuxedAccount) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_MuxedAccount) XdrBound() uint32              { return 1 }
func (v _XdrPtr_MuxedAccount) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_MuxedAccount) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(MuxedAccount)
	}
}
func (v _XdrPtr_MuxedAccount) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_MuxedAccount(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_MuxedAccount) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_MuxedAccount) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_MuxedAccount(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_MuxedAccount) XdrTypeName() string       { return "MuxedAccount*" }
func (v _XdrPtr_MuxedAccount) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_MuxedAccount) XdrValue() interface{}   { return *v.p }

type XdrType_Operation = *Operation

func (v *Operation) XdrPointer() interface{}       { return v }
func (Operation) XdrTypeName() string              { return "Operation" }
func (v Operation) XdrValue() interface{}          { return v }
func (v *Operation) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Operation) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), _XdrPtr_MuxedAccount{&v.SourceAccount})
	x.Marshal(x.Sprintf("%sbody", name), XDR_XdrAnon_Operation_Body(&v.Body))
}
func XDR_Operation(v *Operation) *Operation { return v }

type XdrType_XdrAnon_HashIDPreimage_OperationID = *XdrAnon_HashIDPreimage_OperationID

func (v *XdrAnon_HashIDPreimage_OperationID) XdrPointer() interface{} { return v }
func (XdrAnon_HashIDPreimage_OperationID) XdrTypeName() string {
	return "XdrAnon_HashIDPreimage_OperationID"
}
func (v XdrAnon_HashIDPreimage_OperationID) XdrValue() interface{}          { return v }
func (v *XdrAnon_HashIDPreimage_OperationID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_HashIDPreimage_OperationID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), XDR_AccountID(&v.SourceAccount))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%sopNum", name), XDR_Uint32(&v.OpNum))
}
func XDR_XdrAnon_HashIDPreimage_OperationID(v *XdrAnon_HashIDPreimage_OperationID) *XdrAnon_HashIDPreimage_OperationID {
	return v
}

type XdrType_XdrAnon_HashIDPreimage_RevokeID = *XdrAnon_HashIDPreimage_RevokeID

func (v *XdrAnon_HashIDPreimage_RevokeID) XdrPointer() interface{}       { return v }
func (XdrAnon_HashIDPreimage_RevokeID) XdrTypeName() string              { return "XdrAnon_HashIDPreimage_RevokeID" }
func (v XdrAnon_HashIDPreimage_RevokeID) XdrValue() interface{}          { return v }
func (v *XdrAnon_HashIDPreimage_RevokeID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_HashIDPreimage_RevokeID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), XDR_AccountID(&v.SourceAccount))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%sopNum", name), XDR_Uint32(&v.OpNum))
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
}
func XDR_XdrAnon_HashIDPreimage_RevokeID(v *XdrAnon_HashIDPreimage_RevokeID) *XdrAnon_HashIDPreimage_RevokeID {
	return v
}

type XdrType_XdrAnon_HashIDPreimage_ContractID = *XdrAnon_HashIDPreimage_ContractID

func (v *XdrAnon_HashIDPreimage_ContractID) XdrPointer() interface{} { return v }
func (XdrAnon_HashIDPreimage_ContractID) XdrTypeName() string {
	return "XdrAnon_HashIDPreimage_ContractID"
}
func (v XdrAnon_HashIDPreimage_ContractID) XdrValue() interface{}          { return v }
func (v *XdrAnon_HashIDPreimage_ContractID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_HashIDPreimage_ContractID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snetworkID", name), XDR_Hash(&v.NetworkID))
	x.Marshal(x.Sprintf("%scontractIDPreimage", name), XDR_ContractIDPreimage(&v.ContractIDPreimage))
}
func XDR_XdrAnon_HashIDPreimage_ContractID(v *XdrAnon_HashIDPreimage_ContractID) *XdrAnon_HashIDPreimage_ContractID {
	return v
}

type XdrType_XdrAnon_HashIDPreimage_SorobanAuthorization = *XdrAnon_HashIDPreimage_SorobanAuthorization

func (v *XdrAnon_HashIDPreimage_SorobanAuthorization) XdrPointer() interface{} { return v }
func (XdrAnon_HashIDPreimage_SorobanAuthorization) XdrTypeName() string {
	return "XdrAnon_HashIDPreimage_SorobanAuthorization"
}
func (v XdrAnon_HashIDPreimage_SorobanAuthorization) XdrValue() interface{} { return v }
func (v *XdrAnon_HashIDPreimage_SorobanAuthorization) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_HashIDPreimage_SorobanAuthorization) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snetworkID", name), XDR_Hash(&v.NetworkID))
	x.Marshal(x.Sprintf("%snonce", name), XDR_Int64(&v.Nonce))
	x.Marshal(x.Sprintf("%ssignatureExpirationLedger", name), XDR_Uint32(&v.SignatureExpirationLedger))
	x.Marshal(x.Sprintf("%sinvocation", name), XDR_SorobanAuthorizedInvocation(&v.Invocation))
}
func XDR_XdrAnon_HashIDPreimage_SorobanAuthorization(v *XdrAnon_HashIDPreimage_SorobanAuthorization) *XdrAnon_HashIDPreimage_SorobanAuthorization {
	return v
}

var _XdrTags_HashIDPreimage = map[int32]bool{
	XdrToI32(ENVELOPE_TYPE_OP_ID):                 true,
	XdrToI32(ENVELOPE_TYPE_POOL_REVOKE_OP_ID):     true,
	XdrToI32(ENVELOPE_TYPE_CONTRACT_ID):           true,
	XdrToI32(ENVELOPE_TYPE_SOROBAN_AUTHORIZATION): true,
}

func (_ HashIDPreimage) XdrValidTags() map[int32]bool {
	return _XdrTags_HashIDPreimage
}
func (u *HashIDPreimage) OperationID() *XdrAnon_HashIDPreimage_OperationID {
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_OperationID); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_OperationID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.OperationID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HashIDPreimage) RevokeID() *XdrAnon_HashIDPreimage_RevokeID {
	switch u.Type {
	case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_RevokeID); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_RevokeID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.RevokeID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HashIDPreimage) ContractID() *XdrAnon_HashIDPreimage_ContractID {
	switch u.Type {
	case ENVELOPE_TYPE_CONTRACT_ID:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_ContractID); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_ContractID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.ContractID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HashIDPreimage) SorobanAuthorization() *XdrAnon_HashIDPreimage_SorobanAuthorization {
	switch u.Type {
	case ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_SorobanAuthorization); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_SorobanAuthorization
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.SorobanAuthorization accessed when Type == %v", u.Type)
		return nil
	}
}
func (u HashIDPreimage) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID, ENVELOPE_TYPE_POOL_REVOKE_OP_ID, ENVELOPE_TYPE_CONTRACT_ID, ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
		return true
	}
	return false
}
func (u *HashIDPreimage) XdrUnionTag() XdrNum32 {
	return XDR_EnvelopeType(&u.Type)
}
func (u *HashIDPreimage) XdrUnionTagName() string {
	return "Type"
}
func (u *HashIDPreimage) XdrUnionBody() XdrType {
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID:
		return XDR_XdrAnon_HashIDPreimage_OperationID(u.OperationID())
	case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
		return XDR_XdrAnon_HashIDPreimage_RevokeID(u.RevokeID())
	case ENVELOPE_TYPE_CONTRACT_ID:
		return XDR_XdrAnon_HashIDPreimage_ContractID(u.ContractID())
	case ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
		return XDR_XdrAnon_HashIDPreimage_SorobanAuthorization(u.SorobanAuthorization())
	}
	return nil
}
func (u *HashIDPreimage) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID:
		return "OperationID"
	case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
		return "RevokeID"
	case ENVELOPE_TYPE_CONTRACT_ID:
		return "ContractID"
	case ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
		return "SorobanAuthorization"
	}
	return ""
}

type XdrType_HashIDPreimage = *HashIDPreimage

func (v *HashIDPreimage) XdrPointer() interface{}       { return v }
func (HashIDPreimage) XdrTypeName() string              { return "HashIDPreimage" }
func (v HashIDPreimage) XdrValue() interface{}          { return v }
func (v *HashIDPreimage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *HashIDPreimage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID:
		x.Marshal(x.Sprintf("%soperationID", name), XDR_XdrAnon_HashIDPreimage_OperationID(u.OperationID()))
		return
	case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
		x.Marshal(x.Sprintf("%srevokeID", name), XDR_XdrAnon_HashIDPreimage_RevokeID(u.RevokeID()))
		return
	case ENVELOPE_TYPE_CONTRACT_ID:
		x.Marshal(x.Sprintf("%scontractID", name), XDR_XdrAnon_HashIDPreimage_ContractID(u.ContractID()))
		return
	case ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
		x.Marshal(x.Sprintf("%ssorobanAuthorization", name), XDR_XdrAnon_HashIDPreimage_SorobanAuthorization(u.SorobanAuthorization()))
		return
	}
	XdrPanic("invalid Type (%v) in HashIDPreimage", u.Type)
}
func (v *HashIDPreimage) XdrInitialize() {
	var zero EnvelopeType
	switch zero {
	case ENVELOPE_TYPE_OP_ID, ENVELOPE_TYPE_POOL_REVOKE_OP_ID, ENVELOPE_TYPE_CONTRACT_ID, ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
	default:
		if v.Type == zero {
			v.Type = ENVELOPE_TYPE_OP_ID
		}
	}
}
func XDR_HashIDPreimage(v *HashIDPreimage) *HashIDPreimage { return v }

var _XdrNames_MemoType = map[int32]string{
	int32(MEMO_NONE):   "MEMO_NONE",
	int32(MEMO_TEXT):   "MEMO_TEXT",
	int32(MEMO_ID):     "MEMO_ID",
	int32(MEMO_HASH):   "MEMO_HASH",
	int32(MEMO_RETURN): "MEMO_RETURN",
}
var _XdrValues_MemoType = map[string]int32{
	"MEMO_NONE":   int32(MEMO_NONE),
	"MEMO_TEXT":   int32(MEMO_TEXT),
	"MEMO_ID":     int32(MEMO_ID),
	"MEMO_HASH":   int32(MEMO_HASH),
	"MEMO_RETURN": int32(MEMO_RETURN),
}

func (MemoType) XdrEnumNames() map[int32]string {
	return _XdrNames_MemoType
}
func (v MemoType) String() string {
	if s, ok := _XdrNames_MemoType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("MemoType#%d", v)
}
func (v *MemoType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_MemoType[stok]; ok {
			*v = MemoType(val)
			return nil
		} else if stok == "MemoType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid MemoType.", stok))
	}
}
func (v MemoType) GetU32() uint32                 { return uint32(v) }
func (v *MemoType) SetU32(n uint32)               { *v = MemoType(n) }
func (v *MemoType) XdrPointer() interface{}       { return v }
func (MemoType) XdrTypeName() string              { return "MemoType" }
func (v MemoType) XdrValue() interface{}          { return v }
func (v *MemoType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_MemoType = *MemoType

func XDR_MemoType(v *MemoType) *MemoType { return v }

var _XdrTags_Memo = map[int32]bool{
	XdrToI32(MEMO_NONE):   true,
	XdrToI32(MEMO_TEXT):   true,
	XdrToI32(MEMO_ID):     true,
	XdrToI32(MEMO_HASH):   true,
	XdrToI32(MEMO_RETURN): true,
}

func (_ Memo) XdrValidTags() map[int32]bool {
	return _XdrTags_Memo
}
func (u *Memo) Text() *string {
	switch u.Type {
	case MEMO_TEXT:
		if v, ok := u._u.(*string); ok {
			return v
		} else {
			var zero string
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Text accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Memo) Id() *Uint64 {
	switch u.Type {
	case MEMO_ID:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Id accessed when Type == %v", u.Type)
		return nil
	}
}

// the hash of what to pull from the content server
func (u *Memo) Hash() *Hash {
	switch u.Type {
	case MEMO_HASH:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Hash accessed when Type == %v", u.Type)
		return nil
	}
}

// the hash of the tx you are rejecting
func (u *Memo) RetHash() *Hash {
	switch u.Type {
	case MEMO_RETURN:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.RetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Memo) XdrValid() bool {
	switch u.Type {
	case MEMO_NONE, MEMO_TEXT, MEMO_ID, MEMO_HASH, MEMO_RETURN:
		return true
	}
	return false
}
func (u *Memo) XdrUnionTag() XdrNum32 {
	return XDR_MemoType(&u.Type)
}
func (u *Memo) XdrUnionTagName() string {
	return "Type"
}
func (u *Memo) XdrUnionBody() XdrType {
	switch u.Type {
	case MEMO_NONE:
		return nil
	case MEMO_TEXT:
		return XdrString{u.Text(), 28}
	case MEMO_ID:
		return XDR_Uint64(u.Id())
	case MEMO_HASH:
		return XDR_Hash(u.Hash())
	case MEMO_RETURN:
		return XDR_Hash(u.RetHash())
	}
	return nil
}
func (u *Memo) XdrUnionBodyName() string {
	switch u.Type {
	case MEMO_NONE:
		return ""
	case MEMO_TEXT:
		return "Text"
	case MEMO_ID:
		return "Id"
	case MEMO_HASH:
		return "Hash"
	case MEMO_RETURN:
		return "RetHash"
	}
	return ""
}

type XdrType_Memo = *Memo

func (v *Memo) XdrPointer() interface{}       { return v }
func (Memo) XdrTypeName() string              { return "Memo" }
func (v Memo) XdrValue() interface{}          { return v }
func (v *Memo) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Memo) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MemoType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case MEMO_NONE:
		return
	case MEMO_TEXT:
		x.Marshal(x.Sprintf("%stext", name), XdrString{u.Text(), 28})
		return
	case MEMO_ID:
		x.Marshal(x.Sprintf("%sid", name), XDR_Uint64(u.Id()))
		return
	case MEMO_HASH:
		x.Marshal(x.Sprintf("%shash", name), XDR_Hash(u.Hash()))
		return
	case MEMO_RETURN:
		x.Marshal(x.Sprintf("%sretHash", name), XDR_Hash(u.RetHash()))
		return
	}
	XdrPanic("invalid Type (%v) in Memo", u.Type)
}
func XDR_Memo(v *Memo) *Memo { return v }

type XdrType_TimeBounds = *TimeBounds

func (v *TimeBounds) XdrPointer() interface{}       { return v }
func (TimeBounds) XdrTypeName() string              { return "TimeBounds" }
func (v TimeBounds) XdrValue() interface{}          { return v }
func (v *TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TimeBounds) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sminTime", name), XDR_TimePoint(&v.MinTime))
	x.Marshal(x.Sprintf("%smaxTime", name), XDR_TimePoint(&v.MaxTime))
}
func XDR_TimeBounds(v *TimeBounds) *TimeBounds { return v }

type XdrType_LedgerBounds = *LedgerBounds

func (v *LedgerBounds) XdrPointer() interface{}       { return v }
func (LedgerBounds) XdrTypeName() string              { return "LedgerBounds" }
func (v LedgerBounds) XdrValue() interface{}          { return v }
func (v *LedgerBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerBounds) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sminLedger", name), XDR_Uint32(&v.MinLedger))
	x.Marshal(x.Sprintf("%smaxLedger", name), XDR_Uint32(&v.MaxLedger))
}
func XDR_LedgerBounds(v *LedgerBounds) *LedgerBounds { return v }

type _XdrPtr_TimeBounds struct {
	p **TimeBounds
}
type _ptrflag_TimeBounds _XdrPtr_TimeBounds

func (v _ptrflag_TimeBounds) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_TimeBounds) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("TimeBounds flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_TimeBounds) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_TimeBounds) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(TimeBounds)
		}
	default:
		XdrPanic("*TimeBounds present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_TimeBounds) XdrTypeName() string             { return "TimeBounds?" }
func (v _ptrflag_TimeBounds) XdrPointer() interface{}       { return nil }
func (v _ptrflag_TimeBounds) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_TimeBounds) XdrBound() uint32              { return 1 }
func (v _XdrPtr_TimeBounds) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_TimeBounds) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(TimeBounds)
	}
}
func (v _XdrPtr_TimeBounds) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_TimeBounds(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_TimeBounds) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_TimeBounds(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_TimeBounds) XdrTypeName() string       { return "TimeBounds*" }
func (v _XdrPtr_TimeBounds) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_TimeBounds) XdrValue() interface{}   { return *v.p }

type _XdrPtr_LedgerBounds struct {
	p **LedgerBounds
}
type _ptrflag_LedgerBounds _XdrPtr_LedgerBounds

func (v _ptrflag_LedgerBounds) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_LedgerBounds) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("LedgerBounds flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_LedgerBounds) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_LedgerBounds) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(LedgerBounds)
		}
	default:
		XdrPanic("*LedgerBounds present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_LedgerBounds) XdrTypeName() string             { return "LedgerBounds?" }
func (v _ptrflag_LedgerBounds) XdrPointer() interface{}       { return nil }
func (v _ptrflag_LedgerBounds) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_LedgerBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_LedgerBounds) XdrBound() uint32              { return 1 }
func (v _XdrPtr_LedgerBounds) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_LedgerBounds) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(LedgerBounds)
	}
}
func (v _XdrPtr_LedgerBounds) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_LedgerBounds(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_LedgerBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_LedgerBounds) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_LedgerBounds(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_LedgerBounds) XdrTypeName() string       { return "LedgerBounds*" }
func (v _XdrPtr_LedgerBounds) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_LedgerBounds) XdrValue() interface{}   { return *v.p }

type _XdrPtr_SequenceNumber struct {
	p **SequenceNumber
}
type _ptrflag_SequenceNumber _XdrPtr_SequenceNumber

func (v _ptrflag_SequenceNumber) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SequenceNumber) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SequenceNumber flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SequenceNumber) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SequenceNumber) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SequenceNumber)
		}
	default:
		XdrPanic("*SequenceNumber present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SequenceNumber) XdrTypeName() string             { return "SequenceNumber?" }
func (v _ptrflag_SequenceNumber) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SequenceNumber) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SequenceNumber) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SequenceNumber) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SequenceNumber) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SequenceNumber) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SequenceNumber)
	}
}
func (v _XdrPtr_SequenceNumber) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SequenceNumber(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SequenceNumber) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SequenceNumber) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SequenceNumber(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SequenceNumber) XdrTypeName() string       { return "SequenceNumber*" }
func (v _XdrPtr_SequenceNumber) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SequenceNumber) XdrValue() interface{}   { return *v.p }

type _XdrVec_2_SignerKey []SignerKey

func (_XdrVec_2_SignerKey) XdrBound() uint32 {
	const bound uint32 = 2 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_2_SignerKey) XdrCheckLen(length uint32) {
	if length > uint32(2) {
		XdrPanic("_XdrVec_2_SignerKey length %d exceeds bound 2", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_2_SignerKey length %d exceeds max int", length)
	}
}
func (v _XdrVec_2_SignerKey) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_2_SignerKey) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(2); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SignerKey, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_2_SignerKey) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SignerKey(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_2_SignerKey) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 2}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_2_SignerKey) XdrTypeName() string              { return "SignerKey<>" }
func (v *_XdrVec_2_SignerKey) XdrPointer() interface{}       { return (*[]SignerKey)(v) }
func (v _XdrVec_2_SignerKey) XdrValue() interface{}          { return ([]SignerKey)(v) }
func (v *_XdrVec_2_SignerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PreconditionsV2 = *PreconditionsV2

func (v *PreconditionsV2) XdrPointer() interface{}       { return v }
func (PreconditionsV2) XdrTypeName() string              { return "PreconditionsV2" }
func (v PreconditionsV2) XdrValue() interface{}          { return v }
func (v *PreconditionsV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PreconditionsV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stimeBounds", name), _XdrPtr_TimeBounds{&v.TimeBounds})
	x.Marshal(x.Sprintf("%sledgerBounds", name), _XdrPtr_LedgerBounds{&v.LedgerBounds})
	x.Marshal(x.Sprintf("%sminSeqNum", name), _XdrPtr_SequenceNumber{&v.MinSeqNum})
	x.Marshal(x.Sprintf("%sminSeqAge", name), XDR_Duration(&v.MinSeqAge))
	x.Marshal(x.Sprintf("%sminSeqLedgerGap", name), XDR_Uint32(&v.MinSeqLedgerGap))
	x.Marshal(x.Sprintf("%sextraSigners", name), (*_XdrVec_2_SignerKey)(&v.ExtraSigners))
}
func XDR_PreconditionsV2(v *PreconditionsV2) *PreconditionsV2 { return v }

var _XdrNames_PreconditionType = map[int32]string{
	int32(PRECOND_NONE): "PRECOND_NONE",
	int32(PRECOND_TIME): "PRECOND_TIME",
	int32(PRECOND_V2):   "PRECOND_V2",
}
var _XdrValues_PreconditionType = map[string]int32{
	"PRECOND_NONE": int32(PRECOND_NONE),
	"PRECOND_TIME": int32(PRECOND_TIME),
	"PRECOND_V2":   int32(PRECOND_V2),
}

func (PreconditionType) XdrEnumNames() map[int32]string {
	return _XdrNames_PreconditionType
}
func (v PreconditionType) String() string {
	if s, ok := _XdrNames_PreconditionType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PreconditionType#%d", v)
}
func (v *PreconditionType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PreconditionType[stok]; ok {
			*v = PreconditionType(val)
			return nil
		} else if stok == "PreconditionType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PreconditionType.", stok))
	}
}
func (v PreconditionType) GetU32() uint32                 { return uint32(v) }
func (v *PreconditionType) SetU32(n uint32)               { *v = PreconditionType(n) }
func (v *PreconditionType) XdrPointer() interface{}       { return v }
func (PreconditionType) XdrTypeName() string              { return "PreconditionType" }
func (v PreconditionType) XdrValue() interface{}          { return v }
func (v *PreconditionType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PreconditionType = *PreconditionType

func XDR_PreconditionType(v *PreconditionType) *PreconditionType { return v }

var _XdrTags_Preconditions = map[int32]bool{
	XdrToI32(PRECOND_NONE): true,
	XdrToI32(PRECOND_TIME): true,
	XdrToI32(PRECOND_V2):   true,
}

func (_ Preconditions) XdrValidTags() map[int32]bool {
	return _XdrTags_Preconditions
}
func (u *Preconditions) TimeBounds() *TimeBounds {
	switch u.Type {
	case PRECOND_TIME:
		if v, ok := u._u.(*TimeBounds); ok {
			return v
		} else {
			var zero TimeBounds
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Preconditions.TimeBounds accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Preconditions) V2() *PreconditionsV2 {
	switch u.Type {
	case PRECOND_V2:
		if v, ok := u._u.(*PreconditionsV2); ok {
			return v
		} else {
			var zero PreconditionsV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Preconditions.V2 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Preconditions) XdrValid() bool {
	switch u.Type {
	case PRECOND_NONE, PRECOND_TIME, PRECOND_V2:
		return true
	}
	return false
}
func (u *Preconditions) XdrUnionTag() XdrNum32 {
	return XDR_PreconditionType(&u.Type)
}
func (u *Preconditions) XdrUnionTagName() string {
	return "Type"
}
func (u *Preconditions) XdrUnionBody() XdrType {
	switch u.Type {
	case PRECOND_NONE:
		return nil
	case PRECOND_TIME:
		return XDR_TimeBounds(u.TimeBounds())
	case PRECOND_V2:
		return XDR_PreconditionsV2(u.V2())
	}
	return nil
}
func (u *Preconditions) XdrUnionBodyName() string {
	switch u.Type {
	case PRECOND_NONE:
		return ""
	case PRECOND_TIME:
		return "TimeBounds"
	case PRECOND_V2:
		return "V2"
	}
	return ""
}

type XdrType_Preconditions = *Preconditions

func (v *Preconditions) XdrPointer() interface{}       { return v }
func (Preconditions) XdrTypeName() string              { return "Preconditions" }
func (v Preconditions) XdrValue() interface{}          { return v }
func (v *Preconditions) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Preconditions) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PreconditionType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case PRECOND_NONE:
		return
	case PRECOND_TIME:
		x.Marshal(x.Sprintf("%stimeBounds", name), XDR_TimeBounds(u.TimeBounds()))
		return
	case PRECOND_V2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_PreconditionsV2(u.V2()))
		return
	}
	XdrPanic("invalid Type (%v) in Preconditions", u.Type)
}
func XDR_Preconditions(v *Preconditions) *Preconditions { return v }

type XdrType_LedgerFootprint = *LedgerFootprint

func (v *LedgerFootprint) XdrPointer() interface{}       { return v }
func (LedgerFootprint) XdrTypeName() string              { return "LedgerFootprint" }
func (v LedgerFootprint) XdrValue() interface{}          { return v }
func (v *LedgerFootprint) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerFootprint) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sreadOnly", name), (*_XdrVec_unbounded_LedgerKey)(&v.ReadOnly))
	x.Marshal(x.Sprintf("%sreadWrite", name), (*_XdrVec_unbounded_LedgerKey)(&v.ReadWrite))
}
func XDR_LedgerFootprint(v *LedgerFootprint) *LedgerFootprint { return v }

type XdrType_SorobanResources = *SorobanResources

func (v *SorobanResources) XdrPointer() interface{}       { return v }
func (SorobanResources) XdrTypeName() string              { return "SorobanResources" }
func (v SorobanResources) XdrValue() interface{}          { return v }
func (v *SorobanResources) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SorobanResources) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfootprint", name), XDR_LedgerFootprint(&v.Footprint))
	x.Marshal(x.Sprintf("%sinstructions", name), XDR_Uint32(&v.Instructions))
	x.Marshal(x.Sprintf("%sreadBytes", name), XDR_Uint32(&v.ReadBytes))
	x.Marshal(x.Sprintf("%swriteBytes", name), XDR_Uint32(&v.WriteBytes))
}
func XDR_SorobanResources(v *SorobanResources) *SorobanResources { return v }

type XdrType_SorobanTransactionData = *SorobanTransactionData

func (v *SorobanTransactionData) XdrPointer() interface{}       { return v }
func (SorobanTransactionData) XdrTypeName() string              { return "SorobanTransactionData" }
func (v SorobanTransactionData) XdrValue() interface{}          { return v }
func (v *SorobanTransactionData) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SorobanTransactionData) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%sresources", name), XDR_SorobanResources(&v.Resources))
	x.Marshal(x.Sprintf("%sresourceFee", name), XDR_Int64(&v.ResourceFee))
}
func XDR_SorobanTransactionData(v *SorobanTransactionData) *SorobanTransactionData { return v }

var _XdrTags_XdrAnon_TransactionV0_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TransactionV0_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionV0_Ext
}
func (u XdrAnon_TransactionV0_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionV0_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionV0_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionV0_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionV0_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionV0_Ext = *XdrAnon_TransactionV0_Ext

func (v *XdrAnon_TransactionV0_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_TransactionV0_Ext) XdrTypeName() string              { return "XdrAnon_TransactionV0_Ext" }
func (v XdrAnon_TransactionV0_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TransactionV0_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionV0_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionV0_Ext", u.V)
}
func XDR_XdrAnon_TransactionV0_Ext(v *XdrAnon_TransactionV0_Ext) *XdrAnon_TransactionV0_Ext { return v }

type _XdrVec_100_Operation []Operation

func (_XdrVec_100_Operation) XdrBound() uint32 {
	const bound uint32 = 100 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_100_Operation) XdrCheckLen(length uint32) {
	if length > uint32(100) {
		XdrPanic("_XdrVec_100_Operation length %d exceeds bound 100", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_100_Operation length %d exceeds max int", length)
	}
}
func (v _XdrVec_100_Operation) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_100_Operation) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(100); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Operation, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_100_Operation) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Operation(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_100_Operation) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 100}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_100_Operation) XdrTypeName() string              { return "Operation<>" }
func (v *_XdrVec_100_Operation) XdrPointer() interface{}       { return (*[]Operation)(v) }
func (v _XdrVec_100_Operation) XdrValue() interface{}          { return ([]Operation)(v) }
func (v *_XdrVec_100_Operation) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionV0 = *TransactionV0

func (v *TransactionV0) XdrPointer() interface{}       { return v }
func (TransactionV0) XdrTypeName() string              { return "TransactionV0" }
func (v TransactionV0) XdrValue() interface{}          { return v }
func (v *TransactionV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccountEd25519", name), XDR_Uint256(&v.SourceAccountEd25519))
	x.Marshal(x.Sprintf("%sfee", name), XDR_Uint32(&v.Fee))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%stimeBounds", name), _XdrPtr_TimeBounds{&v.TimeBounds})
	x.Marshal(x.Sprintf("%smemo", name), XDR_Memo(&v.Memo))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_100_Operation)(&v.Operations))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionV0_Ext(&v.Ext))
}
func XDR_TransactionV0(v *TransactionV0) *TransactionV0 { return v }

type _XdrVec_20_DecoratedSignature []DecoratedSignature

func (_XdrVec_20_DecoratedSignature) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_20_DecoratedSignature) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		XdrPanic("_XdrVec_20_DecoratedSignature length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_20_DecoratedSignature length %d exceeds max int", length)
	}
}
func (v _XdrVec_20_DecoratedSignature) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_20_DecoratedSignature) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]DecoratedSignature, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_20_DecoratedSignature) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_DecoratedSignature(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_20_DecoratedSignature) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 20}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_20_DecoratedSignature) XdrTypeName() string              { return "DecoratedSignature<>" }
func (v *_XdrVec_20_DecoratedSignature) XdrPointer() interface{}       { return (*[]DecoratedSignature)(v) }
func (v _XdrVec_20_DecoratedSignature) XdrValue() interface{}          { return ([]DecoratedSignature)(v) }
func (v *_XdrVec_20_DecoratedSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionV0Envelope = *TransactionV0Envelope

func (v *TransactionV0Envelope) XdrPointer() interface{}       { return v }
func (TransactionV0Envelope) XdrTypeName() string              { return "TransactionV0Envelope" }
func (v TransactionV0Envelope) XdrValue() interface{}          { return v }
func (v *TransactionV0Envelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionV0Envelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stx", name), XDR_TransactionV0(&v.Tx))
	x.Marshal(x.Sprintf("%ssignatures", name), (*_XdrVec_20_DecoratedSignature)(&v.Signatures))
}
func XDR_TransactionV0Envelope(v *TransactionV0Envelope) *TransactionV0Envelope { return v }

var _XdrTags_XdrAnon_Transaction_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_Transaction_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_Transaction_Ext
}
func (u *XdrAnon_Transaction_Ext) SorobanData() *SorobanTransactionData {
	switch u.V {
	case 1:
		if v, ok := u._u.(*SorobanTransactionData); ok {
			return v
		} else {
			var zero SorobanTransactionData
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Transaction_Ext.SorobanData accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_Transaction_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_Transaction_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_Transaction_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_Transaction_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_SorobanTransactionData(u.SorobanData())
	}
	return nil
}
func (u *XdrAnon_Transaction_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "SorobanData"
	}
	return ""
}

type XdrType_XdrAnon_Transaction_Ext = *XdrAnon_Transaction_Ext

func (v *XdrAnon_Transaction_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_Transaction_Ext) XdrTypeName() string              { return "XdrAnon_Transaction_Ext" }
func (v XdrAnon_Transaction_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_Transaction_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_Transaction_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%ssorobanData", name), XDR_SorobanTransactionData(u.SorobanData()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_Transaction_Ext", u.V)
}
func XDR_XdrAnon_Transaction_Ext(v *XdrAnon_Transaction_Ext) *XdrAnon_Transaction_Ext { return v }

type XdrType_Transaction = *Transaction

func (v *Transaction) XdrPointer() interface{}       { return v }
func (Transaction) XdrTypeName() string              { return "Transaction" }
func (v Transaction) XdrValue() interface{}          { return v }
func (v *Transaction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Transaction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), XDR_MuxedAccount(&v.SourceAccount))
	x.Marshal(x.Sprintf("%sfee", name), XDR_Uint32(&v.Fee))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%scond", name), XDR_Preconditions(&v.Cond))
	x.Marshal(x.Sprintf("%smemo", name), XDR_Memo(&v.Memo))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_100_Operation)(&v.Operations))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_Transaction_Ext(&v.Ext))
}
func XDR_Transaction(v *Transaction) *Transaction { return v }

type XdrType_TransactionV1Envelope = *TransactionV1Envelope

func (v *TransactionV1Envelope) XdrPointer() interface{}       { return v }
func (TransactionV1Envelope) XdrTypeName() string              { return "TransactionV1Envelope" }
func (v TransactionV1Envelope) XdrValue() interface{}          { return v }
func (v *TransactionV1Envelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionV1Envelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stx", name), XDR_Transaction(&v.Tx))
	x.Marshal(x.Sprintf("%ssignatures", name), (*_XdrVec_20_DecoratedSignature)(&v.Signatures))
}
func XDR_TransactionV1Envelope(v *TransactionV1Envelope) *TransactionV1Envelope { return v }

var _XdrTags_XdrAnon_FeeBumpTransaction_InnerTx = map[int32]bool{
	XdrToI32(ENVELOPE_TYPE_TX): true,
}

func (_ XdrAnon_FeeBumpTransaction_InnerTx) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_FeeBumpTransaction_InnerTx
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) V1() *TransactionV1Envelope {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		if v, ok := u._u.(*TransactionV1Envelope); ok {
			return v
		} else {
			var zero TransactionV1Envelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_FeeBumpTransaction_InnerTx.V1 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_FeeBumpTransaction_InnerTx) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return true
	}
	return false
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrUnionTag() XdrNum32 {
	return XDR_EnvelopeType(&u.Type)
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrUnionBody() XdrType {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return XDR_TransactionV1Envelope(u.V1())
	}
	return nil
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_FeeBumpTransaction_InnerTx = *XdrAnon_FeeBumpTransaction_InnerTx

func (v *XdrAnon_FeeBumpTransaction_InnerTx) XdrPointer() interface{} { return v }
func (XdrAnon_FeeBumpTransaction_InnerTx) XdrTypeName() string {
	return "XdrAnon_FeeBumpTransaction_InnerTx"
}
func (v XdrAnon_FeeBumpTransaction_InnerTx) XdrValue() interface{}          { return v }
func (v *XdrAnon_FeeBumpTransaction_InnerTx) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		x.Marshal(x.Sprintf("%sv1", name), XDR_TransactionV1Envelope(u.V1()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_FeeBumpTransaction_InnerTx", u.Type)
}
func (v *XdrAnon_FeeBumpTransaction_InnerTx) XdrInitialize() {
	var zero EnvelopeType
	switch zero {
	case ENVELOPE_TYPE_TX:
	default:
		if v.Type == zero {
			v.Type = ENVELOPE_TYPE_TX
		}
	}
}
func XDR_XdrAnon_FeeBumpTransaction_InnerTx(v *XdrAnon_FeeBumpTransaction_InnerTx) *XdrAnon_FeeBumpTransaction_InnerTx {
	return v
}

var _XdrTags_XdrAnon_FeeBumpTransaction_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_FeeBumpTransaction_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_FeeBumpTransaction_Ext
}
func (u XdrAnon_FeeBumpTransaction_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_FeeBumpTransaction_Ext = *XdrAnon_FeeBumpTransaction_Ext

func (v *XdrAnon_FeeBumpTransaction_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_FeeBumpTransaction_Ext) XdrTypeName() string              { return "XdrAnon_FeeBumpTransaction_Ext" }
func (v XdrAnon_FeeBumpTransaction_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_FeeBumpTransaction_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_FeeBumpTransaction_Ext", u.V)
}
func XDR_XdrAnon_FeeBumpTransaction_Ext(v *XdrAnon_FeeBumpTransaction_Ext) *XdrAnon_FeeBumpTransaction_Ext {
	return v
}

type XdrType_FeeBumpTransaction = *FeeBumpTransaction

func (v *FeeBumpTransaction) XdrPointer() interface{}       { return v }
func (FeeBumpTransaction) XdrTypeName() string              { return "FeeBumpTransaction" }
func (v FeeBumpTransaction) XdrValue() interface{}          { return v }
func (v *FeeBumpTransaction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FeeBumpTransaction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfeeSource", name), XDR_MuxedAccount(&v.FeeSource))
	x.Marshal(x.Sprintf("%sfee", name), XDR_Int64(&v.Fee))
	x.Marshal(x.Sprintf("%sinnerTx", name), XDR_XdrAnon_FeeBumpTransaction_InnerTx(&v.InnerTx))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_FeeBumpTransaction_Ext(&v.Ext))
}
func XDR_FeeBumpTransaction(v *FeeBumpTransaction) *FeeBumpTransaction { return v }

type XdrType_FeeBumpTransactionEnvelope = *FeeBumpTransactionEnvelope

func (v *FeeBumpTransactionEnvelope) XdrPointer() interface{}       { return v }
func (FeeBumpTransactionEnvelope) XdrTypeName() string              { return "FeeBumpTransactionEnvelope" }
func (v FeeBumpTransactionEnvelope) XdrValue() interface{}          { return v }
func (v *FeeBumpTransactionEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FeeBumpTransactionEnvelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stx", name), XDR_FeeBumpTransaction(&v.Tx))
	x.Marshal(x.Sprintf("%ssignatures", name), (*_XdrVec_20_DecoratedSignature)(&v.Signatures))
}
func XDR_FeeBumpTransactionEnvelope(v *FeeBumpTransactionEnvelope) *FeeBumpTransactionEnvelope {
	return v
}

var _XdrTags_TransactionEnvelope = map[int32]bool{
	XdrToI32(ENVELOPE_TYPE_TX_V0):       true,
	XdrToI32(ENVELOPE_TYPE_TX):          true,
	XdrToI32(ENVELOPE_TYPE_TX_FEE_BUMP): true,
}

func (_ TransactionEnvelope) XdrValidTags() map[int32]bool {
	return _XdrTags_TransactionEnvelope
}
func (u *TransactionEnvelope) V0() *TransactionV0Envelope {
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0:
		if v, ok := u._u.(*TransactionV0Envelope); ok {
			return v
		} else {
			var zero TransactionV0Envelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionEnvelope.V0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *TransactionEnvelope) V1() *TransactionV1Envelope {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		if v, ok := u._u.(*TransactionV1Envelope); ok {
			return v
		} else {
			var zero TransactionV1Envelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionEnvelope.V1 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *TransactionEnvelope) FeeBump() *FeeBumpTransactionEnvelope {
	switch u.Type {
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		if v, ok := u._u.(*FeeBumpTransactionEnvelope); ok {
			return v
		} else {
			var zero FeeBumpTransactionEnvelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionEnvelope.FeeBump accessed when Type == %v", u.Type)
		return nil
	}
}
func (u TransactionEnvelope) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0, ENVELOPE_TYPE_TX, ENVELOPE_TYPE_TX_FEE_BUMP:
		return true
	}
	return false
}
func (u *TransactionEnvelope) XdrUnionTag() XdrNum32 {
	return XDR_EnvelopeType(&u.Type)
}
func (u *TransactionEnvelope) XdrUnionTagName() string {
	return "Type"
}
func (u *TransactionEnvelope) XdrUnionBody() XdrType {
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0:
		return XDR_TransactionV0Envelope(u.V0())
	case ENVELOPE_TYPE_TX:
		return XDR_TransactionV1Envelope(u.V1())
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		return XDR_FeeBumpTransactionEnvelope(u.FeeBump())
	}
	return nil
}
func (u *TransactionEnvelope) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0:
		return "V0"
	case ENVELOPE_TYPE_TX:
		return "V1"
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		return "FeeBump"
	}
	return ""
}

type XdrType_TransactionEnvelope = *TransactionEnvelope

func (v *TransactionEnvelope) XdrPointer() interface{}       { return v }
func (TransactionEnvelope) XdrTypeName() string              { return "TransactionEnvelope" }
func (v TransactionEnvelope) XdrValue() interface{}          { return v }
func (v *TransactionEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TransactionEnvelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_TransactionV0Envelope(u.V0()))
		return
	case ENVELOPE_TYPE_TX:
		x.Marshal(x.Sprintf("%sv1", name), XDR_TransactionV1Envelope(u.V1()))
		return
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		x.Marshal(x.Sprintf("%sfeeBump", name), XDR_FeeBumpTransactionEnvelope(u.FeeBump()))
		return
	}
	XdrPanic("invalid Type (%v) in TransactionEnvelope", u.Type)
}
func XDR_TransactionEnvelope(v *TransactionEnvelope) *TransactionEnvelope { return v }

var _XdrTags_XdrAnon_TransactionSignaturePayload_TaggedTransaction = map[int32]bool{
	XdrToI32(ENVELOPE_TYPE_TX):          true,
	XdrToI32(ENVELOPE_TYPE_TX_FEE_BUMP): true,
}

func (_ XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionSignaturePayload_TaggedTransaction
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) Tx() *Transaction {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		if v, ok := u._u.(*Transaction); ok {
			return v
		} else {
			var zero Transaction
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionSignaturePayload_TaggedTransaction.Tx accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) FeeBump() *FeeBumpTransaction {
	switch u.Type {
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		if v, ok := u._u.(*FeeBumpTransaction); ok {
			return v
		} else {
			var zero FeeBumpTransaction
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionSignaturePayload_TaggedTransaction.FeeBump accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_TX, ENVELOPE_TYPE_TX_FEE_BUMP:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionTag() XdrNum32 {
	return XDR_EnvelopeType(&u.Type)
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionBody() XdrType {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return XDR_Transaction(u.Tx())
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		return XDR_FeeBumpTransaction(u.FeeBump())
	}
	return nil
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return "Tx"
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		return "FeeBump"
	}
	return ""
}

type XdrType_XdrAnon_TransactionSignaturePayload_TaggedTransaction = *XdrAnon_TransactionSignaturePayload_TaggedTransaction

func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrTypeName() string {
	return "XdrAnon_TransactionSignaturePayload_TaggedTransaction"
}
func (v XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		x.Marshal(x.Sprintf("%stx", name), XDR_Transaction(u.Tx()))
		return
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		x.Marshal(x.Sprintf("%sfeeBump", name), XDR_FeeBumpTransaction(u.FeeBump()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_TransactionSignaturePayload_TaggedTransaction", u.Type)
}
func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrInitialize() {
	var zero EnvelopeType
	switch zero {
	case ENVELOPE_TYPE_TX, ENVELOPE_TYPE_TX_FEE_BUMP:
	default:
		if v.Type == zero {
			v.Type = ENVELOPE_TYPE_TX
		}
	}
}
func XDR_XdrAnon_TransactionSignaturePayload_TaggedTransaction(v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) *XdrAnon_TransactionSignaturePayload_TaggedTransaction {
	return v
}

type XdrType_TransactionSignaturePayload = *TransactionSignaturePayload

func (v *TransactionSignaturePayload) XdrPointer() interface{}       { return v }
func (TransactionSignaturePayload) XdrTypeName() string              { return "TransactionSignaturePayload" }
func (v TransactionSignaturePayload) XdrValue() interface{}          { return v }
func (v *TransactionSignaturePayload) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSignaturePayload) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snetworkId", name), XDR_Hash(&v.NetworkId))
	x.Marshal(x.Sprintf("%staggedTransaction", name), XDR_XdrAnon_TransactionSignaturePayload_TaggedTransaction(&v.TaggedTransaction))
}
func XDR_TransactionSignaturePayload(v *TransactionSignaturePayload) *TransactionSignaturePayload {
	return v
}

var _XdrNames_ClaimAtomType = map[int32]string{
	int32(CLAIM_ATOM_TYPE_V0):             "CLAIM_ATOM_TYPE_V0",
	int32(CLAIM_ATOM_TYPE_ORDER_BOOK):     "CLAIM_ATOM_TYPE_ORDER_BOOK",
	int32(CLAIM_ATOM_TYPE_LIQUIDITY_POOL): "CLAIM_ATOM_TYPE_LIQUIDITY_POOL",
}
var _XdrValues_ClaimAtomType = map[string]int32{
	"CLAIM_ATOM_TYPE_V0":             int32(CLAIM_ATOM_TYPE_V0),
	"CLAIM_ATOM_TYPE_ORDER_BOOK":     int32(CLAIM_ATOM_TYPE_ORDER_BOOK),
	"CLAIM_ATOM_TYPE_LIQUIDITY_POOL": int32(CLAIM_ATOM_TYPE_LIQUIDITY_POOL),
}

func (ClaimAtomType) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimAtomType
}
func (v ClaimAtomType) String() string {
	if s, ok := _XdrNames_ClaimAtomType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimAtomType#%d", v)
}
func (v *ClaimAtomType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimAtomType[stok]; ok {
			*v = ClaimAtomType(val)
			return nil
		} else if stok == "ClaimAtomType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimAtomType.", stok))
	}
}
func (v ClaimAtomType) GetU32() uint32                 { return uint32(v) }
func (v *ClaimAtomType) SetU32(n uint32)               { *v = ClaimAtomType(n) }
func (v *ClaimAtomType) XdrPointer() interface{}       { return v }
func (ClaimAtomType) XdrTypeName() string              { return "ClaimAtomType" }
func (v ClaimAtomType) XdrValue() interface{}          { return v }
func (v *ClaimAtomType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimAtomType = *ClaimAtomType

func XDR_ClaimAtomType(v *ClaimAtomType) *ClaimAtomType { return v }

type XdrType_ClaimOfferAtomV0 = *ClaimOfferAtomV0

func (v *ClaimOfferAtomV0) XdrPointer() interface{}       { return v }
func (ClaimOfferAtomV0) XdrTypeName() string              { return "ClaimOfferAtomV0" }
func (v ClaimOfferAtomV0) XdrValue() interface{}          { return v }
func (v *ClaimOfferAtomV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimOfferAtomV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssellerEd25519", name), XDR_Uint256(&v.SellerEd25519))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
	x.Marshal(x.Sprintf("%sassetSold", name), XDR_Asset(&v.AssetSold))
	x.Marshal(x.Sprintf("%samountSold", name), XDR_Int64(&v.AmountSold))
	x.Marshal(x.Sprintf("%sassetBought", name), XDR_Asset(&v.AssetBought))
	x.Marshal(x.Sprintf("%samountBought", name), XDR_Int64(&v.AmountBought))
}
func XDR_ClaimOfferAtomV0(v *ClaimOfferAtomV0) *ClaimOfferAtomV0 { return v }

type XdrType_ClaimOfferAtom = *ClaimOfferAtom

func (v *ClaimOfferAtom) XdrPointer() interface{}       { return v }
func (ClaimOfferAtom) XdrTypeName() string              { return "ClaimOfferAtom" }
func (v ClaimOfferAtom) XdrValue() interface{}          { return v }
func (v *ClaimOfferAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimOfferAtom) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssellerID", name), XDR_AccountID(&v.SellerID))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
	x.Marshal(x.Sprintf("%sassetSold", name), XDR_Asset(&v.AssetSold))
	x.Marshal(x.Sprintf("%samountSold", name), XDR_Int64(&v.AmountSold))
	x.Marshal(x.Sprintf("%sassetBought", name), XDR_Asset(&v.AssetBought))
	x.Marshal(x.Sprintf("%samountBought", name), XDR_Int64(&v.AmountBought))
}
func XDR_ClaimOfferAtom(v *ClaimOfferAtom) *ClaimOfferAtom { return v }

type XdrType_ClaimLiquidityAtom = *ClaimLiquidityAtom

func (v *ClaimLiquidityAtom) XdrPointer() interface{}       { return v }
func (ClaimLiquidityAtom) XdrTypeName() string              { return "ClaimLiquidityAtom" }
func (v ClaimLiquidityAtom) XdrValue() interface{}          { return v }
func (v *ClaimLiquidityAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimLiquidityAtom) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%sassetSold", name), XDR_Asset(&v.AssetSold))
	x.Marshal(x.Sprintf("%samountSold", name), XDR_Int64(&v.AmountSold))
	x.Marshal(x.Sprintf("%sassetBought", name), XDR_Asset(&v.AssetBought))
	x.Marshal(x.Sprintf("%samountBought", name), XDR_Int64(&v.AmountBought))
}
func XDR_ClaimLiquidityAtom(v *ClaimLiquidityAtom) *ClaimLiquidityAtom { return v }

var _XdrTags_ClaimAtom = map[int32]bool{
	XdrToI32(CLAIM_ATOM_TYPE_V0):             true,
	XdrToI32(CLAIM_ATOM_TYPE_ORDER_BOOK):     true,
	XdrToI32(CLAIM_ATOM_TYPE_LIQUIDITY_POOL): true,
}

func (_ ClaimAtom) XdrValidTags() map[int32]bool {
	return _XdrTags_ClaimAtom
}
func (u *ClaimAtom) V0() *ClaimOfferAtomV0 {
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0:
		if v, ok := u._u.(*ClaimOfferAtomV0); ok {
			return v
		} else {
			var zero ClaimOfferAtomV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimAtom.V0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ClaimAtom) OrderBook() *ClaimOfferAtom {
	switch u.Type {
	case CLAIM_ATOM_TYPE_ORDER_BOOK:
		if v, ok := u._u.(*ClaimOfferAtom); ok {
			return v
		} else {
			var zero ClaimOfferAtom
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimAtom.OrderBook accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ClaimAtom) LiquidityPool() *ClaimLiquidityAtom {
	switch u.Type {
	case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		if v, ok := u._u.(*ClaimLiquidityAtom); ok {
			return v
		} else {
			var zero ClaimLiquidityAtom
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimAtom.LiquidityPool accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ClaimAtom) XdrValid() bool {
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0, CLAIM_ATOM_TYPE_ORDER_BOOK, CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		return true
	}
	return false
}
func (u *ClaimAtom) XdrUnionTag() XdrNum32 {
	return XDR_ClaimAtomType(&u.Type)
}
func (u *ClaimAtom) XdrUnionTagName() string {
	return "Type"
}
func (u *ClaimAtom) XdrUnionBody() XdrType {
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0:
		return XDR_ClaimOfferAtomV0(u.V0())
	case CLAIM_ATOM_TYPE_ORDER_BOOK:
		return XDR_ClaimOfferAtom(u.OrderBook())
	case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		return XDR_ClaimLiquidityAtom(u.LiquidityPool())
	}
	return nil
}
func (u *ClaimAtom) XdrUnionBodyName() string {
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0:
		return "V0"
	case CLAIM_ATOM_TYPE_ORDER_BOOK:
		return "OrderBook"
	case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		return "LiquidityPool"
	}
	return ""
}

type XdrType_ClaimAtom = *ClaimAtom

func (v *ClaimAtom) XdrPointer() interface{}       { return v }
func (ClaimAtom) XdrTypeName() string              { return "ClaimAtom" }
func (v ClaimAtom) XdrValue() interface{}          { return v }
func (v *ClaimAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClaimAtom) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimAtomType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_ClaimOfferAtomV0(u.V0()))
		return
	case CLAIM_ATOM_TYPE_ORDER_BOOK:
		x.Marshal(x.Sprintf("%sorderBook", name), XDR_ClaimOfferAtom(u.OrderBook()))
		return
	case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		x.Marshal(x.Sprintf("%sliquidityPool", name), XDR_ClaimLiquidityAtom(u.LiquidityPool()))
		return
	}
	XdrPanic("invalid Type (%v) in ClaimAtom", u.Type)
}
func XDR_ClaimAtom(v *ClaimAtom) *ClaimAtom { return v }

var _XdrNames_CreateAccountResultCode = map[int32]string{
	int32(CREATE_ACCOUNT_SUCCESS):       "CREATE_ACCOUNT_SUCCESS",
	int32(CREATE_ACCOUNT_MALFORMED):     "CREATE_ACCOUNT_MALFORMED",
	int32(CREATE_ACCOUNT_UNDERFUNDED):   "CREATE_ACCOUNT_UNDERFUNDED",
	int32(CREATE_ACCOUNT_LOW_RESERVE):   "CREATE_ACCOUNT_LOW_RESERVE",
	int32(CREATE_ACCOUNT_ALREADY_EXIST): "CREATE_ACCOUNT_ALREADY_EXIST",
}
var _XdrValues_CreateAccountResultCode = map[string]int32{
	"CREATE_ACCOUNT_SUCCESS":       int32(CREATE_ACCOUNT_SUCCESS),
	"CREATE_ACCOUNT_MALFORMED":     int32(CREATE_ACCOUNT_MALFORMED),
	"CREATE_ACCOUNT_UNDERFUNDED":   int32(CREATE_ACCOUNT_UNDERFUNDED),
	"CREATE_ACCOUNT_LOW_RESERVE":   int32(CREATE_ACCOUNT_LOW_RESERVE),
	"CREATE_ACCOUNT_ALREADY_EXIST": int32(CREATE_ACCOUNT_ALREADY_EXIST),
}

func (CreateAccountResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_CreateAccountResultCode
}
func (v CreateAccountResultCode) String() string {
	if s, ok := _XdrNames_CreateAccountResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("CreateAccountResultCode#%d", v)
}
func (v *CreateAccountResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CreateAccountResultCode[stok]; ok {
			*v = CreateAccountResultCode(val)
			return nil
		} else if stok == "CreateAccountResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid CreateAccountResultCode.", stok))
	}
}
func (v CreateAccountResultCode) GetU32() uint32                 { return uint32(v) }
func (v *CreateAccountResultCode) SetU32(n uint32)               { *v = CreateAccountResultCode(n) }
func (v *CreateAccountResultCode) XdrPointer() interface{}       { return v }
func (CreateAccountResultCode) XdrTypeName() string              { return "CreateAccountResultCode" }
func (v CreateAccountResultCode) XdrValue() interface{}          { return v }
func (v *CreateAccountResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_CreateAccountResultCode = *CreateAccountResultCode

func XDR_CreateAccountResultCode(v *CreateAccountResultCode) *CreateAccountResultCode { return v }

var _XdrComments_CreateAccountResultCode = map[int32]string{
	int32(CREATE_ACCOUNT_SUCCESS):       "account was created",
	int32(CREATE_ACCOUNT_MALFORMED):     "invalid destination",
	int32(CREATE_ACCOUNT_UNDERFUNDED):   "not enough funds in source account",
	int32(CREATE_ACCOUNT_LOW_RESERVE):   "would create an account below the min reserve",
	int32(CREATE_ACCOUNT_ALREADY_EXIST): "account already exists",
}

func (e CreateAccountResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_CreateAccountResultCode
}

var _XdrTags_CreateAccountResult = map[int32]bool{
	XdrToI32(CREATE_ACCOUNT_SUCCESS):       true,
	XdrToI32(CREATE_ACCOUNT_MALFORMED):     true,
	XdrToI32(CREATE_ACCOUNT_UNDERFUNDED):   true,
	XdrToI32(CREATE_ACCOUNT_LOW_RESERVE):   true,
	XdrToI32(CREATE_ACCOUNT_ALREADY_EXIST): true,
}

func (_ CreateAccountResult) XdrValidTags() map[int32]bool {
	return _XdrTags_CreateAccountResult
}
func (u CreateAccountResult) XdrValid() bool {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS, CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
		return true
	}
	return false
}
func (u *CreateAccountResult) XdrUnionTag() XdrNum32 {
	return XDR_CreateAccountResultCode(&u.Code)
}
func (u *CreateAccountResult) XdrUnionTagName() string {
	return "Code"
}
func (u *CreateAccountResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return nil
	case CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
		return nil
	}
	return nil
}
func (u *CreateAccountResult) XdrUnionBodyName() string {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return ""
	case CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
		return ""
	}
	return ""
}

type XdrType_CreateAccountResult = *CreateAccountResult

func (v *CreateAccountResult) XdrPointer() interface{}       { return v }
func (CreateAccountResult) XdrTypeName() string              { return "CreateAccountResult" }
func (v CreateAccountResult) XdrValue() interface{}          { return v }
func (v *CreateAccountResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CreateAccountResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_CreateAccountResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return
	case CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
		return
	}
	XdrPanic("invalid Code (%v) in CreateAccountResult", u.Code)
}
func XDR_CreateAccountResult(v *CreateAccountResult) *CreateAccountResult { return v }

var _XdrNames_PaymentResultCode = map[int32]string{
	int32(PAYMENT_SUCCESS):            "PAYMENT_SUCCESS",
	int32(PAYMENT_MALFORMED):          "PAYMENT_MALFORMED",
	int32(PAYMENT_UNDERFUNDED):        "PAYMENT_UNDERFUNDED",
	int32(PAYMENT_SRC_NO_TRUST):       "PAYMENT_SRC_NO_TRUST",
	int32(PAYMENT_SRC_NOT_AUTHORIZED): "PAYMENT_SRC_NOT_AUTHORIZED",
	int32(PAYMENT_NO_DESTINATION):     "PAYMENT_NO_DESTINATION",
	int32(PAYMENT_NO_TRUST):           "PAYMENT_NO_TRUST",
	int32(PAYMENT_NOT_AUTHORIZED):     "PAYMENT_NOT_AUTHORIZED",
	int32(PAYMENT_LINE_FULL):          "PAYMENT_LINE_FULL",
	int32(PAYMENT_NO_ISSUER):          "PAYMENT_NO_ISSUER",
}
var _XdrValues_PaymentResultCode = map[string]int32{
	"PAYMENT_SUCCESS":            int32(PAYMENT_SUCCESS),
	"PAYMENT_MALFORMED":          int32(PAYMENT_MALFORMED),
	"PAYMENT_UNDERFUNDED":        int32(PAYMENT_UNDERFUNDED),
	"PAYMENT_SRC_NO_TRUST":       int32(PAYMENT_SRC_NO_TRUST),
	"PAYMENT_SRC_NOT_AUTHORIZED": int32(PAYMENT_SRC_NOT_AUTHORIZED),
	"PAYMENT_NO_DESTINATION":     int32(PAYMENT_NO_DESTINATION),
	"PAYMENT_NO_TRUST":           int32(PAYMENT_NO_TRUST),
	"PAYMENT_NOT_AUTHORIZED":     int32(PAYMENT_NOT_AUTHORIZED),
	"PAYMENT_LINE_FULL":          int32(PAYMENT_LINE_FULL),
	"PAYMENT_NO_ISSUER":          int32(PAYMENT_NO_ISSUER),
}

func (PaymentResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PaymentResultCode
}
func (v PaymentResultCode) String() string {
	if s, ok := _XdrNames_PaymentResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PaymentResultCode#%d", v)
}
func (v *PaymentResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PaymentResultCode[stok]; ok {
			*v = PaymentResultCode(val)
			return nil
		} else if stok == "PaymentResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PaymentResultCode.", stok))
	}
}
func (v PaymentResultCode) GetU32() uint32                 { return uint32(v) }
func (v *PaymentResultCode) SetU32(n uint32)               { *v = PaymentResultCode(n) }
func (v *PaymentResultCode) XdrPointer() interface{}       { return v }
func (PaymentResultCode) XdrTypeName() string              { return "PaymentResultCode" }
func (v PaymentResultCode) XdrValue() interface{}          { return v }
func (v *PaymentResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PaymentResultCode = *PaymentResultCode

func XDR_PaymentResultCode(v *PaymentResultCode) *PaymentResultCode { return v }

var _XdrComments_PaymentResultCode = map[int32]string{
	int32(PAYMENT_SUCCESS):            "payment successfully completed",
	int32(PAYMENT_MALFORMED):          "bad input",
	int32(PAYMENT_UNDERFUNDED):        "not enough funds in source account",
	int32(PAYMENT_SRC_NO_TRUST):       "no trust line on source account",
	int32(PAYMENT_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PAYMENT_NO_DESTINATION):     "destination account does not exist",
	int32(PAYMENT_NO_TRUST):           "destination missing a trust line for asset",
	int32(PAYMENT_NOT_AUTHORIZED):     "destination not authorized to hold asset",
	int32(PAYMENT_LINE_FULL):          "destination would go above their limit",
	int32(PAYMENT_NO_ISSUER):          "missing issuer on asset",
}

func (e PaymentResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PaymentResultCode
}

var _XdrTags_PaymentResult = map[int32]bool{
	XdrToI32(PAYMENT_SUCCESS):            true,
	XdrToI32(PAYMENT_MALFORMED):          true,
	XdrToI32(PAYMENT_UNDERFUNDED):        true,
	XdrToI32(PAYMENT_SRC_NO_TRUST):       true,
	XdrToI32(PAYMENT_SRC_NOT_AUTHORIZED): true,
	XdrToI32(PAYMENT_NO_DESTINATION):     true,
	XdrToI32(PAYMENT_NO_TRUST):           true,
	XdrToI32(PAYMENT_NOT_AUTHORIZED):     true,
	XdrToI32(PAYMENT_LINE_FULL):          true,
	XdrToI32(PAYMENT_NO_ISSUER):          true,
}

func (_ PaymentResult) XdrValidTags() map[int32]bool {
	return _XdrTags_PaymentResult
}
func (u PaymentResult) XdrValid() bool {
	switch u.Code {
	case PAYMENT_SUCCESS, PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
		return true
	}
	return false
}
func (u *PaymentResult) XdrUnionTag() XdrNum32 {
	return XDR_PaymentResultCode(&u.Code)
}
func (u *PaymentResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PaymentResult) XdrUnionBody() XdrType {
	switch u.Code {
	case PAYMENT_SUCCESS:
		return nil
	case PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
		return nil
	}
	return nil
}
func (u *PaymentResult) XdrUnionBodyName() string {
	switch u.Code {
	case PAYMENT_SUCCESS:
		return ""
	case PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
		return ""
	}
	return ""
}

type XdrType_PaymentResult = *PaymentResult

func (v *PaymentResult) XdrPointer() interface{}       { return v }
func (PaymentResult) XdrTypeName() string              { return "PaymentResult" }
func (v PaymentResult) XdrValue() interface{}          { return v }
func (v *PaymentResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PaymentResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PaymentResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PAYMENT_SUCCESS:
		return
	case PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
		return
	}
	XdrPanic("invalid Code (%v) in PaymentResult", u.Code)
}
func XDR_PaymentResult(v *PaymentResult) *PaymentResult { return v }

var _XdrNames_PathPaymentStrictReceiveResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS):            "PATH_PAYMENT_STRICT_RECEIVE_SUCCESS",
	int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED):          "PATH_PAYMENT_STRICT_RECEIVE_MALFORMED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED):        "PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST):       "PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED): "PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION):     "PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST):           "PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED):     "PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL):          "PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER):          "PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER",
	int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS):     "PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF):   "PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX):       "PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX",
}
var _XdrValues_PathPaymentStrictReceiveResultCode = map[string]int32{
	"PATH_PAYMENT_STRICT_RECEIVE_SUCCESS":            int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS),
	"PATH_PAYMENT_STRICT_RECEIVE_MALFORMED":          int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED),
	"PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED":        int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED),
	"PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST":       int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST),
	"PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED": int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION":     int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST":           int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST),
	"PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED":     int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL":          int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER":          int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER),
	"PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS":     int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS),
	"PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF":   int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF),
	"PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX":       int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX),
}

func (PathPaymentStrictReceiveResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PathPaymentStrictReceiveResultCode
}
func (v PathPaymentStrictReceiveResultCode) String() string {
	if s, ok := _XdrNames_PathPaymentStrictReceiveResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PathPaymentStrictReceiveResultCode#%d", v)
}
func (v *PathPaymentStrictReceiveResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PathPaymentStrictReceiveResultCode[stok]; ok {
			*v = PathPaymentStrictReceiveResultCode(val)
			return nil
		} else if stok == "PathPaymentStrictReceiveResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PathPaymentStrictReceiveResultCode.", stok))
	}
}
func (v PathPaymentStrictReceiveResultCode) GetU32() uint32 { return uint32(v) }
func (v *PathPaymentStrictReceiveResultCode) SetU32(n uint32) {
	*v = PathPaymentStrictReceiveResultCode(n)
}
func (v *PathPaymentStrictReceiveResultCode) XdrPointer() interface{} { return v }
func (PathPaymentStrictReceiveResultCode) XdrTypeName() string {
	return "PathPaymentStrictReceiveResultCode"
}
func (v PathPaymentStrictReceiveResultCode) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictReceiveResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PathPaymentStrictReceiveResultCode = *PathPaymentStrictReceiveResultCode

func XDR_PathPaymentStrictReceiveResultCode(v *PathPaymentStrictReceiveResultCode) *PathPaymentStrictReceiveResultCode {
	return v
}

var _XdrComments_PathPaymentStrictReceiveResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS):            "success",
	int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED):          "bad input",
	int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED):        "not enough funds in source account",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST):       "no trust line on source account",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION):     "destination account does not exist",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST):           "dest missing a trust line for asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED):     "dest not authorized to hold asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL):          "dest would go above their limit",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER):          "missing issuer on one asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS):     "not enough offers to satisfy path",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF):   "would cross one of its own offers",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX):       "could not satisfy sendmax",
}

func (e PathPaymentStrictReceiveResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PathPaymentStrictReceiveResultCode
}

type XdrType_SimplePaymentResult = *SimplePaymentResult

func (v *SimplePaymentResult) XdrPointer() interface{}       { return v }
func (SimplePaymentResult) XdrTypeName() string              { return "SimplePaymentResult" }
func (v SimplePaymentResult) XdrValue() interface{}          { return v }
func (v *SimplePaymentResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SimplePaymentResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_AccountID(&v.Destination))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
}
func XDR_SimplePaymentResult(v *SimplePaymentResult) *SimplePaymentResult { return v }

type _XdrVec_unbounded_ClaimAtom []ClaimAtom

func (_XdrVec_unbounded_ClaimAtom) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_ClaimAtom) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_ClaimAtom length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_ClaimAtom length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_ClaimAtom) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_ClaimAtom) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ClaimAtom, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_ClaimAtom) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_ClaimAtom(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_ClaimAtom) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_ClaimAtom) XdrTypeName() string              { return "ClaimAtom<>" }
func (v *_XdrVec_unbounded_ClaimAtom) XdrPointer() interface{}       { return (*[]ClaimAtom)(v) }
func (v _XdrVec_unbounded_ClaimAtom) XdrValue() interface{}          { return ([]ClaimAtom)(v) }
func (v *_XdrVec_unbounded_ClaimAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_XdrAnon_PathPaymentStrictReceiveResult_Success = *XdrAnon_PathPaymentStrictReceiveResult_Success

func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrPointer() interface{} { return v }
func (XdrAnon_PathPaymentStrictReceiveResult_Success) XdrTypeName() string {
	return "XdrAnon_PathPaymentStrictReceiveResult_Success"
}
func (v XdrAnon_PathPaymentStrictReceiveResult_Success) XdrValue() interface{} { return v }
func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffers", name), (*_XdrVec_unbounded_ClaimAtom)(&v.Offers))
	x.Marshal(x.Sprintf("%slast", name), XDR_SimplePaymentResult(&v.Last))
}
func XDR_XdrAnon_PathPaymentStrictReceiveResult_Success(v *XdrAnon_PathPaymentStrictReceiveResult_Success) *XdrAnon_PathPaymentStrictReceiveResult_Success {
	return v
}

var _XdrTags_PathPaymentStrictReceiveResult = map[int32]bool{
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS):            true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED):          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED):        true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST):       true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED): true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION):     true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST):           true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED):     true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL):          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER):          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS):     true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF):   true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX):       true,
}

func (_ PathPaymentStrictReceiveResult) XdrValidTags() map[int32]bool {
	return _XdrTags_PathPaymentStrictReceiveResult
}
func (u *PathPaymentStrictReceiveResult) Success() *XdrAnon_PathPaymentStrictReceiveResult_Success {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		if v, ok := u._u.(*XdrAnon_PathPaymentStrictReceiveResult_Success); ok {
			return v
		} else {
			var zero XdrAnon_PathPaymentStrictReceiveResult_Success
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictReceiveResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}

// the asset that caused the error
func (u *PathPaymentStrictReceiveResult) NoIssuer() *Asset {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictReceiveResult.NoIssuer accessed when Code == %v", u.Code)
		return nil
	}
}
func (u PathPaymentStrictReceiveResult) XdrValid() bool {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS, PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL, PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER, PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
		return true
	}
	return false
}
func (u *PathPaymentStrictReceiveResult) XdrUnionTag() XdrNum32 {
	return XDR_PathPaymentStrictReceiveResultCode(&u.Code)
}
func (u *PathPaymentStrictReceiveResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PathPaymentStrictReceiveResult) XdrUnionBody() XdrType {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		return XDR_XdrAnon_PathPaymentStrictReceiveResult_Success(u.Success())
	case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
		return nil
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		return XDR_Asset(u.NoIssuer())
	case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
		return nil
	}
	return nil
}
func (u *PathPaymentStrictReceiveResult) XdrUnionBodyName() string {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		return "Success"
	case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
		return ""
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		return "NoIssuer"
	case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
		return ""
	}
	return ""
}

type XdrType_PathPaymentStrictReceiveResult = *PathPaymentStrictReceiveResult

func (v *PathPaymentStrictReceiveResult) XdrPointer() interface{}       { return v }
func (PathPaymentStrictReceiveResult) XdrTypeName() string              { return "PathPaymentStrictReceiveResult" }
func (v PathPaymentStrictReceiveResult) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictReceiveResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PathPaymentStrictReceiveResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PathPaymentStrictReceiveResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_XdrAnon_PathPaymentStrictReceiveResult_Success(u.Success()))
		return
	case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
		return
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		x.Marshal(x.Sprintf("%snoIssuer", name), XDR_Asset(u.NoIssuer()))
		return
	case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
		return
	}
	XdrPanic("invalid Code (%v) in PathPaymentStrictReceiveResult", u.Code)
}
func XDR_PathPaymentStrictReceiveResult(v *PathPaymentStrictReceiveResult) *PathPaymentStrictReceiveResult {
	return v
}

var _XdrNames_PathPaymentStrictSendResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_SEND_SUCCESS):            "PATH_PAYMENT_STRICT_SEND_SUCCESS",
	int32(PATH_PAYMENT_STRICT_SEND_MALFORMED):          "PATH_PAYMENT_STRICT_SEND_MALFORMED",
	int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED):        "PATH_PAYMENT_STRICT_SEND_UNDERFUNDED",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST):       "PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED): "PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION):     "PATH_PAYMENT_STRICT_SEND_NO_DESTINATION",
	int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST):           "PATH_PAYMENT_STRICT_SEND_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED):     "PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL):          "PATH_PAYMENT_STRICT_SEND_LINE_FULL",
	int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER):          "PATH_PAYMENT_STRICT_SEND_NO_ISSUER",
	int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS):     "PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS",
	int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF):   "PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF",
	int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN):      "PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN",
}
var _XdrValues_PathPaymentStrictSendResultCode = map[string]int32{
	"PATH_PAYMENT_STRICT_SEND_SUCCESS":            int32(PATH_PAYMENT_STRICT_SEND_SUCCESS),
	"PATH_PAYMENT_STRICT_SEND_MALFORMED":          int32(PATH_PAYMENT_STRICT_SEND_MALFORMED),
	"PATH_PAYMENT_STRICT_SEND_UNDERFUNDED":        int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED),
	"PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST":       int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST),
	"PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED": int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_SEND_NO_DESTINATION":     int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION),
	"PATH_PAYMENT_STRICT_SEND_NO_TRUST":           int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST),
	"PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED":     int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_SEND_LINE_FULL":          int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL),
	"PATH_PAYMENT_STRICT_SEND_NO_ISSUER":          int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER),
	"PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS":     int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS),
	"PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF":   int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF),
	"PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN":      int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN),
}

func (PathPaymentStrictSendResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PathPaymentStrictSendResultCode
}
func (v PathPaymentStrictSendResultCode) String() string {
	if s, ok := _XdrNames_PathPaymentStrictSendResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PathPaymentStrictSendResultCode#%d", v)
}
func (v *PathPaymentStrictSendResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PathPaymentStrictSendResultCode[stok]; ok {
			*v = PathPaymentStrictSendResultCode(val)
			return nil
		} else if stok == "PathPaymentStrictSendResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PathPaymentStrictSendResultCode.", stok))
	}
}
func (v PathPaymentStrictSendResultCode) GetU32() uint32                 { return uint32(v) }
func (v *PathPaymentStrictSendResultCode) SetU32(n uint32)               { *v = PathPaymentStrictSendResultCode(n) }
func (v *PathPaymentStrictSendResultCode) XdrPointer() interface{}       { return v }
func (PathPaymentStrictSendResultCode) XdrTypeName() string              { return "PathPaymentStrictSendResultCode" }
func (v PathPaymentStrictSendResultCode) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictSendResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PathPaymentStrictSendResultCode = *PathPaymentStrictSendResultCode

func XDR_PathPaymentStrictSendResultCode(v *PathPaymentStrictSendResultCode) *PathPaymentStrictSendResultCode {
	return v
}

var _XdrComments_PathPaymentStrictSendResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_SEND_SUCCESS):            "success",
	int32(PATH_PAYMENT_STRICT_SEND_MALFORMED):          "bad input",
	int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED):        "not enough funds in source account",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST):       "no trust line on source account",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION):     "destination account does not exist",
	int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST):           "dest missing a trust line for asset",
	int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED):     "dest not authorized to hold asset",
	int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL):          "dest would go above their limit",
	int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER):          "missing issuer on one asset",
	int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS):     "not enough offers to satisfy path",
	int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF):   "would cross one of its own offers",
	int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN):      "could not satisfy destMin",
}

func (e PathPaymentStrictSendResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PathPaymentStrictSendResultCode
}

type XdrType_XdrAnon_PathPaymentStrictSendResult_Success = *XdrAnon_PathPaymentStrictSendResult_Success

func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrPointer() interface{} { return v }
func (XdrAnon_PathPaymentStrictSendResult_Success) XdrTypeName() string {
	return "XdrAnon_PathPaymentStrictSendResult_Success"
}
func (v XdrAnon_PathPaymentStrictSendResult_Success) XdrValue() interface{} { return v }
func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffers", name), (*_XdrVec_unbounded_ClaimAtom)(&v.Offers))
	x.Marshal(x.Sprintf("%slast", name), XDR_SimplePaymentResult(&v.Last))
}
func XDR_XdrAnon_PathPaymentStrictSendResult_Success(v *XdrAnon_PathPaymentStrictSendResult_Success) *XdrAnon_PathPaymentStrictSendResult_Success {
	return v
}

var _XdrTags_PathPaymentStrictSendResult = map[int32]bool{
	XdrToI32(PATH_PAYMENT_STRICT_SEND_SUCCESS):            true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_MALFORMED):          true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED):        true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST):       true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED): true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION):     true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_NO_TRUST):           true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED):     true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_LINE_FULL):          true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER):          true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS):     true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF):   true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN):      true,
}

func (_ PathPaymentStrictSendResult) XdrValidTags() map[int32]bool {
	return _XdrTags_PathPaymentStrictSendResult
}
func (u *PathPaymentStrictSendResult) Success() *XdrAnon_PathPaymentStrictSendResult_Success {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		if v, ok := u._u.(*XdrAnon_PathPaymentStrictSendResult_Success); ok {
			return v
		} else {
			var zero XdrAnon_PathPaymentStrictSendResult_Success
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictSendResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}

// the asset that caused the error
func (u *PathPaymentStrictSendResult) NoIssuer() *Asset {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictSendResult.NoIssuer accessed when Code == %v", u.Code)
		return nil
	}
}
func (u PathPaymentStrictSendResult) XdrValid() bool {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS, PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL, PATH_PAYMENT_STRICT_SEND_NO_ISSUER, PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
		return true
	}
	return false
}
func (u *PathPaymentStrictSendResult) XdrUnionTag() XdrNum32 {
	return XDR_PathPaymentStrictSendResultCode(&u.Code)
}
func (u *PathPaymentStrictSendResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PathPaymentStrictSendResult) XdrUnionBody() XdrType {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		return XDR_XdrAnon_PathPaymentStrictSendResult_Success(u.Success())
	case PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL:
		return nil
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		return XDR_Asset(u.NoIssuer())
	case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
		return nil
	}
	return nil
}
func (u *PathPaymentStrictSendResult) XdrUnionBodyName() string {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		return "Success"
	case PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL:
		return ""
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		return "NoIssuer"
	case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
		return ""
	}
	return ""
}

type XdrType_PathPaymentStrictSendResult = *PathPaymentStrictSendResult

func (v *PathPaymentStrictSendResult) XdrPointer() interface{}       { return v }
func (PathPaymentStrictSendResult) XdrTypeName() string              { return "PathPaymentStrictSendResult" }
func (v PathPaymentStrictSendResult) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictSendResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PathPaymentStrictSendResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PathPaymentStrictSendResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_XdrAnon_PathPaymentStrictSendResult_Success(u.Success()))
		return
	case PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL:
		return
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		x.Marshal(x.Sprintf("%snoIssuer", name), XDR_Asset(u.NoIssuer()))
		return
	case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
		return
	}
	XdrPanic("invalid Code (%v) in PathPaymentStrictSendResult", u.Code)
}
func XDR_PathPaymentStrictSendResult(v *PathPaymentStrictSendResult) *PathPaymentStrictSendResult {
	return v
}

var _XdrNames_ManageSellOfferResultCode = map[int32]string{
	int32(MANAGE_SELL_OFFER_SUCCESS):             "MANAGE_SELL_OFFER_SUCCESS",
	int32(MANAGE_SELL_OFFER_MALFORMED):           "MANAGE_SELL_OFFER_MALFORMED",
	int32(MANAGE_SELL_OFFER_SELL_NO_TRUST):       "MANAGE_SELL_OFFER_SELL_NO_TRUST",
	int32(MANAGE_SELL_OFFER_BUY_NO_TRUST):        "MANAGE_SELL_OFFER_BUY_NO_TRUST",
	int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED): "MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED",
	int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED):  "MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED",
	int32(MANAGE_SELL_OFFER_LINE_FULL):           "MANAGE_SELL_OFFER_LINE_FULL",
	int32(MANAGE_SELL_OFFER_UNDERFUNDED):         "MANAGE_SELL_OFFER_UNDERFUNDED",
	int32(MANAGE_SELL_OFFER_CROSS_SELF):          "MANAGE_SELL_OFFER_CROSS_SELF",
	int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER):      "MANAGE_SELL_OFFER_SELL_NO_ISSUER",
	int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER):       "MANAGE_SELL_OFFER_BUY_NO_ISSUER",
	int32(MANAGE_SELL_OFFER_NOT_FOUND):           "MANAGE_SELL_OFFER_NOT_FOUND",
	int32(MANAGE_SELL_OFFER_LOW_RESERVE):         "MANAGE_SELL_OFFER_LOW_RESERVE",
}
var _XdrValues_ManageSellOfferResultCode = map[string]int32{
	"MANAGE_SELL_OFFER_SUCCESS":             int32(MANAGE_SELL_OFFER_SUCCESS),
	"MANAGE_SELL_OFFER_MALFORMED":           int32(MANAGE_SELL_OFFER_MALFORMED),
	"MANAGE_SELL_OFFER_SELL_NO_TRUST":       int32(MANAGE_SELL_OFFER_SELL_NO_TRUST),
	"MANAGE_SELL_OFFER_BUY_NO_TRUST":        int32(MANAGE_SELL_OFFER_BUY_NO_TRUST),
	"MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED": int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED),
	"MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED":  int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED),
	"MANAGE_SELL_OFFER_LINE_FULL":           int32(MANAGE_SELL_OFFER_LINE_FULL),
	"MANAGE_SELL_OFFER_UNDERFUNDED":         int32(MANAGE_SELL_OFFER_UNDERFUNDED),
	"MANAGE_SELL_OFFER_CROSS_SELF":          int32(MANAGE_SELL_OFFER_CROSS_SELF),
	"MANAGE_SELL_OFFER_SELL_NO_ISSUER":      int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER),
	"MANAGE_SELL_OFFER_BUY_NO_ISSUER":       int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER),
	"MANAGE_SELL_OFFER_NOT_FOUND":           int32(MANAGE_SELL_OFFER_NOT_FOUND),
	"MANAGE_SELL_OFFER_LOW_RESERVE":         int32(MANAGE_SELL_OFFER_LOW_RESERVE),
}

func (ManageSellOfferResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageSellOfferResultCode
}
func (v ManageSellOfferResultCode) String() string {
	if s, ok := _XdrNames_ManageSellOfferResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageSellOfferResultCode#%d", v)
}
func (v *ManageSellOfferResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageSellOfferResultCode[stok]; ok {
			*v = ManageSellOfferResultCode(val)
			return nil
		} else if stok == "ManageSellOfferResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageSellOfferResultCode.", stok))
	}
}
func (v ManageSellOfferResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ManageSellOfferResultCode) SetU32(n uint32)               { *v = ManageSellOfferResultCode(n) }
func (v *ManageSellOfferResultCode) XdrPointer() interface{}       { return v }
func (ManageSellOfferResultCode) XdrTypeName() string              { return "ManageSellOfferResultCode" }
func (v ManageSellOfferResultCode) XdrValue() interface{}          { return v }
func (v *ManageSellOfferResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ManageSellOfferResultCode = *ManageSellOfferResultCode

func XDR_ManageSellOfferResultCode(v *ManageSellOfferResultCode) *ManageSellOfferResultCode { return v }

var _XdrComments_ManageSellOfferResultCode = map[int32]string{
	int32(MANAGE_SELL_OFFER_SUCCESS):             "codes considered as \"success\" for the operation",
	int32(MANAGE_SELL_OFFER_MALFORMED):           "generated offer would be invalid",
	int32(MANAGE_SELL_OFFER_SELL_NO_TRUST):       "no trust line for what we're selling",
	int32(MANAGE_SELL_OFFER_BUY_NO_TRUST):        "no trust line for what we're buying",
	int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED): "not authorized to sell",
	int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED):  "not authorized to buy",
	int32(MANAGE_SELL_OFFER_LINE_FULL):           "can't receive more of what it's buying",
	int32(MANAGE_SELL_OFFER_UNDERFUNDED):         "doesn't hold what it's trying to sell",
	int32(MANAGE_SELL_OFFER_CROSS_SELF):          "would cross an offer from the same user",
	int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER):      "no issuer for what we're selling",
	int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER):       "no issuer for what we're buying",
	int32(MANAGE_SELL_OFFER_NOT_FOUND):           "offerID does not match an existing offer",
	int32(MANAGE_SELL_OFFER_LOW_RESERVE):         "not enough funds to create a new Offer",
}

func (e ManageSellOfferResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageSellOfferResultCode
}

var _XdrNames_ManageOfferEffect = map[int32]string{
	int32(MANAGE_OFFER_CREATED): "MANAGE_OFFER_CREATED",
	int32(MANAGE_OFFER_UPDATED): "MANAGE_OFFER_UPDATED",
	int32(MANAGE_OFFER_DELETED): "MANAGE_OFFER_DELETED",
}
var _XdrValues_ManageOfferEffect = map[string]int32{
	"MANAGE_OFFER_CREATED": int32(MANAGE_OFFER_CREATED),
	"MANAGE_OFFER_UPDATED": int32(MANAGE_OFFER_UPDATED),
	"MANAGE_OFFER_DELETED": int32(MANAGE_OFFER_DELETED),
}

func (ManageOfferEffect) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageOfferEffect
}
func (v ManageOfferEffect) String() string {
	if s, ok := _XdrNames_ManageOfferEffect[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageOfferEffect#%d", v)
}
func (v *ManageOfferEffect) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageOfferEffect[stok]; ok {
			*v = ManageOfferEffect(val)
			return nil
		} else if stok == "ManageOfferEffect" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageOfferEffect.", stok))
	}
}
func (v ManageOfferEffect) GetU32() uint32                 { return uint32(v) }
func (v *ManageOfferEffect) SetU32(n uint32)               { *v = ManageOfferEffect(n) }
func (v *ManageOfferEffect) XdrPointer() interface{}       { return v }
func (ManageOfferEffect) XdrTypeName() string              { return "ManageOfferEffect" }
func (v ManageOfferEffect) XdrValue() interface{}          { return v }
func (v *ManageOfferEffect) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ManageOfferEffect = *ManageOfferEffect

func XDR_ManageOfferEffect(v *ManageOfferEffect) *ManageOfferEffect { return v }

var _XdrTags_XdrAnon_ManageOfferSuccessResult_Offer = map[int32]bool{
	XdrToI32(MANAGE_OFFER_CREATED): true,
	XdrToI32(MANAGE_OFFER_UPDATED): true,
	XdrToI32(MANAGE_OFFER_DELETED): true,
}

func (_ XdrAnon_ManageOfferSuccessResult_Offer) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ManageOfferSuccessResult_Offer
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) Offer() *OfferEntry {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		if v, ok := u._u.(*OfferEntry); ok {
			return v
		} else {
			var zero OfferEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_ManageOfferSuccessResult_Offer.Offer accessed when Effect == %v", u.Effect)
		return nil
	}
}
func (u XdrAnon_ManageOfferSuccessResult_Offer) XdrValid() bool {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED, MANAGE_OFFER_DELETED:
		return true
	}
	return false
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionTag() XdrNum32 {
	return XDR_ManageOfferEffect(&u.Effect)
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionTagName() string {
	return "Effect"
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionBody() XdrType {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		return XDR_OfferEntry(u.Offer())
	case MANAGE_OFFER_DELETED:
		return nil
	}
	return nil
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionBodyName() string {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		return "Offer"
	case MANAGE_OFFER_DELETED:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_ManageOfferSuccessResult_Offer = *XdrAnon_ManageOfferSuccessResult_Offer

func (v *XdrAnon_ManageOfferSuccessResult_Offer) XdrPointer() interface{} { return v }
func (XdrAnon_ManageOfferSuccessResult_Offer) XdrTypeName() string {
	return "XdrAnon_ManageOfferSuccessResult_Offer"
}
func (v XdrAnon_ManageOfferSuccessResult_Offer) XdrValue() interface{}          { return v }
func (v *XdrAnon_ManageOfferSuccessResult_Offer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageOfferEffect(&u.Effect).XdrMarshal(x, x.Sprintf("%seffect", name))
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		x.Marshal(x.Sprintf("%soffer", name), XDR_OfferEntry(u.Offer()))
		return
	case MANAGE_OFFER_DELETED:
		return
	}
	XdrPanic("invalid Effect (%v) in XdrAnon_ManageOfferSuccessResult_Offer", u.Effect)
}
func XDR_XdrAnon_ManageOfferSuccessResult_Offer(v *XdrAnon_ManageOfferSuccessResult_Offer) *XdrAnon_ManageOfferSuccessResult_Offer {
	return v
}

type XdrType_ManageOfferSuccessResult = *ManageOfferSuccessResult

func (v *ManageOfferSuccessResult) XdrPointer() interface{}       { return v }
func (ManageOfferSuccessResult) XdrTypeName() string              { return "ManageOfferSuccessResult" }
func (v ManageOfferSuccessResult) XdrValue() interface{}          { return v }
func (v *ManageOfferSuccessResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageOfferSuccessResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffersClaimed", name), (*_XdrVec_unbounded_ClaimAtom)(&v.OffersClaimed))
	x.Marshal(x.Sprintf("%soffer", name), XDR_XdrAnon_ManageOfferSuccessResult_Offer(&v.Offer))
}
func XDR_ManageOfferSuccessResult(v *ManageOfferSuccessResult) *ManageOfferSuccessResult { return v }

var _XdrTags_ManageSellOfferResult = map[int32]bool{
	XdrToI32(MANAGE_SELL_OFFER_SUCCESS):             true,
	XdrToI32(MANAGE_SELL_OFFER_MALFORMED):           true,
	XdrToI32(MANAGE_SELL_OFFER_SELL_NO_TRUST):       true,
	XdrToI32(MANAGE_SELL_OFFER_BUY_NO_TRUST):        true,
	XdrToI32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED): true,
	XdrToI32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED):  true,
	XdrToI32(MANAGE_SELL_OFFER_LINE_FULL):           true,
	XdrToI32(MANAGE_SELL_OFFER_UNDERFUNDED):         true,
	XdrToI32(MANAGE_SELL_OFFER_CROSS_SELF):          true,
	XdrToI32(MANAGE_SELL_OFFER_SELL_NO_ISSUER):      true,
	XdrToI32(MANAGE_SELL_OFFER_BUY_NO_ISSUER):       true,
	XdrToI32(MANAGE_SELL_OFFER_NOT_FOUND):           true,
	XdrToI32(MANAGE_SELL_OFFER_LOW_RESERVE):         true,
}

func (_ ManageSellOfferResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ManageSellOfferResult
}
func (u *ManageSellOfferResult) Success() *ManageOfferSuccessResult {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		if v, ok := u._u.(*ManageOfferSuccessResult); ok {
			return v
		} else {
			var zero ManageOfferSuccessResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ManageSellOfferResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u ManageSellOfferResult) XdrValid() bool {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS, MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
		return true
	}
	return false
}
func (u *ManageSellOfferResult) XdrUnionTag() XdrNum32 {
	return XDR_ManageSellOfferResultCode(&u.Code)
}
func (u *ManageSellOfferResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageSellOfferResult) XdrUnionBody() XdrType {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		return XDR_ManageOfferSuccessResult(u.Success())
	case MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
		return nil
	}
	return nil
}
func (u *ManageSellOfferResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		return "Success"
	case MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
		return ""
	}
	return ""
}

type XdrType_ManageSellOfferResult = *ManageSellOfferResult

func (v *ManageSellOfferResult) XdrPointer() interface{}       { return v }
func (ManageSellOfferResult) XdrTypeName() string              { return "ManageSellOfferResult" }
func (v ManageSellOfferResult) XdrValue() interface{}          { return v }
func (v *ManageSellOfferResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageSellOfferResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageSellOfferResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_ManageOfferSuccessResult(u.Success()))
		return
	case MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
		return
	}
	XdrPanic("invalid Code (%v) in ManageSellOfferResult", u.Code)
}
func XDR_ManageSellOfferResult(v *ManageSellOfferResult) *ManageSellOfferResult { return v }

var _XdrNames_ManageBuyOfferResultCode = map[int32]string{
	int32(MANAGE_BUY_OFFER_SUCCESS):             "MANAGE_BUY_OFFER_SUCCESS",
	int32(MANAGE_BUY_OFFER_MALFORMED):           "MANAGE_BUY_OFFER_MALFORMED",
	int32(MANAGE_BUY_OFFER_SELL_NO_TRUST):       "MANAGE_BUY_OFFER_SELL_NO_TRUST",
	int32(MANAGE_BUY_OFFER_BUY_NO_TRUST):        "MANAGE_BUY_OFFER_BUY_NO_TRUST",
	int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED): "MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED",
	int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED):  "MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED",
	int32(MANAGE_BUY_OFFER_LINE_FULL):           "MANAGE_BUY_OFFER_LINE_FULL",
	int32(MANAGE_BUY_OFFER_UNDERFUNDED):         "MANAGE_BUY_OFFER_UNDERFUNDED",
	int32(MANAGE_BUY_OFFER_CROSS_SELF):          "MANAGE_BUY_OFFER_CROSS_SELF",
	int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER):      "MANAGE_BUY_OFFER_SELL_NO_ISSUER",
	int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER):       "MANAGE_BUY_OFFER_BUY_NO_ISSUER",
	int32(MANAGE_BUY_OFFER_NOT_FOUND):           "MANAGE_BUY_OFFER_NOT_FOUND",
	int32(MANAGE_BUY_OFFER_LOW_RESERVE):         "MANAGE_BUY_OFFER_LOW_RESERVE",
}
var _XdrValues_ManageBuyOfferResultCode = map[string]int32{
	"MANAGE_BUY_OFFER_SUCCESS":             int32(MANAGE_BUY_OFFER_SUCCESS),
	"MANAGE_BUY_OFFER_MALFORMED":           int32(MANAGE_BUY_OFFER_MALFORMED),
	"MANAGE_BUY_OFFER_SELL_NO_TRUST":       int32(MANAGE_BUY_OFFER_SELL_NO_TRUST),
	"MANAGE_BUY_OFFER_BUY_NO_TRUST":        int32(MANAGE_BUY_OFFER_BUY_NO_TRUST),
	"MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED": int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED),
	"MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED":  int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED),
	"MANAGE_BUY_OFFER_LINE_FULL":           int32(MANAGE_BUY_OFFER_LINE_FULL),
	"MANAGE_BUY_OFFER_UNDERFUNDED":         int32(MANAGE_BUY_OFFER_UNDERFUNDED),
	"MANAGE_BUY_OFFER_CROSS_SELF":          int32(MANAGE_BUY_OFFER_CROSS_SELF),
	"MANAGE_BUY_OFFER_SELL_NO_ISSUER":      int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER),
	"MANAGE_BUY_OFFER_BUY_NO_ISSUER":       int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER),
	"MANAGE_BUY_OFFER_NOT_FOUND":           int32(MANAGE_BUY_OFFER_NOT_FOUND),
	"MANAGE_BUY_OFFER_LOW_RESERVE":         int32(MANAGE_BUY_OFFER_LOW_RESERVE),
}

func (ManageBuyOfferResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageBuyOfferResultCode
}
func (v ManageBuyOfferResultCode) String() string {
	if s, ok := _XdrNames_ManageBuyOfferResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageBuyOfferResultCode#%d", v)
}
func (v *ManageBuyOfferResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageBuyOfferResultCode[stok]; ok {
			*v = ManageBuyOfferResultCode(val)
			return nil
		} else if stok == "ManageBuyOfferResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageBuyOfferResultCode.", stok))
	}
}
func (v ManageBuyOfferResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ManageBuyOfferResultCode) SetU32(n uint32)               { *v = ManageBuyOfferResultCode(n) }
func (v *ManageBuyOfferResultCode) XdrPointer() interface{}       { return v }
func (ManageBuyOfferResultCode) XdrTypeName() string              { return "ManageBuyOfferResultCode" }
func (v ManageBuyOfferResultCode) XdrValue() interface{}          { return v }
func (v *ManageBuyOfferResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ManageBuyOfferResultCode = *ManageBuyOfferResultCode

func XDR_ManageBuyOfferResultCode(v *ManageBuyOfferResultCode) *ManageBuyOfferResultCode { return v }

var _XdrComments_ManageBuyOfferResultCode = map[int32]string{
	int32(MANAGE_BUY_OFFER_SUCCESS):             "codes considered as \"success\" for the operation",
	int32(MANAGE_BUY_OFFER_MALFORMED):           "generated offer would be invalid",
	int32(MANAGE_BUY_OFFER_SELL_NO_TRUST):       "no trust line for what we're selling",
	int32(MANAGE_BUY_OFFER_BUY_NO_TRUST):        "no trust line for what we're buying",
	int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED): "not authorized to sell",
	int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED):  "not authorized to buy",
	int32(MANAGE_BUY_OFFER_LINE_FULL):           "can't receive more of what it's buying",
	int32(MANAGE_BUY_OFFER_UNDERFUNDED):         "doesn't hold what it's trying to sell",
	int32(MANAGE_BUY_OFFER_CROSS_SELF):          "would cross an offer from the same user",
	int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER):      "no issuer for what we're selling",
	int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER):       "no issuer for what we're buying",
	int32(MANAGE_BUY_OFFER_NOT_FOUND):           "offerID does not match an existing offer",
	int32(MANAGE_BUY_OFFER_LOW_RESERVE):         "not enough funds to create a new Offer",
}

func (e ManageBuyOfferResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageBuyOfferResultCode
}

var _XdrTags_ManageBuyOfferResult = map[int32]bool{
	XdrToI32(MANAGE_BUY_OFFER_SUCCESS):             true,
	XdrToI32(MANAGE_BUY_OFFER_MALFORMED):           true,
	XdrToI32(MANAGE_BUY_OFFER_SELL_NO_TRUST):       true,
	XdrToI32(MANAGE_BUY_OFFER_BUY_NO_TRUST):        true,
	XdrToI32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED): true,
	XdrToI32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED):  true,
	XdrToI32(MANAGE_BUY_OFFER_LINE_FULL):           true,
	XdrToI32(MANAGE_BUY_OFFER_UNDERFUNDED):         true,
	XdrToI32(MANAGE_BUY_OFFER_CROSS_SELF):          true,
	XdrToI32(MANAGE_BUY_OFFER_SELL_NO_ISSUER):      true,
	XdrToI32(MANAGE_BUY_OFFER_BUY_NO_ISSUER):       true,
	XdrToI32(MANAGE_BUY_OFFER_NOT_FOUND):           true,
	XdrToI32(MANAGE_BUY_OFFER_LOW_RESERVE):         true,
}

func (_ ManageBuyOfferResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ManageBuyOfferResult
}
func (u *ManageBuyOfferResult) Success() *ManageOfferSuccessResult {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		if v, ok := u._u.(*ManageOfferSuccessResult); ok {
			return v
		} else {
			var zero ManageOfferSuccessResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ManageBuyOfferResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u ManageBuyOfferResult) XdrValid() bool {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS, MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
		return true
	}
	return false
}
func (u *ManageBuyOfferResult) XdrUnionTag() XdrNum32 {
	return XDR_ManageBuyOfferResultCode(&u.Code)
}
func (u *ManageBuyOfferResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageBuyOfferResult) XdrUnionBody() XdrType {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		return XDR_ManageOfferSuccessResult(u.Success())
	case MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
		return nil
	}
	return nil
}
func (u *ManageBuyOfferResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		return "Success"
	case MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
		return ""
	}
	return ""
}

type XdrType_ManageBuyOfferResult = *ManageBuyOfferResult

func (v *ManageBuyOfferResult) XdrPointer() interface{}       { return v }
func (ManageBuyOfferResult) XdrTypeName() string              { return "ManageBuyOfferResult" }
func (v ManageBuyOfferResult) XdrValue() interface{}          { return v }
func (v *ManageBuyOfferResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageBuyOfferResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageBuyOfferResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_ManageOfferSuccessResult(u.Success()))
		return
	case MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
		return
	}
	XdrPanic("invalid Code (%v) in ManageBuyOfferResult", u.Code)
}
func XDR_ManageBuyOfferResult(v *ManageBuyOfferResult) *ManageBuyOfferResult { return v }

var _XdrNames_SetOptionsResultCode = map[int32]string{
	int32(SET_OPTIONS_SUCCESS):                 "SET_OPTIONS_SUCCESS",
	int32(SET_OPTIONS_LOW_RESERVE):             "SET_OPTIONS_LOW_RESERVE",
	int32(SET_OPTIONS_TOO_MANY_SIGNERS):        "SET_OPTIONS_TOO_MANY_SIGNERS",
	int32(SET_OPTIONS_BAD_FLAGS):               "SET_OPTIONS_BAD_FLAGS",
	int32(SET_OPTIONS_INVALID_INFLATION):       "SET_OPTIONS_INVALID_INFLATION",
	int32(SET_OPTIONS_CANT_CHANGE):             "SET_OPTIONS_CANT_CHANGE",
	int32(SET_OPTIONS_UNKNOWN_FLAG):            "SET_OPTIONS_UNKNOWN_FLAG",
	int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE):  "SET_OPTIONS_THRESHOLD_OUT_OF_RANGE",
	int32(SET_OPTIONS_BAD_SIGNER):              "SET_OPTIONS_BAD_SIGNER",
	int32(SET_OPTIONS_INVALID_HOME_DOMAIN):     "SET_OPTIONS_INVALID_HOME_DOMAIN",
	int32(SET_OPTIONS_AUTH_REVOCABLE_REQUIRED): "SET_OPTIONS_AUTH_REVOCABLE_REQUIRED",
}
var _XdrValues_SetOptionsResultCode = map[string]int32{
	"SET_OPTIONS_SUCCESS":                 int32(SET_OPTIONS_SUCCESS),
	"SET_OPTIONS_LOW_RESERVE":             int32(SET_OPTIONS_LOW_RESERVE),
	"SET_OPTIONS_TOO_MANY_SIGNERS":        int32(SET_OPTIONS_TOO_MANY_SIGNERS),
	"SET_OPTIONS_BAD_FLAGS":               int32(SET_OPTIONS_BAD_FLAGS),
	"SET_OPTIONS_INVALID_INFLATION":       int32(SET_OPTIONS_INVALID_INFLATION),
	"SET_OPTIONS_CANT_CHANGE":             int32(SET_OPTIONS_CANT_CHANGE),
	"SET_OPTIONS_UNKNOWN_FLAG":            int32(SET_OPTIONS_UNKNOWN_FLAG),
	"SET_OPTIONS_THRESHOLD_OUT_OF_RANGE":  int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE),
	"SET_OPTIONS_BAD_SIGNER":              int32(SET_OPTIONS_BAD_SIGNER),
	"SET_OPTIONS_INVALID_HOME_DOMAIN":     int32(SET_OPTIONS_INVALID_HOME_DOMAIN),
	"SET_OPTIONS_AUTH_REVOCABLE_REQUIRED": int32(SET_OPTIONS_AUTH_REVOCABLE_REQUIRED),
}

func (SetOptionsResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SetOptionsResultCode
}
func (v SetOptionsResultCode) String() string {
	if s, ok := _XdrNames_SetOptionsResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SetOptionsResultCode#%d", v)
}
func (v *SetOptionsResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SetOptionsResultCode[stok]; ok {
			*v = SetOptionsResultCode(val)
			return nil
		} else if stok == "SetOptionsResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SetOptionsResultCode.", stok))
	}
}
func (v SetOptionsResultCode) GetU32() uint32                 { return uint32(v) }
func (v *SetOptionsResultCode) SetU32(n uint32)               { *v = SetOptionsResultCode(n) }
func (v *SetOptionsResultCode) XdrPointer() interface{}       { return v }
func (SetOptionsResultCode) XdrTypeName() string              { return "SetOptionsResultCode" }
func (v SetOptionsResultCode) XdrValue() interface{}          { return v }
func (v *SetOptionsResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SetOptionsResultCode = *SetOptionsResultCode

func XDR_SetOptionsResultCode(v *SetOptionsResultCode) *SetOptionsResultCode { return v }

var _XdrComments_SetOptionsResultCode = map[int32]string{
	int32(SET_OPTIONS_SUCCESS):                 "codes considered as \"success\" for the operation",
	int32(SET_OPTIONS_LOW_RESERVE):             "not enough funds to add a signer",
	int32(SET_OPTIONS_TOO_MANY_SIGNERS):        "max number of signers already reached",
	int32(SET_OPTIONS_BAD_FLAGS):               "invalid combination of clear/set flags",
	int32(SET_OPTIONS_INVALID_INFLATION):       "inflation account does not exist",
	int32(SET_OPTIONS_CANT_CHANGE):             "can no longer change this option",
	int32(SET_OPTIONS_UNKNOWN_FLAG):            "can't set an unknown flag",
	int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE):  "bad value for weight/threshold",
	int32(SET_OPTIONS_BAD_SIGNER):              "signer cannot be masterkey",
	int32(SET_OPTIONS_INVALID_HOME_DOMAIN):     "malformed home domain",
	int32(SET_OPTIONS_AUTH_REVOCABLE_REQUIRED): "auth revocable is required for clawback",
}

func (e SetOptionsResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_SetOptionsResultCode
}

var _XdrTags_SetOptionsResult = map[int32]bool{
	XdrToI32(SET_OPTIONS_SUCCESS):                 true,
	XdrToI32(SET_OPTIONS_LOW_RESERVE):             true,
	XdrToI32(SET_OPTIONS_TOO_MANY_SIGNERS):        true,
	XdrToI32(SET_OPTIONS_BAD_FLAGS):               true,
	XdrToI32(SET_OPTIONS_INVALID_INFLATION):       true,
	XdrToI32(SET_OPTIONS_CANT_CHANGE):             true,
	XdrToI32(SET_OPTIONS_UNKNOWN_FLAG):            true,
	XdrToI32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE):  true,
	XdrToI32(SET_OPTIONS_BAD_SIGNER):              true,
	XdrToI32(SET_OPTIONS_INVALID_HOME_DOMAIN):     true,
	XdrToI32(SET_OPTIONS_AUTH_REVOCABLE_REQUIRED): true,
}

func (_ SetOptionsResult) XdrValidTags() map[int32]bool {
	return _XdrTags_SetOptionsResult
}
func (u SetOptionsResult) XdrValid() bool {
	switch u.Code {
	case SET_OPTIONS_SUCCESS, SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
		return true
	}
	return false
}
func (u *SetOptionsResult) XdrUnionTag() XdrNum32 {
	return XDR_SetOptionsResultCode(&u.Code)
}
func (u *SetOptionsResult) XdrUnionTagName() string {
	return "Code"
}
func (u *SetOptionsResult) XdrUnionBody() XdrType {
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return nil
	case SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
		return nil
	}
	return nil
}
func (u *SetOptionsResult) XdrUnionBodyName() string {
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return ""
	case SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
		return ""
	}
	return ""
}

type XdrType_SetOptionsResult = *SetOptionsResult

func (v *SetOptionsResult) XdrPointer() interface{}       { return v }
func (SetOptionsResult) XdrTypeName() string              { return "SetOptionsResult" }
func (v SetOptionsResult) XdrValue() interface{}          { return v }
func (v *SetOptionsResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SetOptionsResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SetOptionsResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return
	case SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
		return
	}
	XdrPanic("invalid Code (%v) in SetOptionsResult", u.Code)
}
func XDR_SetOptionsResult(v *SetOptionsResult) *SetOptionsResult { return v }

var _XdrNames_ChangeTrustResultCode = map[int32]string{
	int32(CHANGE_TRUST_SUCCESS):                       "CHANGE_TRUST_SUCCESS",
	int32(CHANGE_TRUST_MALFORMED):                     "CHANGE_TRUST_MALFORMED",
	int32(CHANGE_TRUST_NO_ISSUER):                     "CHANGE_TRUST_NO_ISSUER",
	int32(CHANGE_TRUST_INVALID_LIMIT):                 "CHANGE_TRUST_INVALID_LIMIT",
	int32(CHANGE_TRUST_LOW_RESERVE):                   "CHANGE_TRUST_LOW_RESERVE",
	int32(CHANGE_TRUST_SELF_NOT_ALLOWED):              "CHANGE_TRUST_SELF_NOT_ALLOWED",
	int32(CHANGE_TRUST_TRUST_LINE_MISSING):            "CHANGE_TRUST_TRUST_LINE_MISSING",
	int32(CHANGE_TRUST_CANNOT_DELETE):                 "CHANGE_TRUST_CANNOT_DELETE",
	int32(CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES): "CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES",
}
var _XdrValues_ChangeTrustResultCode = map[string]int32{
	"CHANGE_TRUST_SUCCESS":                       int32(CHANGE_TRUST_SUCCESS),
	"CHANGE_TRUST_MALFORMED":                     int32(CHANGE_TRUST_MALFORMED),
	"CHANGE_TRUST_NO_ISSUER":                     int32(CHANGE_TRUST_NO_ISSUER),
	"CHANGE_TRUST_INVALID_LIMIT":                 int32(CHANGE_TRUST_INVALID_LIMIT),
	"CHANGE_TRUST_LOW_RESERVE":                   int32(CHANGE_TRUST_LOW_RESERVE),
	"CHANGE_TRUST_SELF_NOT_ALLOWED":              int32(CHANGE_TRUST_SELF_NOT_ALLOWED),
	"CHANGE_TRUST_TRUST_LINE_MISSING":            int32(CHANGE_TRUST_TRUST_LINE_MISSING),
	"CHANGE_TRUST_CANNOT_DELETE":                 int32(CHANGE_TRUST_CANNOT_DELETE),
	"CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES": int32(CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES),
}

func (ChangeTrustResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ChangeTrustResultCode
}
func (v ChangeTrustResultCode) String() string {
	if s, ok := _XdrNames_ChangeTrustResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ChangeTrustResultCode#%d", v)
}
func (v *ChangeTrustResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ChangeTrustResultCode[stok]; ok {
			*v = ChangeTrustResultCode(val)
			return nil
		} else if stok == "ChangeTrustResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ChangeTrustResultCode.", stok))
	}
}
func (v ChangeTrustResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ChangeTrustResultCode) SetU32(n uint32)               { *v = ChangeTrustResultCode(n) }
func (v *ChangeTrustResultCode) XdrPointer() interface{}       { return v }
func (ChangeTrustResultCode) XdrTypeName() string              { return "ChangeTrustResultCode" }
func (v ChangeTrustResultCode) XdrValue() interface{}          { return v }
func (v *ChangeTrustResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ChangeTrustResultCode = *ChangeTrustResultCode

func XDR_ChangeTrustResultCode(v *ChangeTrustResultCode) *ChangeTrustResultCode { return v }

var _XdrComments_ChangeTrustResultCode = map[int32]string{
	int32(CHANGE_TRUST_SUCCESS):                       "codes considered as \"success\" for the operation",
	int32(CHANGE_TRUST_MALFORMED):                     "bad input",
	int32(CHANGE_TRUST_NO_ISSUER):                     "could not find issuer",
	int32(CHANGE_TRUST_INVALID_LIMIT):                 "cannot drop limit below balance",
	int32(CHANGE_TRUST_LOW_RESERVE):                   "not enough funds to create a new trust line,",
	int32(CHANGE_TRUST_SELF_NOT_ALLOWED):              "trusting self is not allowed",
	int32(CHANGE_TRUST_TRUST_LINE_MISSING):            "Asset trustline is missing for pool",
	int32(CHANGE_TRUST_CANNOT_DELETE):                 "Asset trustline is still referenced in a pool",
	int32(CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES): "Asset trustline is deauthorized",
}

func (e ChangeTrustResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ChangeTrustResultCode
}

var _XdrTags_ChangeTrustResult = map[int32]bool{
	XdrToI32(CHANGE_TRUST_SUCCESS):                       true,
	XdrToI32(CHANGE_TRUST_MALFORMED):                     true,
	XdrToI32(CHANGE_TRUST_NO_ISSUER):                     true,
	XdrToI32(CHANGE_TRUST_INVALID_LIMIT):                 true,
	XdrToI32(CHANGE_TRUST_LOW_RESERVE):                   true,
	XdrToI32(CHANGE_TRUST_SELF_NOT_ALLOWED):              true,
	XdrToI32(CHANGE_TRUST_TRUST_LINE_MISSING):            true,
	XdrToI32(CHANGE_TRUST_CANNOT_DELETE):                 true,
	XdrToI32(CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES): true,
}

func (_ ChangeTrustResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ChangeTrustResult
}
func (u ChangeTrustResult) XdrValid() bool {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS, CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
		return true
	}
	return false
}
func (u *ChangeTrustResult) XdrUnionTag() XdrNum32 {
	return XDR_ChangeTrustResultCode(&u.Code)
}
func (u *ChangeTrustResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ChangeTrustResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return nil
	case CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
		return nil
	}
	return nil
}
func (u *ChangeTrustResult) XdrUnionBodyName() string {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return ""
	case CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
		return ""
	}
	return ""
}

type XdrType_ChangeTrustResult = *ChangeTrustResult

func (v *ChangeTrustResult) XdrPointer() interface{}       { return v }
func (ChangeTrustResult) XdrTypeName() string              { return "ChangeTrustResult" }
func (v ChangeTrustResult) XdrValue() interface{}          { return v }
func (v *ChangeTrustResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ChangeTrustResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ChangeTrustResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return
	case CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
		return
	}
	XdrPanic("invalid Code (%v) in ChangeTrustResult", u.Code)
}
func XDR_ChangeTrustResult(v *ChangeTrustResult) *ChangeTrustResult { return v }

var _XdrNames_AllowTrustResultCode = map[int32]string{
	int32(ALLOW_TRUST_SUCCESS):            "ALLOW_TRUST_SUCCESS",
	int32(ALLOW_TRUST_MALFORMED):          "ALLOW_TRUST_MALFORMED",
	int32(ALLOW_TRUST_NO_TRUST_LINE):      "ALLOW_TRUST_NO_TRUST_LINE",
	int32(ALLOW_TRUST_TRUST_NOT_REQUIRED): "ALLOW_TRUST_TRUST_NOT_REQUIRED",
	int32(ALLOW_TRUST_CANT_REVOKE):        "ALLOW_TRUST_CANT_REVOKE",
	int32(ALLOW_TRUST_SELF_NOT_ALLOWED):   "ALLOW_TRUST_SELF_NOT_ALLOWED",
	int32(ALLOW_TRUST_LOW_RESERVE):        "ALLOW_TRUST_LOW_RESERVE",
}
var _XdrValues_AllowTrustResultCode = map[string]int32{
	"ALLOW_TRUST_SUCCESS":            int32(ALLOW_TRUST_SUCCESS),
	"ALLOW_TRUST_MALFORMED":          int32(ALLOW_TRUST_MALFORMED),
	"ALLOW_TRUST_NO_TRUST_LINE":      int32(ALLOW_TRUST_NO_TRUST_LINE),
	"ALLOW_TRUST_TRUST_NOT_REQUIRED": int32(ALLOW_TRUST_TRUST_NOT_REQUIRED),
	"ALLOW_TRUST_CANT_REVOKE":        int32(ALLOW_TRUST_CANT_REVOKE),
	"ALLOW_TRUST_SELF_NOT_ALLOWED":   int32(ALLOW_TRUST_SELF_NOT_ALLOWED),
	"ALLOW_TRUST_LOW_RESERVE":        int32(ALLOW_TRUST_LOW_RESERVE),
}

func (AllowTrustResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_AllowTrustResultCode
}
func (v AllowTrustResultCode) String() string {
	if s, ok := _XdrNames_AllowTrustResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AllowTrustResultCode#%d", v)
}
func (v *AllowTrustResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AllowTrustResultCode[stok]; ok {
			*v = AllowTrustResultCode(val)
			return nil
		} else if stok == "AllowTrustResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AllowTrustResultCode.", stok))
	}
}
func (v AllowTrustResultCode) GetU32() uint32                 { return uint32(v) }
func (v *AllowTrustResultCode) SetU32(n uint32)               { *v = AllowTrustResultCode(n) }
func (v *AllowTrustResultCode) XdrPointer() interface{}       { return v }
func (AllowTrustResultCode) XdrTypeName() string              { return "AllowTrustResultCode" }
func (v AllowTrustResultCode) XdrValue() interface{}          { return v }
func (v *AllowTrustResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AllowTrustResultCode = *AllowTrustResultCode

func XDR_AllowTrustResultCode(v *AllowTrustResultCode) *AllowTrustResultCode { return v }

var _XdrComments_AllowTrustResultCode = map[int32]string{
	int32(ALLOW_TRUST_SUCCESS):            "codes considered as \"success\" for the operation",
	int32(ALLOW_TRUST_MALFORMED):          "asset is not ASSET_TYPE_ALPHANUM",
	int32(ALLOW_TRUST_NO_TRUST_LINE):      "trustor does not have a trustline",
	int32(ALLOW_TRUST_TRUST_NOT_REQUIRED): "source account does not require trust",
	int32(ALLOW_TRUST_CANT_REVOKE):        "source account can't revoke trust,",
	int32(ALLOW_TRUST_SELF_NOT_ALLOWED):   "trusting self is not allowed",
	int32(ALLOW_TRUST_LOW_RESERVE):        "claimable balances can't be created",
}

func (e AllowTrustResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_AllowTrustResultCode
}

var _XdrTags_AllowTrustResult = map[int32]bool{
	XdrToI32(ALLOW_TRUST_SUCCESS):            true,
	XdrToI32(ALLOW_TRUST_MALFORMED):          true,
	XdrToI32(ALLOW_TRUST_NO_TRUST_LINE):      true,
	XdrToI32(ALLOW_TRUST_TRUST_NOT_REQUIRED): true,
	XdrToI32(ALLOW_TRUST_CANT_REVOKE):        true,
	XdrToI32(ALLOW_TRUST_SELF_NOT_ALLOWED):   true,
	XdrToI32(ALLOW_TRUST_LOW_RESERVE):        true,
}

func (_ AllowTrustResult) XdrValidTags() map[int32]bool {
	return _XdrTags_AllowTrustResult
}
func (u AllowTrustResult) XdrValid() bool {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS, ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
		return true
	}
	return false
}
func (u *AllowTrustResult) XdrUnionTag() XdrNum32 {
	return XDR_AllowTrustResultCode(&u.Code)
}
func (u *AllowTrustResult) XdrUnionTagName() string {
	return "Code"
}
func (u *AllowTrustResult) XdrUnionBody() XdrType {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return nil
	case ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
		return nil
	}
	return nil
}
func (u *AllowTrustResult) XdrUnionBodyName() string {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return ""
	case ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
		return ""
	}
	return ""
}

type XdrType_AllowTrustResult = *AllowTrustResult

func (v *AllowTrustResult) XdrPointer() interface{}       { return v }
func (AllowTrustResult) XdrTypeName() string              { return "AllowTrustResult" }
func (v AllowTrustResult) XdrValue() interface{}          { return v }
func (v *AllowTrustResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AllowTrustResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AllowTrustResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return
	case ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
		return
	}
	XdrPanic("invalid Code (%v) in AllowTrustResult", u.Code)
}
func XDR_AllowTrustResult(v *AllowTrustResult) *AllowTrustResult { return v }

var _XdrNames_AccountMergeResultCode = map[int32]string{
	int32(ACCOUNT_MERGE_SUCCESS):         "ACCOUNT_MERGE_SUCCESS",
	int32(ACCOUNT_MERGE_MALFORMED):       "ACCOUNT_MERGE_MALFORMED",
	int32(ACCOUNT_MERGE_NO_ACCOUNT):      "ACCOUNT_MERGE_NO_ACCOUNT",
	int32(ACCOUNT_MERGE_IMMUTABLE_SET):   "ACCOUNT_MERGE_IMMUTABLE_SET",
	int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): "ACCOUNT_MERGE_HAS_SUB_ENTRIES",
	int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR):  "ACCOUNT_MERGE_SEQNUM_TOO_FAR",
	int32(ACCOUNT_MERGE_DEST_FULL):       "ACCOUNT_MERGE_DEST_FULL",
	int32(ACCOUNT_MERGE_IS_SPONSOR):      "ACCOUNT_MERGE_IS_SPONSOR",
}
var _XdrValues_AccountMergeResultCode = map[string]int32{
	"ACCOUNT_MERGE_SUCCESS":         int32(ACCOUNT_MERGE_SUCCESS),
	"ACCOUNT_MERGE_MALFORMED":       int32(ACCOUNT_MERGE_MALFORMED),
	"ACCOUNT_MERGE_NO_ACCOUNT":      int32(ACCOUNT_MERGE_NO_ACCOUNT),
	"ACCOUNT_MERGE_IMMUTABLE_SET":   int32(ACCOUNT_MERGE_IMMUTABLE_SET),
	"ACCOUNT_MERGE_HAS_SUB_ENTRIES": int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES),
	"ACCOUNT_MERGE_SEQNUM_TOO_FAR":  int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR),
	"ACCOUNT_MERGE_DEST_FULL":       int32(ACCOUNT_MERGE_DEST_FULL),
	"ACCOUNT_MERGE_IS_SPONSOR":      int32(ACCOUNT_MERGE_IS_SPONSOR),
}

func (AccountMergeResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_AccountMergeResultCode
}
func (v AccountMergeResultCode) String() string {
	if s, ok := _XdrNames_AccountMergeResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AccountMergeResultCode#%d", v)
}
func (v *AccountMergeResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AccountMergeResultCode[stok]; ok {
			*v = AccountMergeResultCode(val)
			return nil
		} else if stok == "AccountMergeResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AccountMergeResultCode.", stok))
	}
}
func (v AccountMergeResultCode) GetU32() uint32                 { return uint32(v) }
func (v *AccountMergeResultCode) SetU32(n uint32)               { *v = AccountMergeResultCode(n) }
func (v *AccountMergeResultCode) XdrPointer() interface{}       { return v }
func (AccountMergeResultCode) XdrTypeName() string              { return "AccountMergeResultCode" }
func (v AccountMergeResultCode) XdrValue() interface{}          { return v }
func (v *AccountMergeResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AccountMergeResultCode = *AccountMergeResultCode

func XDR_AccountMergeResultCode(v *AccountMergeResultCode) *AccountMergeResultCode { return v }

var _XdrComments_AccountMergeResultCode = map[int32]string{
	int32(ACCOUNT_MERGE_SUCCESS):         "codes considered as \"success\" for the operation",
	int32(ACCOUNT_MERGE_MALFORMED):       "can't merge onto itself",
	int32(ACCOUNT_MERGE_NO_ACCOUNT):      "destination does not exist",
	int32(ACCOUNT_MERGE_IMMUTABLE_SET):   "source account has AUTH_IMMUTABLE set",
	int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): "account has trust lines/offers",
	int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR):  "sequence number is over max allowed",
	int32(ACCOUNT_MERGE_DEST_FULL):       "can't add source balance to",
	int32(ACCOUNT_MERGE_IS_SPONSOR):      "destination balance",
}

func (e AccountMergeResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_AccountMergeResultCode
}

var _XdrTags_AccountMergeResult = map[int32]bool{
	XdrToI32(ACCOUNT_MERGE_SUCCESS):         true,
	XdrToI32(ACCOUNT_MERGE_MALFORMED):       true,
	XdrToI32(ACCOUNT_MERGE_NO_ACCOUNT):      true,
	XdrToI32(ACCOUNT_MERGE_IMMUTABLE_SET):   true,
	XdrToI32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): true,
	XdrToI32(ACCOUNT_MERGE_SEQNUM_TOO_FAR):  true,
	XdrToI32(ACCOUNT_MERGE_DEST_FULL):       true,
	XdrToI32(ACCOUNT_MERGE_IS_SPONSOR):      true,
}

func (_ AccountMergeResult) XdrValidTags() map[int32]bool {
	return _XdrTags_AccountMergeResult
}

// how much got transferred from source account
func (u *AccountMergeResult) SourceAccountBalance() *Int64 {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AccountMergeResult.SourceAccountBalance accessed when Code == %v", u.Code)
		return nil
	}
}
func (u AccountMergeResult) XdrValid() bool {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS, ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
		return true
	}
	return false
}
func (u *AccountMergeResult) XdrUnionTag() XdrNum32 {
	return XDR_AccountMergeResultCode(&u.Code)
}
func (u *AccountMergeResult) XdrUnionTagName() string {
	return "Code"
}
func (u *AccountMergeResult) XdrUnionBody() XdrType {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		return XDR_Int64(u.SourceAccountBalance())
	case ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
		return nil
	}
	return nil
}
func (u *AccountMergeResult) XdrUnionBodyName() string {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		return "SourceAccountBalance"
	case ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
		return ""
	}
	return ""
}

type XdrType_AccountMergeResult = *AccountMergeResult

func (v *AccountMergeResult) XdrPointer() interface{}       { return v }
func (AccountMergeResult) XdrTypeName() string              { return "AccountMergeResult" }
func (v AccountMergeResult) XdrValue() interface{}          { return v }
func (v *AccountMergeResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AccountMergeResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountMergeResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		x.Marshal(x.Sprintf("%ssourceAccountBalance", name), XDR_Int64(u.SourceAccountBalance()))
		return
	case ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
		return
	}
	XdrPanic("invalid Code (%v) in AccountMergeResult", u.Code)
}
func XDR_AccountMergeResult(v *AccountMergeResult) *AccountMergeResult { return v }

var _XdrNames_InflationResultCode = map[int32]string{
	int32(INFLATION_SUCCESS):  "INFLATION_SUCCESS",
	int32(INFLATION_NOT_TIME): "INFLATION_NOT_TIME",
}
var _XdrValues_InflationResultCode = map[string]int32{
	"INFLATION_SUCCESS":  int32(INFLATION_SUCCESS),
	"INFLATION_NOT_TIME": int32(INFLATION_NOT_TIME),
}

func (InflationResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_InflationResultCode
}
func (v InflationResultCode) String() string {
	if s, ok := _XdrNames_InflationResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("InflationResultCode#%d", v)
}
func (v *InflationResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_InflationResultCode[stok]; ok {
			*v = InflationResultCode(val)
			return nil
		} else if stok == "InflationResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid InflationResultCode.", stok))
	}
}
func (v InflationResultCode) GetU32() uint32                 { return uint32(v) }
func (v *InflationResultCode) SetU32(n uint32)               { *v = InflationResultCode(n) }
func (v *InflationResultCode) XdrPointer() interface{}       { return v }
func (InflationResultCode) XdrTypeName() string              { return "InflationResultCode" }
func (v InflationResultCode) XdrValue() interface{}          { return v }
func (v *InflationResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_InflationResultCode = *InflationResultCode

func XDR_InflationResultCode(v *InflationResultCode) *InflationResultCode { return v }

var _XdrComments_InflationResultCode = map[int32]string{
	int32(INFLATION_SUCCESS):  "codes considered as \"success\" for the operation",
	int32(INFLATION_NOT_TIME): "codes considered as \"failure\" for the operation",
}

func (e InflationResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_InflationResultCode
}

type XdrType_InflationPayout = *InflationPayout

func (v *InflationPayout) XdrPointer() interface{}       { return v }
func (InflationPayout) XdrTypeName() string              { return "InflationPayout" }
func (v InflationPayout) XdrValue() interface{}          { return v }
func (v *InflationPayout) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InflationPayout) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_AccountID(&v.Destination))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
}
func XDR_InflationPayout(v *InflationPayout) *InflationPayout { return v }

type _XdrVec_unbounded_InflationPayout []InflationPayout

func (_XdrVec_unbounded_InflationPayout) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_InflationPayout) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_InflationPayout length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_InflationPayout length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_InflationPayout) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_InflationPayout) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]InflationPayout, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_InflationPayout) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_InflationPayout(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_InflationPayout) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_InflationPayout) XdrTypeName() string              { return "InflationPayout<>" }
func (v *_XdrVec_unbounded_InflationPayout) XdrPointer() interface{}       { return (*[]InflationPayout)(v) }
func (v _XdrVec_unbounded_InflationPayout) XdrValue() interface{}          { return ([]InflationPayout)(v) }
func (v *_XdrVec_unbounded_InflationPayout) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_InflationResult = map[int32]bool{
	XdrToI32(INFLATION_SUCCESS):  true,
	XdrToI32(INFLATION_NOT_TIME): true,
}

func (_ InflationResult) XdrValidTags() map[int32]bool {
	return _XdrTags_InflationResult
}
func (u *InflationResult) Payouts() *[]InflationPayout {
	switch u.Code {
	case INFLATION_SUCCESS:
		if v, ok := u._u.(*[]InflationPayout); ok {
			return v
		} else {
			var zero []InflationPayout
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("InflationResult.Payouts accessed when Code == %v", u.Code)
		return nil
	}
}
func (u InflationResult) XdrValid() bool {
	switch u.Code {
	case INFLATION_SUCCESS, INFLATION_NOT_TIME:
		return true
	}
	return false
}
func (u *InflationResult) XdrUnionTag() XdrNum32 {
	return XDR_InflationResultCode(&u.Code)
}
func (u *InflationResult) XdrUnionTagName() string {
	return "Code"
}
func (u *InflationResult) XdrUnionBody() XdrType {
	switch u.Code {
	case INFLATION_SUCCESS:
		return (*_XdrVec_unbounded_InflationPayout)(u.Payouts())
	case INFLATION_NOT_TIME:
		return nil
	}
	return nil
}
func (u *InflationResult) XdrUnionBodyName() string {
	switch u.Code {
	case INFLATION_SUCCESS:
		return "Payouts"
	case INFLATION_NOT_TIME:
		return ""
	}
	return ""
}

type XdrType_InflationResult = *InflationResult

func (v *InflationResult) XdrPointer() interface{}       { return v }
func (InflationResult) XdrTypeName() string              { return "InflationResult" }
func (v InflationResult) XdrValue() interface{}          { return v }
func (v *InflationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *InflationResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_InflationResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case INFLATION_SUCCESS:
		x.Marshal(x.Sprintf("%spayouts", name), (*_XdrVec_unbounded_InflationPayout)(u.Payouts()))
		return
	case INFLATION_NOT_TIME:
		return
	}
	XdrPanic("invalid Code (%v) in InflationResult", u.Code)
}
func XDR_InflationResult(v *InflationResult) *InflationResult { return v }

var _XdrNames_ManageDataResultCode = map[int32]string{
	int32(MANAGE_DATA_SUCCESS):           "MANAGE_DATA_SUCCESS",
	int32(MANAGE_DATA_NOT_SUPPORTED_YET): "MANAGE_DATA_NOT_SUPPORTED_YET",
	int32(MANAGE_DATA_NAME_NOT_FOUND):    "MANAGE_DATA_NAME_NOT_FOUND",
	int32(MANAGE_DATA_LOW_RESERVE):       "MANAGE_DATA_LOW_RESERVE",
	int32(MANAGE_DATA_INVALID_NAME):      "MANAGE_DATA_INVALID_NAME",
}
var _XdrValues_ManageDataResultCode = map[string]int32{
	"MANAGE_DATA_SUCCESS":           int32(MANAGE_DATA_SUCCESS),
	"MANAGE_DATA_NOT_SUPPORTED_YET": int32(MANAGE_DATA_NOT_SUPPORTED_YET),
	"MANAGE_DATA_NAME_NOT_FOUND":    int32(MANAGE_DATA_NAME_NOT_FOUND),
	"MANAGE_DATA_LOW_RESERVE":       int32(MANAGE_DATA_LOW_RESERVE),
	"MANAGE_DATA_INVALID_NAME":      int32(MANAGE_DATA_INVALID_NAME),
}

func (ManageDataResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageDataResultCode
}
func (v ManageDataResultCode) String() string {
	if s, ok := _XdrNames_ManageDataResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageDataResultCode#%d", v)
}
func (v *ManageDataResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageDataResultCode[stok]; ok {
			*v = ManageDataResultCode(val)
			return nil
		} else if stok == "ManageDataResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageDataResultCode.", stok))
	}
}
func (v ManageDataResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ManageDataResultCode) SetU32(n uint32)               { *v = ManageDataResultCode(n) }
func (v *ManageDataResultCode) XdrPointer() interface{}       { return v }
func (ManageDataResultCode) XdrTypeName() string              { return "ManageDataResultCode" }
func (v ManageDataResultCode) XdrValue() interface{}          { return v }
func (v *ManageDataResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ManageDataResultCode = *ManageDataResultCode

func XDR_ManageDataResultCode(v *ManageDataResultCode) *ManageDataResultCode { return v }

var _XdrComments_ManageDataResultCode = map[int32]string{
	int32(MANAGE_DATA_SUCCESS):           "codes considered as \"success\" for the operation",
	int32(MANAGE_DATA_NOT_SUPPORTED_YET): "The network hasn't moved to this protocol change yet",
	int32(MANAGE_DATA_NAME_NOT_FOUND):    "Trying to remove a Data Entry that isn't there",
	int32(MANAGE_DATA_LOW_RESERVE):       "not enough funds to create a new Data Entry",
	int32(MANAGE_DATA_INVALID_NAME):      "Name not a valid string",
}

func (e ManageDataResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageDataResultCode
}

var _XdrTags_ManageDataResult = map[int32]bool{
	XdrToI32(MANAGE_DATA_SUCCESS):           true,
	XdrToI32(MANAGE_DATA_NOT_SUPPORTED_YET): true,
	XdrToI32(MANAGE_DATA_NAME_NOT_FOUND):    true,
	XdrToI32(MANAGE_DATA_LOW_RESERVE):       true,
	XdrToI32(MANAGE_DATA_INVALID_NAME):      true,
}

func (_ ManageDataResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ManageDataResult
}
func (u ManageDataResult) XdrValid() bool {
	switch u.Code {
	case MANAGE_DATA_SUCCESS, MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
		return true
	}
	return false
}
func (u *ManageDataResult) XdrUnionTag() XdrNum32 {
	return XDR_ManageDataResultCode(&u.Code)
}
func (u *ManageDataResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageDataResult) XdrUnionBody() XdrType {
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return nil
	case MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
		return nil
	}
	return nil
}
func (u *ManageDataResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return ""
	case MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
		return ""
	}
	return ""
}

type XdrType_ManageDataResult = *ManageDataResult

func (v *ManageDataResult) XdrPointer() interface{}       { return v }
func (ManageDataResult) XdrTypeName() string              { return "ManageDataResult" }
func (v ManageDataResult) XdrValue() interface{}          { return v }
func (v *ManageDataResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageDataResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageDataResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return
	case MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
		return
	}
	XdrPanic("invalid Code (%v) in ManageDataResult", u.Code)
}
func XDR_ManageDataResult(v *ManageDataResult) *ManageDataResult { return v }

var _XdrNames_BumpSequenceResultCode = map[int32]string{
	int32(BUMP_SEQUENCE_SUCCESS): "BUMP_SEQUENCE_SUCCESS",
	int32(BUMP_SEQUENCE_BAD_SEQ): "BUMP_SEQUENCE_BAD_SEQ",
}
var _XdrValues_BumpSequenceResultCode = map[string]int32{
	"BUMP_SEQUENCE_SUCCESS": int32(BUMP_SEQUENCE_SUCCESS),
	"BUMP_SEQUENCE_BAD_SEQ": int32(BUMP_SEQUENCE_BAD_SEQ),
}

func (BumpSequenceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_BumpSequenceResultCode
}
func (v BumpSequenceResultCode) String() string {
	if s, ok := _XdrNames_BumpSequenceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("BumpSequenceResultCode#%d", v)
}
func (v *BumpSequenceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BumpSequenceResultCode[stok]; ok {
			*v = BumpSequenceResultCode(val)
			return nil
		} else if stok == "BumpSequenceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid BumpSequenceResultCode.", stok))
	}
}
func (v BumpSequenceResultCode) GetU32() uint32                 { return uint32(v) }
func (v *BumpSequenceResultCode) SetU32(n uint32)               { *v = BumpSequenceResultCode(n) }
func (v *BumpSequenceResultCode) XdrPointer() interface{}       { return v }
func (BumpSequenceResultCode) XdrTypeName() string              { return "BumpSequenceResultCode" }
func (v BumpSequenceResultCode) XdrValue() interface{}          { return v }
func (v *BumpSequenceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_BumpSequenceResultCode = *BumpSequenceResultCode

func XDR_BumpSequenceResultCode(v *BumpSequenceResultCode) *BumpSequenceResultCode { return v }

var _XdrComments_BumpSequenceResultCode = map[int32]string{
	int32(BUMP_SEQUENCE_SUCCESS): "codes considered as \"success\" for the operation",
	int32(BUMP_SEQUENCE_BAD_SEQ): "codes considered as \"failure\" for the operation",
}

func (e BumpSequenceResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_BumpSequenceResultCode
}

var _XdrTags_BumpSequenceResult = map[int32]bool{
	XdrToI32(BUMP_SEQUENCE_SUCCESS): true,
	XdrToI32(BUMP_SEQUENCE_BAD_SEQ): true,
}

func (_ BumpSequenceResult) XdrValidTags() map[int32]bool {
	return _XdrTags_BumpSequenceResult
}
func (u BumpSequenceResult) XdrValid() bool {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS, BUMP_SEQUENCE_BAD_SEQ:
		return true
	}
	return false
}
func (u *BumpSequenceResult) XdrUnionTag() XdrNum32 {
	return XDR_BumpSequenceResultCode(&u.Code)
}
func (u *BumpSequenceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *BumpSequenceResult) XdrUnionBody() XdrType {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return nil
	case BUMP_SEQUENCE_BAD_SEQ:
		return nil
	}
	return nil
}
func (u *BumpSequenceResult) XdrUnionBodyName() string {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return ""
	case BUMP_SEQUENCE_BAD_SEQ:
		return ""
	}
	return ""
}

type XdrType_BumpSequenceResult = *BumpSequenceResult

func (v *BumpSequenceResult) XdrPointer() interface{}       { return v }
func (BumpSequenceResult) XdrTypeName() string              { return "BumpSequenceResult" }
func (v BumpSequenceResult) XdrValue() interface{}          { return v }
func (v *BumpSequenceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *BumpSequenceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BumpSequenceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return
	case BUMP_SEQUENCE_BAD_SEQ:
		return
	}
	XdrPanic("invalid Code (%v) in BumpSequenceResult", u.Code)
}
func XDR_BumpSequenceResult(v *BumpSequenceResult) *BumpSequenceResult { return v }

var _XdrNames_CreateClaimableBalanceResultCode = map[int32]string{
	int32(CREATE_CLAIMABLE_BALANCE_SUCCESS):        "CREATE_CLAIMABLE_BALANCE_SUCCESS",
	int32(CREATE_CLAIMABLE_BALANCE_MALFORMED):      "CREATE_CLAIMABLE_BALANCE_MALFORMED",
	int32(CREATE_CLAIMABLE_BALANCE_LOW_RESERVE):    "CREATE_CLAIMABLE_BALANCE_LOW_RESERVE",
	int32(CREATE_CLAIMABLE_BALANCE_NO_TRUST):       "CREATE_CLAIMABLE_BALANCE_NO_TRUST",
	int32(CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED): "CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED",
	int32(CREATE_CLAIMABLE_BALANCE_UNDERFUNDED):    "CREATE_CLAIMABLE_BALANCE_UNDERFUNDED",
}
var _XdrValues_CreateClaimableBalanceResultCode = map[string]int32{
	"CREATE_CLAIMABLE_BALANCE_SUCCESS":        int32(CREATE_CLAIMABLE_BALANCE_SUCCESS),
	"CREATE_CLAIMABLE_BALANCE_MALFORMED":      int32(CREATE_CLAIMABLE_BALANCE_MALFORMED),
	"CREATE_CLAIMABLE_BALANCE_LOW_RESERVE":    int32(CREATE_CLAIMABLE_BALANCE_LOW_RESERVE),
	"CREATE_CLAIMABLE_BALANCE_NO_TRUST":       int32(CREATE_CLAIMABLE_BALANCE_NO_TRUST),
	"CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED": int32(CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED),
	"CREATE_CLAIMABLE_BALANCE_UNDERFUNDED":    int32(CREATE_CLAIMABLE_BALANCE_UNDERFUNDED),
}

func (CreateClaimableBalanceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_CreateClaimableBalanceResultCode
}
func (v CreateClaimableBalanceResultCode) String() string {
	if s, ok := _XdrNames_CreateClaimableBalanceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("CreateClaimableBalanceResultCode#%d", v)
}
func (v *CreateClaimableBalanceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CreateClaimableBalanceResultCode[stok]; ok {
			*v = CreateClaimableBalanceResultCode(val)
			return nil
		} else if stok == "CreateClaimableBalanceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid CreateClaimableBalanceResultCode.", stok))
	}
}
func (v CreateClaimableBalanceResultCode) GetU32() uint32           { return uint32(v) }
func (v *CreateClaimableBalanceResultCode) SetU32(n uint32)         { *v = CreateClaimableBalanceResultCode(n) }
func (v *CreateClaimableBalanceResultCode) XdrPointer() interface{} { return v }
func (CreateClaimableBalanceResultCode) XdrTypeName() string {
	return "CreateClaimableBalanceResultCode"
}
func (v CreateClaimableBalanceResultCode) XdrValue() interface{}          { return v }
func (v *CreateClaimableBalanceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_CreateClaimableBalanceResultCode = *CreateClaimableBalanceResultCode

func XDR_CreateClaimableBalanceResultCode(v *CreateClaimableBalanceResultCode) *CreateClaimableBalanceResultCode {
	return v
}

var _XdrTags_CreateClaimableBalanceResult = map[int32]bool{
	XdrToI32(CREATE_CLAIMABLE_BALANCE_SUCCESS):        true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_MALFORMED):      true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_LOW_RESERVE):    true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_NO_TRUST):       true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED): true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_UNDERFUNDED):    true,
}

func (_ CreateClaimableBalanceResult) XdrValidTags() map[int32]bool {
	return _XdrTags_CreateClaimableBalanceResult
}
func (u *CreateClaimableBalanceResult) BalanceID() *ClaimableBalanceID {
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS:
		if v, ok := u._u.(*ClaimableBalanceID); ok {
			return v
		} else {
			var zero ClaimableBalanceID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("CreateClaimableBalanceResult.BalanceID accessed when Code == %v", u.Code)
		return nil
	}
}
func (u CreateClaimableBalanceResult) XdrValid() bool {
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS, CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
		return true
	}
	return false
}
func (u *CreateClaimableBalanceResult) XdrUnionTag() XdrNum32 {
	return XDR_CreateClaimableBalanceResultCode(&u.Code)
}
func (u *CreateClaimableBalanceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *CreateClaimableBalanceResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS:
		return XDR_ClaimableBalanceID(u.BalanceID())
	case CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
		return nil
	}
	return nil
}
func (u *CreateClaimableBalanceResult) XdrUnionBodyName() string {
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS:
		return "BalanceID"
	case CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
		return ""
	}
	return ""
}

type XdrType_CreateClaimableBalanceResult = *CreateClaimableBalanceResult

func (v *CreateClaimableBalanceResult) XdrPointer() interface{}       { return v }
func (CreateClaimableBalanceResult) XdrTypeName() string              { return "CreateClaimableBalanceResult" }
func (v CreateClaimableBalanceResult) XdrValue() interface{}          { return v }
func (v *CreateClaimableBalanceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CreateClaimableBalanceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_CreateClaimableBalanceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS:
		x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(u.BalanceID()))
		return
	case CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
		return
	}
	XdrPanic("invalid Code (%v) in CreateClaimableBalanceResult", u.Code)
}
func XDR_CreateClaimableBalanceResult(v *CreateClaimableBalanceResult) *CreateClaimableBalanceResult {
	return v
}

var _XdrNames_ClaimClaimableBalanceResultCode = map[int32]string{
	int32(CLAIM_CLAIMABLE_BALANCE_SUCCESS):        "CLAIM_CLAIMABLE_BALANCE_SUCCESS",
	int32(CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST): "CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST",
	int32(CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM):   "CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM",
	int32(CLAIM_CLAIMABLE_BALANCE_LINE_FULL):      "CLAIM_CLAIMABLE_BALANCE_LINE_FULL",
	int32(CLAIM_CLAIMABLE_BALANCE_NO_TRUST):       "CLAIM_CLAIMABLE_BALANCE_NO_TRUST",
	int32(CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED): "CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED",
}
var _XdrValues_ClaimClaimableBalanceResultCode = map[string]int32{
	"CLAIM_CLAIMABLE_BALANCE_SUCCESS":        int32(CLAIM_CLAIMABLE_BALANCE_SUCCESS),
	"CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST": int32(CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST),
	"CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM":   int32(CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM),
	"CLAIM_CLAIMABLE_BALANCE_LINE_FULL":      int32(CLAIM_CLAIMABLE_BALANCE_LINE_FULL),
	"CLAIM_CLAIMABLE_BALANCE_NO_TRUST":       int32(CLAIM_CLAIMABLE_BALANCE_NO_TRUST),
	"CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED": int32(CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED),
}

func (ClaimClaimableBalanceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimClaimableBalanceResultCode
}
func (v ClaimClaimableBalanceResultCode) String() string {
	if s, ok := _XdrNames_ClaimClaimableBalanceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimClaimableBalanceResultCode#%d", v)
}
func (v *ClaimClaimableBalanceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimClaimableBalanceResultCode[stok]; ok {
			*v = ClaimClaimableBalanceResultCode(val)
			return nil
		} else if stok == "ClaimClaimableBalanceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimClaimableBalanceResultCode.", stok))
	}
}
func (v ClaimClaimableBalanceResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ClaimClaimableBalanceResultCode) SetU32(n uint32)               { *v = ClaimClaimableBalanceResultCode(n) }
func (v *ClaimClaimableBalanceResultCode) XdrPointer() interface{}       { return v }
func (ClaimClaimableBalanceResultCode) XdrTypeName() string              { return "ClaimClaimableBalanceResultCode" }
func (v ClaimClaimableBalanceResultCode) XdrValue() interface{}          { return v }
func (v *ClaimClaimableBalanceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimClaimableBalanceResultCode = *ClaimClaimableBalanceResultCode

func XDR_ClaimClaimableBalanceResultCode(v *ClaimClaimableBalanceResultCode) *ClaimClaimableBalanceResultCode {
	return v
}

var _XdrTags_ClaimClaimableBalanceResult = map[int32]bool{
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_SUCCESS):        true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST): true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM):   true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_LINE_FULL):      true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_NO_TRUST):       true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED): true,
}

func (_ ClaimClaimableBalanceResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ClaimClaimableBalanceResult
}
func (u ClaimClaimableBalanceResult) XdrValid() bool {
	switch u.Code {
	case CLAIM_CLAIMABLE_BALANCE_SUCCESS, CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
		return true
	}
	return false
}
func (u *ClaimClaimableBalanceResult) XdrUnionTag() XdrNum32 {
	return XDR_ClaimClaimableBalanceResultCode(&u.Code)
}
func (u *ClaimClaimableBalanceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ClaimClaimableBalanceResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CLAIM_CLAIMABLE_BALANCE_SUCCESS:
		return nil
	case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
		return nil
	}
	return nil
}
func (u *ClaimClaimableBalanceResult) XdrUnionBodyName() string {
	switch u.Code {
	case CLAIM_CLAIMABLE_BALANCE_SUCCESS:
		return ""
	case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
		return ""
	}
	return ""
}

type XdrType_ClaimClaimableBalanceResult = *ClaimClaimableBalanceResult

func (v *ClaimClaimableBalanceResult) XdrPointer() interface{}       { return v }
func (ClaimClaimableBalanceResult) XdrTypeName() string              { return "ClaimClaimableBalanceResult" }
func (v ClaimClaimableBalanceResult) XdrValue() interface{}          { return v }
func (v *ClaimClaimableBalanceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClaimClaimableBalanceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimClaimableBalanceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CLAIM_CLAIMABLE_BALANCE_SUCCESS:
		return
	case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
		return
	}
	XdrPanic("invalid Code (%v) in ClaimClaimableBalanceResult", u.Code)
}
func XDR_ClaimClaimableBalanceResult(v *ClaimClaimableBalanceResult) *ClaimClaimableBalanceResult {
	return v
}

var _XdrNames_BeginSponsoringFutureReservesResultCode = map[int32]string{
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS):           "BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED):         "BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED): "BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE):         "BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE",
}
var _XdrValues_BeginSponsoringFutureReservesResultCode = map[string]int32{
	"BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS":           int32(BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS),
	"BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED":         int32(BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED),
	"BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED": int32(BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED),
	"BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE":         int32(BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE),
}

func (BeginSponsoringFutureReservesResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_BeginSponsoringFutureReservesResultCode
}
func (v BeginSponsoringFutureReservesResultCode) String() string {
	if s, ok := _XdrNames_BeginSponsoringFutureReservesResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("BeginSponsoringFutureReservesResultCode#%d", v)
}
func (v *BeginSponsoringFutureReservesResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BeginSponsoringFutureReservesResultCode[stok]; ok {
			*v = BeginSponsoringFutureReservesResultCode(val)
			return nil
		} else if stok == "BeginSponsoringFutureReservesResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid BeginSponsoringFutureReservesResultCode.", stok))
	}
}
func (v BeginSponsoringFutureReservesResultCode) GetU32() uint32 { return uint32(v) }
func (v *BeginSponsoringFutureReservesResultCode) SetU32(n uint32) {
	*v = BeginSponsoringFutureReservesResultCode(n)
}
func (v *BeginSponsoringFutureReservesResultCode) XdrPointer() interface{} { return v }
func (BeginSponsoringFutureReservesResultCode) XdrTypeName() string {
	return "BeginSponsoringFutureReservesResultCode"
}
func (v BeginSponsoringFutureReservesResultCode) XdrValue() interface{}          { return v }
func (v *BeginSponsoringFutureReservesResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_BeginSponsoringFutureReservesResultCode = *BeginSponsoringFutureReservesResultCode

func XDR_BeginSponsoringFutureReservesResultCode(v *BeginSponsoringFutureReservesResultCode) *BeginSponsoringFutureReservesResultCode {
	return v
}

var _XdrComments_BeginSponsoringFutureReservesResultCode = map[int32]string{
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS):   "codes considered as \"success\" for the operation",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED): "codes considered as \"failure\" for the operation",
}

func (e BeginSponsoringFutureReservesResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_BeginSponsoringFutureReservesResultCode
}

var _XdrTags_BeginSponsoringFutureReservesResult = map[int32]bool{
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS):           true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED):         true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED): true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE):         true,
}

func (_ BeginSponsoringFutureReservesResult) XdrValidTags() map[int32]bool {
	return _XdrTags_BeginSponsoringFutureReservesResult
}
func (u BeginSponsoringFutureReservesResult) XdrValid() bool {
	switch u.Code {
	case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS, BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
		return true
	}
	return false
}
func (u *BeginSponsoringFutureReservesResult) XdrUnionTag() XdrNum32 {
	return XDR_BeginSponsoringFutureReservesResultCode(&u.Code)
}
func (u *BeginSponsoringFutureReservesResult) XdrUnionTagName() string {
	return "Code"
}
func (u *BeginSponsoringFutureReservesResult) XdrUnionBody() XdrType {
	switch u.Code {
	case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return nil
	case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
		return nil
	}
	return nil
}
func (u *BeginSponsoringFutureReservesResult) XdrUnionBodyName() string {
	switch u.Code {
	case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return ""
	case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
		return ""
	}
	return ""
}

type XdrType_BeginSponsoringFutureReservesResult = *BeginSponsoringFutureReservesResult

func (v *BeginSponsoringFutureReservesResult) XdrPointer() interface{} { return v }
func (BeginSponsoringFutureReservesResult) XdrTypeName() string {
	return "BeginSponsoringFutureReservesResult"
}
func (v BeginSponsoringFutureReservesResult) XdrValue() interface{}          { return v }
func (v *BeginSponsoringFutureReservesResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *BeginSponsoringFutureReservesResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BeginSponsoringFutureReservesResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return
	case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
		return
	}
	XdrPanic("invalid Code (%v) in BeginSponsoringFutureReservesResult", u.Code)
}
func XDR_BeginSponsoringFutureReservesResult(v *BeginSponsoringFutureReservesResult) *BeginSponsoringFutureReservesResult {
	return v
}

var _XdrNames_EndSponsoringFutureReservesResultCode = map[int32]string{
	int32(END_SPONSORING_FUTURE_RESERVES_SUCCESS):       "END_SPONSORING_FUTURE_RESERVES_SUCCESS",
	int32(END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED): "END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED",
}
var _XdrValues_EndSponsoringFutureReservesResultCode = map[string]int32{
	"END_SPONSORING_FUTURE_RESERVES_SUCCESS":       int32(END_SPONSORING_FUTURE_RESERVES_SUCCESS),
	"END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED": int32(END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED),
}

func (EndSponsoringFutureReservesResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_EndSponsoringFutureReservesResultCode
}
func (v EndSponsoringFutureReservesResultCode) String() string {
	if s, ok := _XdrNames_EndSponsoringFutureReservesResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("EndSponsoringFutureReservesResultCode#%d", v)
}
func (v *EndSponsoringFutureReservesResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_EndSponsoringFutureReservesResultCode[stok]; ok {
			*v = EndSponsoringFutureReservesResultCode(val)
			return nil
		} else if stok == "EndSponsoringFutureReservesResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid EndSponsoringFutureReservesResultCode.", stok))
	}
}
func (v EndSponsoringFutureReservesResultCode) GetU32() uint32 { return uint32(v) }
func (v *EndSponsoringFutureReservesResultCode) SetU32(n uint32) {
	*v = EndSponsoringFutureReservesResultCode(n)
}
func (v *EndSponsoringFutureReservesResultCode) XdrPointer() interface{} { return v }
func (EndSponsoringFutureReservesResultCode) XdrTypeName() string {
	return "EndSponsoringFutureReservesResultCode"
}
func (v EndSponsoringFutureReservesResultCode) XdrValue() interface{}          { return v }
func (v *EndSponsoringFutureReservesResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_EndSponsoringFutureReservesResultCode = *EndSponsoringFutureReservesResultCode

func XDR_EndSponsoringFutureReservesResultCode(v *EndSponsoringFutureReservesResultCode) *EndSponsoringFutureReservesResultCode {
	return v
}

var _XdrComments_EndSponsoringFutureReservesResultCode = map[int32]string{
	int32(END_SPONSORING_FUTURE_RESERVES_SUCCESS):       "codes considered as \"success\" for the operation",
	int32(END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED): "codes considered as \"failure\" for the operation",
}

func (e EndSponsoringFutureReservesResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_EndSponsoringFutureReservesResultCode
}

var _XdrTags_EndSponsoringFutureReservesResult = map[int32]bool{
	XdrToI32(END_SPONSORING_FUTURE_RESERVES_SUCCESS):       true,
	XdrToI32(END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED): true,
}

func (_ EndSponsoringFutureReservesResult) XdrValidTags() map[int32]bool {
	return _XdrTags_EndSponsoringFutureReservesResult
}
func (u EndSponsoringFutureReservesResult) XdrValid() bool {
	switch u.Code {
	case END_SPONSORING_FUTURE_RESERVES_SUCCESS, END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
		return true
	}
	return false
}
func (u *EndSponsoringFutureReservesResult) XdrUnionTag() XdrNum32 {
	return XDR_EndSponsoringFutureReservesResultCode(&u.Code)
}
func (u *EndSponsoringFutureReservesResult) XdrUnionTagName() string {
	return "Code"
}
func (u *EndSponsoringFutureReservesResult) XdrUnionBody() XdrType {
	switch u.Code {
	case END_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return nil
	case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
		return nil
	}
	return nil
}
func (u *EndSponsoringFutureReservesResult) XdrUnionBodyName() string {
	switch u.Code {
	case END_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return ""
	case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
		return ""
	}
	return ""
}

type XdrType_EndSponsoringFutureReservesResult = *EndSponsoringFutureReservesResult

func (v *EndSponsoringFutureReservesResult) XdrPointer() interface{} { return v }
func (EndSponsoringFutureReservesResult) XdrTypeName() string {
	return "EndSponsoringFutureReservesResult"
}
func (v EndSponsoringFutureReservesResult) XdrValue() interface{}          { return v }
func (v *EndSponsoringFutureReservesResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *EndSponsoringFutureReservesResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EndSponsoringFutureReservesResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case END_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return
	case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
		return
	}
	XdrPanic("invalid Code (%v) in EndSponsoringFutureReservesResult", u.Code)
}
func XDR_EndSponsoringFutureReservesResult(v *EndSponsoringFutureReservesResult) *EndSponsoringFutureReservesResult {
	return v
}

var _XdrNames_RevokeSponsorshipResultCode = map[int32]string{
	int32(REVOKE_SPONSORSHIP_SUCCESS):           "REVOKE_SPONSORSHIP_SUCCESS",
	int32(REVOKE_SPONSORSHIP_DOES_NOT_EXIST):    "REVOKE_SPONSORSHIP_DOES_NOT_EXIST",
	int32(REVOKE_SPONSORSHIP_NOT_SPONSOR):       "REVOKE_SPONSORSHIP_NOT_SPONSOR",
	int32(REVOKE_SPONSORSHIP_LOW_RESERVE):       "REVOKE_SPONSORSHIP_LOW_RESERVE",
	int32(REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE): "REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE",
	int32(REVOKE_SPONSORSHIP_MALFORMED):         "REVOKE_SPONSORSHIP_MALFORMED",
}
var _XdrValues_RevokeSponsorshipResultCode = map[string]int32{
	"REVOKE_SPONSORSHIP_SUCCESS":           int32(REVOKE_SPONSORSHIP_SUCCESS),
	"REVOKE_SPONSORSHIP_DOES_NOT_EXIST":    int32(REVOKE_SPONSORSHIP_DOES_NOT_EXIST),
	"REVOKE_SPONSORSHIP_NOT_SPONSOR":       int32(REVOKE_SPONSORSHIP_NOT_SPONSOR),
	"REVOKE_SPONSORSHIP_LOW_RESERVE":       int32(REVOKE_SPONSORSHIP_LOW_RESERVE),
	"REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE": int32(REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE),
	"REVOKE_SPONSORSHIP_MALFORMED":         int32(REVOKE_SPONSORSHIP_MALFORMED),
}

func (RevokeSponsorshipResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_RevokeSponsorshipResultCode
}
func (v RevokeSponsorshipResultCode) String() string {
	if s, ok := _XdrNames_RevokeSponsorshipResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("RevokeSponsorshipResultCode#%d", v)
}
func (v *RevokeSponsorshipResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_RevokeSponsorshipResultCode[stok]; ok {
			*v = RevokeSponsorshipResultCode(val)
			return nil
		} else if stok == "RevokeSponsorshipResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid RevokeSponsorshipResultCode.", stok))
	}
}
func (v RevokeSponsorshipResultCode) GetU32() uint32                 { return uint32(v) }
func (v *RevokeSponsorshipResultCode) SetU32(n uint32)               { *v = RevokeSponsorshipResultCode(n) }
func (v *RevokeSponsorshipResultCode) XdrPointer() interface{}       { return v }
func (RevokeSponsorshipResultCode) XdrTypeName() string              { return "RevokeSponsorshipResultCode" }
func (v RevokeSponsorshipResultCode) XdrValue() interface{}          { return v }
func (v *RevokeSponsorshipResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_RevokeSponsorshipResultCode = *RevokeSponsorshipResultCode

func XDR_RevokeSponsorshipResultCode(v *RevokeSponsorshipResultCode) *RevokeSponsorshipResultCode {
	return v
}

var _XdrComments_RevokeSponsorshipResultCode = map[int32]string{
	int32(REVOKE_SPONSORSHIP_SUCCESS):        "codes considered as \"success\" for the operation",
	int32(REVOKE_SPONSORSHIP_DOES_NOT_EXIST): "codes considered as \"failure\" for the operation",
}

func (e RevokeSponsorshipResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_RevokeSponsorshipResultCode
}

var _XdrTags_RevokeSponsorshipResult = map[int32]bool{
	XdrToI32(REVOKE_SPONSORSHIP_SUCCESS):           true,
	XdrToI32(REVOKE_SPONSORSHIP_DOES_NOT_EXIST):    true,
	XdrToI32(REVOKE_SPONSORSHIP_NOT_SPONSOR):       true,
	XdrToI32(REVOKE_SPONSORSHIP_LOW_RESERVE):       true,
	XdrToI32(REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE): true,
	XdrToI32(REVOKE_SPONSORSHIP_MALFORMED):         true,
}

func (_ RevokeSponsorshipResult) XdrValidTags() map[int32]bool {
	return _XdrTags_RevokeSponsorshipResult
}
func (u RevokeSponsorshipResult) XdrValid() bool {
	switch u.Code {
	case REVOKE_SPONSORSHIP_SUCCESS, REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
		return true
	}
	return false
}
func (u *RevokeSponsorshipResult) XdrUnionTag() XdrNum32 {
	return XDR_RevokeSponsorshipResultCode(&u.Code)
}
func (u *RevokeSponsorshipResult) XdrUnionTagName() string {
	return "Code"
}
func (u *RevokeSponsorshipResult) XdrUnionBody() XdrType {
	switch u.Code {
	case REVOKE_SPONSORSHIP_SUCCESS:
		return nil
	case REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
		return nil
	}
	return nil
}
func (u *RevokeSponsorshipResult) XdrUnionBodyName() string {
	switch u.Code {
	case REVOKE_SPONSORSHIP_SUCCESS:
		return ""
	case REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
		return ""
	}
	return ""
}

type XdrType_RevokeSponsorshipResult = *RevokeSponsorshipResult

func (v *RevokeSponsorshipResult) XdrPointer() interface{}       { return v }
func (RevokeSponsorshipResult) XdrTypeName() string              { return "RevokeSponsorshipResult" }
func (v RevokeSponsorshipResult) XdrValue() interface{}          { return v }
func (v *RevokeSponsorshipResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *RevokeSponsorshipResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_RevokeSponsorshipResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case REVOKE_SPONSORSHIP_SUCCESS:
		return
	case REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
		return
	}
	XdrPanic("invalid Code (%v) in RevokeSponsorshipResult", u.Code)
}
func XDR_RevokeSponsorshipResult(v *RevokeSponsorshipResult) *RevokeSponsorshipResult { return v }

var _XdrNames_ClawbackResultCode = map[int32]string{
	int32(CLAWBACK_SUCCESS):              "CLAWBACK_SUCCESS",
	int32(CLAWBACK_MALFORMED):            "CLAWBACK_MALFORMED",
	int32(CLAWBACK_NOT_CLAWBACK_ENABLED): "CLAWBACK_NOT_CLAWBACK_ENABLED",
	int32(CLAWBACK_NO_TRUST):             "CLAWBACK_NO_TRUST",
	int32(CLAWBACK_UNDERFUNDED):          "CLAWBACK_UNDERFUNDED",
}
var _XdrValues_ClawbackResultCode = map[string]int32{
	"CLAWBACK_SUCCESS":              int32(CLAWBACK_SUCCESS),
	"CLAWBACK_MALFORMED":            int32(CLAWBACK_MALFORMED),
	"CLAWBACK_NOT_CLAWBACK_ENABLED": int32(CLAWBACK_NOT_CLAWBACK_ENABLED),
	"CLAWBACK_NO_TRUST":             int32(CLAWBACK_NO_TRUST),
	"CLAWBACK_UNDERFUNDED":          int32(CLAWBACK_UNDERFUNDED),
}

func (ClawbackResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ClawbackResultCode
}
func (v ClawbackResultCode) String() string {
	if s, ok := _XdrNames_ClawbackResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClawbackResultCode#%d", v)
}
func (v *ClawbackResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClawbackResultCode[stok]; ok {
			*v = ClawbackResultCode(val)
			return nil
		} else if stok == "ClawbackResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClawbackResultCode.", stok))
	}
}
func (v ClawbackResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ClawbackResultCode) SetU32(n uint32)               { *v = ClawbackResultCode(n) }
func (v *ClawbackResultCode) XdrPointer() interface{}       { return v }
func (ClawbackResultCode) XdrTypeName() string              { return "ClawbackResultCode" }
func (v ClawbackResultCode) XdrValue() interface{}          { return v }
func (v *ClawbackResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClawbackResultCode = *ClawbackResultCode

func XDR_ClawbackResultCode(v *ClawbackResultCode) *ClawbackResultCode { return v }

var _XdrComments_ClawbackResultCode = map[int32]string{
	int32(CLAWBACK_SUCCESS):   "codes considered as \"success\" for the operation",
	int32(CLAWBACK_MALFORMED): "codes considered as \"failure\" for the operation",
}

func (e ClawbackResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ClawbackResultCode
}

var _XdrTags_ClawbackResult = map[int32]bool{
	XdrToI32(CLAWBACK_SUCCESS):              true,
	XdrToI32(CLAWBACK_MALFORMED):            true,
	XdrToI32(CLAWBACK_NOT_CLAWBACK_ENABLED): true,
	XdrToI32(CLAWBACK_NO_TRUST):             true,
	XdrToI32(CLAWBACK_UNDERFUNDED):          true,
}

func (_ ClawbackResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ClawbackResult
}
func (u ClawbackResult) XdrValid() bool {
	switch u.Code {
	case CLAWBACK_SUCCESS, CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
		return true
	}
	return false
}
func (u *ClawbackResult) XdrUnionTag() XdrNum32 {
	return XDR_ClawbackResultCode(&u.Code)
}
func (u *ClawbackResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ClawbackResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CLAWBACK_SUCCESS:
		return nil
	case CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
		return nil
	}
	return nil
}
func (u *ClawbackResult) XdrUnionBodyName() string {
	switch u.Code {
	case CLAWBACK_SUCCESS:
		return ""
	case CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
		return ""
	}
	return ""
}

type XdrType_ClawbackResult = *ClawbackResult

func (v *ClawbackResult) XdrPointer() interface{}       { return v }
func (ClawbackResult) XdrTypeName() string              { return "ClawbackResult" }
func (v ClawbackResult) XdrValue() interface{}          { return v }
func (v *ClawbackResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClawbackResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClawbackResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CLAWBACK_SUCCESS:
		return
	case CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
		return
	}
	XdrPanic("invalid Code (%v) in ClawbackResult", u.Code)
}
func XDR_ClawbackResult(v *ClawbackResult) *ClawbackResult { return v }

var _XdrNames_ClawbackClaimableBalanceResultCode = map[int32]string{
	int32(CLAWBACK_CLAIMABLE_BALANCE_SUCCESS):              "CLAWBACK_CLAIMABLE_BALANCE_SUCCESS",
	int32(CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST):       "CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST",
	int32(CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER):           "CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER",
	int32(CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED): "CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED",
}
var _XdrValues_ClawbackClaimableBalanceResultCode = map[string]int32{
	"CLAWBACK_CLAIMABLE_BALANCE_SUCCESS":              int32(CLAWBACK_CLAIMABLE_BALANCE_SUCCESS),
	"CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST":       int32(CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST),
	"CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER":           int32(CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER),
	"CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED": int32(CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED),
}

func (ClawbackClaimableBalanceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ClawbackClaimableBalanceResultCode
}
func (v ClawbackClaimableBalanceResultCode) String() string {
	if s, ok := _XdrNames_ClawbackClaimableBalanceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClawbackClaimableBalanceResultCode#%d", v)
}
func (v *ClawbackClaimableBalanceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClawbackClaimableBalanceResultCode[stok]; ok {
			*v = ClawbackClaimableBalanceResultCode(val)
			return nil
		} else if stok == "ClawbackClaimableBalanceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClawbackClaimableBalanceResultCode.", stok))
	}
}
func (v ClawbackClaimableBalanceResultCode) GetU32() uint32 { return uint32(v) }
func (v *ClawbackClaimableBalanceResultCode) SetU32(n uint32) {
	*v = ClawbackClaimableBalanceResultCode(n)
}
func (v *ClawbackClaimableBalanceResultCode) XdrPointer() interface{} { return v }
func (ClawbackClaimableBalanceResultCode) XdrTypeName() string {
	return "ClawbackClaimableBalanceResultCode"
}
func (v ClawbackClaimableBalanceResultCode) XdrValue() interface{}          { return v }
func (v *ClawbackClaimableBalanceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClawbackClaimableBalanceResultCode = *ClawbackClaimableBalanceResultCode

func XDR_ClawbackClaimableBalanceResultCode(v *ClawbackClaimableBalanceResultCode) *ClawbackClaimableBalanceResultCode {
	return v
}

var _XdrComments_ClawbackClaimableBalanceResultCode = map[int32]string{
	int32(CLAWBACK_CLAIMABLE_BALANCE_SUCCESS):        "codes considered as \"success\" for the operation",
	int32(CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST): "codes considered as \"failure\" for the operation",
}

func (e ClawbackClaimableBalanceResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ClawbackClaimableBalanceResultCode
}

var _XdrTags_ClawbackClaimableBalanceResult = map[int32]bool{
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE_SUCCESS):              true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST):       true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER):           true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED): true,
}

func (_ ClawbackClaimableBalanceResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ClawbackClaimableBalanceResult
}
func (u ClawbackClaimableBalanceResult) XdrValid() bool {
	switch u.Code {
	case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS, CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
		return true
	}
	return false
}
func (u *ClawbackClaimableBalanceResult) XdrUnionTag() XdrNum32 {
	return XDR_ClawbackClaimableBalanceResultCode(&u.Code)
}
func (u *ClawbackClaimableBalanceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ClawbackClaimableBalanceResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
		return nil
	case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
		return nil
	}
	return nil
}
func (u *ClawbackClaimableBalanceResult) XdrUnionBodyName() string {
	switch u.Code {
	case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
		return ""
	case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
		return ""
	}
	return ""
}

type XdrType_ClawbackClaimableBalanceResult = *ClawbackClaimableBalanceResult

func (v *ClawbackClaimableBalanceResult) XdrPointer() interface{}       { return v }
func (ClawbackClaimableBalanceResult) XdrTypeName() string              { return "ClawbackClaimableBalanceResult" }
func (v ClawbackClaimableBalanceResult) XdrValue() interface{}          { return v }
func (v *ClawbackClaimableBalanceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClawbackClaimableBalanceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClawbackClaimableBalanceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
		return
	case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
		return
	}
	XdrPanic("invalid Code (%v) in ClawbackClaimableBalanceResult", u.Code)
}
func XDR_ClawbackClaimableBalanceResult(v *ClawbackClaimableBalanceResult) *ClawbackClaimableBalanceResult {
	return v
}

var _XdrNames_SetTrustLineFlagsResultCode = map[int32]string{
	int32(SET_TRUST_LINE_FLAGS_SUCCESS):       "SET_TRUST_LINE_FLAGS_SUCCESS",
	int32(SET_TRUST_LINE_FLAGS_MALFORMED):     "SET_TRUST_LINE_FLAGS_MALFORMED",
	int32(SET_TRUST_LINE_FLAGS_NO_TRUST_LINE): "SET_TRUST_LINE_FLAGS_NO_TRUST_LINE",
	int32(SET_TRUST_LINE_FLAGS_CANT_REVOKE):   "SET_TRUST_LINE_FLAGS_CANT_REVOKE",
	int32(SET_TRUST_LINE_FLAGS_INVALID_STATE): "SET_TRUST_LINE_FLAGS_INVALID_STATE",
	int32(SET_TRUST_LINE_FLAGS_LOW_RESERVE):   "SET_TRUST_LINE_FLAGS_LOW_RESERVE",
}
var _XdrValues_SetTrustLineFlagsResultCode = map[string]int32{
	"SET_TRUST_LINE_FLAGS_SUCCESS":       int32(SET_TRUST_LINE_FLAGS_SUCCESS),
	"SET_TRUST_LINE_FLAGS_MALFORMED":     int32(SET_TRUST_LINE_FLAGS_MALFORMED),
	"SET_TRUST_LINE_FLAGS_NO_TRUST_LINE": int32(SET_TRUST_LINE_FLAGS_NO_TRUST_LINE),
	"SET_TRUST_LINE_FLAGS_CANT_REVOKE":   int32(SET_TRUST_LINE_FLAGS_CANT_REVOKE),
	"SET_TRUST_LINE_FLAGS_INVALID_STATE": int32(SET_TRUST_LINE_FLAGS_INVALID_STATE),
	"SET_TRUST_LINE_FLAGS_LOW_RESERVE":   int32(SET_TRUST_LINE_FLAGS_LOW_RESERVE),
}

func (SetTrustLineFlagsResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SetTrustLineFlagsResultCode
}
func (v SetTrustLineFlagsResultCode) String() string {
	if s, ok := _XdrNames_SetTrustLineFlagsResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SetTrustLineFlagsResultCode#%d", v)
}
func (v *SetTrustLineFlagsResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SetTrustLineFlagsResultCode[stok]; ok {
			*v = SetTrustLineFlagsResultCode(val)
			return nil
		} else if stok == "SetTrustLineFlagsResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SetTrustLineFlagsResultCode.", stok))
	}
}
func (v SetTrustLineFlagsResultCode) GetU32() uint32                 { return uint32(v) }
func (v *SetTrustLineFlagsResultCode) SetU32(n uint32)               { *v = SetTrustLineFlagsResultCode(n) }
func (v *SetTrustLineFlagsResultCode) XdrPointer() interface{}       { return v }
func (SetTrustLineFlagsResultCode) XdrTypeName() string              { return "SetTrustLineFlagsResultCode" }
func (v SetTrustLineFlagsResultCode) XdrValue() interface{}          { return v }
func (v *SetTrustLineFlagsResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SetTrustLineFlagsResultCode = *SetTrustLineFlagsResultCode

func XDR_SetTrustLineFlagsResultCode(v *SetTrustLineFlagsResultCode) *SetTrustLineFlagsResultCode {
	return v
}

var _XdrComments_SetTrustLineFlagsResultCode = map[int32]string{
	int32(SET_TRUST_LINE_FLAGS_SUCCESS):     "codes considered as \"success\" for the operation",
	int32(SET_TRUST_LINE_FLAGS_MALFORMED):   "codes considered as \"failure\" for the operation",
	int32(SET_TRUST_LINE_FLAGS_LOW_RESERVE): "claimable balances can't be created",
}

func (e SetTrustLineFlagsResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_SetTrustLineFlagsResultCode
}

var _XdrTags_SetTrustLineFlagsResult = map[int32]bool{
	XdrToI32(SET_TRUST_LINE_FLAGS_SUCCESS):       true,
	XdrToI32(SET_TRUST_LINE_FLAGS_MALFORMED):     true,
	XdrToI32(SET_TRUST_LINE_FLAGS_NO_TRUST_LINE): true,
	XdrToI32(SET_TRUST_LINE_FLAGS_CANT_REVOKE):   true,
	XdrToI32(SET_TRUST_LINE_FLAGS_INVALID_STATE): true,
	XdrToI32(SET_TRUST_LINE_FLAGS_LOW_RESERVE):   true,
}

func (_ SetTrustLineFlagsResult) XdrValidTags() map[int32]bool {
	return _XdrTags_SetTrustLineFlagsResult
}
func (u SetTrustLineFlagsResult) XdrValid() bool {
	switch u.Code {
	case SET_TRUST_LINE_FLAGS_SUCCESS, SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
		return true
	}
	return false
}
func (u *SetTrustLineFlagsResult) XdrUnionTag() XdrNum32 {
	return XDR_SetTrustLineFlagsResultCode(&u.Code)
}
func (u *SetTrustLineFlagsResult) XdrUnionTagName() string {
	return "Code"
}
func (u *SetTrustLineFlagsResult) XdrUnionBody() XdrType {
	switch u.Code {
	case SET_TRUST_LINE_FLAGS_SUCCESS:
		return nil
	case SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
		return nil
	}
	return nil
}
func (u *SetTrustLineFlagsResult) XdrUnionBodyName() string {
	switch u.Code {
	case SET_TRUST_LINE_FLAGS_SUCCESS:
		return ""
	case SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
		return ""
	}
	return ""
}

type XdrType_SetTrustLineFlagsResult = *SetTrustLineFlagsResult

func (v *SetTrustLineFlagsResult) XdrPointer() interface{}       { return v }
func (SetTrustLineFlagsResult) XdrTypeName() string              { return "SetTrustLineFlagsResult" }
func (v SetTrustLineFlagsResult) XdrValue() interface{}          { return v }
func (v *SetTrustLineFlagsResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SetTrustLineFlagsResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SetTrustLineFlagsResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case SET_TRUST_LINE_FLAGS_SUCCESS:
		return
	case SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
		return
	}
	XdrPanic("invalid Code (%v) in SetTrustLineFlagsResult", u.Code)
}
func XDR_SetTrustLineFlagsResult(v *SetTrustLineFlagsResult) *SetTrustLineFlagsResult { return v }

var _XdrNames_LiquidityPoolDepositResultCode = map[int32]string{
	int32(LIQUIDITY_POOL_DEPOSIT_SUCCESS):        "LIQUIDITY_POOL_DEPOSIT_SUCCESS",
	int32(LIQUIDITY_POOL_DEPOSIT_MALFORMED):      "LIQUIDITY_POOL_DEPOSIT_MALFORMED",
	int32(LIQUIDITY_POOL_DEPOSIT_NO_TRUST):       "LIQUIDITY_POOL_DEPOSIT_NO_TRUST",
	int32(LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED): "LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED",
	int32(LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED):    "LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED",
	int32(LIQUIDITY_POOL_DEPOSIT_LINE_FULL):      "LIQUIDITY_POOL_DEPOSIT_LINE_FULL",
	int32(LIQUIDITY_POOL_DEPOSIT_BAD_PRICE):      "LIQUIDITY_POOL_DEPOSIT_BAD_PRICE",
	int32(LIQUIDITY_POOL_DEPOSIT_POOL_FULL):      "LIQUIDITY_POOL_DEPOSIT_POOL_FULL",
}
var _XdrValues_LiquidityPoolDepositResultCode = map[string]int32{
	"LIQUIDITY_POOL_DEPOSIT_SUCCESS":        int32(LIQUIDITY_POOL_DEPOSIT_SUCCESS),
	"LIQUIDITY_POOL_DEPOSIT_MALFORMED":      int32(LIQUIDITY_POOL_DEPOSIT_MALFORMED),
	"LIQUIDITY_POOL_DEPOSIT_NO_TRUST":       int32(LIQUIDITY_POOL_DEPOSIT_NO_TRUST),
	"LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED": int32(LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED),
	"LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED":    int32(LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED),
	"LIQUIDITY_POOL_DEPOSIT_LINE_FULL":      int32(LIQUIDITY_POOL_DEPOSIT_LINE_FULL),
	"LIQUIDITY_POOL_DEPOSIT_BAD_PRICE":      int32(LIQUIDITY_POOL_DEPOSIT_BAD_PRICE),
	"LIQUIDITY_POOL_DEPOSIT_POOL_FULL":      int32(LIQUIDITY_POOL_DEPOSIT_POOL_FULL),
}

func (LiquidityPoolDepositResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_LiquidityPoolDepositResultCode
}
func (v LiquidityPoolDepositResultCode) String() string {
	if s, ok := _XdrNames_LiquidityPoolDepositResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LiquidityPoolDepositResultCode#%d", v)
}
func (v *LiquidityPoolDepositResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LiquidityPoolDepositResultCode[stok]; ok {
			*v = LiquidityPoolDepositResultCode(val)
			return nil
		} else if stok == "LiquidityPoolDepositResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LiquidityPoolDepositResultCode.", stok))
	}
}
func (v LiquidityPoolDepositResultCode) GetU32() uint32                 { return uint32(v) }
func (v *LiquidityPoolDepositResultCode) SetU32(n uint32)               { *v = LiquidityPoolDepositResultCode(n) }
func (v *LiquidityPoolDepositResultCode) XdrPointer() interface{}       { return v }
func (LiquidityPoolDepositResultCode) XdrTypeName() string              { return "LiquidityPoolDepositResultCode" }
func (v LiquidityPoolDepositResultCode) XdrValue() interface{}          { return v }
func (v *LiquidityPoolDepositResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LiquidityPoolDepositResultCode = *LiquidityPoolDepositResultCode

func XDR_LiquidityPoolDepositResultCode(v *LiquidityPoolDepositResultCode) *LiquidityPoolDepositResultCode {
	return v
}

var _XdrComments_LiquidityPoolDepositResultCode = map[int32]string{
	int32(LIQUIDITY_POOL_DEPOSIT_SUCCESS):        "codes considered as \"success\" for the operation",
	int32(LIQUIDITY_POOL_DEPOSIT_MALFORMED):      "bad input",
	int32(LIQUIDITY_POOL_DEPOSIT_NO_TRUST):       "no trust line for one of the",
	int32(LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED): "not authorized for one of the",
	int32(LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED):    "not enough balance for one of",
	int32(LIQUIDITY_POOL_DEPOSIT_LINE_FULL):      "pool share trust line doesn't",
	int32(LIQUIDITY_POOL_DEPOSIT_BAD_PRICE):      "deposit price outside bounds",
	int32(LIQUIDITY_POOL_DEPOSIT_POOL_FULL):      "pool reserves are full",
}

func (e LiquidityPoolDepositResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_LiquidityPoolDepositResultCode
}

var _XdrTags_LiquidityPoolDepositResult = map[int32]bool{
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_SUCCESS):        true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_MALFORMED):      true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_NO_TRUST):       true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED): true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED):    true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_LINE_FULL):      true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_BAD_PRICE):      true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_POOL_FULL):      true,
}

func (_ LiquidityPoolDepositResult) XdrValidTags() map[int32]bool {
	return _XdrTags_LiquidityPoolDepositResult
}
func (u LiquidityPoolDepositResult) XdrValid() bool {
	switch u.Code {
	case LIQUIDITY_POOL_DEPOSIT_SUCCESS, LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
		return true
	}
	return false
}
func (u *LiquidityPoolDepositResult) XdrUnionTag() XdrNum32 {
	return XDR_LiquidityPoolDepositResultCode(&u.Code)
}
func (u *LiquidityPoolDepositResult) XdrUnionTagName() string {
	return "Code"
}
func (u *LiquidityPoolDepositResult) XdrUnionBody() XdrType {
	switch u.Code {
	case LIQUIDITY_POOL_DEPOSIT_SUCCESS:
		return nil
	case LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
		return nil
	}
	return nil
}
func (u *LiquidityPoolDepositResult) XdrUnionBodyName() string {
	switch u.Code {
	case LIQUIDITY_POOL_DEPOSIT_SUCCESS:
		return ""
	case LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
		return ""
	}
	return ""
}

type XdrType_LiquidityPoolDepositResult = *LiquidityPoolDepositResult

func (v *LiquidityPoolDepositResult) XdrPointer() interface{}       { return v }
func (LiquidityPoolDepositResult) XdrTypeName() string              { return "LiquidityPoolDepositResult" }
func (v LiquidityPoolDepositResult) XdrValue() interface{}          { return v }
func (v *LiquidityPoolDepositResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LiquidityPoolDepositResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LiquidityPoolDepositResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case LIQUIDITY_POOL_DEPOSIT_SUCCESS:
		return
	case LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
		return
	}
	XdrPanic("invalid Code (%v) in LiquidityPoolDepositResult", u.Code)
}
func XDR_LiquidityPoolDepositResult(v *LiquidityPoolDepositResult) *LiquidityPoolDepositResult {
	return v
}

var _XdrNames_LiquidityPoolWithdrawResultCode = map[int32]string{
	int32(LIQUIDITY_POOL_WITHDRAW_SUCCESS):       "LIQUIDITY_POOL_WITHDRAW_SUCCESS",
	int32(LIQUIDITY_POOL_WITHDRAW_MALFORMED):     "LIQUIDITY_POOL_WITHDRAW_MALFORMED",
	int32(LIQUIDITY_POOL_WITHDRAW_NO_TRUST):      "LIQUIDITY_POOL_WITHDRAW_NO_TRUST",
	int32(LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED):   "LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED",
	int32(LIQUIDITY_POOL_WITHDRAW_LINE_FULL):     "LIQUIDITY_POOL_WITHDRAW_LINE_FULL",
	int32(LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM): "LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM",
}
var _XdrValues_LiquidityPoolWithdrawResultCode = map[string]int32{
	"LIQUIDITY_POOL_WITHDRAW_SUCCESS":       int32(LIQUIDITY_POOL_WITHDRAW_SUCCESS),
	"LIQUIDITY_POOL_WITHDRAW_MALFORMED":     int32(LIQUIDITY_POOL_WITHDRAW_MALFORMED),
	"LIQUIDITY_POOL_WITHDRAW_NO_TRUST":      int32(LIQUIDITY_POOL_WITHDRAW_NO_TRUST),
	"LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED":   int32(LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED),
	"LIQUIDITY_POOL_WITHDRAW_LINE_FULL":     int32(LIQUIDITY_POOL_WITHDRAW_LINE_FULL),
	"LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM": int32(LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM),
}

func (LiquidityPoolWithdrawResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_LiquidityPoolWithdrawResultCode
}
func (v LiquidityPoolWithdrawResultCode) String() string {
	if s, ok := _XdrNames_LiquidityPoolWithdrawResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LiquidityPoolWithdrawResultCode#%d", v)
}
func (v *LiquidityPoolWithdrawResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LiquidityPoolWithdrawResultCode[stok]; ok {
			*v = LiquidityPoolWithdrawResultCode(val)
			return nil
		} else if stok == "LiquidityPoolWithdrawResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LiquidityPoolWithdrawResultCode.", stok))
	}
}
func (v LiquidityPoolWithdrawResultCode) GetU32() uint32                 { return uint32(v) }
func (v *LiquidityPoolWithdrawResultCode) SetU32(n uint32)               { *v = LiquidityPoolWithdrawResultCode(n) }
func (v *LiquidityPoolWithdrawResultCode) XdrPointer() interface{}       { return v }
func (LiquidityPoolWithdrawResultCode) XdrTypeName() string              { return "LiquidityPoolWithdrawResultCode" }
func (v LiquidityPoolWithdrawResultCode) XdrValue() interface{}          { return v }
func (v *LiquidityPoolWithdrawResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LiquidityPoolWithdrawResultCode = *LiquidityPoolWithdrawResultCode

func XDR_LiquidityPoolWithdrawResultCode(v *LiquidityPoolWithdrawResultCode) *LiquidityPoolWithdrawResultCode {
	return v
}

var _XdrComments_LiquidityPoolWithdrawResultCode = map[int32]string{
	int32(LIQUIDITY_POOL_WITHDRAW_SUCCESS):       "codes considered as \"success\" for the operation",
	int32(LIQUIDITY_POOL_WITHDRAW_MALFORMED):     "bad input",
	int32(LIQUIDITY_POOL_WITHDRAW_NO_TRUST):      "no trust line for one of the",
	int32(LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED):   "not enough balance of the",
	int32(LIQUIDITY_POOL_WITHDRAW_LINE_FULL):     "would go above limit for one",
	int32(LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM): "of the assets",
}

func (e LiquidityPoolWithdrawResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_LiquidityPoolWithdrawResultCode
}

var _XdrTags_LiquidityPoolWithdrawResult = map[int32]bool{
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_SUCCESS):       true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_MALFORMED):     true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_NO_TRUST):      true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED):   true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_LINE_FULL):     true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM): true,
}

func (_ LiquidityPoolWithdrawResult) XdrValidTags() map[int32]bool {
	return _XdrTags_LiquidityPoolWithdrawResult
}
func (u LiquidityPoolWithdrawResult) XdrValid() bool {
	switch u.Code {
	case LIQUIDITY_POOL_WITHDRAW_SUCCESS, LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
		return true
	}
	return false
}
func (u *LiquidityPoolWithdrawResult) XdrUnionTag() XdrNum32 {
	return XDR_LiquidityPoolWithdrawResultCode(&u.Code)
}
func (u *LiquidityPoolWithdrawResult) XdrUnionTagName() string {
	return "Code"
}
func (u *LiquidityPoolWithdrawResult) XdrUnionBody() XdrType {
	switch u.Code {
	case LIQUIDITY_POOL_WITHDRAW_SUCCESS:
		return nil
	case LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
		return nil
	}
	return nil
}
func (u *LiquidityPoolWithdrawResult) XdrUnionBodyName() string {
	switch u.Code {
	case LIQUIDITY_POOL_WITHDRAW_SUCCESS:
		return ""
	case LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
		return ""
	}
	return ""
}

type XdrType_LiquidityPoolWithdrawResult = *LiquidityPoolWithdrawResult

func (v *LiquidityPoolWithdrawResult) XdrPointer() interface{}       { return v }
func (LiquidityPoolWithdrawResult) XdrTypeName() string              { return "LiquidityPoolWithdrawResult" }
func (v LiquidityPoolWithdrawResult) XdrValue() interface{}          { return v }
func (v *LiquidityPoolWithdrawResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LiquidityPoolWithdrawResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LiquidityPoolWithdrawResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case LIQUIDITY_POOL_WITHDRAW_SUCCESS:
		return
	case LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
		return
	}
	XdrPanic("invalid Code (%v) in LiquidityPoolWithdrawResult", u.Code)
}
func XDR_LiquidityPoolWithdrawResult(v *LiquidityPoolWithdrawResult) *LiquidityPoolWithdrawResult {
	return v
}

var _XdrNames_InvokeHostFunctionResultCode = map[int32]string{
	int32(INVOKE_HOST_FUNCTION_SUCCESS):                     "INVOKE_HOST_FUNCTION_SUCCESS",
	int32(INVOKE_HOST_FUNCTION_MALFORMED):                   "INVOKE_HOST_FUNCTION_MALFORMED",
	int32(INVOKE_HOST_FUNCTION_TRAPPED):                     "INVOKE_HOST_FUNCTION_TRAPPED",
	int32(INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED):     "INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED",
	int32(INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED):              "INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED",
	int32(INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE): "INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE",
}
var _XdrValues_InvokeHostFunctionResultCode = map[string]int32{
	"INVOKE_HOST_FUNCTION_SUCCESS":                     int32(INVOKE_HOST_FUNCTION_SUCCESS),
	"INVOKE_HOST_FUNCTION_MALFORMED":                   int32(INVOKE_HOST_FUNCTION_MALFORMED),
	"INVOKE_HOST_FUNCTION_TRAPPED":                     int32(INVOKE_HOST_FUNCTION_TRAPPED),
	"INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED":     int32(INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED),
	"INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED":              int32(INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED),
	"INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE": int32(INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE),
}

func (InvokeHostFunctionResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_InvokeHostFunctionResultCode
}
func (v InvokeHostFunctionResultCode) String() string {
	if s, ok := _XdrNames_InvokeHostFunctionResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("InvokeHostFunctionResultCode#%d", v)
}
func (v *InvokeHostFunctionResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_InvokeHostFunctionResultCode[stok]; ok {
			*v = InvokeHostFunctionResultCode(val)
			return nil
		} else if stok == "InvokeHostFunctionResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid InvokeHostFunctionResultCode.", stok))
	}
}
func (v InvokeHostFunctionResultCode) GetU32() uint32                 { return uint32(v) }
func (v *InvokeHostFunctionResultCode) SetU32(n uint32)               { *v = InvokeHostFunctionResultCode(n) }
func (v *InvokeHostFunctionResultCode) XdrPointer() interface{}       { return v }
func (InvokeHostFunctionResultCode) XdrTypeName() string              { return "InvokeHostFunctionResultCode" }
func (v InvokeHostFunctionResultCode) XdrValue() interface{}          { return v }
func (v *InvokeHostFunctionResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_InvokeHostFunctionResultCode = *InvokeHostFunctionResultCode

func XDR_InvokeHostFunctionResultCode(v *InvokeHostFunctionResultCode) *InvokeHostFunctionResultCode {
	return v
}

var _XdrComments_InvokeHostFunctionResultCode = map[int32]string{
	int32(INVOKE_HOST_FUNCTION_SUCCESS):   "codes considered as \"success\" for the operation",
	int32(INVOKE_HOST_FUNCTION_MALFORMED): "codes considered as \"failure\" for the operation",
}

func (e InvokeHostFunctionResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_InvokeHostFunctionResultCode
}

var _XdrTags_InvokeHostFunctionResult = map[int32]bool{
	XdrToI32(INVOKE_HOST_FUNCTION_SUCCESS):                     true,
	XdrToI32(INVOKE_HOST_FUNCTION_MALFORMED):                   true,
	XdrToI32(INVOKE_HOST_FUNCTION_TRAPPED):                     true,
	XdrToI32(INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED):     true,
	XdrToI32(INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED):              true,
	XdrToI32(INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE): true,
}

func (_ InvokeHostFunctionResult) XdrValidTags() map[int32]bool {
	return _XdrTags_InvokeHostFunctionResult
}

// sha256(InvokeHostFunctionSuccessPreImage)
func (u *InvokeHostFunctionResult) Success() *Hash {
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("InvokeHostFunctionResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u InvokeHostFunctionResult) XdrValid() bool {
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS, INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED, INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED, INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED, INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE:
		return true
	}
	return false
}
func (u *InvokeHostFunctionResult) XdrUnionTag() XdrNum32 {
	return XDR_InvokeHostFunctionResultCode(&u.Code)
}
func (u *InvokeHostFunctionResult) XdrUnionTagName() string {
	return "Code"
}
func (u *InvokeHostFunctionResult) XdrUnionBody() XdrType {
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS:
		return XDR_Hash(u.Success())
	case INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED, INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED, INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED, INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE:
		return nil
	}
	return nil
}
func (u *InvokeHostFunctionResult) XdrUnionBodyName() string {
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS:
		return "Success"
	case INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED, INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED, INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED, INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE:
		return ""
	}
	return ""
}

type XdrType_InvokeHostFunctionResult = *InvokeHostFunctionResult

func (v *InvokeHostFunctionResult) XdrPointer() interface{}       { return v }
func (InvokeHostFunctionResult) XdrTypeName() string              { return "InvokeHostFunctionResult" }
func (v InvokeHostFunctionResult) XdrValue() interface{}          { return v }
func (v *InvokeHostFunctionResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *InvokeHostFunctionResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_InvokeHostFunctionResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_Hash(u.Success()))
		return
	case INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED, INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED, INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED, INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE:
		return
	}
	XdrPanic("invalid Code (%v) in InvokeHostFunctionResult", u.Code)
}
func XDR_InvokeHostFunctionResult(v *InvokeHostFunctionResult) *InvokeHostFunctionResult { return v }

var _XdrNames_ExtendFootprintTTLResultCode = map[int32]string{
	int32(EXTEND_FOOTPRINT_TTL_SUCCESS):                     "EXTEND_FOOTPRINT_TTL_SUCCESS",
	int32(EXTEND_FOOTPRINT_TTL_MALFORMED):                   "EXTEND_FOOTPRINT_TTL_MALFORMED",
	int32(EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED):     "EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED",
	int32(EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE): "EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE",
}
var _XdrValues_ExtendFootprintTTLResultCode = map[string]int32{
	"EXTEND_FOOTPRINT_TTL_SUCCESS":                     int32(EXTEND_FOOTPRINT_TTL_SUCCESS),
	"EXTEND_FOOTPRINT_TTL_MALFORMED":                   int32(EXTEND_FOOTPRINT_TTL_MALFORMED),
	"EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED":     int32(EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED),
	"EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE": int32(EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE),
}

func (ExtendFootprintTTLResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ExtendFootprintTTLResultCode
}
func (v ExtendFootprintTTLResultCode) String() string {
	if s, ok := _XdrNames_ExtendFootprintTTLResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ExtendFootprintTTLResultCode#%d", v)
}
func (v *ExtendFootprintTTLResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ExtendFootprintTTLResultCode[stok]; ok {
			*v = ExtendFootprintTTLResultCode(val)
			return nil
		} else if stok == "ExtendFootprintTTLResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ExtendFootprintTTLResultCode.", stok))
	}
}
func (v ExtendFootprintTTLResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ExtendFootprintTTLResultCode) SetU32(n uint32)               { *v = ExtendFootprintTTLResultCode(n) }
func (v *ExtendFootprintTTLResultCode) XdrPointer() interface{}       { return v }
func (ExtendFootprintTTLResultCode) XdrTypeName() string              { return "ExtendFootprintTTLResultCode" }
func (v ExtendFootprintTTLResultCode) XdrValue() interface{}          { return v }
func (v *ExtendFootprintTTLResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ExtendFootprintTTLResultCode = *ExtendFootprintTTLResultCode

func XDR_ExtendFootprintTTLResultCode(v *ExtendFootprintTTLResultCode) *ExtendFootprintTTLResultCode {
	return v
}

var _XdrComments_ExtendFootprintTTLResultCode = map[int32]string{
	int32(EXTEND_FOOTPRINT_TTL_SUCCESS):   "codes considered as \"success\" for the operation",
	int32(EXTEND_FOOTPRINT_TTL_MALFORMED): "codes considered as \"failure\" for the operation",
}

func (e ExtendFootprintTTLResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ExtendFootprintTTLResultCode
}

var _XdrTags_ExtendFootprintTTLResult = map[int32]bool{
	XdrToI32(EXTEND_FOOTPRINT_TTL_SUCCESS):                     true,
	XdrToI32(EXTEND_FOOTPRINT_TTL_MALFORMED):                   true,
	XdrToI32(EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED):     true,
	XdrToI32(EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE): true,
}

func (_ ExtendFootprintTTLResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ExtendFootprintTTLResult
}
func (u ExtendFootprintTTLResult) XdrValid() bool {
	switch u.Code {
	case EXTEND_FOOTPRINT_TTL_SUCCESS, EXTEND_FOOTPRINT_TTL_MALFORMED, EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED, EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE:
		return true
	}
	return false
}
func (u *ExtendFootprintTTLResult) XdrUnionTag() XdrNum32 {
	return XDR_ExtendFootprintTTLResultCode(&u.Code)
}
func (u *ExtendFootprintTTLResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ExtendFootprintTTLResult) XdrUnionBody() XdrType {
	switch u.Code {
	case EXTEND_FOOTPRINT_TTL_SUCCESS:
		return nil
	case EXTEND_FOOTPRINT_TTL_MALFORMED, EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED, EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE:
		return nil
	}
	return nil
}
func (u *ExtendFootprintTTLResult) XdrUnionBodyName() string {
	switch u.Code {
	case EXTEND_FOOTPRINT_TTL_SUCCESS:
		return ""
	case EXTEND_FOOTPRINT_TTL_MALFORMED, EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED, EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE:
		return ""
	}
	return ""
}

type XdrType_ExtendFootprintTTLResult = *ExtendFootprintTTLResult

func (v *ExtendFootprintTTLResult) XdrPointer() interface{}       { return v }
func (ExtendFootprintTTLResult) XdrTypeName() string              { return "ExtendFootprintTTLResult" }
func (v ExtendFootprintTTLResult) XdrValue() interface{}          { return v }
func (v *ExtendFootprintTTLResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ExtendFootprintTTLResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ExtendFootprintTTLResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case EXTEND_FOOTPRINT_TTL_SUCCESS:
		return
	case EXTEND_FOOTPRINT_TTL_MALFORMED, EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED, EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE:
		return
	}
	XdrPanic("invalid Code (%v) in ExtendFootprintTTLResult", u.Code)
}
func XDR_ExtendFootprintTTLResult(v *ExtendFootprintTTLResult) *ExtendFootprintTTLResult { return v }

var _XdrNames_RestoreFootprintResultCode = map[int32]string{
	int32(RESTORE_FOOTPRINT_SUCCESS):                     "RESTORE_FOOTPRINT_SUCCESS",
	int32(RESTORE_FOOTPRINT_MALFORMED):                   "RESTORE_FOOTPRINT_MALFORMED",
	int32(RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED):     "RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED",
	int32(RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE): "RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE",
}
var _XdrValues_RestoreFootprintResultCode = map[string]int32{
	"RESTORE_FOOTPRINT_SUCCESS":                     int32(RESTORE_FOOTPRINT_SUCCESS),
	"RESTORE_FOOTPRINT_MALFORMED":                   int32(RESTORE_FOOTPRINT_MALFORMED),
	"RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED":     int32(RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED),
	"RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE": int32(RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE),
}

func (RestoreFootprintResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_RestoreFootprintResultCode
}
func (v RestoreFootprintResultCode) String() string {
	if s, ok := _XdrNames_RestoreFootprintResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("RestoreFootprintResultCode#%d", v)
}
func (v *RestoreFootprintResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_RestoreFootprintResultCode[stok]; ok {
			*v = RestoreFootprintResultCode(val)
			return nil
		} else if stok == "RestoreFootprintResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid RestoreFootprintResultCode.", stok))
	}
}
func (v RestoreFootprintResultCode) GetU32() uint32                 { return uint32(v) }
func (v *RestoreFootprintResultCode) SetU32(n uint32)               { *v = RestoreFootprintResultCode(n) }
func (v *RestoreFootprintResultCode) XdrPointer() interface{}       { return v }
func (RestoreFootprintResultCode) XdrTypeName() string              { return "RestoreFootprintResultCode" }
func (v RestoreFootprintResultCode) XdrValue() interface{}          { return v }
func (v *RestoreFootprintResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_RestoreFootprintResultCode = *RestoreFootprintResultCode

func XDR_RestoreFootprintResultCode(v *RestoreFootprintResultCode) *RestoreFootprintResultCode {
	return v
}

var _XdrComments_RestoreFootprintResultCode = map[int32]string{
	int32(RESTORE_FOOTPRINT_SUCCESS):   "codes considered as \"success\" for the operation",
	int32(RESTORE_FOOTPRINT_MALFORMED): "codes considered as \"failure\" for the operation",
}

func (e RestoreFootprintResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_RestoreFootprintResultCode
}

var _XdrTags_RestoreFootprintResult = map[int32]bool{
	XdrToI32(RESTORE_FOOTPRINT_SUCCESS):                     true,
	XdrToI32(RESTORE_FOOTPRINT_MALFORMED):                   true,
	XdrToI32(RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED):     true,
	XdrToI32(RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE): true,
}

func (_ RestoreFootprintResult) XdrValidTags() map[int32]bool {
	return _XdrTags_RestoreFootprintResult
}
func (u RestoreFootprintResult) XdrValid() bool {
	switch u.Code {
	case RESTORE_FOOTPRINT_SUCCESS, RESTORE_FOOTPRINT_MALFORMED, RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED, RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE:
		return true
	}
	return false
}
func (u *RestoreFootprintResult) XdrUnionTag() XdrNum32 {
	return XDR_RestoreFootprintResultCode(&u.Code)
}
func (u *RestoreFootprintResult) XdrUnionTagName() string {
	return "Code"
}
func (u *RestoreFootprintResult) XdrUnionBody() XdrType {
	switch u.Code {
	case RESTORE_FOOTPRINT_SUCCESS:
		return nil
	case RESTORE_FOOTPRINT_MALFORMED, RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED, RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE:
		return nil
	}
	return nil
}
func (u *RestoreFootprintResult) XdrUnionBodyName() string {
	switch u.Code {
	case RESTORE_FOOTPRINT_SUCCESS:
		return ""
	case RESTORE_FOOTPRINT_MALFORMED, RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED, RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE:
		return ""
	}
	return ""
}

type XdrType_RestoreFootprintResult = *RestoreFootprintResult

func (v *RestoreFootprintResult) XdrPointer() interface{}       { return v }
func (RestoreFootprintResult) XdrTypeName() string              { return "RestoreFootprintResult" }
func (v RestoreFootprintResult) XdrValue() interface{}          { return v }
func (v *RestoreFootprintResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *RestoreFootprintResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_RestoreFootprintResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case RESTORE_FOOTPRINT_SUCCESS:
		return
	case RESTORE_FOOTPRINT_MALFORMED, RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED, RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE:
		return
	}
	XdrPanic("invalid Code (%v) in RestoreFootprintResult", u.Code)
}
func XDR_RestoreFootprintResult(v *RestoreFootprintResult) *RestoreFootprintResult { return v }

var _XdrNames_OperationResultCode = map[int32]string{
	int32(OpINNER):               "opINNER",
	int32(OpBAD_AUTH):            "opBAD_AUTH",
	int32(OpNO_ACCOUNT):          "opNO_ACCOUNT",
	int32(OpNOT_SUPPORTED):       "opNOT_SUPPORTED",
	int32(OpTOO_MANY_SUBENTRIES): "opTOO_MANY_SUBENTRIES",
	int32(OpEXCEEDED_WORK_LIMIT): "opEXCEEDED_WORK_LIMIT",
	int32(OpTOO_MANY_SPONSORING): "opTOO_MANY_SPONSORING",
}
var _XdrValues_OperationResultCode = map[string]int32{
	"opINNER":               int32(OpINNER),
	"opBAD_AUTH":            int32(OpBAD_AUTH),
	"opNO_ACCOUNT":          int32(OpNO_ACCOUNT),
	"opNOT_SUPPORTED":       int32(OpNOT_SUPPORTED),
	"opTOO_MANY_SUBENTRIES": int32(OpTOO_MANY_SUBENTRIES),
	"opEXCEEDED_WORK_LIMIT": int32(OpEXCEEDED_WORK_LIMIT),
	"opTOO_MANY_SPONSORING": int32(OpTOO_MANY_SPONSORING),
}

func (OperationResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_OperationResultCode
}
func (v OperationResultCode) String() string {
	if s, ok := _XdrNames_OperationResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OperationResultCode#%d", v)
}
func (v *OperationResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OperationResultCode[stok]; ok {
			*v = OperationResultCode(val)
			return nil
		} else if stok == "OperationResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OperationResultCode.", stok))
	}
}
func (v OperationResultCode) GetU32() uint32                 { return uint32(v) }
func (v *OperationResultCode) SetU32(n uint32)               { *v = OperationResultCode(n) }
func (v *OperationResultCode) XdrPointer() interface{}       { return v }
func (OperationResultCode) XdrTypeName() string              { return "OperationResultCode" }
func (v OperationResultCode) XdrValue() interface{}          { return v }
func (v *OperationResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_OperationResultCode = *OperationResultCode

func XDR_OperationResultCode(v *OperationResultCode) *OperationResultCode { return v }

var _XdrComments_OperationResultCode = map[int32]string{
	int32(OpINNER):               "inner object result is valid",
	int32(OpBAD_AUTH):            "too few valid signatures / wrong network",
	int32(OpNO_ACCOUNT):          "source account was not found",
	int32(OpNOT_SUPPORTED):       "operation not supported at this time",
	int32(OpTOO_MANY_SUBENTRIES): "max number of subentries already reached",
	int32(OpEXCEEDED_WORK_LIMIT): "operation did too much work",
	int32(OpTOO_MANY_SPONSORING): "account is sponsoring too many entries",
}

func (e OperationResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_OperationResultCode
}

var _XdrTags_XdrAnon_OperationResult_Tr = map[int32]bool{
	XdrToI32(CREATE_ACCOUNT):                   true,
	XdrToI32(PAYMENT):                          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE):      true,
	XdrToI32(MANAGE_SELL_OFFER):                true,
	XdrToI32(CREATE_PASSIVE_SELL_OFFER):        true,
	XdrToI32(SET_OPTIONS):                      true,
	XdrToI32(CHANGE_TRUST):                     true,
	XdrToI32(ALLOW_TRUST):                      true,
	XdrToI32(ACCOUNT_MERGE):                    true,
	XdrToI32(INFLATION):                        true,
	XdrToI32(MANAGE_DATA):                      true,
	XdrToI32(BUMP_SEQUENCE):                    true,
	XdrToI32(MANAGE_BUY_OFFER):                 true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND):         true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE):         true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE):          true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES): true,
	XdrToI32(END_SPONSORING_FUTURE_RESERVES):   true,
	XdrToI32(REVOKE_SPONSORSHIP):               true,
	XdrToI32(CLAWBACK):                         true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE):       true,
	XdrToI32(SET_TRUST_LINE_FLAGS):             true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT):           true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW):          true,
	XdrToI32(INVOKE_HOST_FUNCTION):             true,
	XdrToI32(EXTEND_FOOTPRINT_TTL):             true,
	XdrToI32(RESTORE_FOOTPRINT):                true,
}

func (_ XdrAnon_OperationResult_Tr) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_OperationResult_Tr
}
func (u *XdrAnon_OperationResult_Tr) CreateAccountResult() *CreateAccountResult {
	switch u.Type {
	case CREATE_ACCOUNT:
		if v, ok := u._u.(*CreateAccountResult); ok {
			return v
		} else {
			var zero CreateAccountResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.CreateAccountResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PaymentResult() *PaymentResult {
	switch u.Type {
	case PAYMENT:
		if v, ok := u._u.(*PaymentResult); ok {
			return v
		} else {
			var zero PaymentResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PaymentResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PathPaymentStrictReceiveResult() *PathPaymentStrictReceiveResult {
	switch u.Type {
	case PATH_PAYMENT_STRICT_RECEIVE:
		if v, ok := u._u.(*PathPaymentStrictReceiveResult); ok {
			return v
		} else {
			var zero PathPaymentStrictReceiveResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PathPaymentStrictReceiveResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageSellOfferResult() *ManageSellOfferResult {
	switch u.Type {
	case MANAGE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferResult); ok {
			return v
		} else {
			var zero ManageSellOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageSellOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) CreatePassiveSellOfferResult() *ManageSellOfferResult {
	switch u.Type {
	case CREATE_PASSIVE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferResult); ok {
			return v
		} else {
			var zero ManageSellOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.CreatePassiveSellOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) SetOptionsResult() *SetOptionsResult {
	switch u.Type {
	case SET_OPTIONS:
		if v, ok := u._u.(*SetOptionsResult); ok {
			return v
		} else {
			var zero SetOptionsResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.SetOptionsResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ChangeTrustResult() *ChangeTrustResult {
	switch u.Type {
	case CHANGE_TRUST:
		if v, ok := u._u.(*ChangeTrustResult); ok {
			return v
		} else {
			var zero ChangeTrustResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ChangeTrustResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) AllowTrustResult() *AllowTrustResult {
	switch u.Type {
	case ALLOW_TRUST:
		if v, ok := u._u.(*AllowTrustResult); ok {
			return v
		} else {
			var zero AllowTrustResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.AllowTrustResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) AccountMergeResult() *AccountMergeResult {
	switch u.Type {
	case ACCOUNT_MERGE:
		if v, ok := u._u.(*AccountMergeResult); ok {
			return v
		} else {
			var zero AccountMergeResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.AccountMergeResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) InflationResult() *InflationResult {
	switch u.Type {
	case INFLATION:
		if v, ok := u._u.(*InflationResult); ok {
			return v
		} else {
			var zero InflationResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.InflationResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageDataResult() *ManageDataResult {
	switch u.Type {
	case MANAGE_DATA:
		if v, ok := u._u.(*ManageDataResult); ok {
			return v
		} else {
			var zero ManageDataResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageDataResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) BumpSeqResult() *BumpSequenceResult {
	switch u.Type {
	case BUMP_SEQUENCE:
		if v, ok := u._u.(*BumpSequenceResult); ok {
			return v
		} else {
			var zero BumpSequenceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.BumpSeqResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageBuyOfferResult() *ManageBuyOfferResult {
	switch u.Type {
	case MANAGE_BUY_OFFER:
		if v, ok := u._u.(*ManageBuyOfferResult); ok {
			return v
		} else {
			var zero ManageBuyOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageBuyOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PathPaymentStrictSendResult() *PathPaymentStrictSendResult {
	switch u.Type {
	case PATH_PAYMENT_STRICT_SEND:
		if v, ok := u._u.(*PathPaymentStrictSendResult); ok {
			return v
		} else {
			var zero PathPaymentStrictSendResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PathPaymentStrictSendResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) CreateClaimableBalanceResult() *CreateClaimableBalanceResult {
	switch u.Type {
	case CREATE_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*CreateClaimableBalanceResult); ok {
			return v
		} else {
			var zero CreateClaimableBalanceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.CreateClaimableBalanceResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ClaimClaimableBalanceResult() *ClaimClaimableBalanceResult {
	switch u.Type {
	case CLAIM_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClaimClaimableBalanceResult); ok {
			return v
		} else {
			var zero ClaimClaimableBalanceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ClaimClaimableBalanceResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) BeginSponsoringFutureReservesResult() *BeginSponsoringFutureReservesResult {
	switch u.Type {
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		if v, ok := u._u.(*BeginSponsoringFutureReservesResult); ok {
			return v
		} else {
			var zero BeginSponsoringFutureReservesResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.BeginSponsoringFutureReservesResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) EndSponsoringFutureReservesResult() *EndSponsoringFutureReservesResult {
	switch u.Type {
	case END_SPONSORING_FUTURE_RESERVES:
		if v, ok := u._u.(*EndSponsoringFutureReservesResult); ok {
			return v
		} else {
			var zero EndSponsoringFutureReservesResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.EndSponsoringFutureReservesResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) RevokeSponsorshipResult() *RevokeSponsorshipResult {
	switch u.Type {
	case REVOKE_SPONSORSHIP:
		if v, ok := u._u.(*RevokeSponsorshipResult); ok {
			return v
		} else {
			var zero RevokeSponsorshipResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.RevokeSponsorshipResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ClawbackResult() *ClawbackResult {
	switch u.Type {
	case CLAWBACK:
		if v, ok := u._u.(*ClawbackResult); ok {
			return v
		} else {
			var zero ClawbackResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ClawbackResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ClawbackClaimableBalanceResult() *ClawbackClaimableBalanceResult {
	switch u.Type {
	case CLAWBACK_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClawbackClaimableBalanceResult); ok {
			return v
		} else {
			var zero ClawbackClaimableBalanceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ClawbackClaimableBalanceResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) SetTrustLineFlagsResult() *SetTrustLineFlagsResult {
	switch u.Type {
	case SET_TRUST_LINE_FLAGS:
		if v, ok := u._u.(*SetTrustLineFlagsResult); ok {
			return v
		} else {
			var zero SetTrustLineFlagsResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.SetTrustLineFlagsResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) LiquidityPoolDepositResult() *LiquidityPoolDepositResult {
	switch u.Type {
	case LIQUIDITY_POOL_DEPOSIT:
		if v, ok := u._u.(*LiquidityPoolDepositResult); ok {
			return v
		} else {
			var zero LiquidityPoolDepositResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.LiquidityPoolDepositResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) LiquidityPoolWithdrawResult() *LiquidityPoolWithdrawResult {
	switch u.Type {
	case LIQUIDITY_POOL_WITHDRAW:
		if v, ok := u._u.(*LiquidityPoolWithdrawResult); ok {
			return v
		} else {
			var zero LiquidityPoolWithdrawResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.LiquidityPoolWithdrawResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) InvokeHostFunctionResult() *InvokeHostFunctionResult {
	switch u.Type {
	case INVOKE_HOST_FUNCTION:
		if v, ok := u._u.(*InvokeHostFunctionResult); ok {
			return v
		} else {
			var zero InvokeHostFunctionResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.InvokeHostFunctionResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ExtendFootprintTTLResult() *ExtendFootprintTTLResult {
	switch u.Type {
	case EXTEND_FOOTPRINT_TTL:
		if v, ok := u._u.(*ExtendFootprintTTLResult); ok {
			return v
		} else {
			var zero ExtendFootprintTTLResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ExtendFootprintTTLResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) RestoreFootprintResult() *RestoreFootprintResult {
	switch u.Type {
	case RESTORE_FOOTPRINT:
		if v, ok := u._u.(*RestoreFootprintResult); ok {
			return v
		} else {
			var zero RestoreFootprintResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.RestoreFootprintResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_OperationResult_Tr) XdrValid() bool {
	switch u.Type {
	case CREATE_ACCOUNT, PAYMENT, PATH_PAYMENT_STRICT_RECEIVE, MANAGE_SELL_OFFER, CREATE_PASSIVE_SELL_OFFER, SET_OPTIONS, CHANGE_TRUST, ALLOW_TRUST, ACCOUNT_MERGE, INFLATION, MANAGE_DATA, BUMP_SEQUENCE, MANAGE_BUY_OFFER, PATH_PAYMENT_STRICT_SEND, CREATE_CLAIMABLE_BALANCE, CLAIM_CLAIMABLE_BALANCE, BEGIN_SPONSORING_FUTURE_RESERVES, END_SPONSORING_FUTURE_RESERVES, REVOKE_SPONSORSHIP, CLAWBACK, CLAWBACK_CLAIMABLE_BALANCE, SET_TRUST_LINE_FLAGS, LIQUIDITY_POOL_DEPOSIT, LIQUIDITY_POOL_WITHDRAW, INVOKE_HOST_FUNCTION, EXTEND_FOOTPRINT_TTL, RESTORE_FOOTPRINT:
		return true
	}
	return false
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionTag() XdrNum32 {
	return XDR_OperationType(&u.Type)
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionBody() XdrType {
	switch u.Type {
	case CREATE_ACCOUNT:
		return XDR_CreateAccountResult(u.CreateAccountResult())
	case PAYMENT:
		return XDR_PaymentResult(u.PaymentResult())
	case PATH_PAYMENT_STRICT_RECEIVE:
		return XDR_PathPaymentStrictReceiveResult(u.PathPaymentStrictReceiveResult())
	case MANAGE_SELL_OFFER:
		return XDR_ManageSellOfferResult(u.ManageSellOfferResult())
	case CREATE_PASSIVE_SELL_OFFER:
		return XDR_ManageSellOfferResult(u.CreatePassiveSellOfferResult())
	case SET_OPTIONS:
		return XDR_SetOptionsResult(u.SetOptionsResult())
	case CHANGE_TRUST:
		return XDR_ChangeTrustResult(u.ChangeTrustResult())
	case ALLOW_TRUST:
		return XDR_AllowTrustResult(u.AllowTrustResult())
	case ACCOUNT_MERGE:
		return XDR_AccountMergeResult(u.AccountMergeResult())
	case INFLATION:
		return XDR_InflationResult(u.InflationResult())
	case MANAGE_DATA:
		return XDR_ManageDataResult(u.ManageDataResult())
	case BUMP_SEQUENCE:
		return XDR_BumpSequenceResult(u.BumpSeqResult())
	case MANAGE_BUY_OFFER:
		return XDR_ManageBuyOfferResult(u.ManageBuyOfferResult())
	case PATH_PAYMENT_STRICT_SEND:
		return XDR_PathPaymentStrictSendResult(u.PathPaymentStrictSendResult())
	case CREATE_CLAIMABLE_BALANCE:
		return XDR_CreateClaimableBalanceResult(u.CreateClaimableBalanceResult())
	case CLAIM_CLAIMABLE_BALANCE:
		return XDR_ClaimClaimableBalanceResult(u.ClaimClaimableBalanceResult())
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		return XDR_BeginSponsoringFutureReservesResult(u.BeginSponsoringFutureReservesResult())
	case END_SPONSORING_FUTURE_RESERVES:
		return XDR_EndSponsoringFutureReservesResult(u.EndSponsoringFutureReservesResult())
	case REVOKE_SPONSORSHIP:
		return XDR_RevokeSponsorshipResult(u.RevokeSponsorshipResult())
	case CLAWBACK:
		return XDR_ClawbackResult(u.ClawbackResult())
	case CLAWBACK_CLAIMABLE_BALANCE:
		return XDR_ClawbackClaimableBalanceResult(u.ClawbackClaimableBalanceResult())
	case SET_TRUST_LINE_FLAGS:
		return XDR_SetTrustLineFlagsResult(u.SetTrustLineFlagsResult())
	case LIQUIDITY_POOL_DEPOSIT:
		return XDR_LiquidityPoolDepositResult(u.LiquidityPoolDepositResult())
	case LIQUIDITY_POOL_WITHDRAW:
		return XDR_LiquidityPoolWithdrawResult(u.LiquidityPoolWithdrawResult())
	case INVOKE_HOST_FUNCTION:
		return XDR_InvokeHostFunctionResult(u.InvokeHostFunctionResult())
	case EXTEND_FOOTPRINT_TTL:
		return XDR_ExtendFootprintTTLResult(u.ExtendFootprintTTLResult())
	case RESTORE_FOOTPRINT:
		return XDR_RestoreFootprintResult(u.RestoreFootprintResult())
	}
	return nil
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionBodyName() string {
	switch u.Type {
	case CREATE_ACCOUNT:
		return "CreateAccountResult"
	case PAYMENT:
		return "PaymentResult"
	case PATH_PAYMENT_STRICT_RECEIVE:
		return "PathPaymentStrictReceiveResult"
	case MANAGE_SELL_OFFER:
		return "ManageSellOfferResult"
	case CREATE_PASSIVE_SELL_OFFER:
		return "CreatePassiveSellOfferResult"
	case SET_OPTIONS:
		return "SetOptionsResult"
	case CHANGE_TRUST:
		return "ChangeTrustResult"
	case ALLOW_TRUST:
		return "AllowTrustResult"
	case ACCOUNT_MERGE:
		return "AccountMergeResult"
	case INFLATION:
		return "InflationResult"
	case MANAGE_DATA:
		return "ManageDataResult"
	case BUMP_SEQUENCE:
		return "BumpSeqResult"
	case MANAGE_BUY_OFFER:
		return "ManageBuyOfferResult"
	case PATH_PAYMENT_STRICT_SEND:
		return "PathPaymentStrictSendResult"
	case CREATE_CLAIMABLE_BALANCE:
		return "CreateClaimableBalanceResult"
	case CLAIM_CLAIMABLE_BALANCE:
		return "ClaimClaimableBalanceResult"
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		return "BeginSponsoringFutureReservesResult"
	case END_SPONSORING_FUTURE_RESERVES:
		return "EndSponsoringFutureReservesResult"
	case REVOKE_SPONSORSHIP:
		return "RevokeSponsorshipResult"
	case CLAWBACK:
		return "ClawbackResult"
	case CLAWBACK_CLAIMABLE_BALANCE:
		return "ClawbackClaimableBalanceResult"
	case SET_TRUST_LINE_FLAGS:
		return "SetTrustLineFlagsResult"
	case LIQUIDITY_POOL_DEPOSIT:
		return "LiquidityPoolDepositResult"
	case LIQUIDITY_POOL_WITHDRAW:
		return "LiquidityPoolWithdrawResult"
	case INVOKE_HOST_FUNCTION:
		return "InvokeHostFunctionResult"
	case EXTEND_FOOTPRINT_TTL:
		return "ExtendFootprintTTLResult"
	case RESTORE_FOOTPRINT:
		return "RestoreFootprintResult"
	}
	return ""
}

type XdrType_XdrAnon_OperationResult_Tr = *XdrAnon_OperationResult_Tr

func (v *XdrAnon_OperationResult_Tr) XdrPointer() interface{}       { return v }
func (XdrAnon_OperationResult_Tr) XdrTypeName() string              { return "XdrAnon_OperationResult_Tr" }
func (v XdrAnon_OperationResult_Tr) XdrValue() interface{}          { return v }
func (v *XdrAnon_OperationResult_Tr) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_OperationResult_Tr) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CREATE_ACCOUNT:
		x.Marshal(x.Sprintf("%screateAccountResult", name), XDR_CreateAccountResult(u.CreateAccountResult()))
		return
	case PAYMENT:
		x.Marshal(x.Sprintf("%spaymentResult", name), XDR_PaymentResult(u.PaymentResult()))
		return
	case PATH_PAYMENT_STRICT_RECEIVE:
		x.Marshal(x.Sprintf("%spathPaymentStrictReceiveResult", name), XDR_PathPaymentStrictReceiveResult(u.PathPaymentStrictReceiveResult()))
		return
	case MANAGE_SELL_OFFER:
		x.Marshal(x.Sprintf("%smanageSellOfferResult", name), XDR_ManageSellOfferResult(u.ManageSellOfferResult()))
		return
	case CREATE_PASSIVE_SELL_OFFER:
		x.Marshal(x.Sprintf("%screatePassiveSellOfferResult", name), XDR_ManageSellOfferResult(u.CreatePassiveSellOfferResult()))
		return
	case SET_OPTIONS:
		x.Marshal(x.Sprintf("%ssetOptionsResult", name), XDR_SetOptionsResult(u.SetOptionsResult()))
		return
	case CHANGE_TRUST:
		x.Marshal(x.Sprintf("%schangeTrustResult", name), XDR_ChangeTrustResult(u.ChangeTrustResult()))
		return
	case ALLOW_TRUST:
		x.Marshal(x.Sprintf("%sallowTrustResult", name), XDR_AllowTrustResult(u.AllowTrustResult()))
		return
	case ACCOUNT_MERGE:
		x.Marshal(x.Sprintf("%saccountMergeResult", name), XDR_AccountMergeResult(u.AccountMergeResult()))
		return
	case INFLATION:
		x.Marshal(x.Sprintf("%sinflationResult", name), XDR_InflationResult(u.InflationResult()))
		return
	case MANAGE_DATA:
		x.Marshal(x.Sprintf("%smanageDataResult", name), XDR_ManageDataResult(u.ManageDataResult()))
		return
	case BUMP_SEQUENCE:
		x.Marshal(x.Sprintf("%sbumpSeqResult", name), XDR_BumpSequenceResult(u.BumpSeqResult()))
		return
	case MANAGE_BUY_OFFER:
		x.Marshal(x.Sprintf("%smanageBuyOfferResult", name), XDR_ManageBuyOfferResult(u.ManageBuyOfferResult()))
		return
	case PATH_PAYMENT_STRICT_SEND:
		x.Marshal(x.Sprintf("%spathPaymentStrictSendResult", name), XDR_PathPaymentStrictSendResult(u.PathPaymentStrictSendResult()))
		return
	case CREATE_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%screateClaimableBalanceResult", name), XDR_CreateClaimableBalanceResult(u.CreateClaimableBalanceResult()))
		return
	case CLAIM_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclaimClaimableBalanceResult", name), XDR_ClaimClaimableBalanceResult(u.ClaimClaimableBalanceResult()))
		return
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		x.Marshal(x.Sprintf("%sbeginSponsoringFutureReservesResult", name), XDR_BeginSponsoringFutureReservesResult(u.BeginSponsoringFutureReservesResult()))
		return
	case END_SPONSORING_FUTURE_RESERVES:
		x.Marshal(x.Sprintf("%sendSponsoringFutureReservesResult", name), XDR_EndSponsoringFutureReservesResult(u.EndSponsoringFutureReservesResult()))
		return
	case REVOKE_SPONSORSHIP:
		x.Marshal(x.Sprintf("%srevokeSponsorshipResult", name), XDR_RevokeSponsorshipResult(u.RevokeSponsorshipResult()))
		return
	case CLAWBACK:
		x.Marshal(x.Sprintf("%sclawbackResult", name), XDR_ClawbackResult(u.ClawbackResult()))
		return
	case CLAWBACK_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclawbackClaimableBalanceResult", name), XDR_ClawbackClaimableBalanceResult(u.ClawbackClaimableBalanceResult()))
		return
	case SET_TRUST_LINE_FLAGS:
		x.Marshal(x.Sprintf("%ssetTrustLineFlagsResult", name), XDR_SetTrustLineFlagsResult(u.SetTrustLineFlagsResult()))
		return
	case LIQUIDITY_POOL_DEPOSIT:
		x.Marshal(x.Sprintf("%sliquidityPoolDepositResult", name), XDR_LiquidityPoolDepositResult(u.LiquidityPoolDepositResult()))
		return
	case LIQUIDITY_POOL_WITHDRAW:
		x.Marshal(x.Sprintf("%sliquidityPoolWithdrawResult", name), XDR_LiquidityPoolWithdrawResult(u.LiquidityPoolWithdrawResult()))
		return
	case INVOKE_HOST_FUNCTION:
		x.Marshal(x.Sprintf("%sinvokeHostFunctionResult", name), XDR_InvokeHostFunctionResult(u.InvokeHostFunctionResult()))
		return
	case EXTEND_FOOTPRINT_TTL:
		x.Marshal(x.Sprintf("%sextendFootprintTTLResult", name), XDR_ExtendFootprintTTLResult(u.ExtendFootprintTTLResult()))
		return
	case RESTORE_FOOTPRINT:
		x.Marshal(x.Sprintf("%srestoreFootprintResult", name), XDR_RestoreFootprintResult(u.RestoreFootprintResult()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_OperationResult_Tr", u.Type)
}
func XDR_XdrAnon_OperationResult_Tr(v *XdrAnon_OperationResult_Tr) *XdrAnon_OperationResult_Tr {
	return v
}

var _XdrTags_OperationResult = map[int32]bool{
	XdrToI32(OpINNER):               true,
	XdrToI32(OpBAD_AUTH):            true,
	XdrToI32(OpNO_ACCOUNT):          true,
	XdrToI32(OpNOT_SUPPORTED):       true,
	XdrToI32(OpTOO_MANY_SUBENTRIES): true,
	XdrToI32(OpEXCEEDED_WORK_LIMIT): true,
	XdrToI32(OpTOO_MANY_SPONSORING): true,
}

func (_ OperationResult) XdrValidTags() map[int32]bool {
	return _XdrTags_OperationResult
}
func (u *OperationResult) Tr() *XdrAnon_OperationResult_Tr {
	switch u.Code {
	case OpINNER:
		if v, ok := u._u.(*XdrAnon_OperationResult_Tr); ok {
			return v
		} else {
			var zero XdrAnon_OperationResult_Tr
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("OperationResult.Tr accessed when Code == %v", u.Code)
		return nil
	}
}
func (u OperationResult) XdrValid() bool {
	switch u.Code {
	case OpINNER, OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
		return true
	}
	return false
}
func (u *OperationResult) XdrUnionTag() XdrNum32 {
	return XDR_OperationResultCode(&u.Code)
}
func (u *OperationResult) XdrUnionTagName() string {
	return "Code"
}
func (u *OperationResult) XdrUnionBody() XdrType {
	switch u.Code {
	case OpINNER:
		return XDR_XdrAnon_OperationResult_Tr(u.Tr())
	case OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
		return nil
	}
	return nil
}
func (u *OperationResult) XdrUnionBodyName() string {
	switch u.Code {
	case OpINNER:
		return "Tr"
	case OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
		return ""
	}
	return ""
}

type XdrType_OperationResult = *OperationResult

func (v *OperationResult) XdrPointer() interface{}       { return v }
func (OperationResult) XdrTypeName() string              { return "OperationResult" }
func (v OperationResult) XdrValue() interface{}          { return v }
func (v *OperationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *OperationResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case OpINNER:
		x.Marshal(x.Sprintf("%str", name), XDR_XdrAnon_OperationResult_Tr(u.Tr()))
		return
	case OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
		return
	}
	XdrPanic("invalid Code (%v) in OperationResult", u.Code)
}
func XDR_OperationResult(v *OperationResult) *OperationResult { return v }

var _XdrNames_TransactionResultCode = map[int32]string{
	int32(TxFEE_BUMP_INNER_SUCCESS): "txFEE_BUMP_INNER_SUCCESS",
	int32(TxSUCCESS):                "txSUCCESS",
	int32(TxFAILED):                 "txFAILED",
	int32(TxTOO_EARLY):              "txTOO_EARLY",
	int32(TxTOO_LATE):               "txTOO_LATE",
	int32(TxMISSING_OPERATION):      "txMISSING_OPERATION",
	int32(TxBAD_SEQ):                "txBAD_SEQ",
	int32(TxBAD_AUTH):               "txBAD_AUTH",
	int32(TxINSUFFICIENT_BALANCE):   "txINSUFFICIENT_BALANCE",
	int32(TxNO_ACCOUNT):             "txNO_ACCOUNT",
	int32(TxINSUFFICIENT_FEE):       "txINSUFFICIENT_FEE",
	int32(TxBAD_AUTH_EXTRA):         "txBAD_AUTH_EXTRA",
	int32(TxINTERNAL_ERROR):         "txINTERNAL_ERROR",
	int32(TxNOT_SUPPORTED):          "txNOT_SUPPORTED",
	int32(TxFEE_BUMP_INNER_FAILED):  "txFEE_BUMP_INNER_FAILED",
	int32(TxBAD_SPONSORSHIP):        "txBAD_SPONSORSHIP",
	int32(TxBAD_MIN_SEQ_AGE_OR_GAP): "txBAD_MIN_SEQ_AGE_OR_GAP",
	int32(TxMALFORMED):              "txMALFORMED",
	int32(TxSOROBAN_INVALID):        "txSOROBAN_INVALID",
}
var _XdrValues_TransactionResultCode = map[string]int32{
	"txFEE_BUMP_INNER_SUCCESS": int32(TxFEE_BUMP_INNER_SUCCESS),
	"txSUCCESS":                int32(TxSUCCESS),
	"txFAILED":                 int32(TxFAILED),
	"txTOO_EARLY":              int32(TxTOO_EARLY),
	"txTOO_LATE":               int32(TxTOO_LATE),
	"txMISSING_OPERATION":      int32(TxMISSING_OPERATION),
	"txBAD_SEQ":                int32(TxBAD_SEQ),
	"txBAD_AUTH":               int32(TxBAD_AUTH),
	"txINSUFFICIENT_BALANCE":   int32(TxINSUFFICIENT_BALANCE),
	"txNO_ACCOUNT":             int32(TxNO_ACCOUNT),
	"txINSUFFICIENT_FEE":       int32(TxINSUFFICIENT_FEE),
	"txBAD_AUTH_EXTRA":         int32(TxBAD_AUTH_EXTRA),
	"txINTERNAL_ERROR":         int32(TxINTERNAL_ERROR),
	"txNOT_SUPPORTED":          int32(TxNOT_SUPPORTED),
	"txFEE_BUMP_INNER_FAILED":  int32(TxFEE_BUMP_INNER_FAILED),
	"txBAD_SPONSORSHIP":        int32(TxBAD_SPONSORSHIP),
	"txBAD_MIN_SEQ_AGE_OR_GAP": int32(TxBAD_MIN_SEQ_AGE_OR_GAP),
	"txMALFORMED":              int32(TxMALFORMED),
	"txSOROBAN_INVALID":        int32(TxSOROBAN_INVALID),
}

func (TransactionResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_TransactionResultCode
}
func (v TransactionResultCode) String() string {
	if s, ok := _XdrNames_TransactionResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("TransactionResultCode#%d", v)
}
func (v *TransactionResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TransactionResultCode[stok]; ok {
			*v = TransactionResultCode(val)
			return nil
		} else if stok == "TransactionResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid TransactionResultCode.", stok))
	}
}
func (v TransactionResultCode) GetU32() uint32                 { return uint32(v) }
func (v *TransactionResultCode) SetU32(n uint32)               { *v = TransactionResultCode(n) }
func (v *TransactionResultCode) XdrPointer() interface{}       { return v }
func (TransactionResultCode) XdrTypeName() string              { return "TransactionResultCode" }
func (v TransactionResultCode) XdrValue() interface{}          { return v }
func (v *TransactionResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionResultCode = *TransactionResultCode

func XDR_TransactionResultCode(v *TransactionResultCode) *TransactionResultCode { return v }

var _XdrComments_TransactionResultCode = map[int32]string{
	int32(TxFEE_BUMP_INNER_SUCCESS): "fee bump inner transaction succeeded",
	int32(TxSUCCESS):                "all operations succeeded",
	int32(TxFAILED):                 "one of the operations failed (none were applied)",
	int32(TxTOO_EARLY):              "ledger closeTime before minTime",
	int32(TxTOO_LATE):               "ledger closeTime after maxTime",
	int32(TxMISSING_OPERATION):      "no operation was specified",
	int32(TxBAD_SEQ):                "sequence number does not match source account",
	int32(TxBAD_AUTH):               "too few valid signatures / wrong network",
	int32(TxINSUFFICIENT_BALANCE):   "fee would bring account below reserve",
	int32(TxNO_ACCOUNT):             "source account not found",
	int32(TxINSUFFICIENT_FEE):       "fee is too small",
	int32(TxBAD_AUTH_EXTRA):         "unused signatures attached to transaction",
	int32(TxINTERNAL_ERROR):         "an unknown error occurred",
	int32(TxNOT_SUPPORTED):          "transaction type not supported",
	int32(TxFEE_BUMP_INNER_FAILED):  "fee bump inner transaction failed",
	int32(TxBAD_SPONSORSHIP):        "sponsorship not confirmed",
	int32(TxBAD_MIN_SEQ_AGE_OR_GAP): "minSeqAge or minSeqLedgerGap conditions not met",
	int32(TxMALFORMED):              "precondition is invalid",
	int32(TxSOROBAN_INVALID):        "soroban-specific preconditions were not met",
}

func (e TransactionResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_TransactionResultCode
}

type _XdrVec_unbounded_OperationResult []OperationResult

func (_XdrVec_unbounded_OperationResult) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_OperationResult) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_OperationResult length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_OperationResult length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_OperationResult) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_OperationResult) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]OperationResult, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_OperationResult) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_OperationResult(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_OperationResult) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_OperationResult) XdrTypeName() string              { return "OperationResult<>" }
func (v *_XdrVec_unbounded_OperationResult) XdrPointer() interface{}       { return (*[]OperationResult)(v) }
func (v _XdrVec_unbounded_OperationResult) XdrValue() interface{}          { return ([]OperationResult)(v) }
func (v *_XdrVec_unbounded_OperationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_XdrAnon_InnerTransactionResult_Result = map[int32]bool{
	XdrToI32(TxSUCCESS):                true,
	XdrToI32(TxFAILED):                 true,
	XdrToI32(TxTOO_EARLY):              true,
	XdrToI32(TxTOO_LATE):               true,
	XdrToI32(TxMISSING_OPERATION):      true,
	XdrToI32(TxBAD_SEQ):                true,
	XdrToI32(TxBAD_AUTH):               true,
	XdrToI32(TxINSUFFICIENT_BALANCE):   true,
	XdrToI32(TxNO_ACCOUNT):             true,
	XdrToI32(TxINSUFFICIENT_FEE):       true,
	XdrToI32(TxBAD_AUTH_EXTRA):         true,
	XdrToI32(TxINTERNAL_ERROR):         true,
	XdrToI32(TxNOT_SUPPORTED):          true,
	XdrToI32(TxBAD_SPONSORSHIP):        true,
	XdrToI32(TxBAD_MIN_SEQ_AGE_OR_GAP): true,
	XdrToI32(TxMALFORMED):              true,
	XdrToI32(TxSOROBAN_INVALID):        true,
}

func (_ XdrAnon_InnerTransactionResult_Result) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_InnerTransactionResult_Result
}
func (u *XdrAnon_InnerTransactionResult_Result) Results() *[]OperationResult {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		if v, ok := u._u.(*[]OperationResult); ok {
			return v
		} else {
			var zero []OperationResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_InnerTransactionResult_Result.Results accessed when Code == %v", u.Code)
		return nil
	}
}
func (u XdrAnon_InnerTransactionResult_Result) XdrValid() bool {
	switch u.Code {
	case TxSUCCESS, TxFAILED, TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
		return true
	}
	return false
}
func (u *XdrAnon_InnerTransactionResult_Result) XdrUnionTag() XdrNum32 {
	return XDR_TransactionResultCode(&u.Code)
}
func (u *XdrAnon_InnerTransactionResult_Result) XdrUnionTagName() string {
	return "Code"
}
func (u *XdrAnon_InnerTransactionResult_Result) XdrUnionBody() XdrType {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		return (*_XdrVec_unbounded_OperationResult)(u.Results())
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
		return nil
	}
	return nil
}
func (u *XdrAnon_InnerTransactionResult_Result) XdrUnionBodyName() string {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		return "Results"
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_InnerTransactionResult_Result = *XdrAnon_InnerTransactionResult_Result

func (v *XdrAnon_InnerTransactionResult_Result) XdrPointer() interface{} { return v }
func (XdrAnon_InnerTransactionResult_Result) XdrTypeName() string {
	return "XdrAnon_InnerTransactionResult_Result"
}
func (v XdrAnon_InnerTransactionResult_Result) XdrValue() interface{}          { return v }
func (v *XdrAnon_InnerTransactionResult_Result) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_InnerTransactionResult_Result) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TransactionResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_OperationResult)(u.Results()))
		return
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
		return
	}
	XdrPanic("invalid Code (%v) in XdrAnon_InnerTransactionResult_Result", u.Code)
}
func XDR_XdrAnon_InnerTransactionResult_Result(v *XdrAnon_InnerTransactionResult_Result) *XdrAnon_InnerTransactionResult_Result {
	return v
}

var _XdrTags_XdrAnon_InnerTransactionResult_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_InnerTransactionResult_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_InnerTransactionResult_Ext
}
func (u XdrAnon_InnerTransactionResult_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_InnerTransactionResult_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_InnerTransactionResult_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_InnerTransactionResult_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_InnerTransactionResult_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_InnerTransactionResult_Ext = *XdrAnon_InnerTransactionResult_Ext

func (v *XdrAnon_InnerTransactionResult_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_InnerTransactionResult_Ext) XdrTypeName() string {
	return "XdrAnon_InnerTransactionResult_Ext"
}
func (v XdrAnon_InnerTransactionResult_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_InnerTransactionResult_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_InnerTransactionResult_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_InnerTransactionResult_Ext", u.V)
}
func XDR_XdrAnon_InnerTransactionResult_Ext(v *XdrAnon_InnerTransactionResult_Ext) *XdrAnon_InnerTransactionResult_Ext {
	return v
}

type XdrType_InnerTransactionResult = *InnerTransactionResult

func (v *InnerTransactionResult) XdrPointer() interface{}       { return v }
func (InnerTransactionResult) XdrTypeName() string              { return "InnerTransactionResult" }
func (v InnerTransactionResult) XdrValue() interface{}          { return v }
func (v *InnerTransactionResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InnerTransactionResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfeeCharged", name), XDR_Int64(&v.FeeCharged))
	x.Marshal(x.Sprintf("%sresult", name), XDR_XdrAnon_InnerTransactionResult_Result(&v.Result))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_InnerTransactionResult_Ext(&v.Ext))
}
func XDR_InnerTransactionResult(v *InnerTransactionResult) *InnerTransactionResult { return v }

type XdrType_InnerTransactionResultPair = *InnerTransactionResultPair

func (v *InnerTransactionResultPair) XdrPointer() interface{}       { return v }
func (InnerTransactionResultPair) XdrTypeName() string              { return "InnerTransactionResultPair" }
func (v InnerTransactionResultPair) XdrValue() interface{}          { return v }
func (v *InnerTransactionResultPair) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InnerTransactionResultPair) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stransactionHash", name), XDR_Hash(&v.TransactionHash))
	x.Marshal(x.Sprintf("%sresult", name), XDR_InnerTransactionResult(&v.Result))
}
func XDR_InnerTransactionResultPair(v *InnerTransactionResultPair) *InnerTransactionResultPair {
	return v
}

var _XdrTags_XdrAnon_TransactionResult_Result = map[int32]bool{
	XdrToI32(TxFEE_BUMP_INNER_SUCCESS): true,
	XdrToI32(TxFEE_BUMP_INNER_FAILED):  true,
	XdrToI32(TxSUCCESS):                true,
	XdrToI32(TxFAILED):                 true,
	XdrToI32(TxTOO_EARLY):              true,
	XdrToI32(TxTOO_LATE):               true,
	XdrToI32(TxMISSING_OPERATION):      true,
	XdrToI32(TxBAD_SEQ):                true,
	XdrToI32(TxBAD_AUTH):               true,
	XdrToI32(TxINSUFFICIENT_BALANCE):   true,
	XdrToI32(TxNO_ACCOUNT):             true,
	XdrToI32(TxINSUFFICIENT_FEE):       true,
	XdrToI32(TxBAD_AUTH_EXTRA):         true,
	XdrToI32(TxINTERNAL_ERROR):         true,
	XdrToI32(TxNOT_SUPPORTED):          true,
	XdrToI32(TxBAD_SPONSORSHIP):        true,
	XdrToI32(TxBAD_MIN_SEQ_AGE_OR_GAP): true,
	XdrToI32(TxMALFORMED):              true,
	XdrToI32(TxSOROBAN_INVALID):        true,
}

func (_ XdrAnon_TransactionResult_Result) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionResult_Result
}
func (u *XdrAnon_TransactionResult_Result) InnerResultPair() *InnerTransactionResultPair {
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
		if v, ok := u._u.(*InnerTransactionResultPair); ok {
			return v
		} else {
			var zero InnerTransactionResultPair
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionResult_Result.InnerResultPair accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *XdrAnon_TransactionResult_Result) Results() *[]OperationResult {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		if v, ok := u._u.(*[]OperationResult); ok {
			return v
		} else {
			var zero []OperationResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionResult_Result.Results accessed when Code == %v", u.Code)
		return nil
	}
}
func (u XdrAnon_TransactionResult_Result) XdrValid() bool {
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED, TxSUCCESS, TxFAILED, TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionTag() XdrNum32 {
	return XDR_TransactionResultCode(&u.Code)
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionTagName() string {
	return "Code"
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionBody() XdrType {
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
		return XDR_InnerTransactionResultPair(u.InnerResultPair())
	case TxSUCCESS, TxFAILED:
		return (*_XdrVec_unbounded_OperationResult)(u.Results())
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionBodyName() string {
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
		return "InnerResultPair"
	case TxSUCCESS, TxFAILED:
		return "Results"
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionResult_Result = *XdrAnon_TransactionResult_Result

func (v *XdrAnon_TransactionResult_Result) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionResult_Result) XdrTypeName() string {
	return "XdrAnon_TransactionResult_Result"
}
func (v XdrAnon_TransactionResult_Result) XdrValue() interface{}          { return v }
func (v *XdrAnon_TransactionResult_Result) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionResult_Result) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TransactionResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
		x.Marshal(x.Sprintf("%sinnerResultPair", name), XDR_InnerTransactionResultPair(u.InnerResultPair()))
		return
	case TxSUCCESS, TxFAILED:
		x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_OperationResult)(u.Results()))
		return
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED, TxSOROBAN_INVALID:
		return
	}
	XdrPanic("invalid Code (%v) in XdrAnon_TransactionResult_Result", u.Code)
}
func XDR_XdrAnon_TransactionResult_Result(v *XdrAnon_TransactionResult_Result) *XdrAnon_TransactionResult_Result {
	return v
}

var _XdrTags_XdrAnon_TransactionResult_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TransactionResult_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionResult_Ext
}
func (u XdrAnon_TransactionResult_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionResult_Ext = *XdrAnon_TransactionResult_Ext

func (v *XdrAnon_TransactionResult_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_TransactionResult_Ext) XdrTypeName() string              { return "XdrAnon_TransactionResult_Ext" }
func (v XdrAnon_TransactionResult_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TransactionResult_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionResult_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionResult_Ext", u.V)
}
func XDR_XdrAnon_TransactionResult_Ext(v *XdrAnon_TransactionResult_Ext) *XdrAnon_TransactionResult_Ext {
	return v
}

type XdrType_TransactionResult = *TransactionResult

func (v *TransactionResult) XdrPointer() interface{}       { return v }
func (TransactionResult) XdrTypeName() string              { return "TransactionResult" }
func (v TransactionResult) XdrValue() interface{}          { return v }
func (v *TransactionResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfeeCharged", name), XDR_Int64(&v.FeeCharged))
	x.Marshal(x.Sprintf("%sresult", name), XDR_XdrAnon_TransactionResult_Result(&v.Result))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionResult_Ext(&v.Ext))
}
func XDR_TransactionResult(v *TransactionResult) *TransactionResult { return v }

type _XdrArray_32_opaque [32]byte

func (v *_XdrArray_32_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_32_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_32_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_32_opaque) XdrPointer() interface{}       { return (*[32]byte)(v) }
func (v *_XdrArray_32_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_32_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_32_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_32_opaque) XdrArraySize() uint32 {
	const bound uint32 = 32 // Force error if not const or doesn't fit
	return bound
}

type XdrType_Hash struct {
	*_XdrArray_32_opaque
}

func XDR_Hash(v *Hash) XdrType_Hash {
	return XdrType_Hash{(*_XdrArray_32_opaque)(v)}
}
func (XdrType_Hash) XdrTypeName() string  { return "Hash" }
func (v XdrType_Hash) XdrUnwrap() XdrType { return v._XdrArray_32_opaque }

type XdrType_Uint256 struct {
	*_XdrArray_32_opaque
}

func XDR_Uint256(v *Uint256) XdrType_Uint256 {
	return XdrType_Uint256{(*_XdrArray_32_opaque)(v)}
}
func (XdrType_Uint256) XdrTypeName() string  { return "Uint256" }
func (v XdrType_Uint256) XdrUnwrap() XdrType { return v._XdrArray_32_opaque }

type XdrType_Uint32 struct {
	XdrType_uint32
}

func XDR_Uint32(v *Uint32) XdrType_Uint32 {
	return XdrType_Uint32{XDR_uint32(v)}
}
func (XdrType_Uint32) XdrTypeName() string  { return "Uint32" }
func (v XdrType_Uint32) XdrUnwrap() XdrType { return v.XdrType_uint32 }

type XdrType_Int32 struct {
	XdrType_int32
}

func XDR_Int32(v *Int32) XdrType_Int32 {
	return XdrType_Int32{XDR_int32(v)}
}
func (XdrType_Int32) XdrTypeName() string  { return "Int32" }
func (v XdrType_Int32) XdrUnwrap() XdrType { return v.XdrType_int32 }

type XdrType_Uint64 struct {
	XdrType_uint64
}

func XDR_Uint64(v *Uint64) XdrType_Uint64 {
	return XdrType_Uint64{XDR_uint64(v)}
}
func (XdrType_Uint64) XdrTypeName() string  { return "Uint64" }
func (v XdrType_Uint64) XdrUnwrap() XdrType { return v.XdrType_uint64 }

type XdrType_Int64 struct {
	XdrType_int64
}

func XDR_Int64(v *Int64) XdrType_Int64 {
	return XdrType_Int64{XDR_int64(v)}
}
func (XdrType_Int64) XdrTypeName() string  { return "Int64" }
func (v XdrType_Int64) XdrUnwrap() XdrType { return v.XdrType_int64 }

type XdrType_TimePoint struct {
	XdrType_Uint64
}

func XDR_TimePoint(v *TimePoint) XdrType_TimePoint {
	return XdrType_TimePoint{XDR_Uint64(v)}
}
func (XdrType_TimePoint) XdrTypeName() string  { return "TimePoint" }
func (v XdrType_TimePoint) XdrUnwrap() XdrType { return v.XdrType_Uint64 }

type XdrType_Duration struct {
	XdrType_Uint64
}

func XDR_Duration(v *Duration) XdrType_Duration {
	return XdrType_Duration{XDR_Uint64(v)}
}
func (XdrType_Duration) XdrTypeName() string  { return "Duration" }
func (v XdrType_Duration) XdrUnwrap() XdrType { return v.XdrType_Uint64 }

var _XdrTags_ExtensionPoint = map[int32]bool{
	XdrToI32(0): true,
}

func (_ ExtensionPoint) XdrValidTags() map[int32]bool {
	return _XdrTags_ExtensionPoint
}
func (u ExtensionPoint) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *ExtensionPoint) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *ExtensionPoint) XdrUnionTagName() string {
	return "V"
}
func (u *ExtensionPoint) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *ExtensionPoint) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_ExtensionPoint = *ExtensionPoint

func (v *ExtensionPoint) XdrPointer() interface{}       { return v }
func (ExtensionPoint) XdrTypeName() string              { return "ExtensionPoint" }
func (v ExtensionPoint) XdrValue() interface{}          { return v }
func (v *ExtensionPoint) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ExtensionPoint) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in ExtensionPoint", u.V)
}
func XDR_ExtensionPoint(v *ExtensionPoint) *ExtensionPoint { return v }

var _XdrNames_CryptoKeyType = map[int32]string{
	int32(KEY_TYPE_ED25519):                "KEY_TYPE_ED25519",
	int32(KEY_TYPE_PRE_AUTH_TX):            "KEY_TYPE_PRE_AUTH_TX",
	int32(KEY_TYPE_HASH_X):                 "KEY_TYPE_HASH_X",
	int32(KEY_TYPE_ED25519_SIGNED_PAYLOAD): "KEY_TYPE_ED25519_SIGNED_PAYLOAD",
	int32(KEY_TYPE_MUXED_ED25519):          "KEY_TYPE_MUXED_ED25519",
}
var _XdrValues_CryptoKeyType = map[string]int32{
	"KEY_TYPE_ED25519":                int32(KEY_TYPE_ED25519),
	"KEY_TYPE_PRE_AUTH_TX":            int32(KEY_TYPE_PRE_AUTH_TX),
	"KEY_TYPE_HASH_X":                 int32(KEY_TYPE_HASH_X),
	"KEY_TYPE_ED25519_SIGNED_PAYLOAD": int32(KEY_TYPE_ED25519_SIGNED_PAYLOAD),
	"KEY_TYPE_MUXED_ED25519":          int32(KEY_TYPE_MUXED_ED25519),
}

func (CryptoKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_CryptoKeyType
}
func (v CryptoKeyType) String() string {
	if s, ok := _XdrNames_CryptoKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("CryptoKeyType#%d", v)
}
func (v *CryptoKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CryptoKeyType[stok]; ok {
			*v = CryptoKeyType(val)
			return nil
		} else if stok == "CryptoKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid CryptoKeyType.", stok))
	}
}
func (v CryptoKeyType) GetU32() uint32                 { return uint32(v) }
func (v *CryptoKeyType) SetU32(n uint32)               { *v = CryptoKeyType(n) }
func (v *CryptoKeyType) XdrPointer() interface{}       { return v }
func (CryptoKeyType) XdrTypeName() string              { return "CryptoKeyType" }
func (v CryptoKeyType) XdrValue() interface{}          { return v }
func (v *CryptoKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_CryptoKeyType = *CryptoKeyType

func XDR_CryptoKeyType(v *CryptoKeyType) *CryptoKeyType { return v }

var _XdrComments_CryptoKeyType = map[int32]string{
	int32(KEY_TYPE_MUXED_ED25519): "MUXED enum values for supported type are derived from the enum values above by ORing them with 0x100",
}

func (e CryptoKeyType) XdrEnumComments() map[int32]string {
	return _XdrComments_CryptoKeyType
}

var _XdrNames_PublicKeyType = map[int32]string{
	int32(PUBLIC_KEY_TYPE_ED25519): "PUBLIC_KEY_TYPE_ED25519",
}
var _XdrValues_PublicKeyType = map[string]int32{
	"PUBLIC_KEY_TYPE_ED25519": int32(PUBLIC_KEY_TYPE_ED25519),
}

func (PublicKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_PublicKeyType
}
func (v PublicKeyType) String() string {
	if s, ok := _XdrNames_PublicKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PublicKeyType#%d", v)
}
func (v *PublicKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PublicKeyType[stok]; ok {
			*v = PublicKeyType(val)
			return nil
		} else if stok == "PublicKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PublicKeyType.", stok))
	}
}
func (v PublicKeyType) GetU32() uint32                 { return uint32(v) }
func (v *PublicKeyType) SetU32(n uint32)               { *v = PublicKeyType(n) }
func (v *PublicKeyType) XdrPointer() interface{}       { return v }
func (PublicKeyType) XdrTypeName() string              { return "PublicKeyType" }
func (v PublicKeyType) XdrValue() interface{}          { return v }
func (v *PublicKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PublicKeyType = *PublicKeyType

func XDR_PublicKeyType(v *PublicKeyType) *PublicKeyType { return v }

var _XdrNames_SignerKeyType = map[int32]string{
	int32(SIGNER_KEY_TYPE_ED25519):                "SIGNER_KEY_TYPE_ED25519",
	int32(SIGNER_KEY_TYPE_PRE_AUTH_TX):            "SIGNER_KEY_TYPE_PRE_AUTH_TX",
	int32(SIGNER_KEY_TYPE_HASH_X):                 "SIGNER_KEY_TYPE_HASH_X",
	int32(SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD): "SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD",
}
var _XdrValues_SignerKeyType = map[string]int32{
	"SIGNER_KEY_TYPE_ED25519":                int32(SIGNER_KEY_TYPE_ED25519),
	"SIGNER_KEY_TYPE_PRE_AUTH_TX":            int32(SIGNER_KEY_TYPE_PRE_AUTH_TX),
	"SIGNER_KEY_TYPE_HASH_X":                 int32(SIGNER_KEY_TYPE_HASH_X),
	"SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD": int32(SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD),
}

func (SignerKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_SignerKeyType
}
func (v SignerKeyType) String() string {
	if s, ok := _XdrNames_SignerKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SignerKeyType#%d", v)
}
func (v *SignerKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SignerKeyType[stok]; ok {
			*v = SignerKeyType(val)
			return nil
		} else if stok == "SignerKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SignerKeyType.", stok))
	}
}
func (v SignerKeyType) GetU32() uint32                 { return uint32(v) }
func (v *SignerKeyType) SetU32(n uint32)               { *v = SignerKeyType(n) }
func (v *SignerKeyType) XdrPointer() interface{}       { return v }
func (SignerKeyType) XdrTypeName() string              { return "SignerKeyType" }
func (v SignerKeyType) XdrValue() interface{}          { return v }
func (v *SignerKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SignerKeyType = *SignerKeyType

func XDR_SignerKeyType(v *SignerKeyType) *SignerKeyType { return v }

var _XdrTags_PublicKey = map[int32]bool{
	XdrToI32(PUBLIC_KEY_TYPE_ED25519): true,
}

func (_ PublicKey) XdrValidTags() map[int32]bool {
	return _XdrTags_PublicKey
}
func (u *PublicKey) Ed25519() *Uint256 {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PublicKey.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u PublicKey) XdrValid() bool {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return true
	}
	return false
}
func (u *PublicKey) XdrUnionTag() XdrNum32 {
	return XDR_PublicKeyType(&u.Type)
}
func (u *PublicKey) XdrUnionTagName() string {
	return "Type"
}
func (u *PublicKey) XdrUnionBody() XdrType {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return XDR_Uint256(u.Ed25519())
	}
	return nil
}
func (u *PublicKey) XdrUnionBodyName() string {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return "Ed25519"
	}
	return ""
}

type XdrType_PublicKey = *PublicKey

func (v *PublicKey) XdrPointer() interface{}       { return v }
func (PublicKey) XdrTypeName() string              { return "PublicKey" }
func (v PublicKey) XdrValue() interface{}          { return v }
func (v *PublicKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PublicKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PublicKeyType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(u.Ed25519()))
		return
	}
	XdrPanic("invalid Type (%v) in PublicKey", u.Type)
}
func XDR_PublicKey(v *PublicKey) *PublicKey { return v }

type XdrType_XdrAnon_SignerKey_Ed25519SignedPayload = *XdrAnon_SignerKey_Ed25519SignedPayload

func (v *XdrAnon_SignerKey_Ed25519SignedPayload) XdrPointer() interface{} { return v }
func (XdrAnon_SignerKey_Ed25519SignedPayload) XdrTypeName() string {
	return "XdrAnon_SignerKey_Ed25519SignedPayload"
}
func (v XdrAnon_SignerKey_Ed25519SignedPayload) XdrValue() interface{}          { return v }
func (v *XdrAnon_SignerKey_Ed25519SignedPayload) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SignerKey_Ed25519SignedPayload) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(&v.Ed25519))
	x.Marshal(x.Sprintf("%spayload", name), XdrVecOpaque{&v.Payload, 64})
}
func XDR_XdrAnon_SignerKey_Ed25519SignedPayload(v *XdrAnon_SignerKey_Ed25519SignedPayload) *XdrAnon_SignerKey_Ed25519SignedPayload {
	return v
}

var _XdrTags_SignerKey = map[int32]bool{
	XdrToI32(SIGNER_KEY_TYPE_ED25519):                true,
	XdrToI32(SIGNER_KEY_TYPE_PRE_AUTH_TX):            true,
	XdrToI32(SIGNER_KEY_TYPE_HASH_X):                 true,
	XdrToI32(SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD): true,
}

func (_ SignerKey) XdrValidTags() map[int32]bool {
	return _XdrTags_SignerKey
}
func (u *SignerKey) Ed25519() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}

/* SHA-256 Hash of TransactionSignaturePayload structure */
func (u *SignerKey) PreAuthTx() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.PreAuthTx accessed when Type == %v", u.Type)
		return nil
	}
}

/* Hash of random 256 bit preimage X */
func (u *SignerKey) HashX() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_HASH_X:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.HashX accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SignerKey) Ed25519SignedPayload() *XdrAnon_SignerKey_Ed25519SignedPayload {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		if v, ok := u._u.(*XdrAnon_SignerKey_Ed25519SignedPayload); ok {
			return v
		} else {
			var zero XdrAnon_SignerKey_Ed25519SignedPayload
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.Ed25519SignedPayload accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SignerKey) XdrValid() bool {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519, SIGNER_KEY_TYPE_PRE_AUTH_TX, SIGNER_KEY_TYPE_HASH_X, SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		return true
	}
	return false
}
func (u *SignerKey) XdrUnionTag() XdrNum32 {
	return XDR_SignerKeyType(&u.Type)
}
func (u *SignerKey) XdrUnionTagName() string {
	return "Type"
}
func (u *SignerKey) XdrUnionBody() XdrType {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		return XDR_Uint256(u.Ed25519())
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		return XDR_Uint256(u.PreAuthTx())
	case SIGNER_KEY_TYPE_HASH_X:
		return XDR_Uint256(u.HashX())
	case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		return XDR_XdrAnon_SignerKey_Ed25519SignedPayload(u.Ed25519SignedPayload())
	}
	return nil
}
func (u *SignerKey) XdrUnionBodyName() string {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		return "Ed25519"
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		return "PreAuthTx"
	case SIGNER_KEY_TYPE_HASH_X:
		return "HashX"
	case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		return "Ed25519SignedPayload"
	}
	return ""
}

type XdrType_SignerKey = *SignerKey

func (v *SignerKey) XdrPointer() interface{}       { return v }
func (SignerKey) XdrTypeName() string              { return "SignerKey" }
func (v SignerKey) XdrValue() interface{}          { return v }
func (v *SignerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SignerKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SignerKeyType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(u.Ed25519()))
		return
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		x.Marshal(x.Sprintf("%spreAuthTx", name), XDR_Uint256(u.PreAuthTx()))
		return
	case SIGNER_KEY_TYPE_HASH_X:
		x.Marshal(x.Sprintf("%shashX", name), XDR_Uint256(u.HashX()))
		return
	case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		x.Marshal(x.Sprintf("%sed25519SignedPayload", name), XDR_XdrAnon_SignerKey_Ed25519SignedPayload(u.Ed25519SignedPayload()))
		return
	}
	XdrPanic("invalid Type (%v) in SignerKey", u.Type)
}
func XDR_SignerKey(v *SignerKey) *SignerKey { return v }

type XdrType_Signature struct {
	XdrVecOpaque
}

func XDR_Signature(v *Signature) XdrType_Signature {
	return XdrType_Signature{XdrVecOpaque{v, 64}}
}
func (XdrType_Signature) XdrTypeName() string  { return "Signature" }
func (v XdrType_Signature) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_SignatureHint struct {
	*_XdrArray_4_opaque
}

func XDR_SignatureHint(v *SignatureHint) XdrType_SignatureHint {
	return XdrType_SignatureHint{(*_XdrArray_4_opaque)(v)}
}
func (XdrType_SignatureHint) XdrTypeName() string  { return "SignatureHint" }
func (v XdrType_SignatureHint) XdrUnwrap() XdrType { return v._XdrArray_4_opaque }

type XdrType_NodeID struct {
	XdrType_PublicKey
}

func XDR_NodeID(v *NodeID) XdrType_NodeID {
	return XdrType_NodeID{XDR_PublicKey(v)}
}
func (XdrType_NodeID) XdrTypeName() string  { return "NodeID" }
func (v XdrType_NodeID) XdrUnwrap() XdrType { return v.XdrType_PublicKey }

type XdrType_AccountID struct {
	XdrType_PublicKey
}

func XDR_AccountID(v *AccountID) XdrType_AccountID {
	return XdrType_AccountID{XDR_PublicKey(v)}
}
func (XdrType_AccountID) XdrTypeName() string  { return "AccountID" }
func (v XdrType_AccountID) XdrUnwrap() XdrType { return v.XdrType_PublicKey }

type XdrType_Curve25519Secret = *Curve25519Secret

func (v *Curve25519Secret) XdrPointer() interface{}       { return v }
func (Curve25519Secret) XdrTypeName() string              { return "Curve25519Secret" }
func (v Curve25519Secret) XdrValue() interface{}          { return v }
func (v *Curve25519Secret) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Curve25519Secret) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), (*_XdrArray_32_opaque)(&v.Key))
}
func XDR_Curve25519Secret(v *Curve25519Secret) *Curve25519Secret { return v }

type XdrType_Curve25519Public = *Curve25519Public

func (v *Curve25519Public) XdrPointer() interface{}       { return v }
func (Curve25519Public) XdrTypeName() string              { return "Curve25519Public" }
func (v Curve25519Public) XdrValue() interface{}          { return v }
func (v *Curve25519Public) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Curve25519Public) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), (*_XdrArray_32_opaque)(&v.Key))
}
func XDR_Curve25519Public(v *Curve25519Public) *Curve25519Public { return v }

type XdrType_HmacSha256Key = *HmacSha256Key

func (v *HmacSha256Key) XdrPointer() interface{}       { return v }
func (HmacSha256Key) XdrTypeName() string              { return "HmacSha256Key" }
func (v HmacSha256Key) XdrValue() interface{}          { return v }
func (v *HmacSha256Key) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *HmacSha256Key) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), (*_XdrArray_32_opaque)(&v.Key))
}
func XDR_HmacSha256Key(v *HmacSha256Key) *HmacSha256Key { return v }

type XdrType_HmacSha256Mac = *HmacSha256Mac

func (v *HmacSha256Mac) XdrPointer() interface{}       { return v }
func (HmacSha256Mac) XdrTypeName() string              { return "HmacSha256Mac" }
func (v HmacSha256Mac) XdrValue() interface{}          { return v }
func (v *HmacSha256Mac) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *HmacSha256Mac) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%smac", name), (*_XdrArray_32_opaque)(&v.Mac))
}
func XDR_HmacSha256Mac(v *HmacSha256Mac) *HmacSha256Mac { return v }

var _XdrNames_SCEnvMetaKind = map[int32]string{
	int32(SC_ENV_META_KIND_INTERFACE_VERSION): "SC_ENV_META_KIND_INTERFACE_VERSION",
}
var _XdrValues_SCEnvMetaKind = map[string]int32{
	"SC_ENV_META_KIND_INTERFACE_VERSION": int32(SC_ENV_META_KIND_INTERFACE_VERSION),
}

func (SCEnvMetaKind) XdrEnumNames() map[int32]string {
	return _XdrNames_SCEnvMetaKind
}
func (v SCEnvMetaKind) String() string {
	if s, ok := _XdrNames_SCEnvMetaKind[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCEnvMetaKind#%d", v)
}
func (v *SCEnvMetaKind) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCEnvMetaKind[stok]; ok {
			*v = SCEnvMetaKind(val)
			return nil
		} else if stok == "SCEnvMetaKind" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCEnvMetaKind.", stok))
	}
}
func (v SCEnvMetaKind) GetU32() uint32                 { return uint32(v) }
func (v *SCEnvMetaKind) SetU32(n uint32)               { *v = SCEnvMetaKind(n) }
func (v *SCEnvMetaKind) XdrPointer() interface{}       { return v }
func (SCEnvMetaKind) XdrTypeName() string              { return "SCEnvMetaKind" }
func (v SCEnvMetaKind) XdrValue() interface{}          { return v }
func (v *SCEnvMetaKind) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCEnvMetaKind = *SCEnvMetaKind

func XDR_SCEnvMetaKind(v *SCEnvMetaKind) *SCEnvMetaKind { return v }

var _XdrTags_SCEnvMetaEntry = map[int32]bool{
	XdrToI32(SC_ENV_META_KIND_INTERFACE_VERSION): true,
}

func (_ SCEnvMetaEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_SCEnvMetaEntry
}
func (u *SCEnvMetaEntry) InterfaceVersion() *Uint64 {
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCEnvMetaEntry.InterfaceVersion accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u SCEnvMetaEntry) XdrValid() bool {
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		return true
	}
	return false
}
func (u *SCEnvMetaEntry) XdrUnionTag() XdrNum32 {
	return XDR_SCEnvMetaKind(&u.Kind)
}
func (u *SCEnvMetaEntry) XdrUnionTagName() string {
	return "Kind"
}
func (u *SCEnvMetaEntry) XdrUnionBody() XdrType {
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		return XDR_Uint64(u.InterfaceVersion())
	}
	return nil
}
func (u *SCEnvMetaEntry) XdrUnionBodyName() string {
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		return "InterfaceVersion"
	}
	return ""
}

type XdrType_SCEnvMetaEntry = *SCEnvMetaEntry

func (v *SCEnvMetaEntry) XdrPointer() interface{}       { return v }
func (SCEnvMetaEntry) XdrTypeName() string              { return "SCEnvMetaEntry" }
func (v SCEnvMetaEntry) XdrValue() interface{}          { return v }
func (v *SCEnvMetaEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCEnvMetaEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCEnvMetaKind(&u.Kind).XdrMarshal(x, x.Sprintf("%skind", name))
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		x.Marshal(x.Sprintf("%sinterfaceVersion", name), XDR_Uint64(u.InterfaceVersion()))
		return
	}
	XdrPanic("invalid Kind (%v) in SCEnvMetaEntry", u.Kind)
}
func XDR_SCEnvMetaEntry(v *SCEnvMetaEntry) *SCEnvMetaEntry { return v }

type XdrType_SCMetaV0 = *SCMetaV0

func (v *SCMetaV0) XdrPointer() interface{}       { return v }
func (SCMetaV0) XdrTypeName() string              { return "SCMetaV0" }
func (v SCMetaV0) XdrValue() interface{}          { return v }
func (v *SCMetaV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCMetaV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XdrString{&v.Key, 0xffffffff})
	x.Marshal(x.Sprintf("%sval", name), XdrString{&v.Val, 0xffffffff})
}
func XDR_SCMetaV0(v *SCMetaV0) *SCMetaV0 { return v }

var _XdrNames_SCMetaKind = map[int32]string{
	int32(SC_META_V0): "SC_META_V0",
}
var _XdrValues_SCMetaKind = map[string]int32{
	"SC_META_V0": int32(SC_META_V0),
}

func (SCMetaKind) XdrEnumNames() map[int32]string {
	return _XdrNames_SCMetaKind
}
func (v SCMetaKind) String() string {
	if s, ok := _XdrNames_SCMetaKind[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCMetaKind#%d", v)
}
func (v *SCMetaKind) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCMetaKind[stok]; ok {
			*v = SCMetaKind(val)
			return nil
		} else if stok == "SCMetaKind" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCMetaKind.", stok))
	}
}
func (v SCMetaKind) GetU32() uint32                 { return uint32(v) }
func (v *SCMetaKind) SetU32(n uint32)               { *v = SCMetaKind(n) }
func (v *SCMetaKind) XdrPointer() interface{}       { return v }
func (SCMetaKind) XdrTypeName() string              { return "SCMetaKind" }
func (v SCMetaKind) XdrValue() interface{}          { return v }
func (v *SCMetaKind) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCMetaKind = *SCMetaKind

func XDR_SCMetaKind(v *SCMetaKind) *SCMetaKind { return v }

var _XdrTags_SCMetaEntry = map[int32]bool{
	XdrToI32(SC_META_V0): true,
}

func (_ SCMetaEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_SCMetaEntry
}
func (u *SCMetaEntry) V0() *SCMetaV0 {
	switch u.Kind {
	case SC_META_V0:
		if v, ok := u._u.(*SCMetaV0); ok {
			return v
		} else {
			var zero SCMetaV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCMetaEntry.V0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u SCMetaEntry) XdrValid() bool {
	switch u.Kind {
	case SC_META_V0:
		return true
	}
	return false
}
func (u *SCMetaEntry) XdrUnionTag() XdrNum32 {
	return XDR_SCMetaKind(&u.Kind)
}
func (u *SCMetaEntry) XdrUnionTagName() string {
	return "Kind"
}
func (u *SCMetaEntry) XdrUnionBody() XdrType {
	switch u.Kind {
	case SC_META_V0:
		return XDR_SCMetaV0(u.V0())
	}
	return nil
}
func (u *SCMetaEntry) XdrUnionBodyName() string {
	switch u.Kind {
	case SC_META_V0:
		return "V0"
	}
	return ""
}

type XdrType_SCMetaEntry = *SCMetaEntry

func (v *SCMetaEntry) XdrPointer() interface{}       { return v }
func (SCMetaEntry) XdrTypeName() string              { return "SCMetaEntry" }
func (v SCMetaEntry) XdrValue() interface{}          { return v }
func (v *SCMetaEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCMetaEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCMetaKind(&u.Kind).XdrMarshal(x, x.Sprintf("%skind", name))
	switch u.Kind {
	case SC_META_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_SCMetaV0(u.V0()))
		return
	}
	XdrPanic("invalid Kind (%v) in SCMetaEntry", u.Kind)
}
func XDR_SCMetaEntry(v *SCMetaEntry) *SCMetaEntry { return v }

var _XdrNames_SCSpecType = map[int32]string{
	int32(SC_SPEC_TYPE_VAL):       "SC_SPEC_TYPE_VAL",
	int32(SC_SPEC_TYPE_BOOL):      "SC_SPEC_TYPE_BOOL",
	int32(SC_SPEC_TYPE_VOID):      "SC_SPEC_TYPE_VOID",
	int32(SC_SPEC_TYPE_ERROR):     "SC_SPEC_TYPE_ERROR",
	int32(SC_SPEC_TYPE_U32):       "SC_SPEC_TYPE_U32",
	int32(SC_SPEC_TYPE_I32):       "SC_SPEC_TYPE_I32",
	int32(SC_SPEC_TYPE_U64):       "SC_SPEC_TYPE_U64",
	int32(SC_SPEC_TYPE_I64):       "SC_SPEC_TYPE_I64",
	int32(SC_SPEC_TYPE_TIMEPOINT): "SC_SPEC_TYPE_TIMEPOINT",
	int32(SC_SPEC_TYPE_DURATION):  "SC_SPEC_TYPE_DURATION",
	int32(SC_SPEC_TYPE_U128):      "SC_SPEC_TYPE_U128",
	int32(SC_SPEC_TYPE_I128):      "SC_SPEC_TYPE_I128",
	int32(SC_SPEC_TYPE_U256):      "SC_SPEC_TYPE_U256",
	int32(SC_SPEC_TYPE_I256):      "SC_SPEC_TYPE_I256",
	int32(SC_SPEC_TYPE_BYTES):     "SC_SPEC_TYPE_BYTES",
	int32(SC_SPEC_TYPE_STRING):    "SC_SPEC_TYPE_STRING",
	int32(SC_SPEC_TYPE_SYMBOL):    "SC_SPEC_TYPE_SYMBOL",
	int32(SC_SPEC_TYPE_ADDRESS):   "SC_SPEC_TYPE_ADDRESS",
	int32(SC_SPEC_TYPE_OPTION):    "SC_SPEC_TYPE_OPTION",
	int32(SC_SPEC_TYPE_RESULT):    "SC_SPEC_TYPE_RESULT",
	int32(SC_SPEC_TYPE_VEC):       "SC_SPEC_TYPE_VEC",
	int32(SC_SPEC_TYPE_MAP):       "SC_SPEC_TYPE_MAP",
	int32(SC_SPEC_TYPE_TUPLE):     "SC_SPEC_TYPE_TUPLE",
	int32(SC_SPEC_TYPE_BYTES_N):   "SC_SPEC_TYPE_BYTES_N",
	int32(SC_SPEC_TYPE_HASH):      "SC_SPEC_TYPE_HASH",
	int32(SC_SPEC_TYPE_UDT):       "SC_SPEC_TYPE_UDT",
}
var _XdrValues_SCSpecType = map[string]int32{
	"SC_SPEC_TYPE_VAL":       int32(SC_SPEC_TYPE_VAL),
	"SC_SPEC_TYPE_BOOL":      int32(SC_SPEC_TYPE_BOOL),
	"SC_SPEC_TYPE_VOID":      int32(SC_SPEC_TYPE_VOID),
	"SC_SPEC_TYPE_ERROR":     int32(SC_SPEC_TYPE_ERROR),
	"SC_SPEC_TYPE_U32":       int32(SC_SPEC_TYPE_U32),
	"SC_SPEC_TYPE_I32":       int32(SC_SPEC_TYPE_I32),
	"SC_SPEC_TYPE_U64":       int32(SC_SPEC_TYPE_U64),
	"SC_SPEC_TYPE_I64":       int32(SC_SPEC_TYPE_I64),
	"SC_SPEC_TYPE_TIMEPOINT": int32(SC_SPEC_TYPE_TIMEPOINT),
	"SC_SPEC_TYPE_DURATION":  int32(SC_SPEC_TYPE_DURATION),
	"SC_SPEC_TYPE_U128":      int32(SC_SPEC_TYPE_U128),
	"SC_SPEC_TYPE_I128":      int32(SC_SPEC_TYPE_I128),
	"SC_SPEC_TYPE_U256":      int32(SC_SPEC_TYPE_U256),
	"SC_SPEC_TYPE_I256":      int32(SC_SPEC_TYPE_I256),
	"SC_SPEC_TYPE_BYTES":     int32(SC_SPEC_TYPE_BYTES),
	"SC_SPEC_TYPE_STRING":    int32(SC_SPEC_TYPE_STRING),
	"SC_SPEC_TYPE_SYMBOL":    int32(SC_SPEC_TYPE_SYMBOL),
	"SC_SPEC_TYPE_ADDRESS":   int32(SC_SPEC_TYPE_ADDRESS),
	"SC_SPEC_TYPE_OPTION":    int32(SC_SPEC_TYPE_OPTION),
	"SC_SPEC_TYPE_RESULT":    int32(SC_SPEC_TYPE_RESULT),
	"SC_SPEC_TYPE_VEC":       int32(SC_SPEC_TYPE_VEC),
	"SC_SPEC_TYPE_MAP":       int32(SC_SPEC_TYPE_MAP),
	"SC_SPEC_TYPE_TUPLE":     int32(SC_SPEC_TYPE_TUPLE),
	"SC_SPEC_TYPE_BYTES_N":   int32(SC_SPEC_TYPE_BYTES_N),
	"SC_SPEC_TYPE_HASH":      int32(SC_SPEC_TYPE_HASH),
	"SC_SPEC_TYPE_UDT":       int32(SC_SPEC_TYPE_UDT),
}

func (SCSpecType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCSpecType
}
func (v SCSpecType) String() string {
	if s, ok := _XdrNames_SCSpecType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCSpecType#%d", v)
}
func (v *SCSpecType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCSpecType[stok]; ok {
			*v = SCSpecType(val)
			return nil
		} else if stok == "SCSpecType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCSpecType.", stok))
	}
}
func (v SCSpecType) GetU32() uint32                 { return uint32(v) }
func (v *SCSpecType) SetU32(n uint32)               { *v = SCSpecType(n) }
func (v *SCSpecType) XdrPointer() interface{}       { return v }
func (SCSpecType) XdrTypeName() string              { return "SCSpecType" }
func (v SCSpecType) XdrValue() interface{}          { return v }
func (v *SCSpecType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecType = *SCSpecType

func XDR_SCSpecType(v *SCSpecType) *SCSpecType { return v }

var _XdrComments_SCSpecType = map[int32]string{
	int32(SC_SPEC_TYPE_BOOL):   "Types with no parameters.",
	int32(SC_SPEC_TYPE_OPTION): "Types with parameters.",
	int32(SC_SPEC_TYPE_UDT):    "User defined types.",
}

func (e SCSpecType) XdrEnumComments() map[int32]string {
	return _XdrComments_SCSpecType
}

type XdrType_SCSpecTypeOption = *SCSpecTypeOption

func (v *SCSpecTypeOption) XdrPointer() interface{}       { return v }
func (SCSpecTypeOption) XdrTypeName() string              { return "SCSpecTypeOption" }
func (v SCSpecTypeOption) XdrValue() interface{}          { return v }
func (v *SCSpecTypeOption) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeOption) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%svalueType", name), XDR_SCSpecTypeDef(&v.ValueType))
}
func XDR_SCSpecTypeOption(v *SCSpecTypeOption) *SCSpecTypeOption { return v }

type XdrType_SCSpecTypeResult = *SCSpecTypeResult

func (v *SCSpecTypeResult) XdrPointer() interface{}       { return v }
func (SCSpecTypeResult) XdrTypeName() string              { return "SCSpecTypeResult" }
func (v SCSpecTypeResult) XdrValue() interface{}          { return v }
func (v *SCSpecTypeResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sokType", name), XDR_SCSpecTypeDef(&v.OkType))
	x.Marshal(x.Sprintf("%serrorType", name), XDR_SCSpecTypeDef(&v.ErrorType))
}
func XDR_SCSpecTypeResult(v *SCSpecTypeResult) *SCSpecTypeResult { return v }

type XdrType_SCSpecTypeVec = *SCSpecTypeVec

func (v *SCSpecTypeVec) XdrPointer() interface{}       { return v }
func (SCSpecTypeVec) XdrTypeName() string              { return "SCSpecTypeVec" }
func (v SCSpecTypeVec) XdrValue() interface{}          { return v }
func (v *SCSpecTypeVec) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeVec) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%selementType", name), XDR_SCSpecTypeDef(&v.ElementType))
}
func XDR_SCSpecTypeVec(v *SCSpecTypeVec) *SCSpecTypeVec { return v }

type XdrType_SCSpecTypeMap = *SCSpecTypeMap

func (v *SCSpecTypeMap) XdrPointer() interface{}       { return v }
func (SCSpecTypeMap) XdrTypeName() string              { return "SCSpecTypeMap" }
func (v SCSpecTypeMap) XdrValue() interface{}          { return v }
func (v *SCSpecTypeMap) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeMap) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skeyType", name), XDR_SCSpecTypeDef(&v.KeyType))
	x.Marshal(x.Sprintf("%svalueType", name), XDR_SCSpecTypeDef(&v.ValueType))
}
func XDR_SCSpecTypeMap(v *SCSpecTypeMap) *SCSpecTypeMap { return v }

type _XdrVec_12_SCSpecTypeDef []SCSpecTypeDef

func (_XdrVec_12_SCSpecTypeDef) XdrBound() uint32 {
	const bound uint32 = 12 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_12_SCSpecTypeDef) XdrCheckLen(length uint32) {
	if length > uint32(12) {
		XdrPanic("_XdrVec_12_SCSpecTypeDef length %d exceeds bound 12", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_12_SCSpecTypeDef length %d exceeds max int", length)
	}
}
func (v _XdrVec_12_SCSpecTypeDef) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_12_SCSpecTypeDef) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(12); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecTypeDef, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_12_SCSpecTypeDef) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecTypeDef(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_12_SCSpecTypeDef) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 12}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_12_SCSpecTypeDef) XdrTypeName() string              { return "SCSpecTypeDef<>" }
func (v *_XdrVec_12_SCSpecTypeDef) XdrPointer() interface{}       { return (*[]SCSpecTypeDef)(v) }
func (v _XdrVec_12_SCSpecTypeDef) XdrValue() interface{}          { return ([]SCSpecTypeDef)(v) }
func (v *_XdrVec_12_SCSpecTypeDef) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecTypeTuple = *SCSpecTypeTuple

func (v *SCSpecTypeTuple) XdrPointer() interface{}       { return v }
func (SCSpecTypeTuple) XdrTypeName() string              { return "SCSpecTypeTuple" }
func (v SCSpecTypeTuple) XdrValue() interface{}          { return v }
func (v *SCSpecTypeTuple) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeTuple) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%svalueTypes", name), (*_XdrVec_12_SCSpecTypeDef)(&v.ValueTypes))
}
func XDR_SCSpecTypeTuple(v *SCSpecTypeTuple) *SCSpecTypeTuple { return v }

type XdrType_SCSpecTypeBytesN = *SCSpecTypeBytesN

func (v *SCSpecTypeBytesN) XdrPointer() interface{}       { return v }
func (SCSpecTypeBytesN) XdrTypeName() string              { return "SCSpecTypeBytesN" }
func (v SCSpecTypeBytesN) XdrValue() interface{}          { return v }
func (v *SCSpecTypeBytesN) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeBytesN) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sn", name), XDR_Uint32(&v.N))
}
func XDR_SCSpecTypeBytesN(v *SCSpecTypeBytesN) *SCSpecTypeBytesN { return v }

type XdrType_SCSpectTypeHash = *SCSpectTypeHash

func (v *SCSpectTypeHash) XdrPointer() interface{}       { return v }
func (SCSpectTypeHash) XdrTypeName() string              { return "SCSpectTypeHash" }
func (v SCSpectTypeHash) XdrValue() interface{}          { return v }
func (v *SCSpectTypeHash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpectTypeHash) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sn", name), XDR_Uint32(&v.N))
}
func XDR_SCSpectTypeHash(v *SCSpectTypeHash) *SCSpectTypeHash { return v }

type XdrType_SCSpecTypeUDT = *SCSpecTypeUDT

func (v *SCSpecTypeUDT) XdrPointer() interface{}       { return v }
func (SCSpecTypeUDT) XdrTypeName() string              { return "SCSpecTypeUDT" }
func (v SCSpecTypeUDT) XdrValue() interface{}          { return v }
func (v *SCSpecTypeUDT) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeUDT) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
}
func XDR_SCSpecTypeUDT(v *SCSpecTypeUDT) *SCSpecTypeUDT { return v }

var _XdrTags_SCSpecTypeDef = map[int32]bool{
	XdrToI32(SC_SPEC_TYPE_VAL):       true,
	XdrToI32(SC_SPEC_TYPE_BOOL):      true,
	XdrToI32(SC_SPEC_TYPE_VOID):      true,
	XdrToI32(SC_SPEC_TYPE_ERROR):     true,
	XdrToI32(SC_SPEC_TYPE_U32):       true,
	XdrToI32(SC_SPEC_TYPE_I32):       true,
	XdrToI32(SC_SPEC_TYPE_U64):       true,
	XdrToI32(SC_SPEC_TYPE_I64):       true,
	XdrToI32(SC_SPEC_TYPE_TIMEPOINT): true,
	XdrToI32(SC_SPEC_TYPE_DURATION):  true,
	XdrToI32(SC_SPEC_TYPE_U128):      true,
	XdrToI32(SC_SPEC_TYPE_I128):      true,
	XdrToI32(SC_SPEC_TYPE_U256):      true,
	XdrToI32(SC_SPEC_TYPE_I256):      true,
	XdrToI32(SC_SPEC_TYPE_BYTES):     true,
	XdrToI32(SC_SPEC_TYPE_STRING):    true,
	XdrToI32(SC_SPEC_TYPE_SYMBOL):    true,
	XdrToI32(SC_SPEC_TYPE_ADDRESS):   true,
	XdrToI32(SC_SPEC_TYPE_OPTION):    true,
	XdrToI32(SC_SPEC_TYPE_RESULT):    true,
	XdrToI32(SC_SPEC_TYPE_VEC):       true,
	XdrToI32(SC_SPEC_TYPE_MAP):       true,
	XdrToI32(SC_SPEC_TYPE_TUPLE):     true,
	XdrToI32(SC_SPEC_TYPE_BYTES_N):   true,
	XdrToI32(SC_SPEC_TYPE_HASH):      true,
	XdrToI32(SC_SPEC_TYPE_UDT):       true,
}

func (_ SCSpecTypeDef) XdrValidTags() map[int32]bool {
	return _XdrTags_SCSpecTypeDef
}
func (u *SCSpecTypeDef) Option() *SCSpecTypeOption {
	switch u.Type {
	case SC_SPEC_TYPE_OPTION:
		if v, ok := u._u.(*SCSpecTypeOption); ok {
			return v
		} else {
			var zero SCSpecTypeOption
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Option accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Result() *SCSpecTypeResult {
	switch u.Type {
	case SC_SPEC_TYPE_RESULT:
		if v, ok := u._u.(*SCSpecTypeResult); ok {
			return v
		} else {
			var zero SCSpecTypeResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Result accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Vec() *SCSpecTypeVec {
	switch u.Type {
	case SC_SPEC_TYPE_VEC:
		if v, ok := u._u.(*SCSpecTypeVec); ok {
			return v
		} else {
			var zero SCSpecTypeVec
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Vec accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Map() *SCSpecTypeMap {
	switch u.Type {
	case SC_SPEC_TYPE_MAP:
		if v, ok := u._u.(*SCSpecTypeMap); ok {
			return v
		} else {
			var zero SCSpecTypeMap
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Map accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Tuple() *SCSpecTypeTuple {
	switch u.Type {
	case SC_SPEC_TYPE_TUPLE:
		if v, ok := u._u.(*SCSpecTypeTuple); ok {
			return v
		} else {
			var zero SCSpecTypeTuple
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Tuple accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) BytesN() *SCSpecTypeBytesN {
	switch u.Type {
	case SC_SPEC_TYPE_BYTES_N:
		if v, ok := u._u.(*SCSpecTypeBytesN); ok {
			return v
		} else {
			var zero SCSpecTypeBytesN
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.BytesN accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Hash() *SCSpectTypeHash {
	switch u.Type {
	case SC_SPEC_TYPE_HASH:
		if v, ok := u._u.(*SCSpectTypeHash); ok {
			return v
		} else {
			var zero SCSpectTypeHash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Hash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Udt() *SCSpecTypeUDT {
	switch u.Type {
	case SC_SPEC_TYPE_UDT:
		if v, ok := u._u.(*SCSpecTypeUDT); ok {
			return v
		} else {
			var zero SCSpecTypeUDT
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Udt accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCSpecTypeDef) XdrValid() bool {
	switch u.Type {
	case SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_VOID, SC_SPEC_TYPE_ERROR, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_TIMEPOINT, SC_SPEC_TYPE_DURATION, SC_SPEC_TYPE_U128, SC_SPEC_TYPE_I128, SC_SPEC_TYPE_U256, SC_SPEC_TYPE_I256, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_STRING, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_ADDRESS, SC_SPEC_TYPE_OPTION, SC_SPEC_TYPE_RESULT, SC_SPEC_TYPE_VEC, SC_SPEC_TYPE_MAP, SC_SPEC_TYPE_TUPLE, SC_SPEC_TYPE_BYTES_N, SC_SPEC_TYPE_HASH, SC_SPEC_TYPE_UDT:
		return true
	}
	return false
}
func (u *SCSpecTypeDef) XdrUnionTag() XdrNum32 {
	return XDR_SCSpecType(&u.Type)
}
func (u *SCSpecTypeDef) XdrUnionTagName() string {
	return "Type"
}
func (u *SCSpecTypeDef) XdrUnionBody() XdrType {
	switch u.Type {
	case SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_VOID, SC_SPEC_TYPE_ERROR, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_TIMEPOINT, SC_SPEC_TYPE_DURATION, SC_SPEC_TYPE_U128, SC_SPEC_TYPE_I128, SC_SPEC_TYPE_U256, SC_SPEC_TYPE_I256, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_STRING, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_ADDRESS:
		return nil
	case SC_SPEC_TYPE_OPTION:
		return XDR_SCSpecTypeOption(u.Option())
	case SC_SPEC_TYPE_RESULT:
		return XDR_SCSpecTypeResult(u.Result())
	case SC_SPEC_TYPE_VEC:
		return XDR_SCSpecTypeVec(u.Vec())
	case SC_SPEC_TYPE_MAP:
		return XDR_SCSpecTypeMap(u.Map())
	case SC_SPEC_TYPE_TUPLE:
		return XDR_SCSpecTypeTuple(u.Tuple())
	case SC_SPEC_TYPE_BYTES_N:
		return XDR_SCSpecTypeBytesN(u.BytesN())
	case SC_SPEC_TYPE_HASH:
		return XDR_SCSpectTypeHash(u.Hash())
	case SC_SPEC_TYPE_UDT:
		return XDR_SCSpecTypeUDT(u.Udt())
	}
	return nil
}
func (u *SCSpecTypeDef) XdrUnionBodyName() string {
	switch u.Type {
	case SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_VOID, SC_SPEC_TYPE_ERROR, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_TIMEPOINT, SC_SPEC_TYPE_DURATION, SC_SPEC_TYPE_U128, SC_SPEC_TYPE_I128, SC_SPEC_TYPE_U256, SC_SPEC_TYPE_I256, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_STRING, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_ADDRESS:
		return ""
	case SC_SPEC_TYPE_OPTION:
		return "Option"
	case SC_SPEC_TYPE_RESULT:
		return "Result"
	case SC_SPEC_TYPE_VEC:
		return "Vec"
	case SC_SPEC_TYPE_MAP:
		return "Map"
	case SC_SPEC_TYPE_TUPLE:
		return "Tuple"
	case SC_SPEC_TYPE_BYTES_N:
		return "BytesN"
	case SC_SPEC_TYPE_HASH:
		return "Hash"
	case SC_SPEC_TYPE_UDT:
		return "Udt"
	}
	return ""
}

type XdrType_SCSpecTypeDef = *SCSpecTypeDef

func (v *SCSpecTypeDef) XdrPointer() interface{}       { return v }
func (SCSpecTypeDef) XdrTypeName() string              { return "SCSpecTypeDef" }
func (v SCSpecTypeDef) XdrValue() interface{}          { return v }
func (v *SCSpecTypeDef) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCSpecTypeDef) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCSpecType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_VOID, SC_SPEC_TYPE_ERROR, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_TIMEPOINT, SC_SPEC_TYPE_DURATION, SC_SPEC_TYPE_U128, SC_SPEC_TYPE_I128, SC_SPEC_TYPE_U256, SC_SPEC_TYPE_I256, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_STRING, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_ADDRESS:
		return
	case SC_SPEC_TYPE_OPTION:
		x.Marshal(x.Sprintf("%soption", name), XDR_SCSpecTypeOption(u.Option()))
		return
	case SC_SPEC_TYPE_RESULT:
		x.Marshal(x.Sprintf("%sresult", name), XDR_SCSpecTypeResult(u.Result()))
		return
	case SC_SPEC_TYPE_VEC:
		x.Marshal(x.Sprintf("%svec", name), XDR_SCSpecTypeVec(u.Vec()))
		return
	case SC_SPEC_TYPE_MAP:
		x.Marshal(x.Sprintf("%smap", name), XDR_SCSpecTypeMap(u.Map()))
		return
	case SC_SPEC_TYPE_TUPLE:
		x.Marshal(x.Sprintf("%stuple", name), XDR_SCSpecTypeTuple(u.Tuple()))
		return
	case SC_SPEC_TYPE_BYTES_N:
		x.Marshal(x.Sprintf("%sbytesN", name), XDR_SCSpecTypeBytesN(u.BytesN()))
		return
	case SC_SPEC_TYPE_HASH:
		x.Marshal(x.Sprintf("%shash", name), XDR_SCSpectTypeHash(u.Hash()))
		return
	case SC_SPEC_TYPE_UDT:
		x.Marshal(x.Sprintf("%sudt", name), XDR_SCSpecTypeUDT(u.Udt()))
		return
	}
	XdrPanic("invalid Type (%v) in SCSpecTypeDef", u.Type)
}
func XDR_SCSpecTypeDef(v *SCSpecTypeDef) *SCSpecTypeDef { return v }

type XdrType_SCSpecUDTStructFieldV0 = *SCSpecUDTStructFieldV0

func (v *SCSpecUDTStructFieldV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTStructFieldV0) XdrTypeName() string              { return "SCSpecUDTStructFieldV0" }
func (v SCSpecUDTStructFieldV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTStructFieldV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTStructFieldV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 30})
	x.Marshal(x.Sprintf("%stype", name), XDR_SCSpecTypeDef(&v.Type))
}
func XDR_SCSpecUDTStructFieldV0(v *SCSpecUDTStructFieldV0) *SCSpecUDTStructFieldV0 { return v }

type _XdrVec_40_SCSpecUDTStructFieldV0 []SCSpecUDTStructFieldV0

func (_XdrVec_40_SCSpecUDTStructFieldV0) XdrBound() uint32 {
	const bound uint32 = 40 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_40_SCSpecUDTStructFieldV0) XdrCheckLen(length uint32) {
	if length > uint32(40) {
		XdrPanic("_XdrVec_40_SCSpecUDTStructFieldV0 length %d exceeds bound 40", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_40_SCSpecUDTStructFieldV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_40_SCSpecUDTStructFieldV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(40); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecUDTStructFieldV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecUDTStructFieldV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 40}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_40_SCSpecUDTStructFieldV0) XdrTypeName() string { return "SCSpecUDTStructFieldV0<>" }
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) XdrPointer() interface{} {
	return (*[]SCSpecUDTStructFieldV0)(v)
}
func (v _XdrVec_40_SCSpecUDTStructFieldV0) XdrValue() interface{} {
	return ([]SCSpecUDTStructFieldV0)(v)
}
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTStructV0 = *SCSpecUDTStructV0

func (v *SCSpecUDTStructV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTStructV0) XdrTypeName() string              { return "SCSpecUDTStructV0" }
func (v SCSpecUDTStructV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTStructV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTStructV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%slib", name), XdrString{&v.Lib, 80})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%sfields", name), (*_XdrVec_40_SCSpecUDTStructFieldV0)(&v.Fields))
}
func XDR_SCSpecUDTStructV0(v *SCSpecUDTStructV0) *SCSpecUDTStructV0 { return v }

type XdrType_SCSpecUDTUnionCaseVoidV0 = *SCSpecUDTUnionCaseVoidV0

func (v *SCSpecUDTUnionCaseVoidV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTUnionCaseVoidV0) XdrTypeName() string              { return "SCSpecUDTUnionCaseVoidV0" }
func (v SCSpecUDTUnionCaseVoidV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTUnionCaseVoidV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTUnionCaseVoidV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
}
func XDR_SCSpecUDTUnionCaseVoidV0(v *SCSpecUDTUnionCaseVoidV0) *SCSpecUDTUnionCaseVoidV0 { return v }

type XdrType_SCSpecUDTUnionCaseTupleV0 = *SCSpecUDTUnionCaseTupleV0

func (v *SCSpecUDTUnionCaseTupleV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTUnionCaseTupleV0) XdrTypeName() string              { return "SCSpecUDTUnionCaseTupleV0" }
func (v SCSpecUDTUnionCaseTupleV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTUnionCaseTupleV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTUnionCaseTupleV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%stype", name), (*_XdrVec_12_SCSpecTypeDef)(&v.Type))
}
func XDR_SCSpecUDTUnionCaseTupleV0(v *SCSpecUDTUnionCaseTupleV0) *SCSpecUDTUnionCaseTupleV0 { return v }

var _XdrNames_SCSpecUDTUnionCaseV0Kind = map[int32]string{
	int32(SC_SPEC_UDT_UNION_CASE_VOID_V0):  "SC_SPEC_UDT_UNION_CASE_VOID_V0",
	int32(SC_SPEC_UDT_UNION_CASE_TUPLE_V0): "SC_SPEC_UDT_UNION_CASE_TUPLE_V0",
}
var _XdrValues_SCSpecUDTUnionCaseV0Kind = map[string]int32{
	"SC_SPEC_UDT_UNION_CASE_VOID_V0":  int32(SC_SPEC_UDT_UNION_CASE_VOID_V0),
	"SC_SPEC_UDT_UNION_CASE_TUPLE_V0": int32(SC_SPEC_UDT_UNION_CASE_TUPLE_V0),
}

func (SCSpecUDTUnionCaseV0Kind) XdrEnumNames() map[int32]string {
	return _XdrNames_SCSpecUDTUnionCaseV0Kind
}
func (v SCSpecUDTUnionCaseV0Kind) String() string {
	if s, ok := _XdrNames_SCSpecUDTUnionCaseV0Kind[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCSpecUDTUnionCaseV0Kind#%d", v)
}
func (v *SCSpecUDTUnionCaseV0Kind) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCSpecUDTUnionCaseV0Kind[stok]; ok {
			*v = SCSpecUDTUnionCaseV0Kind(val)
			return nil
		} else if stok == "SCSpecUDTUnionCaseV0Kind" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCSpecUDTUnionCaseV0Kind.", stok))
	}
}
func (v SCSpecUDTUnionCaseV0Kind) GetU32() uint32                 { return uint32(v) }
func (v *SCSpecUDTUnionCaseV0Kind) SetU32(n uint32)               { *v = SCSpecUDTUnionCaseV0Kind(n) }
func (v *SCSpecUDTUnionCaseV0Kind) XdrPointer() interface{}       { return v }
func (SCSpecUDTUnionCaseV0Kind) XdrTypeName() string              { return "SCSpecUDTUnionCaseV0Kind" }
func (v SCSpecUDTUnionCaseV0Kind) XdrValue() interface{}          { return v }
func (v *SCSpecUDTUnionCaseV0Kind) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTUnionCaseV0Kind = *SCSpecUDTUnionCaseV0Kind

func XDR_SCSpecUDTUnionCaseV0Kind(v *SCSpecUDTUnionCaseV0Kind) *SCSpecUDTUnionCaseV0Kind { return v }

var _XdrTags_SCSpecUDTUnionCaseV0 = map[int32]bool{
	XdrToI32(SC_SPEC_UDT_UNION_CASE_VOID_V0):  true,
	XdrToI32(SC_SPEC_UDT_UNION_CASE_TUPLE_V0): true,
}

func (_ SCSpecUDTUnionCaseV0) XdrValidTags() map[int32]bool {
	return _XdrTags_SCSpecUDTUnionCaseV0
}
func (u *SCSpecUDTUnionCaseV0) VoidCase() *SCSpecUDTUnionCaseVoidV0 {
	switch u.Kind {
	case SC_SPEC_UDT_UNION_CASE_VOID_V0:
		if v, ok := u._u.(*SCSpecUDTUnionCaseVoidV0); ok {
			return v
		} else {
			var zero SCSpecUDTUnionCaseVoidV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecUDTUnionCaseV0.VoidCase accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecUDTUnionCaseV0) TupleCase() *SCSpecUDTUnionCaseTupleV0 {
	switch u.Kind {
	case SC_SPEC_UDT_UNION_CASE_TUPLE_V0:
		if v, ok := u._u.(*SCSpecUDTUnionCaseTupleV0); ok {
			return v
		} else {
			var zero SCSpecUDTUnionCaseTupleV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecUDTUnionCaseV0.TupleCase accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u SCSpecUDTUnionCaseV0) XdrValid() bool {
	switch u.Kind {
	case SC_SPEC_UDT_UNION_CASE_VOID_V0, SC_SPEC_UDT_UNION_CASE_TUPLE_V0:
		return true
	}
	return false
}
func (u *SCSpecUDTUnionCaseV0) XdrUnionTag() XdrNum32 {
	return XDR_SCSpecUDTUnionCaseV0Kind(&u.Kind)
}
func (u *SCSpecUDTUnionCaseV0) XdrUnionTagName() string {
	return "Kind"
}
func (u *SCSpecUDTUnionCaseV0) XdrUnionBody() XdrType {
	switch u.Kind {
	case SC_SPEC_UDT_UNION_CASE_VOID_V0:
		return XDR_SCSpecUDTUnionCaseVoidV0(u.VoidCase())
	case SC_SPEC_UDT_UNION_CASE_TUPLE_V0:
		return XDR_SCSpecUDTUnionCaseTupleV0(u.TupleCase())
	}
	return nil
}
func (u *SCSpecUDTUnionCaseV0) XdrUnionBodyName() string {
	switch u.Kind {
	case SC_SPEC_UDT_UNION_CASE_VOID_V0:
		return "VoidCase"
	case SC_SPEC_UDT_UNION_CASE_TUPLE_V0:
		return "TupleCase"
	}
	return ""
}

type XdrType_SCSpecUDTUnionCaseV0 = *SCSpecUDTUnionCaseV0

func (v *SCSpecUDTUnionCaseV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTUnionCaseV0) XdrTypeName() string              { return "SCSpecUDTUnionCaseV0" }
func (v SCSpecUDTUnionCaseV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTUnionCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCSpecUDTUnionCaseV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCSpecUDTUnionCaseV0Kind(&u.Kind).XdrMarshal(x, x.Sprintf("%skind", name))
	switch u.Kind {
	case SC_SPEC_UDT_UNION_CASE_VOID_V0:
		x.Marshal(x.Sprintf("%svoidCase", name), XDR_SCSpecUDTUnionCaseVoidV0(u.VoidCase()))
		return
	case SC_SPEC_UDT_UNION_CASE_TUPLE_V0:
		x.Marshal(x.Sprintf("%stupleCase", name), XDR_SCSpecUDTUnionCaseTupleV0(u.TupleCase()))
		return
	}
	XdrPanic("invalid Kind (%v) in SCSpecUDTUnionCaseV0", u.Kind)
}
func XDR_SCSpecUDTUnionCaseV0(v *SCSpecUDTUnionCaseV0) *SCSpecUDTUnionCaseV0 { return v }

type _XdrVec_50_SCSpecUDTUnionCaseV0 []SCSpecUDTUnionCaseV0

func (_XdrVec_50_SCSpecUDTUnionCaseV0) XdrBound() uint32 {
	const bound uint32 = 50 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_50_SCSpecUDTUnionCaseV0) XdrCheckLen(length uint32) {
	if length > uint32(50) {
		XdrPanic("_XdrVec_50_SCSpecUDTUnionCaseV0 length %d exceeds bound 50", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_50_SCSpecUDTUnionCaseV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_50_SCSpecUDTUnionCaseV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(50); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecUDTUnionCaseV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecUDTUnionCaseV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 50}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_50_SCSpecUDTUnionCaseV0) XdrTypeName() string { return "SCSpecUDTUnionCaseV0<>" }
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) XdrPointer() interface{} {
	return (*[]SCSpecUDTUnionCaseV0)(v)
}
func (v _XdrVec_50_SCSpecUDTUnionCaseV0) XdrValue() interface{}          { return ([]SCSpecUDTUnionCaseV0)(v) }
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTUnionV0 = *SCSpecUDTUnionV0

func (v *SCSpecUDTUnionV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTUnionV0) XdrTypeName() string              { return "SCSpecUDTUnionV0" }
func (v SCSpecUDTUnionV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTUnionV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTUnionV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%slib", name), XdrString{&v.Lib, 80})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%scases", name), (*_XdrVec_50_SCSpecUDTUnionCaseV0)(&v.Cases))
}
func XDR_SCSpecUDTUnionV0(v *SCSpecUDTUnionV0) *SCSpecUDTUnionV0 { return v }

type XdrType_SCSpecUDTEnumCaseV0 = *SCSpecUDTEnumCaseV0

func (v *SCSpecUDTEnumCaseV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTEnumCaseV0) XdrTypeName() string              { return "SCSpecUDTEnumCaseV0" }
func (v SCSpecUDTEnumCaseV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTEnumCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTEnumCaseV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%svalue", name), XDR_Uint32(&v.Value))
}
func XDR_SCSpecUDTEnumCaseV0(v *SCSpecUDTEnumCaseV0) *SCSpecUDTEnumCaseV0 { return v }

type _XdrVec_50_SCSpecUDTEnumCaseV0 []SCSpecUDTEnumCaseV0

func (_XdrVec_50_SCSpecUDTEnumCaseV0) XdrBound() uint32 {
	const bound uint32 = 50 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_50_SCSpecUDTEnumCaseV0) XdrCheckLen(length uint32) {
	if length > uint32(50) {
		XdrPanic("_XdrVec_50_SCSpecUDTEnumCaseV0 length %d exceeds bound 50", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_50_SCSpecUDTEnumCaseV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_50_SCSpecUDTEnumCaseV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(50); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecUDTEnumCaseV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecUDTEnumCaseV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 50}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_50_SCSpecUDTEnumCaseV0) XdrTypeName() string              { return "SCSpecUDTEnumCaseV0<>" }
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) XdrPointer() interface{}       { return (*[]SCSpecUDTEnumCaseV0)(v) }
func (v _XdrVec_50_SCSpecUDTEnumCaseV0) XdrValue() interface{}          { return ([]SCSpecUDTEnumCaseV0)(v) }
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTEnumV0 = *SCSpecUDTEnumV0

func (v *SCSpecUDTEnumV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTEnumV0) XdrTypeName() string              { return "SCSpecUDTEnumV0" }
func (v SCSpecUDTEnumV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTEnumV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTEnumV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%slib", name), XdrString{&v.Lib, 80})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%scases", name), (*_XdrVec_50_SCSpecUDTEnumCaseV0)(&v.Cases))
}
func XDR_SCSpecUDTEnumV0(v *SCSpecUDTEnumV0) *SCSpecUDTEnumV0 { return v }

type XdrType_SCSpecUDTErrorEnumCaseV0 = *SCSpecUDTErrorEnumCaseV0

func (v *SCSpecUDTErrorEnumCaseV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTErrorEnumCaseV0) XdrTypeName() string              { return "SCSpecUDTErrorEnumCaseV0" }
func (v SCSpecUDTErrorEnumCaseV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTErrorEnumCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTErrorEnumCaseV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%svalue", name), XDR_Uint32(&v.Value))
}
func XDR_SCSpecUDTErrorEnumCaseV0(v *SCSpecUDTErrorEnumCaseV0) *SCSpecUDTErrorEnumCaseV0 { return v }

type _XdrVec_50_SCSpecUDTErrorEnumCaseV0 []SCSpecUDTErrorEnumCaseV0

func (_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrBound() uint32 {
	const bound uint32 = 50 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrCheckLen(length uint32) {
	if length > uint32(50) {
		XdrPanic("_XdrVec_50_SCSpecUDTErrorEnumCaseV0 length %d exceeds bound 50", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_50_SCSpecUDTErrorEnumCaseV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_50_SCSpecUDTErrorEnumCaseV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(50); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecUDTErrorEnumCaseV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecUDTErrorEnumCaseV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 50}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrTypeName() string { return "SCSpecUDTErrorEnumCaseV0<>" }
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrPointer() interface{} {
	return (*[]SCSpecUDTErrorEnumCaseV0)(v)
}
func (v _XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrValue() interface{} {
	return ([]SCSpecUDTErrorEnumCaseV0)(v)
}
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTErrorEnumV0 = *SCSpecUDTErrorEnumV0

func (v *SCSpecUDTErrorEnumV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTErrorEnumV0) XdrTypeName() string              { return "SCSpecUDTErrorEnumV0" }
func (v SCSpecUDTErrorEnumV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTErrorEnumV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTErrorEnumV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%slib", name), XdrString{&v.Lib, 80})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%scases", name), (*_XdrVec_50_SCSpecUDTErrorEnumCaseV0)(&v.Cases))
}
func XDR_SCSpecUDTErrorEnumV0(v *SCSpecUDTErrorEnumV0) *SCSpecUDTErrorEnumV0 { return v }

type XdrType_SCSpecFunctionInputV0 = *SCSpecFunctionInputV0

func (v *SCSpecFunctionInputV0) XdrPointer() interface{}       { return v }
func (SCSpecFunctionInputV0) XdrTypeName() string              { return "SCSpecFunctionInputV0" }
func (v SCSpecFunctionInputV0) XdrValue() interface{}          { return v }
func (v *SCSpecFunctionInputV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecFunctionInputV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 30})
	x.Marshal(x.Sprintf("%stype", name), XDR_SCSpecTypeDef(&v.Type))
}
func XDR_SCSpecFunctionInputV0(v *SCSpecFunctionInputV0) *SCSpecFunctionInputV0 { return v }

type _XdrVec_10_SCSpecFunctionInputV0 []SCSpecFunctionInputV0

func (_XdrVec_10_SCSpecFunctionInputV0) XdrBound() uint32 {
	const bound uint32 = 10 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_10_SCSpecFunctionInputV0) XdrCheckLen(length uint32) {
	if length > uint32(10) {
		XdrPanic("_XdrVec_10_SCSpecFunctionInputV0 length %d exceeds bound 10", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_10_SCSpecFunctionInputV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_10_SCSpecFunctionInputV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_10_SCSpecFunctionInputV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(10); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecFunctionInputV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_10_SCSpecFunctionInputV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecFunctionInputV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_10_SCSpecFunctionInputV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 10}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_10_SCSpecFunctionInputV0) XdrTypeName() string { return "SCSpecFunctionInputV0<>" }
func (v *_XdrVec_10_SCSpecFunctionInputV0) XdrPointer() interface{} {
	return (*[]SCSpecFunctionInputV0)(v)
}
func (v _XdrVec_10_SCSpecFunctionInputV0) XdrValue() interface{}          { return ([]SCSpecFunctionInputV0)(v) }
func (v *_XdrVec_10_SCSpecFunctionInputV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_1_SCSpecTypeDef []SCSpecTypeDef

func (_XdrVec_1_SCSpecTypeDef) XdrBound() uint32 {
	const bound uint32 = 1 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_1_SCSpecTypeDef) XdrCheckLen(length uint32) {
	if length > uint32(1) {
		XdrPanic("_XdrVec_1_SCSpecTypeDef length %d exceeds bound 1", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_1_SCSpecTypeDef length %d exceeds max int", length)
	}
}
func (v _XdrVec_1_SCSpecTypeDef) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_1_SCSpecTypeDef) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(1); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecTypeDef, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_1_SCSpecTypeDef) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecTypeDef(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_1_SCSpecTypeDef) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 1}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_1_SCSpecTypeDef) XdrTypeName() string              { return "SCSpecTypeDef<>" }
func (v *_XdrVec_1_SCSpecTypeDef) XdrPointer() interface{}       { return (*[]SCSpecTypeDef)(v) }
func (v _XdrVec_1_SCSpecTypeDef) XdrValue() interface{}          { return ([]SCSpecTypeDef)(v) }
func (v *_XdrVec_1_SCSpecTypeDef) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecFunctionV0 = *SCSpecFunctionV0

func (v *SCSpecFunctionV0) XdrPointer() interface{}       { return v }
func (SCSpecFunctionV0) XdrTypeName() string              { return "SCSpecFunctionV0" }
func (v SCSpecFunctionV0) XdrValue() interface{}          { return v }
func (v *SCSpecFunctionV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecFunctionV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdoc", name), XdrString{&v.Doc, SC_SPEC_DOC_LIMIT})
	x.Marshal(x.Sprintf("%sname", name), XDR_SCSymbol(&v.Name))
	x.Marshal(x.Sprintf("%sinputs", name), (*_XdrVec_10_SCSpecFunctionInputV0)(&v.Inputs))
	x.Marshal(x.Sprintf("%soutputs", name), (*_XdrVec_1_SCSpecTypeDef)(&v.Outputs))
}
func XDR_SCSpecFunctionV0(v *SCSpecFunctionV0) *SCSpecFunctionV0 { return v }

var _XdrNames_SCSpecEntryKind = map[int32]string{
	int32(SC_SPEC_ENTRY_FUNCTION_V0):       "SC_SPEC_ENTRY_FUNCTION_V0",
	int32(SC_SPEC_ENTRY_UDT_STRUCT_V0):     "SC_SPEC_ENTRY_UDT_STRUCT_V0",
	int32(SC_SPEC_ENTRY_UDT_UNION_V0):      "SC_SPEC_ENTRY_UDT_UNION_V0",
	int32(SC_SPEC_ENTRY_UDT_ENUM_V0):       "SC_SPEC_ENTRY_UDT_ENUM_V0",
	int32(SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0): "SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0",
}
var _XdrValues_SCSpecEntryKind = map[string]int32{
	"SC_SPEC_ENTRY_FUNCTION_V0":       int32(SC_SPEC_ENTRY_FUNCTION_V0),
	"SC_SPEC_ENTRY_UDT_STRUCT_V0":     int32(SC_SPEC_ENTRY_UDT_STRUCT_V0),
	"SC_SPEC_ENTRY_UDT_UNION_V0":      int32(SC_SPEC_ENTRY_UDT_UNION_V0),
	"SC_SPEC_ENTRY_UDT_ENUM_V0":       int32(SC_SPEC_ENTRY_UDT_ENUM_V0),
	"SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0": int32(SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0),
}

func (SCSpecEntryKind) XdrEnumNames() map[int32]string {
	return _XdrNames_SCSpecEntryKind
}
func (v SCSpecEntryKind) String() string {
	if s, ok := _XdrNames_SCSpecEntryKind[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCSpecEntryKind#%d", v)
}
func (v *SCSpecEntryKind) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCSpecEntryKind[stok]; ok {
			*v = SCSpecEntryKind(val)
			return nil
		} else if stok == "SCSpecEntryKind" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCSpecEntryKind.", stok))
	}
}
func (v SCSpecEntryKind) GetU32() uint32                 { return uint32(v) }
func (v *SCSpecEntryKind) SetU32(n uint32)               { *v = SCSpecEntryKind(n) }
func (v *SCSpecEntryKind) XdrPointer() interface{}       { return v }
func (SCSpecEntryKind) XdrTypeName() string              { return "SCSpecEntryKind" }
func (v SCSpecEntryKind) XdrValue() interface{}          { return v }
func (v *SCSpecEntryKind) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecEntryKind = *SCSpecEntryKind

func XDR_SCSpecEntryKind(v *SCSpecEntryKind) *SCSpecEntryKind { return v }

var _XdrTags_SCSpecEntry = map[int32]bool{
	XdrToI32(SC_SPEC_ENTRY_FUNCTION_V0):       true,
	XdrToI32(SC_SPEC_ENTRY_UDT_STRUCT_V0):     true,
	XdrToI32(SC_SPEC_ENTRY_UDT_UNION_V0):      true,
	XdrToI32(SC_SPEC_ENTRY_UDT_ENUM_V0):       true,
	XdrToI32(SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0): true,
}

func (_ SCSpecEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_SCSpecEntry
}
func (u *SCSpecEntry) FunctionV0() *SCSpecFunctionV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0:
		if v, ok := u._u.(*SCSpecFunctionV0); ok {
			return v
		} else {
			var zero SCSpecFunctionV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.FunctionV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecEntry) UdtStructV0() *SCSpecUDTStructV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_UDT_STRUCT_V0:
		if v, ok := u._u.(*SCSpecUDTStructV0); ok {
			return v
		} else {
			var zero SCSpecUDTStructV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.UdtStructV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecEntry) UdtUnionV0() *SCSpecUDTUnionV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_UDT_UNION_V0:
		if v, ok := u._u.(*SCSpecUDTUnionV0); ok {
			return v
		} else {
			var zero SCSpecUDTUnionV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.UdtUnionV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecEntry) UdtEnumV0() *SCSpecUDTEnumV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_UDT_ENUM_V0:
		if v, ok := u._u.(*SCSpecUDTEnumV0); ok {
			return v
		} else {
			var zero SCSpecUDTEnumV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.UdtEnumV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecEntry) UdtErrorEnumV0() *SCSpecUDTErrorEnumV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		if v, ok := u._u.(*SCSpecUDTErrorEnumV0); ok {
			return v
		} else {
			var zero SCSpecUDTErrorEnumV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.UdtErrorEnumV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u SCSpecEntry) XdrValid() bool {
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0, SC_SPEC_ENTRY_UDT_STRUCT_V0, SC_SPEC_ENTRY_UDT_UNION_V0, SC_SPEC_ENTRY_UDT_ENUM_V0, SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		return true
	}
	return false
}
func (u *SCSpecEntry) XdrUnionTag() XdrNum32 {
	return XDR_SCSpecEntryKind(&u.Kind)
}
func (u *SCSpecEntry) XdrUnionTagName() string {
	return "Kind"
}
func (u *SCSpecEntry) XdrUnionBody() XdrType {
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0:
		return XDR_SCSpecFunctionV0(u.FunctionV0())
	case SC_SPEC_ENTRY_UDT_STRUCT_V0:
		return XDR_SCSpecUDTStructV0(u.UdtStructV0())
	case SC_SPEC_ENTRY_UDT_UNION_V0:
		return XDR_SCSpecUDTUnionV0(u.UdtUnionV0())
	case SC_SPEC_ENTRY_UDT_ENUM_V0:
		return XDR_SCSpecUDTEnumV0(u.UdtEnumV0())
	case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		return XDR_SCSpecUDTErrorEnumV0(u.UdtErrorEnumV0())
	}
	return nil
}
func (u *SCSpecEntry) XdrUnionBodyName() string {
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0:
		return "FunctionV0"
	case SC_SPEC_ENTRY_UDT_STRUCT_V0:
		return "UdtStructV0"
	case SC_SPEC_ENTRY_UDT_UNION_V0:
		return "UdtUnionV0"
	case SC_SPEC_ENTRY_UDT_ENUM_V0:
		return "UdtEnumV0"
	case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		return "UdtErrorEnumV0"
	}
	return ""
}

type XdrType_SCSpecEntry = *SCSpecEntry

func (v *SCSpecEntry) XdrPointer() interface{}       { return v }
func (SCSpecEntry) XdrTypeName() string              { return "SCSpecEntry" }
func (v SCSpecEntry) XdrValue() interface{}          { return v }
func (v *SCSpecEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCSpecEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCSpecEntryKind(&u.Kind).XdrMarshal(x, x.Sprintf("%skind", name))
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0:
		x.Marshal(x.Sprintf("%sfunctionV0", name), XDR_SCSpecFunctionV0(u.FunctionV0()))
		return
	case SC_SPEC_ENTRY_UDT_STRUCT_V0:
		x.Marshal(x.Sprintf("%sudtStructV0", name), XDR_SCSpecUDTStructV0(u.UdtStructV0()))
		return
	case SC_SPEC_ENTRY_UDT_UNION_V0:
		x.Marshal(x.Sprintf("%sudtUnionV0", name), XDR_SCSpecUDTUnionV0(u.UdtUnionV0()))
		return
	case SC_SPEC_ENTRY_UDT_ENUM_V0:
		x.Marshal(x.Sprintf("%sudtEnumV0", name), XDR_SCSpecUDTEnumV0(u.UdtEnumV0()))
		return
	case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		x.Marshal(x.Sprintf("%sudtErrorEnumV0", name), XDR_SCSpecUDTErrorEnumV0(u.UdtErrorEnumV0()))
		return
	}
	XdrPanic("invalid Kind (%v) in SCSpecEntry", u.Kind)
}
func XDR_SCSpecEntry(v *SCSpecEntry) *SCSpecEntry { return v }

var _XdrNames_SCValType = map[int32]string{
	int32(SCV_BOOL):                         "SCV_BOOL",
	int32(SCV_VOID):                         "SCV_VOID",
	int32(SCV_ERROR):                        "SCV_ERROR",
	int32(SCV_U32):                          "SCV_U32",
	int32(SCV_I32):                          "SCV_I32",
	int32(SCV_U64):                          "SCV_U64",
	int32(SCV_I64):                          "SCV_I64",
	int32(SCV_TIMEPOINT):                    "SCV_TIMEPOINT",
	int32(SCV_DURATION):                     "SCV_DURATION",
	int32(SCV_U128):                         "SCV_U128",
	int32(SCV_I128):                         "SCV_I128",
	int32(SCV_U256):                         "SCV_U256",
	int32(SCV_I256):                         "SCV_I256",
	int32(SCV_BYTES):                        "SCV_BYTES",
	int32(SCV_STRING):                       "SCV_STRING",
	int32(SCV_SYMBOL):                       "SCV_SYMBOL",
	int32(SCV_VEC):                          "SCV_VEC",
	int32(SCV_MAP):                          "SCV_MAP",
	int32(SCV_ADDRESS):                      "SCV_ADDRESS",
	int32(SCV_CONTRACT_INSTANCE):            "SCV_CONTRACT_INSTANCE",
	int32(SCV_LEDGER_KEY_CONTRACT_INSTANCE): "SCV_LEDGER_KEY_CONTRACT_INSTANCE",
	int32(SCV_LEDGER_KEY_NONCE):             "SCV_LEDGER_KEY_NONCE",
}
var _XdrValues_SCValType = map[string]int32{
	"SCV_BOOL":                         int32(SCV_BOOL),
	"SCV_VOID":                         int32(SCV_VOID),
	"SCV_ERROR":                        int32(SCV_ERROR),
	"SCV_U32":                          int32(SCV_U32),
	"SCV_I32":                          int32(SCV_I32),
	"SCV_U64":                          int32(SCV_U64),
	"SCV_I64":                          int32(SCV_I64),
	"SCV_TIMEPOINT":                    int32(SCV_TIMEPOINT),
	"SCV_DURATION":                     int32(SCV_DURATION),
	"SCV_U128":                         int32(SCV_U128),
	"SCV_I128":                         int32(SCV_I128),
	"SCV_U256":                         int32(SCV_U256),
	"SCV_I256":                         int32(SCV_I256),
	"SCV_BYTES":                        int32(SCV_BYTES),
	"SCV_STRING":                       int32(SCV_STRING),
	"SCV_SYMBOL":                       int32(SCV_SYMBOL),
	"SCV_VEC":                          int32(SCV_VEC),
	"SCV_MAP":                          int32(SCV_MAP),
	"SCV_ADDRESS":                      int32(SCV_ADDRESS),
	"SCV_CONTRACT_INSTANCE":            int32(SCV_CONTRACT_INSTANCE),
	"SCV_LEDGER_KEY_CONTRACT_INSTANCE": int32(SCV_LEDGER_KEY_CONTRACT_INSTANCE),
	"SCV_LEDGER_KEY_NONCE":             int32(SCV_LEDGER_KEY_NONCE),
}

func (SCValType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCValType
}
func (v SCValType) String() string {
	if s, ok := _XdrNames_SCValType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCValType#%d", v)
}
func (v *SCValType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCValType[stok]; ok {
			*v = SCValType(val)
			return nil
		} else if stok == "SCValType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCValType.", stok))
	}
}
func (v SCValType) GetU32() uint32                 { return uint32(v) }
func (v *SCValType) SetU32(n uint32)               { *v = SCValType(n) }
func (v *SCValType) XdrPointer() interface{}       { return v }
func (SCValType) XdrTypeName() string              { return "SCValType" }
func (v SCValType) XdrValue() interface{}          { return v }
func (v *SCValType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCValType = *SCValType

func XDR_SCValType(v *SCValType) *SCValType { return v }

var _XdrComments_SCValType = map[int32]string{
	int32(SCV_U32):                          "32 bits is the smallest type in WASM or XDR; no need for u8/u16.",
	int32(SCV_U64):                          "64 bits is naturally supported by both WASM and XDR also.",
	int32(SCV_TIMEPOINT):                    "Time-related u64 subtypes with their own functions and formatting.",
	int32(SCV_U128):                         "128 bits is naturally supported by Rust and we use it for Soroban fixed-point arithmetic prices / balances / similar \"quantities\". These are represented in XDR as a pair of 2 u64s.",
	int32(SCV_U256):                         "256 bits is the size of sha256 output, ed25519 keys, and the EVM machine word, so for interop use we include this even though it requires a small amount of Rust guest and/or host library code.",
	int32(SCV_BYTES):                        "Bytes come in 3 flavors, 2 of which have meaningfully different formatting and validity-checking / domain-restriction.",
	int32(SCV_VEC):                          "Vecs and maps are just polymorphic containers of other ScVals.",
	int32(SCV_ADDRESS):                      "Address is the universal identifier for contracts and classic accounts.",
	int32(SCV_CONTRACT_INSTANCE):            "The following are the internal SCVal variants that are not exposed to the contracts.",
	int32(SCV_LEDGER_KEY_CONTRACT_INSTANCE): "SCV_LEDGER_KEY_CONTRACT_INSTANCE and SCV_LEDGER_KEY_NONCE are unique symbolic SCVals used as the key for ledger entries for a contract's instance and an address' nonce, respectively.",
}

func (e SCValType) XdrEnumComments() map[int32]string {
	return _XdrComments_SCValType
}

var _XdrNames_SCErrorType = map[int32]string{
	int32(SCE_CONTRACT): "SCE_CONTRACT",
	int32(SCE_WASM_VM):  "SCE_WASM_VM",
	int32(SCE_CONTEXT):  "SCE_CONTEXT",
	int32(SCE_STORAGE):  "SCE_STORAGE",
	int32(SCE_OBJECT):   "SCE_OBJECT",
	int32(SCE_CRYPTO):   "SCE_CRYPTO",
	int32(SCE_EVENTS):   "SCE_EVENTS",
	int32(SCE_BUDGET):   "SCE_BUDGET",
	int32(SCE_VALUE):    "SCE_VALUE",
	int32(SCE_AUTH):     "SCE_AUTH",
}
var _XdrValues_SCErrorType = map[string]int32{
	"SCE_CONTRACT": int32(SCE_CONTRACT),
	"SCE_WASM_VM":  int32(SCE_WASM_VM),
	"SCE_CONTEXT":  int32(SCE_CONTEXT),
	"SCE_STORAGE":  int32(SCE_STORAGE),
	"SCE_OBJECT":   int32(SCE_OBJECT),
	"SCE_CRYPTO":   int32(SCE_CRYPTO),
	"SCE_EVENTS":   int32(SCE_EVENTS),
	"SCE_BUDGET":   int32(SCE_BUDGET),
	"SCE_VALUE":    int32(SCE_VALUE),
	"SCE_AUTH":     int32(SCE_AUTH),
}

func (SCErrorType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCErrorType
}
func (v SCErrorType) String() string {
	if s, ok := _XdrNames_SCErrorType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCErrorType#%d", v)
}
func (v *SCErrorType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCErrorType[stok]; ok {
			*v = SCErrorType(val)
			return nil
		} else if stok == "SCErrorType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCErrorType.", stok))
	}
}
func (v SCErrorType) GetU32() uint32                 { return uint32(v) }
func (v *SCErrorType) SetU32(n uint32)               { *v = SCErrorType(n) }
func (v *SCErrorType) XdrPointer() interface{}       { return v }
func (SCErrorType) XdrTypeName() string              { return "SCErrorType" }
func (v SCErrorType) XdrValue() interface{}          { return v }
func (v *SCErrorType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCErrorType = *SCErrorType

func XDR_SCErrorType(v *SCErrorType) *SCErrorType { return v }

var _XdrComments_SCErrorType = map[int32]string{
	int32(SCE_CONTRACT): "Contract-specific, user-defined codes.",
	int32(SCE_WASM_VM):  "Errors while interpreting WASM bytecode.",
	int32(SCE_CONTEXT):  "Errors in the contract's host context.",
	int32(SCE_STORAGE):  "Errors accessing host storage.",
	int32(SCE_OBJECT):   "Errors working with host objects.",
	int32(SCE_CRYPTO):   "Errors in cryptographic operations.",
	int32(SCE_EVENTS):   "Errors while emitting events.",
	int32(SCE_BUDGET):   "Errors relating to budget limits.",
	int32(SCE_VALUE):    "Errors working with host values or SCVals.",
	int32(SCE_AUTH):     "Errors from the authentication subsystem.",
}

func (e SCErrorType) XdrEnumComments() map[int32]string {
	return _XdrComments_SCErrorType
}

var _XdrNames_SCErrorCode = map[int32]string{
	int32(SCEC_ARITH_DOMAIN):    "SCEC_ARITH_DOMAIN",
	int32(SCEC_INDEX_BOUNDS):    "SCEC_INDEX_BOUNDS",
	int32(SCEC_INVALID_INPUT):   "SCEC_INVALID_INPUT",
	int32(SCEC_MISSING_VALUE):   "SCEC_MISSING_VALUE",
	int32(SCEC_EXISTING_VALUE):  "SCEC_EXISTING_VALUE",
	int32(SCEC_EXCEEDED_LIMIT):  "SCEC_EXCEEDED_LIMIT",
	int32(SCEC_INVALID_ACTION):  "SCEC_INVALID_ACTION",
	int32(SCEC_INTERNAL_ERROR):  "SCEC_INTERNAL_ERROR",
	int32(SCEC_UNEXPECTED_TYPE): "SCEC_UNEXPECTED_TYPE",
	int32(SCEC_UNEXPECTED_SIZE): "SCEC_UNEXPECTED_SIZE",
}
var _XdrValues_SCErrorCode = map[string]int32{
	"SCEC_ARITH_DOMAIN":    int32(SCEC_ARITH_DOMAIN),
	"SCEC_INDEX_BOUNDS":    int32(SCEC_INDEX_BOUNDS),
	"SCEC_INVALID_INPUT":   int32(SCEC_INVALID_INPUT),
	"SCEC_MISSING_VALUE":   int32(SCEC_MISSING_VALUE),
	"SCEC_EXISTING_VALUE":  int32(SCEC_EXISTING_VALUE),
	"SCEC_EXCEEDED_LIMIT":  int32(SCEC_EXCEEDED_LIMIT),
	"SCEC_INVALID_ACTION":  int32(SCEC_INVALID_ACTION),
	"SCEC_INTERNAL_ERROR":  int32(SCEC_INTERNAL_ERROR),
	"SCEC_UNEXPECTED_TYPE": int32(SCEC_UNEXPECTED_TYPE),
	"SCEC_UNEXPECTED_SIZE": int32(SCEC_UNEXPECTED_SIZE),
}

func (SCErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SCErrorCode
}
func (v SCErrorCode) String() string {
	if s, ok := _XdrNames_SCErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCErrorCode#%d", v)
}
func (v *SCErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCErrorCode[stok]; ok {
			*v = SCErrorCode(val)
			return nil
		} else if stok == "SCErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCErrorCode.", stok))
	}
}
func (v SCErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *SCErrorCode) SetU32(n uint32)               { *v = SCErrorCode(n) }
func (v *SCErrorCode) XdrPointer() interface{}       { return v }
func (SCErrorCode) XdrTypeName() string              { return "SCErrorCode" }
func (v SCErrorCode) XdrValue() interface{}          { return v }
func (v *SCErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCErrorCode = *SCErrorCode

func XDR_SCErrorCode(v *SCErrorCode) *SCErrorCode { return v }

var _XdrComments_SCErrorCode = map[int32]string{
	int32(SCEC_ARITH_DOMAIN):    "Some arithmetic was undefined (overflow, divide-by-zero).",
	int32(SCEC_INDEX_BOUNDS):    "Something was indexed beyond its bounds.",
	int32(SCEC_INVALID_INPUT):   "User provided some otherwise-bad data.",
	int32(SCEC_MISSING_VALUE):   "Some value was required but not provided.",
	int32(SCEC_EXISTING_VALUE):  "Some value was provided where not allowed.",
	int32(SCEC_EXCEEDED_LIMIT):  "Some arbitrary limit -- gas or otherwise -- was hit.",
	int32(SCEC_INVALID_ACTION):  "Data was valid but action requested was not.",
	int32(SCEC_INTERNAL_ERROR):  "The host detected an error in its own logic.",
	int32(SCEC_UNEXPECTED_TYPE): "Some type wasn't as expected.",
	int32(SCEC_UNEXPECTED_SIZE): "Something's size wasn't as expected.",
}

func (e SCErrorCode) XdrEnumComments() map[int32]string {
	return _XdrComments_SCErrorCode
}

var _XdrTags_SCError = map[int32]bool{
	XdrToI32(SCE_CONTRACT): true,
	XdrToI32(SCE_WASM_VM):  true,
	XdrToI32(SCE_CONTEXT):  true,
	XdrToI32(SCE_STORAGE):  true,
	XdrToI32(SCE_OBJECT):   true,
	XdrToI32(SCE_CRYPTO):   true,
	XdrToI32(SCE_EVENTS):   true,
	XdrToI32(SCE_BUDGET):   true,
	XdrToI32(SCE_VALUE):    true,
	XdrToI32(SCE_AUTH):     true,
}

func (_ SCError) XdrValidTags() map[int32]bool {
	return _XdrTags_SCError
}
func (u *SCError) ContractCode() *Uint32 {
	switch u.Type {
	case SCE_CONTRACT:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCError.ContractCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCError) Code() *SCErrorCode {
	switch u.Type {
	case SCE_WASM_VM, SCE_CONTEXT, SCE_STORAGE, SCE_OBJECT, SCE_CRYPTO, SCE_EVENTS, SCE_BUDGET, SCE_VALUE, SCE_AUTH:
		if v, ok := u._u.(*SCErrorCode); ok {
			return v
		} else {
			var zero SCErrorCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCError.Code accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCError) XdrValid() bool {
	switch u.Type {
	case SCE_CONTRACT, SCE_WASM_VM, SCE_CONTEXT, SCE_STORAGE, SCE_OBJECT, SCE_CRYPTO, SCE_EVENTS, SCE_BUDGET, SCE_VALUE, SCE_AUTH:
		return true
	}
	return false
}
func (u *SCError) XdrUnionTag() XdrNum32 {
	return XDR_SCErrorType(&u.Type)
}
func (u *SCError) XdrUnionTagName() string {
	return "Type"
}
func (u *SCError) XdrUnionBody() XdrType {
	switch u.Type {
	case SCE_CONTRACT:
		return XDR_Uint32(u.ContractCode())
	case SCE_WASM_VM, SCE_CONTEXT, SCE_STORAGE, SCE_OBJECT, SCE_CRYPTO, SCE_EVENTS, SCE_BUDGET, SCE_VALUE, SCE_AUTH:
		return XDR_SCErrorCode(u.Code())
	}
	return nil
}
func (u *SCError) XdrUnionBodyName() string {
	switch u.Type {
	case SCE_CONTRACT:
		return "ContractCode"
	case SCE_WASM_VM, SCE_CONTEXT, SCE_STORAGE, SCE_OBJECT, SCE_CRYPTO, SCE_EVENTS, SCE_BUDGET, SCE_VALUE, SCE_AUTH:
		return "Code"
	}
	return ""
}

type XdrType_SCError = *SCError

func (v *SCError) XdrPointer() interface{}       { return v }
func (SCError) XdrTypeName() string              { return "SCError" }
func (v SCError) XdrValue() interface{}          { return v }
func (v *SCError) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCError) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCErrorType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SCE_CONTRACT:
		x.Marshal(x.Sprintf("%scontractCode", name), XDR_Uint32(u.ContractCode()))
		return
	case SCE_WASM_VM, SCE_CONTEXT, SCE_STORAGE, SCE_OBJECT, SCE_CRYPTO, SCE_EVENTS, SCE_BUDGET, SCE_VALUE, SCE_AUTH:
		x.Marshal(x.Sprintf("%scode", name), XDR_SCErrorCode(u.Code()))
		return
	}
	XdrPanic("invalid Type (%v) in SCError", u.Type)
}
func XDR_SCError(v *SCError) *SCError { return v }

type XdrType_UInt128Parts = *UInt128Parts

func (v *UInt128Parts) XdrPointer() interface{}       { return v }
func (UInt128Parts) XdrTypeName() string              { return "UInt128Parts" }
func (v UInt128Parts) XdrValue() interface{}          { return v }
func (v *UInt128Parts) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *UInt128Parts) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shi", name), XDR_Uint64(&v.Hi))
	x.Marshal(x.Sprintf("%slo", name), XDR_Uint64(&v.Lo))
}
func XDR_UInt128Parts(v *UInt128Parts) *UInt128Parts { return v }

type XdrType_Int128Parts = *Int128Parts

func (v *Int128Parts) XdrPointer() interface{}       { return v }
func (Int128Parts) XdrTypeName() string              { return "Int128Parts" }
func (v Int128Parts) XdrValue() interface{}          { return v }
func (v *Int128Parts) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Int128Parts) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shi", name), XDR_Int64(&v.Hi))
	x.Marshal(x.Sprintf("%slo", name), XDR_Uint64(&v.Lo))
}
func XDR_Int128Parts(v *Int128Parts) *Int128Parts { return v }

type XdrType_UInt256Parts = *UInt256Parts

func (v *UInt256Parts) XdrPointer() interface{}       { return v }
func (UInt256Parts) XdrTypeName() string              { return "UInt256Parts" }
func (v UInt256Parts) XdrValue() interface{}          { return v }
func (v *UInt256Parts) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *UInt256Parts) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shi_hi", name), XDR_Uint64(&v.Hi_hi))
	x.Marshal(x.Sprintf("%shi_lo", name), XDR_Uint64(&v.Hi_lo))
	x.Marshal(x.Sprintf("%slo_hi", name), XDR_Uint64(&v.Lo_hi))
	x.Marshal(x.Sprintf("%slo_lo", name), XDR_Uint64(&v.Lo_lo))
}
func XDR_UInt256Parts(v *UInt256Parts) *UInt256Parts { return v }

type XdrType_Int256Parts = *Int256Parts

func (v *Int256Parts) XdrPointer() interface{}       { return v }
func (Int256Parts) XdrTypeName() string              { return "Int256Parts" }
func (v Int256Parts) XdrValue() interface{}          { return v }
func (v *Int256Parts) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Int256Parts) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shi_hi", name), XDR_Int64(&v.Hi_hi))
	x.Marshal(x.Sprintf("%shi_lo", name), XDR_Uint64(&v.Hi_lo))
	x.Marshal(x.Sprintf("%slo_hi", name), XDR_Uint64(&v.Lo_hi))
	x.Marshal(x.Sprintf("%slo_lo", name), XDR_Uint64(&v.Lo_lo))
}
func XDR_Int256Parts(v *Int256Parts) *Int256Parts { return v }

var _XdrNames_ContractExecutableType = map[int32]string{
	int32(CONTRACT_EXECUTABLE_WASM):          "CONTRACT_EXECUTABLE_WASM",
	int32(CONTRACT_EXECUTABLE_STELLAR_ASSET): "CONTRACT_EXECUTABLE_STELLAR_ASSET",
}
var _XdrValues_ContractExecutableType = map[string]int32{
	"CONTRACT_EXECUTABLE_WASM":          int32(CONTRACT_EXECUTABLE_WASM),
	"CONTRACT_EXECUTABLE_STELLAR_ASSET": int32(CONTRACT_EXECUTABLE_STELLAR_ASSET),
}

func (ContractExecutableType) XdrEnumNames() map[int32]string {
	return _XdrNames_ContractExecutableType
}
func (v ContractExecutableType) String() string {
	if s, ok := _XdrNames_ContractExecutableType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ContractExecutableType#%d", v)
}
func (v *ContractExecutableType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ContractExecutableType[stok]; ok {
			*v = ContractExecutableType(val)
			return nil
		} else if stok == "ContractExecutableType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ContractExecutableType.", stok))
	}
}
func (v ContractExecutableType) GetU32() uint32                 { return uint32(v) }
func (v *ContractExecutableType) SetU32(n uint32)               { *v = ContractExecutableType(n) }
func (v *ContractExecutableType) XdrPointer() interface{}       { return v }
func (ContractExecutableType) XdrTypeName() string              { return "ContractExecutableType" }
func (v ContractExecutableType) XdrValue() interface{}          { return v }
func (v *ContractExecutableType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ContractExecutableType = *ContractExecutableType

func XDR_ContractExecutableType(v *ContractExecutableType) *ContractExecutableType { return v }

var _XdrTags_ContractExecutable = map[int32]bool{
	XdrToI32(CONTRACT_EXECUTABLE_WASM):          true,
	XdrToI32(CONTRACT_EXECUTABLE_STELLAR_ASSET): true,
}

func (_ ContractExecutable) XdrValidTags() map[int32]bool {
	return _XdrTags_ContractExecutable
}
func (u *ContractExecutable) Wasm_hash() *Hash {
	switch u.Type {
	case CONTRACT_EXECUTABLE_WASM:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ContractExecutable.Wasm_hash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ContractExecutable) XdrValid() bool {
	switch u.Type {
	case CONTRACT_EXECUTABLE_WASM, CONTRACT_EXECUTABLE_STELLAR_ASSET:
		return true
	}
	return false
}
func (u *ContractExecutable) XdrUnionTag() XdrNum32 {
	return XDR_ContractExecutableType(&u.Type)
}
func (u *ContractExecutable) XdrUnionTagName() string {
	return "Type"
}
func (u *ContractExecutable) XdrUnionBody() XdrType {
	switch u.Type {
	case CONTRACT_EXECUTABLE_WASM:
		return XDR_Hash(u.Wasm_hash())
	case CONTRACT_EXECUTABLE_STELLAR_ASSET:
		return nil
	}
	return nil
}
func (u *ContractExecutable) XdrUnionBodyName() string {
	switch u.Type {
	case CONTRACT_EXECUTABLE_WASM:
		return "Wasm_hash"
	case CONTRACT_EXECUTABLE_STELLAR_ASSET:
		return ""
	}
	return ""
}

type XdrType_ContractExecutable = *ContractExecutable

func (v *ContractExecutable) XdrPointer() interface{}       { return v }
func (ContractExecutable) XdrTypeName() string              { return "ContractExecutable" }
func (v ContractExecutable) XdrValue() interface{}          { return v }
func (v *ContractExecutable) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ContractExecutable) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ContractExecutableType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CONTRACT_EXECUTABLE_WASM:
		x.Marshal(x.Sprintf("%swasm_hash", name), XDR_Hash(u.Wasm_hash()))
		return
	case CONTRACT_EXECUTABLE_STELLAR_ASSET:
		return
	}
	XdrPanic("invalid Type (%v) in ContractExecutable", u.Type)
}
func XDR_ContractExecutable(v *ContractExecutable) *ContractExecutable { return v }

var _XdrNames_SCAddressType = map[int32]string{
	int32(SC_ADDRESS_TYPE_ACCOUNT):  "SC_ADDRESS_TYPE_ACCOUNT",
	int32(SC_ADDRESS_TYPE_CONTRACT): "SC_ADDRESS_TYPE_CONTRACT",
}
var _XdrValues_SCAddressType = map[string]int32{
	"SC_ADDRESS_TYPE_ACCOUNT":  int32(SC_ADDRESS_TYPE_ACCOUNT),
	"SC_ADDRESS_TYPE_CONTRACT": int32(SC_ADDRESS_TYPE_CONTRACT),
}

func (SCAddressType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCAddressType
}
func (v SCAddressType) String() string {
	if s, ok := _XdrNames_SCAddressType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCAddressType#%d", v)
}
func (v *SCAddressType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCAddressType[stok]; ok {
			*v = SCAddressType(val)
			return nil
		} else if stok == "SCAddressType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCAddressType.", stok))
	}
}
func (v SCAddressType) GetU32() uint32                 { return uint32(v) }
func (v *SCAddressType) SetU32(n uint32)               { *v = SCAddressType(n) }
func (v *SCAddressType) XdrPointer() interface{}       { return v }
func (SCAddressType) XdrTypeName() string              { return "SCAddressType" }
func (v SCAddressType) XdrValue() interface{}          { return v }
func (v *SCAddressType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCAddressType = *SCAddressType

func XDR_SCAddressType(v *SCAddressType) *SCAddressType { return v }

var _XdrTags_SCAddress = map[int32]bool{
	XdrToI32(SC_ADDRESS_TYPE_ACCOUNT):  true,
	XdrToI32(SC_ADDRESS_TYPE_CONTRACT): true,
}

func (_ SCAddress) XdrValidTags() map[int32]bool {
	return _XdrTags_SCAddress
}
func (u *SCAddress) AccountId() *AccountID {
	switch u.Type {
	case SC_ADDRESS_TYPE_ACCOUNT:
		if v, ok := u._u.(*AccountID); ok {
			return v
		} else {
			var zero AccountID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCAddress.AccountId accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCAddress) ContractId() *Hash {
	switch u.Type {
	case SC_ADDRESS_TYPE_CONTRACT:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCAddress.ContractId accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCAddress) XdrValid() bool {
	switch u.Type {
	case SC_ADDRESS_TYPE_ACCOUNT, SC_ADDRESS_TYPE_CONTRACT:
		return true
	}
	return false
}
func (u *SCAddress) XdrUnionTag() XdrNum32 {
	return XDR_SCAddressType(&u.Type)
}
func (u *SCAddress) XdrUnionTagName() string {
	return "Type"
}
func (u *SCAddress) XdrUnionBody() XdrType {
	switch u.Type {
	case SC_ADDRESS_TYPE_ACCOUNT:
		return XDR_AccountID(u.AccountId())
	case SC_ADDRESS_TYPE_CONTRACT:
		return XDR_Hash(u.ContractId())
	}
	return nil
}
func (u *SCAddress) XdrUnionBodyName() string {
	switch u.Type {
	case SC_ADDRESS_TYPE_ACCOUNT:
		return "AccountId"
	case SC_ADDRESS_TYPE_CONTRACT:
		return "ContractId"
	}
	return ""
}

type XdrType_SCAddress = *SCAddress

func (v *SCAddress) XdrPointer() interface{}       { return v }
func (SCAddress) XdrTypeName() string              { return "SCAddress" }
func (v SCAddress) XdrValue() interface{}          { return v }
func (v *SCAddress) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCAddress) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCAddressType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SC_ADDRESS_TYPE_ACCOUNT:
		x.Marshal(x.Sprintf("%saccountId", name), XDR_AccountID(u.AccountId()))
		return
	case SC_ADDRESS_TYPE_CONTRACT:
		x.Marshal(x.Sprintf("%scontractId", name), XDR_Hash(u.ContractId()))
		return
	}
	XdrPanic("invalid Type (%v) in SCAddress", u.Type)
}
func XDR_SCAddress(v *SCAddress) *SCAddress { return v }

type XdrType_SCVec struct {
	*_XdrVec_unbounded_SCVal
}

func XDR_SCVec(v *SCVec) XdrType_SCVec {
	return XdrType_SCVec{(*_XdrVec_unbounded_SCVal)(v)}
}
func (XdrType_SCVec) XdrTypeName() string  { return "SCVec" }
func (v XdrType_SCVec) XdrUnwrap() XdrType { return v._XdrVec_unbounded_SCVal }

type _XdrVec_unbounded_SCMapEntry []SCMapEntry

func (_XdrVec_unbounded_SCMapEntry) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCMapEntry) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCMapEntry length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCMapEntry length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCMapEntry) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCMapEntry) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCMapEntry, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCMapEntry) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCMapEntry(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCMapEntry) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SCMapEntry) XdrTypeName() string              { return "SCMapEntry<>" }
func (v *_XdrVec_unbounded_SCMapEntry) XdrPointer() interface{}       { return (*[]SCMapEntry)(v) }
func (v _XdrVec_unbounded_SCMapEntry) XdrValue() interface{}          { return ([]SCMapEntry)(v) }
func (v *_XdrVec_unbounded_SCMapEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCMap struct {
	*_XdrVec_unbounded_SCMapEntry
}

func XDR_SCMap(v *SCMap) XdrType_SCMap {
	return XdrType_SCMap{(*_XdrVec_unbounded_SCMapEntry)(v)}
}
func (XdrType_SCMap) XdrTypeName() string  { return "SCMap" }
func (v XdrType_SCMap) XdrUnwrap() XdrType { return v._XdrVec_unbounded_SCMapEntry }

type XdrType_SCBytes struct {
	XdrVecOpaque
}

func XDR_SCBytes(v *SCBytes) XdrType_SCBytes {
	return XdrType_SCBytes{XdrVecOpaque{v, 0xffffffff}}
}
func (XdrType_SCBytes) XdrTypeName() string  { return "SCBytes" }
func (v XdrType_SCBytes) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_SCString struct {
	XdrString
}

func XDR_SCString(v *SCString) XdrType_SCString {
	return XdrType_SCString{XdrString{v, 0xffffffff}}
}
func (XdrType_SCString) XdrTypeName() string  { return "SCString" }
func (v XdrType_SCString) XdrUnwrap() XdrType { return v.XdrString }

type XdrType_SCSymbol struct {
	XdrString
}

func XDR_SCSymbol(v *SCSymbol) XdrType_SCSymbol {
	return XdrType_SCSymbol{XdrString{v, SCSYMBOL_LIMIT}}
}
func (XdrType_SCSymbol) XdrTypeName() string  { return "SCSymbol" }
func (v XdrType_SCSymbol) XdrUnwrap() XdrType { return v.XdrString }

type XdrType_SCNonceKey = *SCNonceKey

func (v *SCNonceKey) XdrPointer() interface{}       { return v }
func (SCNonceKey) XdrTypeName() string              { return "SCNonceKey" }
func (v SCNonceKey) XdrValue() interface{}          { return v }
func (v *SCNonceKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCNonceKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snonce", name), XDR_Int64(&v.Nonce))
}
func XDR_SCNonceKey(v *SCNonceKey) *SCNonceKey { return v }

type _XdrPtr_SCMap struct {
	p **SCMap
}
type _ptrflag_SCMap _XdrPtr_SCMap

func (v _ptrflag_SCMap) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SCMap) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SCMap flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SCMap) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SCMap) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SCMap)
		}
	default:
		XdrPanic("*SCMap present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SCMap) XdrTypeName() string             { return "SCMap?" }
func (v _ptrflag_SCMap) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SCMap) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SCMap) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SCMap) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SCMap) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SCMap) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SCMap)
	}
}
func (v _XdrPtr_SCMap) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SCMap(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SCMap) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SCMap) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SCMap(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SCMap) XdrTypeName() string       { return "SCMap*" }
func (v _XdrPtr_SCMap) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SCMap) XdrValue() interface{}   { return *v.p }

type XdrType_SCContractInstance = *SCContractInstance

func (v *SCContractInstance) XdrPointer() interface{}       { return v }
func (SCContractInstance) XdrTypeName() string              { return "SCContractInstance" }
func (v SCContractInstance) XdrValue() interface{}          { return v }
func (v *SCContractInstance) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCContractInstance) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sexecutable", name), XDR_ContractExecutable(&v.Executable))
	x.Marshal(x.Sprintf("%sstorage", name), _XdrPtr_SCMap{&v.Storage})
}
func XDR_SCContractInstance(v *SCContractInstance) *SCContractInstance { return v }

type _XdrPtr_SCVec struct {
	p **SCVec
}
type _ptrflag_SCVec _XdrPtr_SCVec

func (v _ptrflag_SCVec) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SCVec) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SCVec flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SCVec) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SCVec) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SCVec)
		}
	default:
		XdrPanic("*SCVec present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SCVec) XdrTypeName() string             { return "SCVec?" }
func (v _ptrflag_SCVec) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SCVec) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SCVec) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SCVec) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SCVec) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SCVec) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SCVec)
	}
}
func (v _XdrPtr_SCVec) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SCVec(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SCVec) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SCVec) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SCVec(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SCVec) XdrTypeName() string       { return "SCVec*" }
func (v _XdrPtr_SCVec) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SCVec) XdrValue() interface{}   { return *v.p }

var _XdrTags_SCVal = map[int32]bool{
	XdrToI32(SCV_BOOL):                         true,
	XdrToI32(SCV_VOID):                         true,
	XdrToI32(SCV_ERROR):                        true,
	XdrToI32(SCV_U32):                          true,
	XdrToI32(SCV_I32):                          true,
	XdrToI32(SCV_U64):                          true,
	XdrToI32(SCV_I64):                          true,
	XdrToI32(SCV_TIMEPOINT):                    true,
	XdrToI32(SCV_DURATION):                     true,
	XdrToI32(SCV_U128):                         true,
	XdrToI32(SCV_I128):                         true,
	XdrToI32(SCV_U256):                         true,
	XdrToI32(SCV_I256):                         true,
	XdrToI32(SCV_BYTES):                        true,
	XdrToI32(SCV_STRING):                       true,
	XdrToI32(SCV_SYMBOL):                       true,
	XdrToI32(SCV_VEC):                          true,
	XdrToI32(SCV_MAP):                          true,
	XdrToI32(SCV_ADDRESS):                      true,
	XdrToI32(SCV_LEDGER_KEY_CONTRACT_INSTANCE): true,
	XdrToI32(SCV_LEDGER_KEY_NONCE):             true,
	XdrToI32(SCV_CONTRACT_INSTANCE):            true,
}

func (_ SCVal) XdrValidTags() map[int32]bool {
	return _XdrTags_SCVal
}
func (u *SCVal) B() *bool {
	switch u.Type {
	case SCV_BOOL:
		if v, ok := u._u.(*bool); ok {
			return v
		} else {
			var zero bool
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.B accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Error() *SCError {
	switch u.Type {
	case SCV_ERROR:
		if v, ok := u._u.(*SCError); ok {
			return v
		} else {
			var zero SCError
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Error accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) U32() *Uint32 {
	switch u.Type {
	case SCV_U32:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.U32 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) I32() *Int32 {
	switch u.Type {
	case SCV_I32:
		if v, ok := u._u.(*Int32); ok {
			return v
		} else {
			var zero Int32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.I32 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) U64() *Uint64 {
	switch u.Type {
	case SCV_U64:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.U64 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) I64() *Int64 {
	switch u.Type {
	case SCV_I64:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.I64 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Timepoint() *TimePoint {
	switch u.Type {
	case SCV_TIMEPOINT:
		if v, ok := u._u.(*TimePoint); ok {
			return v
		} else {
			var zero TimePoint
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Timepoint accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Duration() *Duration {
	switch u.Type {
	case SCV_DURATION:
		if v, ok := u._u.(*Duration); ok {
			return v
		} else {
			var zero Duration
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Duration accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) U128() *UInt128Parts {
	switch u.Type {
	case SCV_U128:
		if v, ok := u._u.(*UInt128Parts); ok {
			return v
		} else {
			var zero UInt128Parts
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.U128 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) I128() *Int128Parts {
	switch u.Type {
	case SCV_I128:
		if v, ok := u._u.(*Int128Parts); ok {
			return v
		} else {
			var zero Int128Parts
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.I128 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) U256() *UInt256Parts {
	switch u.Type {
	case SCV_U256:
		if v, ok := u._u.(*UInt256Parts); ok {
			return v
		} else {
			var zero UInt256Parts
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.U256 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) I256() *Int256Parts {
	switch u.Type {
	case SCV_I256:
		if v, ok := u._u.(*Int256Parts); ok {
			return v
		} else {
			var zero Int256Parts
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.I256 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Bytes() *SCBytes {
	switch u.Type {
	case SCV_BYTES:
		if v, ok := u._u.(*SCBytes); ok {
			return v
		} else {
			var zero SCBytes
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Bytes accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Str() *SCString {
	switch u.Type {
	case SCV_STRING:
		if v, ok := u._u.(*SCString); ok {
			return v
		} else {
			var zero SCString
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Str accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Sym() *SCSymbol {
	switch u.Type {
	case SCV_SYMBOL:
		if v, ok := u._u.(*SCSymbol); ok {
			return v
		} else {
			var zero SCSymbol
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Sym accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Vec() **SCVec {
	switch u.Type {
	case SCV_VEC:
		if v, ok := u._u.(**SCVec); ok {
			return v
		} else {
			var zero *SCVec
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Vec accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Map() **SCMap {
	switch u.Type {
	case SCV_MAP:
		if v, ok := u._u.(**SCMap); ok {
			return v
		} else {
			var zero *SCMap
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Map accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Address() *SCAddress {
	switch u.Type {
	case SCV_ADDRESS:
		if v, ok := u._u.(*SCAddress); ok {
			return v
		} else {
			var zero SCAddress
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Address accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Nonce_key() *SCNonceKey {
	switch u.Type {
	case SCV_LEDGER_KEY_NONCE:
		if v, ok := u._u.(*SCNonceKey); ok {
			return v
		} else {
			var zero SCNonceKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Nonce_key accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Instance() *SCContractInstance {
	switch u.Type {
	case SCV_CONTRACT_INSTANCE:
		if v, ok := u._u.(*SCContractInstance); ok {
			return v
		} else {
			var zero SCContractInstance
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Instance accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCVal) XdrValid() bool {
	switch u.Type {
	case SCV_BOOL, SCV_VOID, SCV_ERROR, SCV_U32, SCV_I32, SCV_U64, SCV_I64, SCV_TIMEPOINT, SCV_DURATION, SCV_U128, SCV_I128, SCV_U256, SCV_I256, SCV_BYTES, SCV_STRING, SCV_SYMBOL, SCV_VEC, SCV_MAP, SCV_ADDRESS, SCV_LEDGER_KEY_CONTRACT_INSTANCE, SCV_LEDGER_KEY_NONCE, SCV_CONTRACT_INSTANCE:
		return true
	}
	return false
}
func (u *SCVal) XdrUnionTag() XdrNum32 {
	return XDR_SCValType(&u.Type)
}
func (u *SCVal) XdrUnionTagName() string {
	return "Type"
}
func (u *SCVal) XdrUnionBody() XdrType {
	switch u.Type {
	case SCV_BOOL:
		return XDR_bool(u.B())
	case SCV_VOID:
		return nil
	case SCV_ERROR:
		return XDR_SCError(u.Error())
	case SCV_U32:
		return XDR_Uint32(u.U32())
	case SCV_I32:
		return XDR_Int32(u.I32())
	case SCV_U64:
		return XDR_Uint64(u.U64())
	case SCV_I64:
		return XDR_Int64(u.I64())
	case SCV_TIMEPOINT:
		return XDR_TimePoint(u.Timepoint())
	case SCV_DURATION:
		return XDR_Duration(u.Duration())
	case SCV_U128:
		return XDR_UInt128Parts(u.U128())
	case SCV_I128:
		return XDR_Int128Parts(u.I128())
	case SCV_U256:
		return XDR_UInt256Parts(u.U256())
	case SCV_I256:
		return XDR_Int256Parts(u.I256())
	case SCV_BYTES:
		return XDR_SCBytes(u.Bytes())
	case SCV_STRING:
		return XDR_SCString(u.Str())
	case SCV_SYMBOL:
		return XDR_SCSymbol(u.Sym())
	case SCV_VEC:
		return _XdrPtr_SCVec{u.Vec()}
	case SCV_MAP:
		return _XdrPtr_SCMap{u.Map()}
	case SCV_ADDRESS:
		return XDR_SCAddress(u.Address())
	case SCV_LEDGER_KEY_CONTRACT_INSTANCE:
		return nil
	case SCV_LEDGER_KEY_NONCE:
		return XDR_SCNonceKey(u.Nonce_key())
	case SCV_CONTRACT_INSTANCE:
		return XDR_SCContractInstance(u.Instance())
	}
	return nil
}
func (u *SCVal) XdrUnionBodyName() string {
	switch u.Type {
	case SCV_BOOL:
		return "B"
	case SCV_VOID:
		return ""
	case SCV_ERROR:
		return "Error"
	case SCV_U32:
		return "U32"
	case SCV_I32:
		return "I32"
	case SCV_U64:
		return "U64"
	case SCV_I64:
		return "I64"
	case SCV_TIMEPOINT:
		return "Timepoint"
	case SCV_DURATION:
		return "Duration"
	case SCV_U128:
		return "U128"
	case SCV_I128:
		return "I128"
	case SCV_U256:
		return "U256"
	case SCV_I256:
		return "I256"
	case SCV_BYTES:
		return "Bytes"
	case SCV_STRING:
		return "Str"
	case SCV_SYMBOL:
		return "Sym"
	case SCV_VEC:
		return "Vec"
	case SCV_MAP:
		return "Map"
	case SCV_ADDRESS:
		return "Address"
	case SCV_LEDGER_KEY_CONTRACT_INSTANCE:
		return ""
	case SCV_LEDGER_KEY_NONCE:
		return "Nonce_key"
	case SCV_CONTRACT_INSTANCE:
		return "Instance"
	}
	return ""
}

type XdrType_SCVal = *SCVal

func (v *SCVal) XdrPointer() interface{}       { return v }
func (SCVal) XdrTypeName() string              { return "SCVal" }
func (v SCVal) XdrValue() interface{}          { return v }
func (v *SCVal) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCVal) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCValType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SCV_BOOL:
		x.Marshal(x.Sprintf("%sb", name), XDR_bool(u.B()))
		return
	case SCV_VOID:
		return
	case SCV_ERROR:
		x.Marshal(x.Sprintf("%serror", name), XDR_SCError(u.Error()))
		return
	case SCV_U32:
		x.Marshal(x.Sprintf("%su32", name), XDR_Uint32(u.U32()))
		return
	case SCV_I32:
		x.Marshal(x.Sprintf("%si32", name), XDR_Int32(u.I32()))
		return
	case SCV_U64:
		x.Marshal(x.Sprintf("%su64", name), XDR_Uint64(u.U64()))
		return
	case SCV_I64:
		x.Marshal(x.Sprintf("%si64", name), XDR_Int64(u.I64()))
		return
	case SCV_TIMEPOINT:
		x.Marshal(x.Sprintf("%stimepoint", name), XDR_TimePoint(u.Timepoint()))
		return
	case SCV_DURATION:
		x.Marshal(x.Sprintf("%sduration", name), XDR_Duration(u.Duration()))
		return
	case SCV_U128:
		x.Marshal(x.Sprintf("%su128", name), XDR_UInt128Parts(u.U128()))
		return
	case SCV_I128:
		x.Marshal(x.Sprintf("%si128", name), XDR_Int128Parts(u.I128()))
		return
	case SCV_U256:
		x.Marshal(x.Sprintf("%su256", name), XDR_UInt256Parts(u.U256()))
		return
	case SCV_I256:
		x.Marshal(x.Sprintf("%si256", name), XDR_Int256Parts(u.I256()))
		return
	case SCV_BYTES:
		x.Marshal(x.Sprintf("%sbytes", name), XDR_SCBytes(u.Bytes()))
		return
	case SCV_STRING:
		x.Marshal(x.Sprintf("%sstr", name), XDR_SCString(u.Str()))
		return
	case SCV_SYMBOL:
		x.Marshal(x.Sprintf("%ssym", name), XDR_SCSymbol(u.Sym()))
		return
	case SCV_VEC:
		x.Marshal(x.Sprintf("%svec", name), _XdrPtr_SCVec{u.Vec()})
		return
	case SCV_MAP:
		x.Marshal(x.Sprintf("%smap", name), _XdrPtr_SCMap{u.Map()})
		return
	case SCV_ADDRESS:
		x.Marshal(x.Sprintf("%saddress", name), XDR_SCAddress(u.Address()))
		return
	case SCV_LEDGER_KEY_CONTRACT_INSTANCE:
		return
	case SCV_LEDGER_KEY_NONCE:
		x.Marshal(x.Sprintf("%snonce_key", name), XDR_SCNonceKey(u.Nonce_key()))
		return
	case SCV_CONTRACT_INSTANCE:
		x.Marshal(x.Sprintf("%sinstance", name), XDR_SCContractInstance(u.Instance()))
		return
	}
	XdrPanic("invalid Type (%v) in SCVal", u.Type)
}
func XDR_SCVal(v *SCVal) *SCVal { return v }

type XdrType_SCMapEntry = *SCMapEntry

func (v *SCMapEntry) XdrPointer() interface{}       { return v }
func (SCMapEntry) XdrTypeName() string              { return "SCMapEntry" }
func (v SCMapEntry) XdrValue() interface{}          { return v }
func (v *SCMapEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCMapEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XDR_SCVal(&v.Key))
	x.Marshal(x.Sprintf("%sval", name), XDR_SCVal(&v.Val))
}
func XDR_SCMapEntry(v *SCMapEntry) *SCMapEntry { return v }

var _XdrTags_StoredTransactionSet = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ StoredTransactionSet) XdrValidTags() map[int32]bool {
	return _XdrTags_StoredTransactionSet
}
func (u *StoredTransactionSet) TxSet() *TransactionSet {
	switch u.V {
	case 0:
		if v, ok := u._u.(*TransactionSet); ok {
			return v
		} else {
			var zero TransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StoredTransactionSet.TxSet accessed when V == %v", u.V)
		return nil
	}
}
func (u *StoredTransactionSet) GeneralizedTxSet() *GeneralizedTransactionSet {
	switch u.V {
	case 1:
		if v, ok := u._u.(*GeneralizedTransactionSet); ok {
			return v
		} else {
			var zero GeneralizedTransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StoredTransactionSet.GeneralizedTxSet accessed when V == %v", u.V)
		return nil
	}
}
func (u StoredTransactionSet) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *StoredTransactionSet) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *StoredTransactionSet) XdrUnionTagName() string {
	return "V"
}
func (u *StoredTransactionSet) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_TransactionSet(u.TxSet())
	case 1:
		return XDR_GeneralizedTransactionSet(u.GeneralizedTxSet())
	}
	return nil
}
func (u *StoredTransactionSet) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "TxSet"
	case 1:
		return "GeneralizedTxSet"
	}
	return ""
}

type XdrType_StoredTransactionSet = *StoredTransactionSet

func (v *StoredTransactionSet) XdrPointer() interface{}       { return v }
func (StoredTransactionSet) XdrTypeName() string              { return "StoredTransactionSet" }
func (v StoredTransactionSet) XdrValue() interface{}          { return v }
func (v *StoredTransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *StoredTransactionSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%stxSet", name), XDR_TransactionSet(u.TxSet()))
		return
	case 1:
		x.Marshal(x.Sprintf("%sgeneralizedTxSet", name), XDR_GeneralizedTransactionSet(u.GeneralizedTxSet()))
		return
	}
	XdrPanic("invalid V (%v) in StoredTransactionSet", u.V)
}
func XDR_StoredTransactionSet(v *StoredTransactionSet) *StoredTransactionSet { return v }

type XdrType_StoredDebugTransactionSet = *StoredDebugTransactionSet

func (v *StoredDebugTransactionSet) XdrPointer() interface{}       { return v }
func (StoredDebugTransactionSet) XdrTypeName() string              { return "StoredDebugTransactionSet" }
func (v StoredDebugTransactionSet) XdrValue() interface{}          { return v }
func (v *StoredDebugTransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *StoredDebugTransactionSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxSet", name), XDR_StoredTransactionSet(&v.TxSet))
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%sscpValue", name), XDR_StellarValue(&v.ScpValue))
}
func XDR_StoredDebugTransactionSet(v *StoredDebugTransactionSet) *StoredDebugTransactionSet { return v }

type _XdrVec_unbounded_StoredTransactionSet []StoredTransactionSet

func (_XdrVec_unbounded_StoredTransactionSet) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_StoredTransactionSet) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_StoredTransactionSet length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_StoredTransactionSet length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_StoredTransactionSet) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_StoredTransactionSet) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]StoredTransactionSet, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_StoredTransactionSet) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_StoredTransactionSet(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_StoredTransactionSet) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_StoredTransactionSet) XdrTypeName() string { return "StoredTransactionSet<>" }
func (v *_XdrVec_unbounded_StoredTransactionSet) XdrPointer() interface{} {
	return (*[]StoredTransactionSet)(v)
}
func (v _XdrVec_unbounded_StoredTransactionSet) XdrValue() interface{} {
	return ([]StoredTransactionSet)(v)
}
func (v *_XdrVec_unbounded_StoredTransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PersistedSCPStateV0 = *PersistedSCPStateV0

func (v *PersistedSCPStateV0) XdrPointer() interface{}       { return v }
func (PersistedSCPStateV0) XdrTypeName() string              { return "PersistedSCPStateV0" }
func (v PersistedSCPStateV0) XdrValue() interface{}          { return v }
func (v *PersistedSCPStateV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PersistedSCPStateV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sscpEnvelopes", name), (*_XdrVec_unbounded_SCPEnvelope)(&v.ScpEnvelopes))
	x.Marshal(x.Sprintf("%squorumSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.QuorumSets))
	x.Marshal(x.Sprintf("%stxSets", name), (*_XdrVec_unbounded_StoredTransactionSet)(&v.TxSets))
}
func XDR_PersistedSCPStateV0(v *PersistedSCPStateV0) *PersistedSCPStateV0 { return v }

type XdrType_PersistedSCPStateV1 = *PersistedSCPStateV1

func (v *PersistedSCPStateV1) XdrPointer() interface{}       { return v }
func (PersistedSCPStateV1) XdrTypeName() string              { return "PersistedSCPStateV1" }
func (v PersistedSCPStateV1) XdrValue() interface{}          { return v }
func (v *PersistedSCPStateV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PersistedSCPStateV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sscpEnvelopes", name), (*_XdrVec_unbounded_SCPEnvelope)(&v.ScpEnvelopes))
	x.Marshal(x.Sprintf("%squorumSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.QuorumSets))
}
func XDR_PersistedSCPStateV1(v *PersistedSCPStateV1) *PersistedSCPStateV1 { return v }

var _XdrTags_PersistedSCPState = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ PersistedSCPState) XdrValidTags() map[int32]bool {
	return _XdrTags_PersistedSCPState
}
func (u *PersistedSCPState) V0() *PersistedSCPStateV0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*PersistedSCPStateV0); ok {
			return v
		} else {
			var zero PersistedSCPStateV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PersistedSCPState.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u *PersistedSCPState) V1() *PersistedSCPStateV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*PersistedSCPStateV1); ok {
			return v
		} else {
			var zero PersistedSCPStateV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PersistedSCPState.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u PersistedSCPState) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *PersistedSCPState) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *PersistedSCPState) XdrUnionTagName() string {
	return "V"
}
func (u *PersistedSCPState) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_PersistedSCPStateV0(u.V0())
	case 1:
		return XDR_PersistedSCPStateV1(u.V1())
	}
	return nil
}
func (u *PersistedSCPState) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_PersistedSCPState = *PersistedSCPState

func (v *PersistedSCPState) XdrPointer() interface{}       { return v }
func (PersistedSCPState) XdrTypeName() string              { return "PersistedSCPState" }
func (v PersistedSCPState) XdrValue() interface{}          { return v }
func (v *PersistedSCPState) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PersistedSCPState) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_PersistedSCPStateV0(u.V0()))
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_PersistedSCPStateV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in PersistedSCPState", u.V)
}
func XDR_PersistedSCPState(v *PersistedSCPState) *PersistedSCPState { return v }

type XdrType_ConfigSettingContractExecutionLanesV0 = *ConfigSettingContractExecutionLanesV0

func (v *ConfigSettingContractExecutionLanesV0) XdrPointer() interface{} { return v }
func (ConfigSettingContractExecutionLanesV0) XdrTypeName() string {
	return "ConfigSettingContractExecutionLanesV0"
}
func (v ConfigSettingContractExecutionLanesV0) XdrValue() interface{}          { return v }
func (v *ConfigSettingContractExecutionLanesV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigSettingContractExecutionLanesV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerMaxTxCount", name), XDR_Uint32(&v.LedgerMaxTxCount))
}
func XDR_ConfigSettingContractExecutionLanesV0(v *ConfigSettingContractExecutionLanesV0) *ConfigSettingContractExecutionLanesV0 {
	return v
}

type XdrType_ConfigSettingContractComputeV0 = *ConfigSettingContractComputeV0

func (v *ConfigSettingContractComputeV0) XdrPointer() interface{}       { return v }
func (ConfigSettingContractComputeV0) XdrTypeName() string              { return "ConfigSettingContractComputeV0" }
func (v ConfigSettingContractComputeV0) XdrValue() interface{}          { return v }
func (v *ConfigSettingContractComputeV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigSettingContractComputeV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerMaxInstructions", name), XDR_Int64(&v.LedgerMaxInstructions))
	x.Marshal(x.Sprintf("%stxMaxInstructions", name), XDR_Int64(&v.TxMaxInstructions))
	x.Marshal(x.Sprintf("%sfeeRatePerInstructionsIncrement", name), XDR_Int64(&v.FeeRatePerInstructionsIncrement))
	x.Marshal(x.Sprintf("%stxMemoryLimit", name), XDR_Uint32(&v.TxMemoryLimit))
}
func XDR_ConfigSettingContractComputeV0(v *ConfigSettingContractComputeV0) *ConfigSettingContractComputeV0 {
	return v
}

type XdrType_ConfigSettingContractLedgerCostV0 = *ConfigSettingContractLedgerCostV0

func (v *ConfigSettingContractLedgerCostV0) XdrPointer() interface{} { return v }
func (ConfigSettingContractLedgerCostV0) XdrTypeName() string {
	return "ConfigSettingContractLedgerCostV0"
}
func (v ConfigSettingContractLedgerCostV0) XdrValue() interface{}          { return v }
func (v *ConfigSettingContractLedgerCostV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigSettingContractLedgerCostV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerMaxReadLedgerEntries", name), XDR_Uint32(&v.LedgerMaxReadLedgerEntries))
	x.Marshal(x.Sprintf("%sledgerMaxReadBytes", name), XDR_Uint32(&v.LedgerMaxReadBytes))
	x.Marshal(x.Sprintf("%sledgerMaxWriteLedgerEntries", name), XDR_Uint32(&v.LedgerMaxWriteLedgerEntries))
	x.Marshal(x.Sprintf("%sledgerMaxWriteBytes", name), XDR_Uint32(&v.LedgerMaxWriteBytes))
	x.Marshal(x.Sprintf("%stxMaxReadLedgerEntries", name), XDR_Uint32(&v.TxMaxReadLedgerEntries))
	x.Marshal(x.Sprintf("%stxMaxReadBytes", name), XDR_Uint32(&v.TxMaxReadBytes))
	x.Marshal(x.Sprintf("%stxMaxWriteLedgerEntries", name), XDR_Uint32(&v.TxMaxWriteLedgerEntries))
	x.Marshal(x.Sprintf("%stxMaxWriteBytes", name), XDR_Uint32(&v.TxMaxWriteBytes))
	x.Marshal(x.Sprintf("%sfeeReadLedgerEntry", name), XDR_Int64(&v.FeeReadLedgerEntry))
	x.Marshal(x.Sprintf("%sfeeWriteLedgerEntry", name), XDR_Int64(&v.FeeWriteLedgerEntry))
	x.Marshal(x.Sprintf("%sfeeRead1KB", name), XDR_Int64(&v.FeeRead1KB))
	x.Marshal(x.Sprintf("%sbucketListTargetSizeBytes", name), XDR_Int64(&v.BucketListTargetSizeBytes))
	x.Marshal(x.Sprintf("%swriteFee1KBBucketListLow", name), XDR_Int64(&v.WriteFee1KBBucketListLow))
	x.Marshal(x.Sprintf("%swriteFee1KBBucketListHigh", name), XDR_Int64(&v.WriteFee1KBBucketListHigh))
	x.Marshal(x.Sprintf("%sbucketListWriteFeeGrowthFactor", name), XDR_Uint32(&v.BucketListWriteFeeGrowthFactor))
}
func XDR_ConfigSettingContractLedgerCostV0(v *ConfigSettingContractLedgerCostV0) *ConfigSettingContractLedgerCostV0 {
	return v
}

type XdrType_ConfigSettingContractHistoricalDataV0 = *ConfigSettingContractHistoricalDataV0

func (v *ConfigSettingContractHistoricalDataV0) XdrPointer() interface{} { return v }
func (ConfigSettingContractHistoricalDataV0) XdrTypeName() string {
	return "ConfigSettingContractHistoricalDataV0"
}
func (v ConfigSettingContractHistoricalDataV0) XdrValue() interface{}          { return v }
func (v *ConfigSettingContractHistoricalDataV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigSettingContractHistoricalDataV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfeeHistorical1KB", name), XDR_Int64(&v.FeeHistorical1KB))
}
func XDR_ConfigSettingContractHistoricalDataV0(v *ConfigSettingContractHistoricalDataV0) *ConfigSettingContractHistoricalDataV0 {
	return v
}

type XdrType_ConfigSettingContractEventsV0 = *ConfigSettingContractEventsV0

func (v *ConfigSettingContractEventsV0) XdrPointer() interface{}       { return v }
func (ConfigSettingContractEventsV0) XdrTypeName() string              { return "ConfigSettingContractEventsV0" }
func (v ConfigSettingContractEventsV0) XdrValue() interface{}          { return v }
func (v *ConfigSettingContractEventsV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigSettingContractEventsV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxMaxContractEventsSizeBytes", name), XDR_Uint32(&v.TxMaxContractEventsSizeBytes))
	x.Marshal(x.Sprintf("%sfeeContractEvents1KB", name), XDR_Int64(&v.FeeContractEvents1KB))
}
func XDR_ConfigSettingContractEventsV0(v *ConfigSettingContractEventsV0) *ConfigSettingContractEventsV0 {
	return v
}

type XdrType_ConfigSettingContractBandwidthV0 = *ConfigSettingContractBandwidthV0

func (v *ConfigSettingContractBandwidthV0) XdrPointer() interface{} { return v }
func (ConfigSettingContractBandwidthV0) XdrTypeName() string {
	return "ConfigSettingContractBandwidthV0"
}
func (v ConfigSettingContractBandwidthV0) XdrValue() interface{}          { return v }
func (v *ConfigSettingContractBandwidthV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigSettingContractBandwidthV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerMaxTxsSizeBytes", name), XDR_Uint32(&v.LedgerMaxTxsSizeBytes))
	x.Marshal(x.Sprintf("%stxMaxSizeBytes", name), XDR_Uint32(&v.TxMaxSizeBytes))
	x.Marshal(x.Sprintf("%sfeeTxSize1KB", name), XDR_Int64(&v.FeeTxSize1KB))
}
func XDR_ConfigSettingContractBandwidthV0(v *ConfigSettingContractBandwidthV0) *ConfigSettingContractBandwidthV0 {
	return v
}

var _XdrNames_ContractCostType = map[int32]string{
	int32(WasmInsnExec):                    "WasmInsnExec",
	int32(MemAlloc):                        "MemAlloc",
	int32(MemCpy):                          "MemCpy",
	int32(MemCmp):                          "MemCmp",
	int32(DispatchHostFunction):            "DispatchHostFunction",
	int32(VisitObject):                     "VisitObject",
	int32(ValSer):                          "ValSer",
	int32(ValDeser):                        "ValDeser",
	int32(ComputeSha256Hash):               "ComputeSha256Hash",
	int32(ComputeEd25519PubKey):            "ComputeEd25519PubKey",
	int32(VerifyEd25519Sig):                "VerifyEd25519Sig",
	int32(VmInstantiation):                 "VmInstantiation",
	int32(VmCachedInstantiation):           "VmCachedInstantiation",
	int32(InvokeVmFunction):                "InvokeVmFunction",
	int32(ComputeKeccak256Hash):            "ComputeKeccak256Hash",
	int32(DecodeEcdsaCurve256Sig):          "DecodeEcdsaCurve256Sig",
	int32(RecoverEcdsaSecp256k1Key):        "RecoverEcdsaSecp256k1Key",
	int32(Int256AddSub):                    "Int256AddSub",
	int32(Int256Mul):                       "Int256Mul",
	int32(Int256Div):                       "Int256Div",
	int32(Int256Pow):                       "Int256Pow",
	int32(Int256Shift):                     "Int256Shift",
	int32(ChaCha20DrawBytes):               "ChaCha20DrawBytes",
	int32(ParseWasmInstructions):           "ParseWasmInstructions",
	int32(ParseWasmFunctions):              "ParseWasmFunctions",
	int32(ParseWasmGlobals):                "ParseWasmGlobals",
	int32(ParseWasmTableEntries):           "ParseWasmTableEntries",
	int32(ParseWasmTypes):                  "ParseWasmTypes",
	int32(ParseWasmDataSegments):           "ParseWasmDataSegments",
	int32(ParseWasmElemSegments):           "ParseWasmElemSegments",
	int32(ParseWasmImports):                "ParseWasmImports",
	int32(ParseWasmExports):                "ParseWasmExports",
	int32(ParseWasmDataSegmentBytes):       "ParseWasmDataSegmentBytes",
	int32(InstantiateWasmInstructions):     "InstantiateWasmInstructions",
	int32(InstantiateWasmFunctions):        "InstantiateWasmFunctions",
	int32(InstantiateWasmGlobals):          "InstantiateWasmGlobals",
	int32(InstantiateWasmTableEntries):     "InstantiateWasmTableEntries",
	int32(InstantiateWasmTypes):            "InstantiateWasmTypes",
	int32(InstantiateWasmDataSegments):     "InstantiateWasmDataSegments",
	int32(InstantiateWasmElemSegments):     "InstantiateWasmElemSegments",
	int32(InstantiateWasmImports):          "InstantiateWasmImports",
	int32(InstantiateWasmExports):          "InstantiateWasmExports",
	int32(InstantiateWasmDataSegmentBytes): "InstantiateWasmDataSegmentBytes",
	int32(Sec1DecodePointUncompressed):     "Sec1DecodePointUncompressed",
	int32(VerifyEcdsaSecp256r1Sig):         "VerifyEcdsaSecp256r1Sig",
}
var _XdrValues_ContractCostType = map[string]int32{
	"WasmInsnExec":                    int32(WasmInsnExec),
	"MemAlloc":                        int32(MemAlloc),
	"MemCpy":                          int32(MemCpy),
	"MemCmp":                          int32(MemCmp),
	"DispatchHostFunction":            int32(DispatchHostFunction),
	"VisitObject":                     int32(VisitObject),
	"ValSer":                          int32(ValSer),
	"ValDeser":                        int32(ValDeser),
	"ComputeSha256Hash":               int32(ComputeSha256Hash),
	"ComputeEd25519PubKey":            int32(ComputeEd25519PubKey),
	"VerifyEd25519Sig":                int32(VerifyEd25519Sig),
	"VmInstantiation":                 int32(VmInstantiation),
	"VmCachedInstantiation":           int32(VmCachedInstantiation),
	"InvokeVmFunction":                int32(InvokeVmFunction),
	"ComputeKeccak256Hash":            int32(ComputeKeccak256Hash),
	"DecodeEcdsaCurve256Sig":          int32(DecodeEcdsaCurve256Sig),
	"RecoverEcdsaSecp256k1Key":        int32(RecoverEcdsaSecp256k1Key),
	"Int256AddSub":                    int32(Int256AddSub),
	"Int256Mul":                       int32(Int256Mul),
	"Int256Div":                       int32(Int256Div),
	"Int256Pow":                       int32(Int256Pow),
	"Int256Shift":                     int32(Int256Shift),
	"ChaCha20DrawBytes":               int32(ChaCha20DrawBytes),
	"ParseWasmInstructions":           int32(ParseWasmInstructions),
	"ParseWasmFunctions":              int32(ParseWasmFunctions),
	"ParseWasmGlobals":                int32(ParseWasmGlobals),
	"ParseWasmTableEntries":           int32(ParseWasmTableEntries),
	"ParseWasmTypes":                  int32(ParseWasmTypes),
	"ParseWasmDataSegments":           int32(ParseWasmDataSegments),
	"ParseWasmElemSegments":           int32(ParseWasmElemSegments),
	"ParseWasmImports":                int32(ParseWasmImports),
	"ParseWasmExports":                int32(ParseWasmExports),
	"ParseWasmDataSegmentBytes":       int32(ParseWasmDataSegmentBytes),
	"InstantiateWasmInstructions":     int32(InstantiateWasmInstructions),
	"InstantiateWasmFunctions":        int32(InstantiateWasmFunctions),
	"InstantiateWasmGlobals":          int32(InstantiateWasmGlobals),
	"InstantiateWasmTableEntries":     int32(InstantiateWasmTableEntries),
	"InstantiateWasmTypes":            int32(InstantiateWasmTypes),
	"InstantiateWasmDataSegments":     int32(InstantiateWasmDataSegments),
	"InstantiateWasmElemSegments":     int32(InstantiateWasmElemSegments),
	"InstantiateWasmImports":          int32(InstantiateWasmImports),
	"InstantiateWasmExports":          int32(InstantiateWasmExports),
	"InstantiateWasmDataSegmentBytes": int32(InstantiateWasmDataSegmentBytes),
	"Sec1DecodePointUncompressed":     int32(Sec1DecodePointUncompressed),
	"VerifyEcdsaSecp256r1Sig":         int32(VerifyEcdsaSecp256r1Sig),
}

func (ContractCostType) XdrEnumNames() map[int32]string {
	return _XdrNames_ContractCostType
}
func (v ContractCostType) String() string {
	if s, ok := _XdrNames_ContractCostType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ContractCostType#%d", v)
}
func (v *ContractCostType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ContractCostType[stok]; ok {
			*v = ContractCostType(val)
			return nil
		} else if stok == "ContractCostType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ContractCostType.", stok))
	}
}
func (v ContractCostType) GetU32() uint32                 { return uint32(v) }
func (v *ContractCostType) SetU32(n uint32)               { *v = ContractCostType(n) }
func (v *ContractCostType) XdrPointer() interface{}       { return v }
func (ContractCostType) XdrTypeName() string              { return "ContractCostType" }
func (v ContractCostType) XdrValue() interface{}          { return v }
func (v *ContractCostType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ContractCostType = *ContractCostType

func XDR_ContractCostType(v *ContractCostType) *ContractCostType { return v }

var _XdrComments_ContractCostType = map[int32]string{
	int32(WasmInsnExec):                    "Cost of running 1 wasm instruction",
	int32(MemAlloc):                        "Cost of allocating a slice of memory (in bytes)",
	int32(MemCpy):                          "Cost of copying a slice of bytes into a pre-allocated memory",
	int32(MemCmp):                          "Cost of comparing two slices of memory",
	int32(DispatchHostFunction):            "Cost of a host function dispatch, not including the actual work done by the function nor the cost of VM invocation machinary",
	int32(VisitObject):                     "Cost of visiting a host object from the host object storage. Exists to make sure some baseline cost coverage, i.e. repeatly visiting objects by the guest will always incur some charges.",
	int32(ValSer):                          "Cost of serializing an xdr object to bytes",
	int32(ValDeser):                        "Cost of deserializing an xdr object from bytes",
	int32(ComputeSha256Hash):               "Cost of computing the sha256 hash from bytes",
	int32(ComputeEd25519PubKey):            "Cost of computing the ed25519 pubkey from bytes",
	int32(VerifyEd25519Sig):                "Cost of verifying ed25519 signature of a payload.",
	int32(VmInstantiation):                 "Cost of instantiation a VM from wasm bytes code.",
	int32(VmCachedInstantiation):           "Cost of instantiation a VM from a cached state.",
	int32(InvokeVmFunction):                "Cost of invoking a function on the VM. If the function is a host function, additional cost will be covered by `DispatchHostFunction`.",
	int32(ComputeKeccak256Hash):            "Cost of computing a keccak256 hash from bytes.",
	int32(DecodeEcdsaCurve256Sig):          "Cost of decoding an ECDSA signature computed from a 256-bit prime modulus curve (e.g. secp256k1 and secp256r1)",
	int32(RecoverEcdsaSecp256k1Key):        "Cost of recovering an ECDSA secp256k1 key from a signature.",
	int32(Int256AddSub):                    "Cost of int256 addition (`+`) and subtraction (`-`) operations",
	int32(Int256Mul):                       "Cost of int256 multiplication (`*`) operation",
	int32(Int256Div):                       "Cost of int256 division (`/`) operation",
	int32(Int256Pow):                       "Cost of int256 power (`exp`) operation",
	int32(Int256Shift):                     "Cost of int256 shift (`shl`, `shr`) operation",
	int32(ChaCha20DrawBytes):               "Cost of drawing random bytes using a ChaCha20 PRNG",
	int32(ParseWasmInstructions):           "Cost of parsing wasm bytes that only encode instructions.",
	int32(ParseWasmFunctions):              "Cost of parsing a known number of wasm functions.",
	int32(ParseWasmGlobals):                "Cost of parsing a known number of wasm globals.",
	int32(ParseWasmTableEntries):           "Cost of parsing a known number of wasm table entries.",
	int32(ParseWasmTypes):                  "Cost of parsing a known number of wasm types.",
	int32(ParseWasmDataSegments):           "Cost of parsing a known number of wasm data segments.",
	int32(ParseWasmElemSegments):           "Cost of parsing a known number of wasm element segments.",
	int32(ParseWasmImports):                "Cost of parsing a known number of wasm imports.",
	int32(ParseWasmExports):                "Cost of parsing a known number of wasm exports.",
	int32(ParseWasmDataSegmentBytes):       "Cost of parsing a known number of data segment bytes.",
	int32(InstantiateWasmInstructions):     "Cost of instantiating wasm bytes that only encode instructions.",
	int32(InstantiateWasmFunctions):        "Cost of instantiating a known number of wasm functions.",
	int32(InstantiateWasmGlobals):          "Cost of instantiating a known number of wasm globals.",
	int32(InstantiateWasmTableEntries):     "Cost of instantiating a known number of wasm table entries.",
	int32(InstantiateWasmTypes):            "Cost of instantiating a known number of wasm types.",
	int32(InstantiateWasmDataSegments):     "Cost of instantiating a known number of wasm data segments.",
	int32(InstantiateWasmElemSegments):     "Cost of instantiating a known number of wasm element segments.",
	int32(InstantiateWasmImports):          "Cost of instantiating a known number of wasm imports.",
	int32(InstantiateWasmExports):          "Cost of instantiating a known number of wasm exports.",
	int32(InstantiateWasmDataSegmentBytes): "Cost of instantiating a known number of data segment bytes.",
	int32(Sec1DecodePointUncompressed):     "Cost of decoding a bytes array representing an uncompressed SEC-1 encoded point on a 256-bit elliptic curve",
	int32(VerifyEcdsaSecp256r1Sig):         "Cost of verifying an ECDSA Secp256r1 signature",
}

func (e ContractCostType) XdrEnumComments() map[int32]string {
	return _XdrComments_ContractCostType
}

type XdrType_ContractCostParamEntry = *ContractCostParamEntry

func (v *ContractCostParamEntry) XdrPointer() interface{}       { return v }
func (ContractCostParamEntry) XdrTypeName() string              { return "ContractCostParamEntry" }
func (v ContractCostParamEntry) XdrValue() interface{}          { return v }
func (v *ContractCostParamEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ContractCostParamEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%sconstTerm", name), XDR_Int64(&v.ConstTerm))
	x.Marshal(x.Sprintf("%slinearTerm", name), XDR_Int64(&v.LinearTerm))
}
func XDR_ContractCostParamEntry(v *ContractCostParamEntry) *ContractCostParamEntry { return v }

type XdrType_StateArchivalSettings = *StateArchivalSettings

func (v *StateArchivalSettings) XdrPointer() interface{}       { return v }
func (StateArchivalSettings) XdrTypeName() string              { return "StateArchivalSettings" }
func (v StateArchivalSettings) XdrValue() interface{}          { return v }
func (v *StateArchivalSettings) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *StateArchivalSettings) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%smaxEntryTTL", name), XDR_Uint32(&v.MaxEntryTTL))
	x.Marshal(x.Sprintf("%sminTemporaryTTL", name), XDR_Uint32(&v.MinTemporaryTTL))
	x.Marshal(x.Sprintf("%sminPersistentTTL", name), XDR_Uint32(&v.MinPersistentTTL))
	x.Marshal(x.Sprintf("%spersistentRentRateDenominator", name), XDR_Int64(&v.PersistentRentRateDenominator))
	x.Marshal(x.Sprintf("%stempRentRateDenominator", name), XDR_Int64(&v.TempRentRateDenominator))
	x.Marshal(x.Sprintf("%smaxEntriesToArchive", name), XDR_Uint32(&v.MaxEntriesToArchive))
	x.Marshal(x.Sprintf("%sbucketListSizeWindowSampleSize", name), XDR_Uint32(&v.BucketListSizeWindowSampleSize))
	x.Marshal(x.Sprintf("%sbucketListWindowSamplePeriod", name), XDR_Uint32(&v.BucketListWindowSamplePeriod))
	x.Marshal(x.Sprintf("%sevictionScanSize", name), XDR_Uint32(&v.EvictionScanSize))
	x.Marshal(x.Sprintf("%sstartingEvictionScanLevel", name), XDR_Uint32(&v.StartingEvictionScanLevel))
}
func XDR_StateArchivalSettings(v *StateArchivalSettings) *StateArchivalSettings { return v }

type XdrType_EvictionIterator = *EvictionIterator

func (v *EvictionIterator) XdrPointer() interface{}       { return v }
func (EvictionIterator) XdrTypeName() string              { return "EvictionIterator" }
func (v EvictionIterator) XdrValue() interface{}          { return v }
func (v *EvictionIterator) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *EvictionIterator) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbucketListLevel", name), XDR_Uint32(&v.BucketListLevel))
	x.Marshal(x.Sprintf("%sisCurrBucket", name), XDR_bool(&v.IsCurrBucket))
	x.Marshal(x.Sprintf("%sbucketFileOffset", name), XDR_Uint64(&v.BucketFileOffset))
}
func XDR_EvictionIterator(v *EvictionIterator) *EvictionIterator { return v }

type _XdrVec_1024_ContractCostParamEntry []ContractCostParamEntry

func (_XdrVec_1024_ContractCostParamEntry) XdrBound() uint32 {
	const bound uint32 = 1024 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_1024_ContractCostParamEntry) XdrCheckLen(length uint32) {
	if length > uint32(1024) {
		XdrPanic("_XdrVec_1024_ContractCostParamEntry length %d exceeds bound 1024", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_1024_ContractCostParamEntry length %d exceeds max int", length)
	}
}
func (v _XdrVec_1024_ContractCostParamEntry) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_1024_ContractCostParamEntry) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(1024); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ContractCostParamEntry, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_1024_ContractCostParamEntry) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_ContractCostParamEntry(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_1024_ContractCostParamEntry) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 1024}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_1024_ContractCostParamEntry) XdrTypeName() string { return "ContractCostParamEntry<>" }
func (v *_XdrVec_1024_ContractCostParamEntry) XdrPointer() interface{} {
	return (*[]ContractCostParamEntry)(v)
}
func (v _XdrVec_1024_ContractCostParamEntry) XdrValue() interface{} {
	return ([]ContractCostParamEntry)(v)
}
func (v *_XdrVec_1024_ContractCostParamEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ContractCostParams struct {
	*_XdrVec_1024_ContractCostParamEntry
}

func XDR_ContractCostParams(v *ContractCostParams) XdrType_ContractCostParams {
	return XdrType_ContractCostParams{(*_XdrVec_1024_ContractCostParamEntry)(v)}
}
func (XdrType_ContractCostParams) XdrTypeName() string  { return "ContractCostParams" }
func (v XdrType_ContractCostParams) XdrUnwrap() XdrType { return v._XdrVec_1024_ContractCostParamEntry }

var _XdrNames_ConfigSettingID = map[int32]string{
	int32(CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES):               "CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES",
	int32(CONFIG_SETTING_CONTRACT_COMPUTE_V0):                   "CONFIG_SETTING_CONTRACT_COMPUTE_V0",
	int32(CONFIG_SETTING_CONTRACT_LEDGER_COST_V0):               "CONFIG_SETTING_CONTRACT_LEDGER_COST_V0",
	int32(CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0):           "CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0",
	int32(CONFIG_SETTING_CONTRACT_EVENTS_V0):                    "CONFIG_SETTING_CONTRACT_EVENTS_V0",
	int32(CONFIG_SETTING_CONTRACT_BANDWIDTH_V0):                 "CONFIG_SETTING_CONTRACT_BANDWIDTH_V0",
	int32(CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS): "CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS",
	int32(CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES):     "CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES",
	int32(CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES):          "CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES",
	int32(CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES):        "CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES",
	int32(CONFIG_SETTING_STATE_ARCHIVAL):                        "CONFIG_SETTING_STATE_ARCHIVAL",
	int32(CONFIG_SETTING_CONTRACT_EXECUTION_LANES):              "CONFIG_SETTING_CONTRACT_EXECUTION_LANES",
	int32(CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW):                "CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW",
	int32(CONFIG_SETTING_EVICTION_ITERATOR):                     "CONFIG_SETTING_EVICTION_ITERATOR",
}
var _XdrValues_ConfigSettingID = map[string]int32{
	"CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES":               int32(CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES),
	"CONFIG_SETTING_CONTRACT_COMPUTE_V0":                   int32(CONFIG_SETTING_CONTRACT_COMPUTE_V0),
	"CONFIG_SETTING_CONTRACT_LEDGER_COST_V0":               int32(CONFIG_SETTING_CONTRACT_LEDGER_COST_V0),
	"CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0":           int32(CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0),
	"CONFIG_SETTING_CONTRACT_EVENTS_V0":                    int32(CONFIG_SETTING_CONTRACT_EVENTS_V0),
	"CONFIG_SETTING_CONTRACT_BANDWIDTH_V0":                 int32(CONFIG_SETTING_CONTRACT_BANDWIDTH_V0),
	"CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS": int32(CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS),
	"CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES":     int32(CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES),
	"CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES":          int32(CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES),
	"CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES":        int32(CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES),
	"CONFIG_SETTING_STATE_ARCHIVAL":                        int32(CONFIG_SETTING_STATE_ARCHIVAL),
	"CONFIG_SETTING_CONTRACT_EXECUTION_LANES":              int32(CONFIG_SETTING_CONTRACT_EXECUTION_LANES),
	"CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW":                int32(CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW),
	"CONFIG_SETTING_EVICTION_ITERATOR":                     int32(CONFIG_SETTING_EVICTION_ITERATOR),
}

func (ConfigSettingID) XdrEnumNames() map[int32]string {
	return _XdrNames_ConfigSettingID
}
func (v ConfigSettingID) String() string {
	if s, ok := _XdrNames_ConfigSettingID[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ConfigSettingID#%d", v)
}
func (v *ConfigSettingID) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ConfigSettingID[stok]; ok {
			*v = ConfigSettingID(val)
			return nil
		} else if stok == "ConfigSettingID" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ConfigSettingID.", stok))
	}
}
func (v ConfigSettingID) GetU32() uint32                 { return uint32(v) }
func (v *ConfigSettingID) SetU32(n uint32)               { *v = ConfigSettingID(n) }
func (v *ConfigSettingID) XdrPointer() interface{}       { return v }
func (ConfigSettingID) XdrTypeName() string              { return "ConfigSettingID" }
func (v ConfigSettingID) XdrValue() interface{}          { return v }
func (v *ConfigSettingID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ConfigSettingID = *ConfigSettingID

func XDR_ConfigSettingID(v *ConfigSettingID) *ConfigSettingID { return v }

type _XdrVec_unbounded_Uint64 []Uint64

func (_XdrVec_unbounded_Uint64) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Uint64) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Uint64 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Uint64 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Uint64) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Uint64) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Uint64, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Uint64) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Uint64(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Uint64) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Uint64) XdrTypeName() string              { return "Uint64<>" }
func (v *_XdrVec_unbounded_Uint64) XdrPointer() interface{}       { return (*[]Uint64)(v) }
func (v _XdrVec_unbounded_Uint64) XdrValue() interface{}          { return ([]Uint64)(v) }
func (v *_XdrVec_unbounded_Uint64) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_ConfigSettingEntry = map[int32]bool{
	XdrToI32(CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES):               true,
	XdrToI32(CONFIG_SETTING_CONTRACT_COMPUTE_V0):                   true,
	XdrToI32(CONFIG_SETTING_CONTRACT_LEDGER_COST_V0):               true,
	XdrToI32(CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0):           true,
	XdrToI32(CONFIG_SETTING_CONTRACT_EVENTS_V0):                    true,
	XdrToI32(CONFIG_SETTING_CONTRACT_BANDWIDTH_V0):                 true,
	XdrToI32(CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS): true,
	XdrToI32(CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES):     true,
	XdrToI32(CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES):          true,
	XdrToI32(CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES):        true,
	XdrToI32(CONFIG_SETTING_STATE_ARCHIVAL):                        true,
	XdrToI32(CONFIG_SETTING_CONTRACT_EXECUTION_LANES):              true,
	XdrToI32(CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW):                true,
	XdrToI32(CONFIG_SETTING_EVICTION_ITERATOR):                     true,
}

func (_ ConfigSettingEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_ConfigSettingEntry
}
func (u *ConfigSettingEntry) ContractMaxSizeBytes() *Uint32 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractMaxSizeBytes accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractCompute() *ConfigSettingContractComputeV0 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_COMPUTE_V0:
		if v, ok := u._u.(*ConfigSettingContractComputeV0); ok {
			return v
		} else {
			var zero ConfigSettingContractComputeV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractCompute accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractLedgerCost() *ConfigSettingContractLedgerCostV0 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_LEDGER_COST_V0:
		if v, ok := u._u.(*ConfigSettingContractLedgerCostV0); ok {
			return v
		} else {
			var zero ConfigSettingContractLedgerCostV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractLedgerCost accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractHistoricalData() *ConfigSettingContractHistoricalDataV0 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0:
		if v, ok := u._u.(*ConfigSettingContractHistoricalDataV0); ok {
			return v
		} else {
			var zero ConfigSettingContractHistoricalDataV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractHistoricalData accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractEvents() *ConfigSettingContractEventsV0 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_EVENTS_V0:
		if v, ok := u._u.(*ConfigSettingContractEventsV0); ok {
			return v
		} else {
			var zero ConfigSettingContractEventsV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractEvents accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractBandwidth() *ConfigSettingContractBandwidthV0 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_BANDWIDTH_V0:
		if v, ok := u._u.(*ConfigSettingContractBandwidthV0); ok {
			return v
		} else {
			var zero ConfigSettingContractBandwidthV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractBandwidth accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractCostParamsCpuInsns() *ContractCostParams {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS:
		if v, ok := u._u.(*ContractCostParams); ok {
			return v
		} else {
			var zero ContractCostParams
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractCostParamsCpuInsns accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractCostParamsMemBytes() *ContractCostParams {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES:
		if v, ok := u._u.(*ContractCostParams); ok {
			return v
		} else {
			var zero ContractCostParams
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractCostParamsMemBytes accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractDataKeySizeBytes() *Uint32 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractDataKeySizeBytes accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractDataEntrySizeBytes() *Uint32 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractDataEntrySizeBytes accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) StateArchivalSettings() *StateArchivalSettings {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_STATE_ARCHIVAL:
		if v, ok := u._u.(*StateArchivalSettings); ok {
			return v
		} else {
			var zero StateArchivalSettings
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.StateArchivalSettings accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) ContractExecutionLanes() *ConfigSettingContractExecutionLanesV0 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_EXECUTION_LANES:
		if v, ok := u._u.(*ConfigSettingContractExecutionLanesV0); ok {
			return v
		} else {
			var zero ConfigSettingContractExecutionLanesV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.ContractExecutionLanes accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) BucketListSizeWindow() *[]Uint64 {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW:
		if v, ok := u._u.(*[]Uint64); ok {
			return v
		} else {
			var zero []Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.BucketListSizeWindow accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u *ConfigSettingEntry) EvictionIterator() *EvictionIterator {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_EVICTION_ITERATOR:
		if v, ok := u._u.(*EvictionIterator); ok {
			return v
		} else {
			var zero EvictionIterator
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSettingEntry.EvictionIterator accessed when ConfigSettingID == %v", u.ConfigSettingID)
		return nil
	}
}
func (u ConfigSettingEntry) XdrValid() bool {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES, CONFIG_SETTING_CONTRACT_COMPUTE_V0, CONFIG_SETTING_CONTRACT_LEDGER_COST_V0, CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0, CONFIG_SETTING_CONTRACT_EVENTS_V0, CONFIG_SETTING_CONTRACT_BANDWIDTH_V0, CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS, CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES, CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES, CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES, CONFIG_SETTING_STATE_ARCHIVAL, CONFIG_SETTING_CONTRACT_EXECUTION_LANES, CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW, CONFIG_SETTING_EVICTION_ITERATOR:
		return true
	}
	return false
}
func (u *ConfigSettingEntry) XdrUnionTag() XdrNum32 {
	return XDR_ConfigSettingID(&u.ConfigSettingID)
}
func (u *ConfigSettingEntry) XdrUnionTagName() string {
	return "ConfigSettingID"
}
func (u *ConfigSettingEntry) XdrUnionBody() XdrType {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES:
		return XDR_Uint32(u.ContractMaxSizeBytes())
	case CONFIG_SETTING_CONTRACT_COMPUTE_V0:
		return XDR_ConfigSettingContractComputeV0(u.ContractCompute())
	case CONFIG_SETTING_CONTRACT_LEDGER_COST_V0:
		return XDR_ConfigSettingContractLedgerCostV0(u.ContractLedgerCost())
	case CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0:
		return XDR_ConfigSettingContractHistoricalDataV0(u.ContractHistoricalData())
	case CONFIG_SETTING_CONTRACT_EVENTS_V0:
		return XDR_ConfigSettingContractEventsV0(u.ContractEvents())
	case CONFIG_SETTING_CONTRACT_BANDWIDTH_V0:
		return XDR_ConfigSettingContractBandwidthV0(u.ContractBandwidth())
	case CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS:
		return XDR_ContractCostParams(u.ContractCostParamsCpuInsns())
	case CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES:
		return XDR_ContractCostParams(u.ContractCostParamsMemBytes())
	case CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES:
		return XDR_Uint32(u.ContractDataKeySizeBytes())
	case CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES:
		return XDR_Uint32(u.ContractDataEntrySizeBytes())
	case CONFIG_SETTING_STATE_ARCHIVAL:
		return XDR_StateArchivalSettings(u.StateArchivalSettings())
	case CONFIG_SETTING_CONTRACT_EXECUTION_LANES:
		return XDR_ConfigSettingContractExecutionLanesV0(u.ContractExecutionLanes())
	case CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW:
		return (*_XdrVec_unbounded_Uint64)(u.BucketListSizeWindow())
	case CONFIG_SETTING_EVICTION_ITERATOR:
		return XDR_EvictionIterator(u.EvictionIterator())
	}
	return nil
}
func (u *ConfigSettingEntry) XdrUnionBodyName() string {
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES:
		return "ContractMaxSizeBytes"
	case CONFIG_SETTING_CONTRACT_COMPUTE_V0:
		return "ContractCompute"
	case CONFIG_SETTING_CONTRACT_LEDGER_COST_V0:
		return "ContractLedgerCost"
	case CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0:
		return "ContractHistoricalData"
	case CONFIG_SETTING_CONTRACT_EVENTS_V0:
		return "ContractEvents"
	case CONFIG_SETTING_CONTRACT_BANDWIDTH_V0:
		return "ContractBandwidth"
	case CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS:
		return "ContractCostParamsCpuInsns"
	case CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES:
		return "ContractCostParamsMemBytes"
	case CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES:
		return "ContractDataKeySizeBytes"
	case CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES:
		return "ContractDataEntrySizeBytes"
	case CONFIG_SETTING_STATE_ARCHIVAL:
		return "StateArchivalSettings"
	case CONFIG_SETTING_CONTRACT_EXECUTION_LANES:
		return "ContractExecutionLanes"
	case CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW:
		return "BucketListSizeWindow"
	case CONFIG_SETTING_EVICTION_ITERATOR:
		return "EvictionIterator"
	}
	return ""
}

type XdrType_ConfigSettingEntry = *ConfigSettingEntry

func (v *ConfigSettingEntry) XdrPointer() interface{}       { return v }
func (ConfigSettingEntry) XdrTypeName() string              { return "ConfigSettingEntry" }
func (v ConfigSettingEntry) XdrValue() interface{}          { return v }
func (v *ConfigSettingEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ConfigSettingEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ConfigSettingID(&u.ConfigSettingID).XdrMarshal(x, x.Sprintf("%sconfigSettingID", name))
	switch u.ConfigSettingID {
	case CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES:
		x.Marshal(x.Sprintf("%scontractMaxSizeBytes", name), XDR_Uint32(u.ContractMaxSizeBytes()))
		return
	case CONFIG_SETTING_CONTRACT_COMPUTE_V0:
		x.Marshal(x.Sprintf("%scontractCompute", name), XDR_ConfigSettingContractComputeV0(u.ContractCompute()))
		return
	case CONFIG_SETTING_CONTRACT_LEDGER_COST_V0:
		x.Marshal(x.Sprintf("%scontractLedgerCost", name), XDR_ConfigSettingContractLedgerCostV0(u.ContractLedgerCost()))
		return
	case CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0:
		x.Marshal(x.Sprintf("%scontractHistoricalData", name), XDR_ConfigSettingContractHistoricalDataV0(u.ContractHistoricalData()))
		return
	case CONFIG_SETTING_CONTRACT_EVENTS_V0:
		x.Marshal(x.Sprintf("%scontractEvents", name), XDR_ConfigSettingContractEventsV0(u.ContractEvents()))
		return
	case CONFIG_SETTING_CONTRACT_BANDWIDTH_V0:
		x.Marshal(x.Sprintf("%scontractBandwidth", name), XDR_ConfigSettingContractBandwidthV0(u.ContractBandwidth()))
		return
	case CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS:
		x.Marshal(x.Sprintf("%scontractCostParamsCpuInsns", name), XDR_ContractCostParams(u.ContractCostParamsCpuInsns()))
		return
	case CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES:
		x.Marshal(x.Sprintf("%scontractCostParamsMemBytes", name), XDR_ContractCostParams(u.ContractCostParamsMemBytes()))
		return
	case CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES:
		x.Marshal(x.Sprintf("%scontractDataKeySizeBytes", name), XDR_Uint32(u.ContractDataKeySizeBytes()))
		return
	case CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES:
		x.Marshal(x.Sprintf("%scontractDataEntrySizeBytes", name), XDR_Uint32(u.ContractDataEntrySizeBytes()))
		return
	case CONFIG_SETTING_STATE_ARCHIVAL:
		x.Marshal(x.Sprintf("%sstateArchivalSettings", name), XDR_StateArchivalSettings(u.StateArchivalSettings()))
		return
	case CONFIG_SETTING_CONTRACT_EXECUTION_LANES:
		x.Marshal(x.Sprintf("%scontractExecutionLanes", name), XDR_ConfigSettingContractExecutionLanesV0(u.ContractExecutionLanes()))
		return
	case CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW:
		x.Marshal(x.Sprintf("%sbucketListSizeWindow", name), (*_XdrVec_unbounded_Uint64)(u.BucketListSizeWindow()))
		return
	case CONFIG_SETTING_EVICTION_ITERATOR:
		x.Marshal(x.Sprintf("%sevictionIterator", name), XDR_EvictionIterator(u.EvictionIterator()))
		return
	}
	XdrPanic("invalid ConfigSettingID (%v) in ConfigSettingEntry", u.ConfigSettingID)
}
func XDR_ConfigSettingEntry(v *ConfigSettingEntry) *ConfigSettingEntry { return v }

type XdrType_BitmapIndex = *BitmapIndex

func (v *BitmapIndex) XdrPointer() interface{}       { return v }
func (BitmapIndex) XdrTypeName() string              { return "BitmapIndex" }
func (v BitmapIndex) XdrValue() interface{}          { return v }
func (v *BitmapIndex) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BitmapIndex) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfirstBit", name), XDR_Uint32(&v.FirstBit))
	x.Marshal(x.Sprintf("%slastBit", name), XDR_Uint32(&v.LastBit))
	x.Marshal(x.Sprintf("%sbitmap", name), XDR_Value(&v.Bitmap))
}
func XDR_BitmapIndex(v *BitmapIndex) *BitmapIndex { return v }

type XdrType_TrieIndex = *TrieIndex

func (v *TrieIndex) XdrPointer() interface{}       { return v }
func (TrieIndex) XdrTypeName() string              { return "TrieIndex" }
func (v TrieIndex) XdrValue() interface{}          { return v }
func (v *TrieIndex) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TrieIndex) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sversion_", name), XDR_Uint32(&v.Version_))
	x.Marshal(x.Sprintf("%sroot", name), XDR_TrieNode(&v.Root))
}
func XDR_TrieIndex(v *TrieIndex) *TrieIndex { return v }

type _XdrArray_1_opaque [1]byte

func (v *_XdrArray_1_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_1_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_1_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_1_opaque) XdrPointer() interface{}       { return (*[1]byte)(v) }
func (v *_XdrArray_1_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_1_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_1_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_1_opaque) XdrArraySize() uint32 {
	const bound uint32 = 1 // Force error if not const or doesn't fit
	return bound
}

type XdrType_TrieNodeChild = *TrieNodeChild

func (v *TrieNodeChild) XdrPointer() interface{}       { return v }
func (TrieNodeChild) XdrTypeName() string              { return "TrieNodeChild" }
func (v TrieNodeChild) XdrValue() interface{}          { return v }
func (v *TrieNodeChild) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TrieNodeChild) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), (*_XdrArray_1_opaque)(&v.Key))
	x.Marshal(x.Sprintf("%snode", name), XDR_TrieNode(&v.Node))
}
func XDR_TrieNodeChild(v *TrieNodeChild) *TrieNodeChild { return v }

type _XdrVec_unbounded_TrieNodeChild []TrieNodeChild

func (_XdrVec_unbounded_TrieNodeChild) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TrieNodeChild) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TrieNodeChild length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TrieNodeChild length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TrieNodeChild) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TrieNodeChild) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TrieNodeChild, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TrieNodeChild) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TrieNodeChild(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TrieNodeChild) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TrieNodeChild) XdrTypeName() string              { return "TrieNodeChild<>" }
func (v *_XdrVec_unbounded_TrieNodeChild) XdrPointer() interface{}       { return (*[]TrieNodeChild)(v) }
func (v _XdrVec_unbounded_TrieNodeChild) XdrValue() interface{}          { return ([]TrieNodeChild)(v) }
func (v *_XdrVec_unbounded_TrieNodeChild) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TrieNode = *TrieNode

func (v *TrieNode) XdrPointer() interface{}       { return v }
func (TrieNode) XdrTypeName() string              { return "TrieNode" }
func (v TrieNode) XdrValue() interface{}          { return v }
func (v *TrieNode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TrieNode) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sprefix", name), XDR_Value(&v.Prefix))
	x.Marshal(x.Sprintf("%svalue", name), XDR_Value(&v.Value))
	x.Marshal(x.Sprintf("%schildren", name), (*_XdrVec_unbounded_TrieNodeChild)(&v.Children))
}
func XDR_TrieNode(v *TrieNode) *TrieNode { return v }

var _XdrTags_SerializedLedgerCloseMeta = map[int32]bool{
	XdrToI32(0): true,
}

func (_ SerializedLedgerCloseMeta) XdrValidTags() map[int32]bool {
	return _XdrTags_SerializedLedgerCloseMeta
}
func (u *SerializedLedgerCloseMeta) V0() *LedgerCloseMeta {
	switch u.V {
	case 0:
		if v, ok := u._u.(*LedgerCloseMeta); ok {
			return v
		} else {
			var zero LedgerCloseMeta
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SerializedLedgerCloseMeta.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u SerializedLedgerCloseMeta) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *SerializedLedgerCloseMeta) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *SerializedLedgerCloseMeta) XdrUnionTagName() string {
	return "V"
}
func (u *SerializedLedgerCloseMeta) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_LedgerCloseMeta(u.V0())
	}
	return nil
}
func (u *SerializedLedgerCloseMeta) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}

type XdrType_SerializedLedgerCloseMeta = *SerializedLedgerCloseMeta

func (v *SerializedLedgerCloseMeta) XdrPointer() interface{}       { return v }
func (SerializedLedgerCloseMeta) XdrTypeName() string              { return "SerializedLedgerCloseMeta" }
func (v SerializedLedgerCloseMeta) XdrValue() interface{}          { return v }
func (v *SerializedLedgerCloseMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SerializedLedgerCloseMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_LedgerCloseMeta(u.V0()))
		return
	}
	XdrPanic("invalid V (%v) in SerializedLedgerCloseMeta", u.V)
}
func XDR_SerializedLedgerCloseMeta(v *SerializedLedgerCloseMeta) *SerializedLedgerCloseMeta { return v }

type _XdrVec_unbounded_LedgerCloseMeta []LedgerCloseMeta

func (_XdrVec_unbounded_LedgerCloseMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_LedgerCloseMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_LedgerCloseMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_LedgerCloseMeta length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_LedgerCloseMeta) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_LedgerCloseMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]LedgerCloseMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_LedgerCloseMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_LedgerCloseMeta(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_LedgerCloseMeta) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_LedgerCloseMeta) XdrTypeName() string              { return "LedgerCloseMeta<>" }
func (v *_XdrVec_unbounded_LedgerCloseMeta) XdrPointer() interface{}       { return (*[]LedgerCloseMeta)(v) }
func (v _XdrVec_unbounded_LedgerCloseMeta) XdrValue() interface{}          { return ([]LedgerCloseMeta)(v) }
func (v *_XdrVec_unbounded_LedgerCloseMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerCloseMetaBatch = *LedgerCloseMetaBatch

func (v *LedgerCloseMetaBatch) XdrPointer() interface{}       { return v }
func (LedgerCloseMetaBatch) XdrTypeName() string              { return "LedgerCloseMetaBatch" }
func (v LedgerCloseMetaBatch) XdrValue() interface{}          { return v }
func (v *LedgerCloseMetaBatch) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseMetaBatch) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstartSequence", name), XDR_Uint32(&v.StartSequence))
	x.Marshal(x.Sprintf("%sendSequence", name), XDR_Uint32(&v.EndSequence))
	x.Marshal(x.Sprintf("%sledgerCloseMetas", name), (*_XdrVec_unbounded_LedgerCloseMeta)(&v.LedgerCloseMetas))
}
func XDR_LedgerCloseMetaBatch(v *LedgerCloseMetaBatch) *LedgerCloseMetaBatch { return v }
