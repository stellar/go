// Code generated by goxdr -p gxdr -enum-comments -o gxdr/xdr_generated.go xdr/Stellar-SCP.x xdr/Stellar-ledger-entries.x xdr/Stellar-ledger.x xdr/Stellar-overlay.x xdr/Stellar-transaction.x xdr/Stellar-types.x xdr/Stellar-contract-env-meta.x xdr/Stellar-contract-spec.x xdr/Stellar-contract.x xdr/Stellar-internal.x; DO NOT EDIT.

package gxdr

import "fmt"
import "context"
import . "github.com/xdrpp/goxdr/xdr"

var _ XDR
var _ = fmt.Sprintf
var _ context.Context

//
// Data types defined in XDR file
//

type Value = []byte

type SCPBallot struct {
	// n
	Counter Uint32
	// x
	Value Value
}

type SCPStatementType int32

const (
	SCP_ST_PREPARE     SCPStatementType = 0
	SCP_ST_CONFIRM     SCPStatementType = 1
	SCP_ST_EXTERNALIZE SCPStatementType = 2
	SCP_ST_NOMINATE    SCPStatementType = 3
)

type SCPNomination struct {
	// D
	QuorumSetHash Hash
	// X
	Votes []Value
	// Y
	Accepted []Value
}

type SCPStatement struct {
	// v
	NodeID NodeID
	// i
	SlotIndex Uint64
	Pledges   XdrAnon_SCPStatement_Pledges
}
type XdrAnon_SCPStatement_Pledges struct {
	// The union discriminant Type selects among the following arms:
	//   SCP_ST_PREPARE:
	//      Prepare() *XdrAnon_SCPStatement_Pledges_Prepare
	//   SCP_ST_CONFIRM:
	//      Confirm() *XdrAnon_SCPStatement_Pledges_Confirm
	//   SCP_ST_EXTERNALIZE:
	//      Externalize() *XdrAnon_SCPStatement_Pledges_Externalize
	//   SCP_ST_NOMINATE:
	//      Nominate() *SCPNomination
	Type SCPStatementType
	_u   interface{}
}
type XdrAnon_SCPStatement_Pledges_Prepare struct {
	// D
	QuorumSetHash Hash
	// b
	Ballot SCPBallot
	// p
	Prepared *SCPBallot
	// p'
	PreparedPrime *SCPBallot
	// c.n
	NC Uint32
	// h.n
	NH Uint32
}
type XdrAnon_SCPStatement_Pledges_Confirm struct {
	// b
	Ballot SCPBallot
	// p.n
	NPrepared Uint32
	// c.n
	NCommit Uint32
	// h.n
	NH Uint32
	// D
	QuorumSetHash Hash
}
type XdrAnon_SCPStatement_Pledges_Externalize struct {
	// c
	Commit SCPBallot
	// h.n
	NH Uint32
	// D used before EXTERNALIZE
	CommitQuorumSetHash Hash
}

type SCPEnvelope struct {
	Statement SCPStatement
	Signature Signature
}

// supports things like: A,B,C,(D,E,F),(G,H,(I,J,K,L))
// only allows 2 levels of nesting
type SCPQuorumSet struct {
	Threshold  Uint32
	Validators []NodeID
	InnerSets  []SCPQuorumSet
}

type Thresholds = [4]byte

type String32 = string // bound 32

type String64 = string // bound 64

type SequenceNumber = Int64

type TimePoint = Uint64

type Duration = Uint64

type DataValue = []byte // bound 64

// SHA256(LiquidityPoolParameters)
type PoolID = Hash

// 1-4 alphanumeric characters right-padded with 0 bytes
type AssetCode4 = [4]byte

// 5-12 alphanumeric characters right-padded with 0 bytes
type AssetCode12 = [12]byte

type AssetType int32

const (
	ASSET_TYPE_NATIVE            AssetType = 0
	ASSET_TYPE_CREDIT_ALPHANUM4  AssetType = 1
	ASSET_TYPE_CREDIT_ALPHANUM12 AssetType = 2
	ASSET_TYPE_POOL_SHARE        AssetType = 3
)

type AssetCode struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AssetCode4() *AssetCode4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AssetCode12() *AssetCode12
	Type AssetType
	_u   interface{}
}

type AlphaNum4 struct {
	AssetCode AssetCode4
	Issuer    AccountID
}

type AlphaNum12 struct {
	AssetCode AssetCode12
	Issuer    AccountID
}

type Asset struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_NATIVE:
	//      void
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AlphaNum4() *AlphaNum4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AlphaNum12() *AlphaNum12
	Type AssetType
	_u   interface{}
}

// price in fractional representation
type Price struct {
	// numerator
	N Int32
	// denominator
	D Int32
}

type Liabilities struct {
	Buying  Int64
	Selling Int64
}

// the 'Thresholds' type is packed uint8_t values
// defined by these indexes
type ThresholdIndexes int32

const (
	THRESHOLD_MASTER_WEIGHT ThresholdIndexes = 0
	THRESHOLD_LOW           ThresholdIndexes = 1
	THRESHOLD_MED           ThresholdIndexes = 2
	THRESHOLD_HIGH          ThresholdIndexes = 3
)

type LedgerEntryType int32

const (
	ACCOUNT           LedgerEntryType = 0
	TRUSTLINE         LedgerEntryType = 1
	OFFER             LedgerEntryType = 2
	DATA              LedgerEntryType = 3
	CLAIMABLE_BALANCE LedgerEntryType = 4
	LIQUIDITY_POOL    LedgerEntryType = 5
	CONTRACT_DATA     LedgerEntryType = 6
	CONFIG_SETTING    LedgerEntryType = 7
)

type Signer struct {
	Key SignerKey
	// really only need 1 byte
	Weight Uint32
}

type AccountFlags int32

const (
	// Flags set on issuer accounts
	// TrustLines are created with authorized set to "false" requiring
	// the issuer to set it for each TrustLine
	AUTH_REQUIRED_FLAG AccountFlags = AccountFlags(0x1)
	// If set, the authorized flag in TrustLines can be cleared
	// otherwise, authorization cannot be revoked
	AUTH_REVOCABLE_FLAG AccountFlags = AccountFlags(0x2)
	// Once set, causes all AUTH_* flags to be read-only
	AUTH_IMMUTABLE_FLAG AccountFlags = AccountFlags(0x4)
	// Trustlines are created with clawback enabled set to "true",
	// and claimable balances created from those trustlines are created
	// with clawback enabled set to "true"
	AUTH_CLAWBACK_ENABLED_FLAG AccountFlags = AccountFlags(0x8)
)

// mask for all valid flags
const MASK_ACCOUNT_FLAGS = 0x7

const MASK_ACCOUNT_FLAGS_V17 = 0xF

// maximum number of signers
const MAX_SIGNERS = 20

type SponsorshipDescriptor = *AccountID

type AccountEntryExtensionV3 struct {
	// We can use this to add more fields, or because it is first, to
	// change AccountEntryExtensionV3 into a union.
	Ext ExtensionPoint
	// Ledger number at which `seqNum` took on its present value.
	SeqLedger Uint32
	// Time at which `seqNum` took on its present value.
	SeqTime TimePoint
}

type AccountEntryExtensionV2 struct {
	NumSponsored        Uint32
	NumSponsoring       Uint32
	SignerSponsoringIDs []SponsorshipDescriptor // bound MAX_SIGNERS
	Ext                 XdrAnon_AccountEntryExtensionV2_Ext
}
type XdrAnon_AccountEntryExtensionV2_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   3:
	//      V3() *AccountEntryExtensionV3
	V  int32
	_u interface{}
}

type AccountEntryExtensionV1 struct {
	Liabilities Liabilities
	Ext         XdrAnon_AccountEntryExtensionV1_Ext
}
type XdrAnon_AccountEntryExtensionV1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   2:
	//      V2() *AccountEntryExtensionV2
	V  int32
	_u interface{}
}

/*
AccountEntry

	Main entry representing a user in Stellar. All transactions are
	performed using an account.

	Other ledger entries created require an account.
*/
type AccountEntry struct {
	// master public key for this account
	AccountID AccountID
	// in stroops
	Balance Int64
	// last sequence number used for this account
	SeqNum SequenceNumber
	// number of sub-entries this account has
	NumSubEntries Uint32
	// drives the reserve
	InflationDest *AccountID
	// see AccountFlags
	Flags Uint32
	// can be used for reverse federation and memo lookup
	HomeDomain String32
	// fields used for signatures
	// thresholds stores unsigned bytes: [weight of master|low|medium|high]
	Thresholds Thresholds
	// possible signers for this account
	Signers []Signer // bound MAX_SIGNERS
	Ext     XdrAnon_AccountEntry_Ext
}

// reserved for future use
type XdrAnon_AccountEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *AccountEntryExtensionV1
	V  int32
	_u interface{}
}

type TrustLineFlags int32

const (
	// issuer has authorized account to perform transactions with its credit
	AUTHORIZED_FLAG TrustLineFlags = 1
	// issuer has authorized account to maintain and reduce liabilities for its
	// credit
	AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG TrustLineFlags = 2
	// issuer has specified that it may clawback its credit, and that claimable
	// balances created with its credit may also be clawed back
	TRUSTLINE_CLAWBACK_ENABLED_FLAG TrustLineFlags = 4
)

// mask for all trustline flags
const MASK_TRUSTLINE_FLAGS = 1

const MASK_TRUSTLINE_FLAGS_V13 = 3

const MASK_TRUSTLINE_FLAGS_V17 = 7

type LiquidityPoolType int32

const (
	LIQUIDITY_POOL_CONSTANT_PRODUCT LiquidityPoolType = 0
)

type TrustLineAsset struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_NATIVE:
	//      void
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AlphaNum4() *AlphaNum4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AlphaNum12() *AlphaNum12
	//   ASSET_TYPE_POOL_SHARE:
	//      LiquidityPoolID() *PoolID
	Type AssetType
	_u   interface{}
}

type TrustLineEntryExtensionV2 struct {
	LiquidityPoolUseCount Int32
	Ext                   XdrAnon_TrustLineEntryExtensionV2_Ext
}
type XdrAnon_TrustLineEntryExtensionV2_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type TrustLineEntry struct {
	// account this trustline belongs to
	AccountID AccountID
	// type of asset (with issuer)
	Asset TrustLineAsset
	// how much of this asset the user has.
	Balance Int64
	// balance cannot be above this
	Limit Int64
	// see TrustLineFlags
	Flags Uint32
	Ext   XdrAnon_TrustLineEntry_Ext
}

// reserved for future use
type XdrAnon_TrustLineEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *XdrAnon_TrustLineEntry_Ext_V1
	V  int32
	_u interface{}
}
type XdrAnon_TrustLineEntry_Ext_V1 struct {
	Liabilities Liabilities
	Ext         XdrAnon_TrustLineEntry_Ext_V1_Ext
}
type XdrAnon_TrustLineEntry_Ext_V1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   2:
	//      V2() *TrustLineEntryExtensionV2
	V  int32
	_u interface{}
}

type OfferEntryFlags int32

const (
	// an offer with this flag will not act on and take a reverse offer of equal
	// price
	PASSIVE_FLAG OfferEntryFlags = 1
)

// Mask for OfferEntry flags
const MASK_OFFERENTRY_FLAGS = 1

/*
OfferEntry

	An offer is the building block of the offer book, they are automatically
	claimed by payments when the price set by the owner is met.

	For example an Offer is selling 10A where 1A is priced at 1.5B
*/
type OfferEntry struct {
	SellerID AccountID
	OfferID  Int64
	// A
	Selling Asset
	// B
	Buying Asset
	// amount of A
	Amount Int64
	/* price for this offer:
	   price of A in terms of B
	   price=AmountB/AmountA=priceNumerator/priceDenominator
	   price is after fees
	*/
	Price Price
	// see OfferEntryFlags
	Flags Uint32
	Ext   XdrAnon_OfferEntry_Ext
}

// reserved for future use
type XdrAnon_OfferEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

/*
DataEntry

	Data can be attached to accounts.
*/
type DataEntry struct {
	// account this data belongs to
	AccountID AccountID
	DataName  String64
	DataValue DataValue
	Ext       XdrAnon_DataEntry_Ext
}

// reserved for future use
type XdrAnon_DataEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type ClaimPredicateType int32

const (
	CLAIM_PREDICATE_UNCONDITIONAL        ClaimPredicateType = 0
	CLAIM_PREDICATE_AND                  ClaimPredicateType = 1
	CLAIM_PREDICATE_OR                   ClaimPredicateType = 2
	CLAIM_PREDICATE_NOT                  ClaimPredicateType = 3
	CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME ClaimPredicateType = 4
	CLAIM_PREDICATE_BEFORE_RELATIVE_TIME ClaimPredicateType = 5
)

type ClaimPredicate struct {
	// The union discriminant Type selects among the following arms:
	//   CLAIM_PREDICATE_UNCONDITIONAL:
	//      void
	//   CLAIM_PREDICATE_AND:
	//      AndPredicates() *[]ClaimPredicate // bound 2
	//   CLAIM_PREDICATE_OR:
	//      OrPredicates() *[]ClaimPredicate // bound 2
	//   CLAIM_PREDICATE_NOT:
	//      NotPredicate() **ClaimPredicate
	//   CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
	//      AbsBefore() *Int64
	//   CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
	//      RelBefore() *Int64
	Type ClaimPredicateType
	_u   interface{}
}

type ClaimantType int32

const (
	CLAIMANT_TYPE_V0 ClaimantType = 0
)

type Claimant struct {
	// The union discriminant Type selects among the following arms:
	//   CLAIMANT_TYPE_V0:
	//      V0() *XdrAnon_Claimant_V0
	Type ClaimantType
	_u   interface{}
}
type XdrAnon_Claimant_V0 struct {
	// The account that can use this condition
	Destination AccountID
	// Claimable if predicate is true
	Predicate ClaimPredicate
}

type ClaimableBalanceIDType int32

const (
	CLAIMABLE_BALANCE_ID_TYPE_V0 ClaimableBalanceIDType = 0
)

type ClaimableBalanceID struct {
	// The union discriminant Type selects among the following arms:
	//   CLAIMABLE_BALANCE_ID_TYPE_V0:
	//      V0() *Hash
	Type ClaimableBalanceIDType
	_u   interface{}
}

type ClaimableBalanceFlags int32

const (
	// If set, the issuer account of the asset held by the claimable balance may
	// clawback the claimable balance
	CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG ClaimableBalanceFlags = ClaimableBalanceFlags(0x1)
)

const MASK_CLAIMABLE_BALANCE_FLAGS = 0x1

type ClaimableBalanceEntryExtensionV1 struct {
	Ext XdrAnon_ClaimableBalanceEntryExtensionV1_Ext
	// see ClaimableBalanceFlags
	Flags Uint32
}
type XdrAnon_ClaimableBalanceEntryExtensionV1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type ClaimableBalanceEntry struct {
	// Unique identifier for this ClaimableBalanceEntry
	BalanceID ClaimableBalanceID
	// List of claimants with associated predicate
	Claimants []Claimant // bound 10
	// Any asset including native
	Asset Asset
	// Amount of asset
	Amount Int64
	Ext    XdrAnon_ClaimableBalanceEntry_Ext
}

// reserved for future use
type XdrAnon_ClaimableBalanceEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *ClaimableBalanceEntryExtensionV1
	V  int32
	_u interface{}
}

type LiquidityPoolConstantProductParameters struct {
	// assetA < assetB
	AssetA Asset
	AssetB Asset
	// Fee is in basis points, so the actual rate is (fee/100)%
	Fee Int32
}

type LiquidityPoolEntry struct {
	LiquidityPoolID PoolID
	Body            XdrAnon_LiquidityPoolEntry_Body
}
type XdrAnon_LiquidityPoolEntry_Body struct {
	// The union discriminant Type selects among the following arms:
	//   LIQUIDITY_POOL_CONSTANT_PRODUCT:
	//      ConstantProduct() *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct
	Type LiquidityPoolType
	_u   interface{}
}
type XdrAnon_LiquidityPoolEntry_Body_ConstantProduct struct {
	Params LiquidityPoolConstantProductParameters
	// amount of A in the pool
	ReserveA Int64
	// amount of B in the pool
	ReserveB Int64
	// total number of pool shares issued
	TotalPoolShares Int64
	// number of trust lines for the
	PoolSharesTrustLineCount Int64
}

type ContractDataEntry struct {
	ContractID Hash
	Key        SCVal
	Val        SCVal
}

type ConfigSettingType int32

const (
	CONFIG_SETTING_TYPE_UINT32 ConfigSettingType = 0
)

type ConfigSetting struct {
	// The union discriminant Type selects among the following arms:
	//   CONFIG_SETTING_TYPE_UINT32:
	//      Uint32Val() *Uint32
	Type ConfigSettingType
	_u   interface{}
}

type ConfigSettingID int32

const (
	CONFIG_SETTING_CONTRACT_MAX_SIZE ConfigSettingID = 0
)

type ConfigSettingEntry struct {
	Ext             XdrAnon_ConfigSettingEntry_Ext
	ConfigSettingID ConfigSettingID
	Setting         ConfigSetting
}
type XdrAnon_ConfigSettingEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type LedgerEntryExtensionV1 struct {
	SponsoringID SponsorshipDescriptor
	Ext          XdrAnon_LedgerEntryExtensionV1_Ext
}
type XdrAnon_LedgerEntryExtensionV1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type LedgerEntry struct {
	// ledger the LedgerEntry was last changed
	LastModifiedLedgerSeq Uint32
	Data                  XdrAnon_LedgerEntry_Data
	Ext                   XdrAnon_LedgerEntry_Ext
}
type XdrAnon_LedgerEntry_Data struct {
	// The union discriminant Type selects among the following arms:
	//   ACCOUNT:
	//      Account() *AccountEntry
	//   TRUSTLINE:
	//      TrustLine() *TrustLineEntry
	//   OFFER:
	//      Offer() *OfferEntry
	//   DATA:
	//      Data() *DataEntry
	//   CLAIMABLE_BALANCE:
	//      ClaimableBalance() *ClaimableBalanceEntry
	//   LIQUIDITY_POOL:
	//      LiquidityPool() *LiquidityPoolEntry
	//   CONTRACT_DATA:
	//      ContractData() *ContractDataEntry
	//   CONFIG_SETTING:
	//      ConfigSetting() *ConfigSettingEntry
	Type LedgerEntryType
	_u   interface{}
}

// reserved for future use
type XdrAnon_LedgerEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *LedgerEntryExtensionV1
	V  int32
	_u interface{}
}

type LedgerKey struct {
	// The union discriminant Type selects among the following arms:
	//   ACCOUNT:
	//      Account() *XdrAnon_LedgerKey_Account
	//   TRUSTLINE:
	//      TrustLine() *XdrAnon_LedgerKey_TrustLine
	//   OFFER:
	//      Offer() *XdrAnon_LedgerKey_Offer
	//   DATA:
	//      Data() *XdrAnon_LedgerKey_Data
	//   CLAIMABLE_BALANCE:
	//      ClaimableBalance() *XdrAnon_LedgerKey_ClaimableBalance
	//   LIQUIDITY_POOL:
	//      LiquidityPool() *XdrAnon_LedgerKey_LiquidityPool
	//   CONTRACT_DATA:
	//      ContractData() *XdrAnon_LedgerKey_ContractData
	//   CONFIG_SETTING:
	//      ConfigSetting() *XdrAnon_LedgerKey_ConfigSetting
	Type LedgerEntryType
	_u   interface{}
}
type XdrAnon_LedgerKey_Account struct {
	AccountID AccountID
}
type XdrAnon_LedgerKey_TrustLine struct {
	AccountID AccountID
	Asset     TrustLineAsset
}
type XdrAnon_LedgerKey_Offer struct {
	SellerID AccountID
	OfferID  Int64
}
type XdrAnon_LedgerKey_Data struct {
	AccountID AccountID
	DataName  String64
}
type XdrAnon_LedgerKey_ClaimableBalance struct {
	BalanceID ClaimableBalanceID
}
type XdrAnon_LedgerKey_LiquidityPool struct {
	LiquidityPoolID PoolID
}
type XdrAnon_LedgerKey_ContractData struct {
	ContractID Hash
	Key        SCVal
}
type XdrAnon_LedgerKey_ConfigSetting struct {
	ConfigSettingID ConfigSettingID
}

// list of all envelope types used in the application
// those are prefixes used when building signatures for
// the respective envelopes
type EnvelopeType int32

const (
	ENVELOPE_TYPE_TX_V0                           EnvelopeType = 0
	ENVELOPE_TYPE_SCP                             EnvelopeType = 1
	ENVELOPE_TYPE_TX                              EnvelopeType = 2
	ENVELOPE_TYPE_AUTH                            EnvelopeType = 3
	ENVELOPE_TYPE_SCPVALUE                        EnvelopeType = 4
	ENVELOPE_TYPE_TX_FEE_BUMP                     EnvelopeType = 5
	ENVELOPE_TYPE_OP_ID                           EnvelopeType = 6
	ENVELOPE_TYPE_POOL_REVOKE_OP_ID               EnvelopeType = 7
	ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519        EnvelopeType = 8
	ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT       EnvelopeType = 9
	ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET          EnvelopeType = 10
	ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT EnvelopeType = 11
)

type UpgradeType = []byte // bound 128

type StellarValueType int32

const (
	STELLAR_VALUE_BASIC  StellarValueType = 0
	STELLAR_VALUE_SIGNED StellarValueType = 1
)

type LedgerCloseValueSignature struct {
	// which node introduced the value
	NodeID NodeID
	// nodeID's signature
	Signature Signature
}

/* StellarValue is the value used by SCP to reach consensus on a given ledger
 */
type StellarValue struct {
	// transaction set to apply to previous ledger
	TxSetHash Hash
	// network close time
	CloseTime TimePoint
	// upgrades to apply to the previous ledger (usually empty)
	// this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
	// unknown steps during consensus if needed.
	// see notes below on 'LedgerUpgrade' for more detail
	// max size is dictated by number of upgrade types (+ room for future)
	Upgrades []UpgradeType // bound 6
	Ext      XdrAnon_StellarValue_Ext
}

// reserved for future use
type XdrAnon_StellarValue_Ext struct {
	// The union discriminant V selects among the following arms:
	//   STELLAR_VALUE_BASIC:
	//      void
	//   STELLAR_VALUE_SIGNED:
	//      LcValueSignature() *LedgerCloseValueSignature
	V  StellarValueType
	_u interface{}
}

const MASK_LEDGER_HEADER_FLAGS = 0x7F

type LedgerHeaderFlags int32

const (
	DISABLE_LIQUIDITY_POOL_TRADING_FLAG    LedgerHeaderFlags = LedgerHeaderFlags(0x1)
	DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG    LedgerHeaderFlags = LedgerHeaderFlags(0x2)
	DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG LedgerHeaderFlags = LedgerHeaderFlags(0x4)
	DISABLE_CONTRACT_CREATE                LedgerHeaderFlags = LedgerHeaderFlags(0x8)
	DISABLE_CONTRACT_UPDATE                LedgerHeaderFlags = LedgerHeaderFlags(0x10)
	DISABLE_CONTRACT_REMOVE                LedgerHeaderFlags = LedgerHeaderFlags(0x20)
	DISABLE_CONTRACT_INVOKE                LedgerHeaderFlags = LedgerHeaderFlags(0x40)
)

type LedgerHeaderExtensionV1 struct {
	// LedgerHeaderFlags
	Flags Uint32
	Ext   XdrAnon_LedgerHeaderExtensionV1_Ext
}
type XdrAnon_LedgerHeaderExtensionV1_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

/* The LedgerHeader is the highest level structure representing the
 * state of a ledger, cryptographically linked to previous ledgers.
 */
type LedgerHeader struct {
	// the protocol version of the ledger
	LedgerVersion Uint32
	// hash of the previous ledger header
	PreviousLedgerHash Hash
	// what consensus agreed to
	ScpValue StellarValue
	// the TransactionResultSet that led to this ledger
	TxSetResultHash Hash
	// hash of the ledger state
	BucketListHash Hash
	// sequence number of this ledger
	LedgerSeq Uint32
	// total number of stroops in existence.
	TotalCoins Int64
	// fees burned since last inflation run
	FeePool Int64
	// inflation sequence number
	InflationSeq Uint32
	// last used global ID, used for generating objects
	IdPool Uint64
	// base fee per operation in stroops
	BaseFee Uint32
	// account base reserve in stroops
	BaseReserve Uint32
	// maximum size a transaction set can be
	MaxTxSetSize Uint32
	// hashes of ledgers in the past. allows you to jump back
	SkipList [4]Hash
	Ext      XdrAnon_LedgerHeader_Ext
}

// reserved for future use
type XdrAnon_LedgerHeader_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      V1() *LedgerHeaderExtensionV1
	V  int32
	_u interface{}
}

/*
	Ledger upgrades

note that the `upgrades` field from StellarValue is normalized such that
it only contains one entry per LedgerUpgradeType, and entries are sorted
in ascending order
*/
type LedgerUpgradeType int32

const (
	LEDGER_UPGRADE_VERSION         LedgerUpgradeType = 1
	LEDGER_UPGRADE_BASE_FEE        LedgerUpgradeType = 2
	LEDGER_UPGRADE_MAX_TX_SET_SIZE LedgerUpgradeType = 3
	LEDGER_UPGRADE_BASE_RESERVE    LedgerUpgradeType = 4
	LEDGER_UPGRADE_FLAGS           LedgerUpgradeType = 5
	LEDGER_UPGRADE_CONFIG          LedgerUpgradeType = 6
)

type LedgerUpgrade struct {
	// The union discriminant Type selects among the following arms:
	//   LEDGER_UPGRADE_VERSION:
	//      NewLedgerVersion() *Uint32
	//   LEDGER_UPGRADE_BASE_FEE:
	//      NewBaseFee() *Uint32
	//   LEDGER_UPGRADE_MAX_TX_SET_SIZE:
	//      NewMaxTxSetSize() *Uint32
	//   LEDGER_UPGRADE_BASE_RESERVE:
	//      NewBaseReserve() *Uint32
	//   LEDGER_UPGRADE_FLAGS:
	//      NewFlags() *Uint32
	//   LEDGER_UPGRADE_CONFIG:
	//      ConfigSetting() *XdrAnon_LedgerUpgrade_ConfigSetting
	Type LedgerUpgradeType
	_u   interface{}
}
type XdrAnon_LedgerUpgrade_ConfigSetting struct {
	// id to update
	Id ConfigSettingID
	// new value
	Setting ConfigSetting
}

/* Entries used to define the bucket list */
type BucketEntryType int32

const (
	// At-and-after protocol 11: bucket metadata, should come first.
	METAENTRY BucketEntryType = -1
	// Before protocol 11: created-or-updated;
	LIVEENTRY BucketEntryType = 0
	// At-and-after protocol 11: only updated.
	DEADENTRY BucketEntryType = 1
	// At-and-after protocol 11: only created.
	INITENTRY BucketEntryType = 2
)

type BucketMetadata struct {
	// Indicates the protocol version used to create / merge this bucket.
	LedgerVersion Uint32
	Ext           XdrAnon_BucketMetadata_Ext
}

// reserved for future use
type XdrAnon_BucketMetadata_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type BucketEntry struct {
	// The union discriminant Type selects among the following arms:
	//   LIVEENTRY, INITENTRY:
	//      LiveEntry() *LedgerEntry
	//   DEADENTRY:
	//      DeadEntry() *LedgerKey
	//   METAENTRY:
	//      MetaEntry() *BucketMetadata
	Type BucketEntryType
	_u   interface{}
}

type TxSetComponentType int32

const (
	// txs with effective fee <= bid derived from a base fee (if any).
	// If base fee is not specified, no discount is applied.
	TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE TxSetComponentType = 0
)

type TxSetComponent struct {
	// The union discriminant Type selects among the following arms:
	//   TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
	//      TxsMaybeDiscountedFee() *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee
	Type TxSetComponentType
	_u   interface{}
}
type XdrAnon_TxSetComponent_TxsMaybeDiscountedFee struct {
	BaseFee *Int64
	Txs     []TransactionEnvelope
}

type TransactionPhase struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0Components() *[]TxSetComponent
	V  int32
	_u interface{}
}

// Transaction sets are the unit used by SCP to decide on transitions
// between ledgers
type TransactionSet struct {
	PreviousLedgerHash Hash
	Txs                []TransactionEnvelope
}

type TransactionSetV1 struct {
	PreviousLedgerHash Hash
	Phases             []TransactionPhase
}

type GeneralizedTransactionSet struct {
	// The union discriminant V selects among the following arms:
	//   1:
	//      V1TxSet() *TransactionSetV1
	V  int32
	_u interface{}
}

type TransactionResultPair struct {
	TransactionHash Hash
	// result for the transaction
	Result TransactionResult
}

// TransactionResultSet is used to recover results between ledgers
type TransactionResultSet struct {
	Results []TransactionResultPair
}

type TransactionHistoryEntry struct {
	LedgerSeq Uint32
	TxSet     TransactionSet
	Ext       XdrAnon_TransactionHistoryEntry_Ext
}

// when v != 0, txSet must be empty
type XdrAnon_TransactionHistoryEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	//   1:
	//      GeneralizedTxSet() *GeneralizedTransactionSet
	V  int32
	_u interface{}
}

type TransactionHistoryResultEntry struct {
	LedgerSeq   Uint32
	TxResultSet TransactionResultSet
	Ext         XdrAnon_TransactionHistoryResultEntry_Ext
}

// reserved for future use
type XdrAnon_TransactionHistoryResultEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type TransactionResultPairV2 struct {
	TransactionHash Hash
	// hash of hashes in TransactionMetaV3
	HashOfMetaHashes Hash
}

type TransactionResultSetV2 struct {
	Results []TransactionResultPairV2
}

type TransactionHistoryResultEntryV2 struct {
	LedgerSeq   Uint32
	TxResultSet TransactionResultSetV2
	Ext         XdrAnon_TransactionHistoryResultEntryV2_Ext
}

// reserved for future use
type XdrAnon_TransactionHistoryResultEntryV2_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type LedgerHeaderHistoryEntry struct {
	Hash   Hash
	Header LedgerHeader
	Ext    XdrAnon_LedgerHeaderHistoryEntry_Ext
}

// reserved for future use
type XdrAnon_LedgerHeaderHistoryEntry_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type LedgerSCPMessages struct {
	LedgerSeq Uint32
	Messages  []SCPEnvelope
}

// note: ledgerMessages may refer to any quorumSets encountered
// in the file so far, not just the one from this entry
type SCPHistoryEntryV0 struct {
	// additional quorum sets used by ledgerMessages
	QuorumSets     []SCPQuorumSet
	LedgerMessages LedgerSCPMessages
}

// SCP history file is an array of these
type SCPHistoryEntry struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *SCPHistoryEntryV0
	V  int32
	_u interface{}
}

type LedgerEntryChangeType int32

const (
	// entry was added to the ledger
	LEDGER_ENTRY_CREATED LedgerEntryChangeType = 0
	// entry was modified in the ledger
	LEDGER_ENTRY_UPDATED LedgerEntryChangeType = 1
	// entry was removed from the ledger
	LEDGER_ENTRY_REMOVED LedgerEntryChangeType = 2
	// value of the entry
	LEDGER_ENTRY_STATE LedgerEntryChangeType = 3
)

type LedgerEntryChange struct {
	// The union discriminant Type selects among the following arms:
	//   LEDGER_ENTRY_CREATED:
	//      Created() *LedgerEntry
	//   LEDGER_ENTRY_UPDATED:
	//      Updated() *LedgerEntry
	//   LEDGER_ENTRY_REMOVED:
	//      Removed() *LedgerKey
	//   LEDGER_ENTRY_STATE:
	//      State() *LedgerEntry
	Type LedgerEntryChangeType
	_u   interface{}
}

type LedgerEntryChanges = []LedgerEntryChange

type OperationMeta struct {
	Changes LedgerEntryChanges
}

type TransactionMetaV1 struct {
	// tx level changes if any
	TxChanges LedgerEntryChanges
	// meta for each operation
	Operations []OperationMeta
}

type TransactionMetaV2 struct {
	// tx level changes before operations
	TxChangesBefore LedgerEntryChanges
	// are applied if any
	Operations []OperationMeta
	// tx level changes after operations are
	TxChangesAfter LedgerEntryChanges
}

type ContractEventType int32

const (
	SYSTEM   ContractEventType = 0
	CONTRACT ContractEventType = 1
)

type ContractEvent struct {
	// We can use this to add more fields, or because it
	// is first, to change ContractEvent into a union.
	Ext        ExtensionPoint
	ContractID *Hash
	Type       ContractEventType
	Body       XdrAnon_ContractEvent_Body
}
type XdrAnon_ContractEvent_Body struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *XdrAnon_ContractEvent_Body_V0
	V  int32
	_u interface{}
}
type XdrAnon_ContractEvent_Body_V0 struct {
	Topics SCVec
	Data   SCVal
}

type TransactionMetaV3 struct {
	// tx level changes before operations
	TxChangesBefore LedgerEntryChanges
	// are applied if any
	Operations []OperationMeta
	// tx level changes after operations are
	TxChangesAfter LedgerEntryChanges
	// applied if any
	Events []ContractEvent
	// contracts themselves
	TxResult TransactionResult
	// stores sha256(txChangesBefore, operations, txChangesAfter),
	Hashes [3]Hash
}

// this is the meta produced when applying transactions
// it does not include pre-apply updates such as fees
type TransactionMeta struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      Operations() *[]OperationMeta
	//   1:
	//      V1() *TransactionMetaV1
	//   2:
	//      V2() *TransactionMetaV2
	//   3:
	//      V3() *TransactionMetaV3
	V  int32
	_u interface{}
}

// This struct groups together changes on a per transaction basis
// note however that fees and transaction application are done in separate
// phases
type TransactionResultMeta struct {
	Result            TransactionResultPair
	FeeProcessing     LedgerEntryChanges
	TxApplyProcessing TransactionMeta
}

type TransactionResultMetaV2 struct {
	Result            TransactionResultPairV2
	FeeProcessing     LedgerEntryChanges
	TxApplyProcessing TransactionMeta
}

// this represents a single upgrade that was performed as part of a ledger
// upgrade
type UpgradeEntryMeta struct {
	Upgrade LedgerUpgrade
	Changes LedgerEntryChanges
}

type LedgerCloseMetaV0 struct {
	LedgerHeader LedgerHeaderHistoryEntry
	// NB: txSet is sorted in "Hash order"
	TxSet TransactionSet
	// NB: transactions are sorted in apply order here
	// fees for all transactions are processed first
	// followed by applying transactions
	TxProcessing []TransactionResultMeta
	// upgrades are applied last
	UpgradesProcessing []UpgradeEntryMeta
	// other misc information attached to the ledger close
	ScpInfo []SCPHistoryEntry
}

type LedgerCloseMetaV1 struct {
	LedgerHeader LedgerHeaderHistoryEntry
	TxSet        GeneralizedTransactionSet
	// NB: transactions are sorted in apply order here
	// fees for all transactions are processed first
	// followed by applying transactions
	TxProcessing []TransactionResultMeta
	// upgrades are applied last
	UpgradesProcessing []UpgradeEntryMeta
	// other misc information attached to the ledger close
	ScpInfo []SCPHistoryEntry
}

// only difference between V1 and V2 is this uses TransactionResultMetaV2
type LedgerCloseMetaV2 struct {
	LedgerHeader LedgerHeaderHistoryEntry
	TxSet        GeneralizedTransactionSet
	// NB: transactions are sorted in apply order here
	// fees for all transactions are processed first
	// followed by applying transactions
	TxProcessing []TransactionResultMetaV2
	// upgrades are applied last
	UpgradesProcessing []UpgradeEntryMeta
	// other misc information attached to the ledger close
	ScpInfo []SCPHistoryEntry
}

type LedgerCloseMeta struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *LedgerCloseMetaV0
	//   1:
	//      V1() *LedgerCloseMetaV1
	//   2:
	//      V2() *LedgerCloseMetaV2
	V  int32
	_u interface{}
}

type ErrorCode int32

const (
	// Unspecific error
	ERR_MISC ErrorCode = 0
	// Malformed data
	ERR_DATA ErrorCode = 1
	// Misconfiguration error
	ERR_CONF ErrorCode = 2
	// Authentication failure
	ERR_AUTH ErrorCode = 3
	// System overloaded
	ERR_LOAD ErrorCode = 4
)

type Error struct {
	Code ErrorCode
	Msg  string // bound 100
}

type SendMore struct {
	NumMessages Uint32
}

type AuthCert struct {
	Pubkey     Curve25519Public
	Expiration Uint64
	Sig        Signature
}

type Hello struct {
	LedgerVersion     Uint32
	OverlayVersion    Uint32
	OverlayMinVersion Uint32
	NetworkID         Hash
	VersionStr        string // bound 100
	ListeningPort     int32
	PeerID            NodeID
	Cert              AuthCert
	Nonce             Uint256
}

// During the roll-out phrase, pull mode will be optional.
// Therefore, we need a way to communicate with other nodes
// that we want/don't want pull mode.
// However, the goal is for everyone to enable it by default,
// so we don't want to introduce a new member variable.
// For now, we'll use the `flags` field (originally named
// `unused`) in `Auth`.
// 100 is just a number that is not 0.
const AUTH_MSG_FLAG_PULL_MODE_REQUESTED = 100

type Auth struct {
	Flags int32
}

type IPAddrType int32

const (
	IPv4 IPAddrType = 0
	IPv6 IPAddrType = 1
)

type PeerAddress struct {
	Ip          XdrAnon_PeerAddress_Ip
	Port        Uint32
	NumFailures Uint32
}
type XdrAnon_PeerAddress_Ip struct {
	// The union discriminant Type selects among the following arms:
	//   IPv4:
	//      Ipv4() *[4]byte
	//   IPv6:
	//      Ipv6() *[16]byte
	Type IPAddrType
	_u   interface{}
}

// Next ID: 18
type MessageType int32

const (
	ERROR_MSG MessageType = 0
	AUTH      MessageType = 2
	DONT_HAVE MessageType = 3
	// gets a list of peers this guy knows about
	GET_PEERS MessageType = 4
	PEERS     MessageType = 5
	// gets a particular txset by hash
	GET_TX_SET         MessageType = 6
	TX_SET             MessageType = 7
	GENERALIZED_TX_SET MessageType = 17
	// pass on a tx you have heard about
	TRANSACTION MessageType = 8
	// SCP
	GET_SCP_QUORUMSET MessageType = 9
	SCP_QUORUMSET     MessageType = 10
	SCP_MESSAGE       MessageType = 11
	GET_SCP_STATE     MessageType = 12
	// new messages
	HELLO           MessageType = 13
	SURVEY_REQUEST  MessageType = 14
	SURVEY_RESPONSE MessageType = 15
	SEND_MORE       MessageType = 16
	FLOOD_ADVERT    MessageType = 18
	FLOOD_DEMAND    MessageType = 19
)

type DontHave struct {
	Type    MessageType
	ReqHash Uint256
}

type SurveyMessageCommandType int32

const (
	SURVEY_TOPOLOGY SurveyMessageCommandType = 0
)

type SurveyRequestMessage struct {
	SurveyorPeerID NodeID
	SurveyedPeerID NodeID
	LedgerNum      Uint32
	EncryptionKey  Curve25519Public
	CommandType    SurveyMessageCommandType
}

type SignedSurveyRequestMessage struct {
	RequestSignature Signature
	Request          SurveyRequestMessage
}

type EncryptedBody = []byte // bound 64000

type SurveyResponseMessage struct {
	SurveyorPeerID NodeID
	SurveyedPeerID NodeID
	LedgerNum      Uint32
	CommandType    SurveyMessageCommandType
	EncryptedBody  EncryptedBody
}

type SignedSurveyResponseMessage struct {
	ResponseSignature Signature
	Response          SurveyResponseMessage
}

type PeerStats struct {
	Id                        NodeID
	VersionStr                string // bound 100
	MessagesRead              Uint64
	MessagesWritten           Uint64
	BytesRead                 Uint64
	BytesWritten              Uint64
	SecondsConnected          Uint64
	UniqueFloodBytesRecv      Uint64
	DuplicateFloodBytesRecv   Uint64
	UniqueFetchBytesRecv      Uint64
	DuplicateFetchBytesRecv   Uint64
	UniqueFloodMessageRecv    Uint64
	DuplicateFloodMessageRecv Uint64
	UniqueFetchMessageRecv    Uint64
	DuplicateFetchMessageRecv Uint64
}

type PeerStatList = []PeerStats // bound 25

type TopologyResponseBody struct {
	InboundPeers           PeerStatList
	OutboundPeers          PeerStatList
	TotalInboundPeerCount  Uint32
	TotalOutboundPeerCount Uint32
}

const TX_ADVERT_VECTOR_MAX_SIZE = 1000

type TxAdvertVector = []Hash // bound TX_ADVERT_VECTOR_MAX_SIZE

type FloodAdvert struct {
	TxHashes TxAdvertVector
}

const TX_DEMAND_VECTOR_MAX_SIZE = 1000

type TxDemandVector = []Hash // bound TX_DEMAND_VECTOR_MAX_SIZE

type FloodDemand struct {
	TxHashes TxDemandVector
}

type SurveyResponseBody struct {
	// The union discriminant Type selects among the following arms:
	//   SURVEY_TOPOLOGY:
	//      TopologyResponseBody() *TopologyResponseBody
	Type SurveyMessageCommandType
	_u   interface{}
}

type StellarMessage struct {
	// The union discriminant Type selects among the following arms:
	//   ERROR_MSG:
	//      Error() *Error
	//   HELLO:
	//      Hello() *Hello
	//   AUTH:
	//      Auth() *Auth
	//   DONT_HAVE:
	//      DontHave() *DontHave
	//   GET_PEERS:
	//      void
	//   PEERS:
	//      Peers() *[]PeerAddress // bound 100
	//   GET_TX_SET:
	//      TxSetHash() *Uint256
	//   TX_SET:
	//      TxSet() *TransactionSet
	//   GENERALIZED_TX_SET:
	//      GeneralizedTxSet() *GeneralizedTransactionSet
	//   TRANSACTION:
	//      Transaction() *TransactionEnvelope
	//   SURVEY_REQUEST:
	//      SignedSurveyRequestMessage() *SignedSurveyRequestMessage
	//   SURVEY_RESPONSE:
	//      SignedSurveyResponseMessage() *SignedSurveyResponseMessage
	//   GET_SCP_QUORUMSET:
	//      QSetHash() *Uint256
	//   SCP_QUORUMSET:
	//      QSet() *SCPQuorumSet
	//   SCP_MESSAGE:
	//      Envelope() *SCPEnvelope
	//   GET_SCP_STATE:
	//      GetSCPLedgerSeq() *Uint32
	//   SEND_MORE:
	//      SendMoreMessage() *SendMore
	//   FLOOD_ADVERT:
	//      FloodAdvert() *FloodAdvert
	//   FLOOD_DEMAND:
	//      FloodDemand() *FloodDemand
	Type MessageType
	_u   interface{}
}

type AuthenticatedMessage struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *XdrAnon_AuthenticatedMessage_V0
	V  Uint32
	_u interface{}
}
type XdrAnon_AuthenticatedMessage_V0 struct {
	Sequence Uint64
	Message  StellarMessage
	Mac      HmacSha256Mac
}

type LiquidityPoolParameters struct {
	// The union discriminant Type selects among the following arms:
	//   LIQUIDITY_POOL_CONSTANT_PRODUCT:
	//      ConstantProduct() *LiquidityPoolConstantProductParameters
	Type LiquidityPoolType
	_u   interface{}
}

// Source or destination of a payment operation
type MuxedAccount struct {
	// The union discriminant Type selects among the following arms:
	//   KEY_TYPE_ED25519:
	//      Ed25519() *Uint256
	//   KEY_TYPE_MUXED_ED25519:
	//      Med25519() *XdrAnon_MuxedAccount_Med25519
	Type CryptoKeyType
	_u   interface{}
}
type XdrAnon_MuxedAccount_Med25519 struct {
	Id      Uint64
	Ed25519 Uint256
}

type DecoratedSignature struct {
	// last 4 bytes of the public key, used as a hint
	Hint SignatureHint
	// actual signature
	Signature Signature
}

// Ledger key sets touched by a smart contract transaction.
type LedgerFootprint struct {
	ReadOnly  []LedgerKey
	ReadWrite []LedgerKey
}

type OperationType int32

const (
	CREATE_ACCOUNT                   OperationType = 0
	PAYMENT                          OperationType = 1
	PATH_PAYMENT_STRICT_RECEIVE      OperationType = 2
	MANAGE_SELL_OFFER                OperationType = 3
	CREATE_PASSIVE_SELL_OFFER        OperationType = 4
	SET_OPTIONS                      OperationType = 5
	CHANGE_TRUST                     OperationType = 6
	ALLOW_TRUST                      OperationType = 7
	ACCOUNT_MERGE                    OperationType = 8
	INFLATION                        OperationType = 9
	MANAGE_DATA                      OperationType = 10
	BUMP_SEQUENCE                    OperationType = 11
	MANAGE_BUY_OFFER                 OperationType = 12
	PATH_PAYMENT_STRICT_SEND         OperationType = 13
	CREATE_CLAIMABLE_BALANCE         OperationType = 14
	CLAIM_CLAIMABLE_BALANCE          OperationType = 15
	BEGIN_SPONSORING_FUTURE_RESERVES OperationType = 16
	END_SPONSORING_FUTURE_RESERVES   OperationType = 17
	REVOKE_SPONSORSHIP               OperationType = 18
	CLAWBACK                         OperationType = 19
	CLAWBACK_CLAIMABLE_BALANCE       OperationType = 20
	SET_TRUST_LINE_FLAGS             OperationType = 21
	LIQUIDITY_POOL_DEPOSIT           OperationType = 22
	LIQUIDITY_POOL_WITHDRAW          OperationType = 23
	INVOKE_HOST_FUNCTION             OperationType = 24
)

/*
	CreateAccount

Creates and funds a new account with the specified starting balance.

Threshold: med

Result: CreateAccountResult
*/
type CreateAccountOp struct {
	// account to create
	Destination AccountID
	// amount they end up with
	StartingBalance Int64
}

/*
Payment

	Send an amount in specified asset to a destination account.

	Threshold: med

	Result: PaymentResult
*/
type PaymentOp struct {
	// recipient of the payment
	Destination MuxedAccount
	// what they end up with
	Asset Asset
	// amount they end up with
	Amount Int64
}

/*
	PathPaymentStrictReceive

send an amount to a destination account through a path.
(up to sendMax, sendAsset)
(X0, Path[0]) .. (Xn, Path[n])
(destAmount, destAsset)

Threshold: med

Result: PathPaymentStrictReceiveResult
*/
type PathPaymentStrictReceiveOp struct {
	// asset we pay with
	SendAsset Asset
	// the maximum amount of sendAsset to
	SendMax Int64
	// recipient of the payment
	Destination MuxedAccount
	// what they end up with
	DestAsset Asset
	// amount they end up with
	DestAmount Int64
	// additional hops it must go through to get there
	Path []Asset // bound 5
}

/*
	PathPaymentStrictSend

send an amount to a destination account through a path.
(sendMax, sendAsset)
(X0, Path[0]) .. (Xn, Path[n])
(at least destAmount, destAsset)

Threshold: med

Result: PathPaymentStrictSendResult
*/
type PathPaymentStrictSendOp struct {
	// asset we pay with
	SendAsset Asset
	// amount of sendAsset to send (excluding fees)
	SendAmount Int64
	// recipient of the payment
	Destination MuxedAccount
	// what they end up with
	DestAsset Asset
	// the minimum amount of dest asset to
	DestMin Int64
	// additional hops it must go through to get there
	Path []Asset // bound 5
}

/*
	Creates, updates or deletes an offer

Threshold: med

Result: ManageSellOfferResult
*/
type ManageSellOfferOp struct {
	Selling Asset
	Buying  Asset
	// amount being sold. if set to 0, delete the offer
	Amount Int64
	// price of thing being sold in terms of what you are buying
	Price Price
	// 0=create a new offer, otherwise edit an existing offer
	OfferID Int64
}

/*
	Creates, updates or deletes an offer with amount in terms of buying asset

Threshold: med

Result: ManageBuyOfferResult
*/
type ManageBuyOfferOp struct {
	Selling Asset
	Buying  Asset
	// amount being bought. if set to 0, delete the offer
	BuyAmount Int64
	// price of thing being bought in terms of what you are
	Price Price
	// 0=create a new offer, otherwise edit an existing offer
	OfferID Int64
}

/*
	Creates an offer that doesn't take offers of the same price

Threshold: med

Result: CreatePassiveSellOfferResult
*/
type CreatePassiveSellOfferOp struct {
	// A
	Selling Asset
	// B
	Buying Asset
	// amount taker gets
	Amount Int64
	// cost of A in terms of B
	Price Price
}

/*
Set Account Options

	updates "AccountEntry" fields.
	note: updating thresholds or signers requires high threshold

	Threshold: med or high

	Result: SetOptionsResult
*/
type SetOptionsOp struct {
	// sets the inflation destination
	InflationDest *AccountID
	// which flags to clear
	ClearFlags *Uint32
	// which flags to set
	SetFlags *Uint32
	// account threshold manipulation
	MasterWeight  *Uint32
	LowThreshold  *Uint32
	MedThreshold  *Uint32
	HighThreshold *Uint32
	// sets the home domain
	HomeDomain *String32
	// Add, update or remove a signer for the account
	// signer is deleted if the weight is 0
	Signer *Signer
}

type ChangeTrustAsset struct {
	// The union discriminant Type selects among the following arms:
	//   ASSET_TYPE_NATIVE:
	//      void
	//   ASSET_TYPE_CREDIT_ALPHANUM4:
	//      AlphaNum4() *AlphaNum4
	//   ASSET_TYPE_CREDIT_ALPHANUM12:
	//      AlphaNum12() *AlphaNum12
	//   ASSET_TYPE_POOL_SHARE:
	//      LiquidityPool() *LiquidityPoolParameters
	Type AssetType
	_u   interface{}
}

/*
Creates, updates or deletes a trust line

	Threshold: med

	Result: ChangeTrustResult
*/
type ChangeTrustOp struct {
	Line ChangeTrustAsset
	// if limit is set to 0, deletes the trust line
	Limit Int64
}

/*
Updates the "authorized" flag of an existing trust line

	this is called by the issuer of the related asset.

	note that authorize can only be set (and not cleared) if
	the issuer account does not have the AUTH_REVOCABLE_FLAG set
	Threshold: low

	Result: AllowTrustResult
*/
type AllowTrustOp struct {
	Trustor AccountID
	Asset   AssetCode
	// One of 0, AUTHORIZED_FLAG, or AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG
	Authorize Uint32
}

/*
ManageData

	Adds, Updates, or Deletes a key value pair associated with a particular
	    account.

	Threshold: med

	Result: ManageDataResult
*/
type ManageDataOp struct {
	DataName String64
	// set to null to clear
	DataValue *DataValue
}

/*
Bump Sequence

	increases the sequence to a given level

	Threshold: low

	Result: BumpSequenceResult
*/
type BumpSequenceOp struct {
	BumpTo SequenceNumber
}

/*
Creates a claimable balance entry

	Threshold: med

	Result: CreateClaimableBalanceResult
*/
type CreateClaimableBalanceOp struct {
	Asset     Asset
	Amount    Int64
	Claimants []Claimant // bound 10
}

/*
Claims a claimable balance entry

	Threshold: low

	Result: ClaimClaimableBalanceResult
*/
type ClaimClaimableBalanceOp struct {
	BalanceID ClaimableBalanceID
}

/*
BeginSponsoringFutureReserves

	Establishes the is-sponsoring-future-reserves-for relationship between
	the source account and sponsoredID

	Threshold: med

	Result: BeginSponsoringFutureReservesResult
*/
type BeginSponsoringFutureReservesOp struct {
	SponsoredID AccountID
}

/*
RevokeSponsorship

	If source account is not sponsored or is sponsored by the owner of the
	specified entry or sub-entry, then attempt to revoke the sponsorship.
	If source account is sponsored, then attempt to transfer the sponsorship
	to the sponsor of source account.

	Threshold: med

	Result: RevokeSponsorshipResult
*/
type RevokeSponsorshipType int32

const (
	REVOKE_SPONSORSHIP_LEDGER_ENTRY RevokeSponsorshipType = 0
	REVOKE_SPONSORSHIP_SIGNER       RevokeSponsorshipType = 1
)

type RevokeSponsorshipOp struct {
	// The union discriminant Type selects among the following arms:
	//   REVOKE_SPONSORSHIP_LEDGER_ENTRY:
	//      LedgerKey() *LedgerKey
	//   REVOKE_SPONSORSHIP_SIGNER:
	//      Signer() *XdrAnon_RevokeSponsorshipOp_Signer
	Type RevokeSponsorshipType
	_u   interface{}
}
type XdrAnon_RevokeSponsorshipOp_Signer struct {
	AccountID AccountID
	SignerKey SignerKey
}

/*
Claws back an amount of an asset from an account

	Threshold: med

	Result: ClawbackResult
*/
type ClawbackOp struct {
	Asset  Asset
	From   MuxedAccount
	Amount Int64
}

/*
Claws back a claimable balance

	Threshold: med

	Result: ClawbackClaimableBalanceResult
*/
type ClawbackClaimableBalanceOp struct {
	BalanceID ClaimableBalanceID
}

/*
SetTrustLineFlagsOp

	Updates the flags of an existing trust line.
	This is called by the issuer of the related asset.

	Threshold: low

	Result: SetTrustLineFlagsResult
*/
type SetTrustLineFlagsOp struct {
	Trustor AccountID
	Asset   Asset
	// which flags to clear
	ClearFlags Uint32
	// which flags to set
	SetFlags Uint32
}

const LIQUIDITY_POOL_FEE_V18 = 30

/*
Deposit assets into a liquidity pool

	Threshold: med

	Result: LiquidityPoolDepositResult
*/
type LiquidityPoolDepositOp struct {
	LiquidityPoolID PoolID
	// maximum amount of first asset to deposit
	MaxAmountA Int64
	// maximum amount of second asset to deposit
	MaxAmountB Int64
	// minimum depositA/depositB
	MinPrice Price
	// maximum depositA/depositB
	MaxPrice Price
}

/*
Withdraw assets from a liquidity pool

	Threshold: med

	Result: LiquidityPoolWithdrawResult
*/
type LiquidityPoolWithdrawOp struct {
	LiquidityPoolID PoolID
	// amount of pool shares to withdraw
	Amount Int64
	// minimum amount of first asset to withdraw
	MinAmountA Int64
	// minimum amount of second asset to withdraw
	MinAmountB Int64
}

type HostFunction int32

const (
	HOST_FN_INVOKE_CONTRACT                           HostFunction = 0
	HOST_FN_CREATE_CONTRACT_WITH_ED25519              HostFunction = 1
	HOST_FN_CREATE_CONTRACT_WITH_SOURCE_ACCOUNT       HostFunction = 2
	HOST_FN_CREATE_TOKEN_CONTRACT_WITH_SOURCE_ACCOUNT HostFunction = 3
	HOST_FN_CREATE_TOKEN_CONTRACT_WITH_ASSET          HostFunction = 4
)

type InvokeHostFunctionOp struct {
	// The host function to invoke
	Function HostFunction
	// Parameters to the host function
	Parameters SCVec
	// The footprint for this invocation
	Footprint LedgerFootprint
}

/* An operation is the lowest unit of work that a transaction does */
type Operation struct {
	// sourceAccount is the account used to run the operation
	// if not set, the runtime defaults to "sourceAccount" specified at
	// the transaction level
	SourceAccount *MuxedAccount
	Body          XdrAnon_Operation_Body
}
type XdrAnon_Operation_Body struct {
	// The union discriminant Type selects among the following arms:
	//   CREATE_ACCOUNT:
	//      CreateAccountOp() *CreateAccountOp
	//   PAYMENT:
	//      PaymentOp() *PaymentOp
	//   PATH_PAYMENT_STRICT_RECEIVE:
	//      PathPaymentStrictReceiveOp() *PathPaymentStrictReceiveOp
	//   MANAGE_SELL_OFFER:
	//      ManageSellOfferOp() *ManageSellOfferOp
	//   CREATE_PASSIVE_SELL_OFFER:
	//      CreatePassiveSellOfferOp() *CreatePassiveSellOfferOp
	//   SET_OPTIONS:
	//      SetOptionsOp() *SetOptionsOp
	//   CHANGE_TRUST:
	//      ChangeTrustOp() *ChangeTrustOp
	//   ALLOW_TRUST:
	//      AllowTrustOp() *AllowTrustOp
	//   ACCOUNT_MERGE:
	//      Destination() *MuxedAccount
	//   INFLATION:
	//      void
	//   MANAGE_DATA:
	//      ManageDataOp() *ManageDataOp
	//   BUMP_SEQUENCE:
	//      BumpSequenceOp() *BumpSequenceOp
	//   MANAGE_BUY_OFFER:
	//      ManageBuyOfferOp() *ManageBuyOfferOp
	//   PATH_PAYMENT_STRICT_SEND:
	//      PathPaymentStrictSendOp() *PathPaymentStrictSendOp
	//   CREATE_CLAIMABLE_BALANCE:
	//      CreateClaimableBalanceOp() *CreateClaimableBalanceOp
	//   CLAIM_CLAIMABLE_BALANCE:
	//      ClaimClaimableBalanceOp() *ClaimClaimableBalanceOp
	//   BEGIN_SPONSORING_FUTURE_RESERVES:
	//      BeginSponsoringFutureReservesOp() *BeginSponsoringFutureReservesOp
	//   END_SPONSORING_FUTURE_RESERVES:
	//      void
	//   REVOKE_SPONSORSHIP:
	//      RevokeSponsorshipOp() *RevokeSponsorshipOp
	//   CLAWBACK:
	//      ClawbackOp() *ClawbackOp
	//   CLAWBACK_CLAIMABLE_BALANCE:
	//      ClawbackClaimableBalanceOp() *ClawbackClaimableBalanceOp
	//   SET_TRUST_LINE_FLAGS:
	//      SetTrustLineFlagsOp() *SetTrustLineFlagsOp
	//   LIQUIDITY_POOL_DEPOSIT:
	//      LiquidityPoolDepositOp() *LiquidityPoolDepositOp
	//   LIQUIDITY_POOL_WITHDRAW:
	//      LiquidityPoolWithdrawOp() *LiquidityPoolWithdrawOp
	//   INVOKE_HOST_FUNCTION:
	//      InvokeHostFunctionOp() *InvokeHostFunctionOp
	Type OperationType
	_u   interface{}
}

type HashIDPreimage struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_OP_ID:
	//      OperationID() *XdrAnon_HashIDPreimage_OperationID
	//   ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
	//      RevokeID() *XdrAnon_HashIDPreimage_RevokeID
	//   ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519:
	//      Ed25519ContractID() *XdrAnon_HashIDPreimage_Ed25519ContractID
	//   ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT:
	//      ContractID() *XdrAnon_HashIDPreimage_ContractID
	//   ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET:
	//      FromAsset() *Asset
	//   ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT:
	//      SourceAccountContractID() *XdrAnon_HashIDPreimage_SourceAccountContractID
	Type EnvelopeType
	_u   interface{}
}
type XdrAnon_HashIDPreimage_OperationID struct {
	SourceAccount AccountID
	SeqNum        SequenceNumber
	OpNum         Uint32
}
type XdrAnon_HashIDPreimage_RevokeID struct {
	SourceAccount   AccountID
	SeqNum          SequenceNumber
	OpNum           Uint32
	LiquidityPoolID PoolID
	Asset           Asset
}
type XdrAnon_HashIDPreimage_Ed25519ContractID struct {
	Ed25519 Uint256
	Salt    Uint256
}
type XdrAnon_HashIDPreimage_ContractID struct {
	ContractID Hash
	Salt       Uint256
}
type XdrAnon_HashIDPreimage_SourceAccountContractID struct {
	SourceAccount AccountID
	Salt          Uint256
}

type MemoType int32

const (
	MEMO_NONE   MemoType = 0
	MEMO_TEXT   MemoType = 1
	MEMO_ID     MemoType = 2
	MEMO_HASH   MemoType = 3
	MEMO_RETURN MemoType = 4
)

type Memo struct {
	// The union discriminant Type selects among the following arms:
	//   MEMO_NONE:
	//      void
	//   MEMO_TEXT:
	//      Text() *string // bound 28
	//   MEMO_ID:
	//      Id() *Uint64
	//   MEMO_HASH:
	//      Hash() *Hash
	//   MEMO_RETURN:
	//      RetHash() *Hash
	Type MemoType
	_u   interface{}
}

type TimeBounds struct {
	MinTime TimePoint
	// 0 here means no maxTime
	MaxTime TimePoint
}

type LedgerBounds struct {
	MinLedger Uint32
	// 0 here means no maxLedger
	MaxLedger Uint32
}

type PreconditionsV2 struct {
	TimeBounds *TimeBounds
	// Transaction only valid for ledger numbers n such that
	// minLedger <= n < maxLedger (if maxLedger == 0, then
	// only minLedger is checked)
	LedgerBounds *LedgerBounds
	// If NULL, only valid when sourceAccount's sequence number
	// is seqNum - 1.  Otherwise, valid when sourceAccount's
	// sequence number n satisfies minSeqNum <= n < tx.seqNum.
	// Note that after execution the account's sequence number
	// is always raised to tx.seqNum, and a transaction is not
	// valid if tx.seqNum is too high to ensure replay protection.
	MinSeqNum *SequenceNumber
	// For the transaction to be valid, the current ledger time must
	// be at least minSeqAge greater than sourceAccount's seqTime.
	MinSeqAge Duration
	// For the transaction to be valid, the current ledger number
	// must be at least minSeqLedgerGap greater than sourceAccount's
	// seqLedger.
	MinSeqLedgerGap Uint32
	// For the transaction to be valid, there must be a signature
	// corresponding to every Signer in this array, even if the
	// signature is not otherwise required by the sourceAccount or
	// operations.
	ExtraSigners []SignerKey // bound 2
}

type PreconditionType int32

const (
	PRECOND_NONE PreconditionType = 0
	PRECOND_TIME PreconditionType = 1
	PRECOND_V2   PreconditionType = 2
)

type Preconditions struct {
	// The union discriminant Type selects among the following arms:
	//   PRECOND_NONE:
	//      void
	//   PRECOND_TIME:
	//      TimeBounds() *TimeBounds
	//   PRECOND_V2:
	//      V2() *PreconditionsV2
	Type PreconditionType
	_u   interface{}
}

// maximum number of operations per transaction
const MAX_OPS_PER_TX = 100

// TransactionV0 is a transaction with the AccountID discriminant stripped off,
// leaving a raw ed25519 public key to identify the source account. This is used
// for backwards compatibility starting from the protocol 12/13 boundary. If an
// "old-style" TransactionEnvelope containing a Transaction is parsed with this
// XDR definition, it will be parsed as a "new-style" TransactionEnvelope
// containing a TransactionV0.
type TransactionV0 struct {
	SourceAccountEd25519 Uint256
	Fee                  Uint32
	SeqNum               SequenceNumber
	TimeBounds           *TimeBounds
	Memo                 Memo
	Operations           []Operation // bound MAX_OPS_PER_TX
	Ext                  XdrAnon_TransactionV0_Ext
}
type XdrAnon_TransactionV0_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type TransactionV0Envelope struct {
	Tx TransactionV0
	/* Each decorated signature is a signature over the SHA256 hash of
	 * a TransactionSignaturePayload */
	Signatures []DecoratedSignature // bound 20
}

/*
a transaction is a container for a set of operations
  - is executed by an account
  - fees are collected from the account
  - operations are executed in order as one ACID transaction
    either all operations are applied or none are
    if any returns a failing code
*/
type Transaction struct {
	// account used to run the transaction
	SourceAccount MuxedAccount
	// the fee the sourceAccount will pay
	Fee Uint32
	// sequence number to consume in the account
	SeqNum SequenceNumber
	// validity conditions
	Cond       Preconditions
	Memo       Memo
	Operations []Operation // bound MAX_OPS_PER_TX
	Ext        XdrAnon_Transaction_Ext
}

// reserved for future use
type XdrAnon_Transaction_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type TransactionV1Envelope struct {
	Tx Transaction
	/* Each decorated signature is a signature over the SHA256 hash of
	 * a TransactionSignaturePayload */
	Signatures []DecoratedSignature // bound 20
}

type FeeBumpTransaction struct {
	FeeSource MuxedAccount
	Fee       Int64
	InnerTx   XdrAnon_FeeBumpTransaction_InnerTx
	Ext       XdrAnon_FeeBumpTransaction_Ext
}
type XdrAnon_FeeBumpTransaction_InnerTx struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_TX:
	//      V1() *TransactionV1Envelope
	Type EnvelopeType
	_u   interface{}
}
type XdrAnon_FeeBumpTransaction_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type FeeBumpTransactionEnvelope struct {
	Tx FeeBumpTransaction
	/* Each decorated signature is a signature over the SHA256 hash of
	 * a TransactionSignaturePayload */
	Signatures []DecoratedSignature // bound 20
}

/* A TransactionEnvelope wraps a transaction with signatures. */
type TransactionEnvelope struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_TX_V0:
	//      V0() *TransactionV0Envelope
	//   ENVELOPE_TYPE_TX:
	//      V1() *TransactionV1Envelope
	//   ENVELOPE_TYPE_TX_FEE_BUMP:
	//      FeeBump() *FeeBumpTransactionEnvelope
	Type EnvelopeType
	_u   interface{}
}

type TransactionSignaturePayload struct {
	NetworkId         Hash
	TaggedTransaction XdrAnon_TransactionSignaturePayload_TaggedTransaction
}
type XdrAnon_TransactionSignaturePayload_TaggedTransaction struct {
	// The union discriminant Type selects among the following arms:
	//   ENVELOPE_TYPE_TX:
	//      Tx() *Transaction
	//   ENVELOPE_TYPE_TX_FEE_BUMP:
	//      FeeBump() *FeeBumpTransaction
	Type EnvelopeType
	_u   interface{}
}

type ClaimAtomType int32

const (
	CLAIM_ATOM_TYPE_V0             ClaimAtomType = 0
	CLAIM_ATOM_TYPE_ORDER_BOOK     ClaimAtomType = 1
	CLAIM_ATOM_TYPE_LIQUIDITY_POOL ClaimAtomType = 2
)

// ClaimOfferAtomV0 is a ClaimOfferAtom with the AccountID discriminant stripped
// off, leaving a raw ed25519 public key to identify the source account. This is
// used for backwards compatibility starting from the protocol 17/18 boundary.
// If an "old-style" ClaimOfferAtom is parsed with this XDR definition, it will
// be parsed as a "new-style" ClaimAtom containing a ClaimOfferAtomV0.
type ClaimOfferAtomV0 struct {
	// emitted to identify the offer
	SellerEd25519 Uint256
	OfferID       Int64
	// amount and asset taken from the owner
	AssetSold  Asset
	AmountSold Int64
	// amount and asset sent to the owner
	AssetBought  Asset
	AmountBought Int64
}

type ClaimOfferAtom struct {
	// emitted to identify the offer
	SellerID AccountID
	OfferID  Int64
	// amount and asset taken from the owner
	AssetSold  Asset
	AmountSold Int64
	// amount and asset sent to the owner
	AssetBought  Asset
	AmountBought Int64
}

type ClaimLiquidityAtom struct {
	LiquidityPoolID PoolID
	// amount and asset taken from the pool
	AssetSold  Asset
	AmountSold Int64
	// amount and asset sent to the pool
	AssetBought  Asset
	AmountBought Int64
}

/*
This result is used when offers are taken or liquidity is exchanged with a

	liquidity pool during an operation
*/
type ClaimAtom struct {
	// The union discriminant Type selects among the following arms:
	//   CLAIM_ATOM_TYPE_V0:
	//      V0() *ClaimOfferAtomV0
	//   CLAIM_ATOM_TYPE_ORDER_BOOK:
	//      OrderBook() *ClaimOfferAtom
	//   CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
	//      LiquidityPool() *ClaimLiquidityAtom
	Type ClaimAtomType
	_u   interface{}
}

type CreateAccountResultCode int32

const (
	// account was created
	CREATE_ACCOUNT_SUCCESS CreateAccountResultCode = 0
	// invalid destination
	CREATE_ACCOUNT_MALFORMED CreateAccountResultCode = -1
	// not enough funds in source account
	CREATE_ACCOUNT_UNDERFUNDED CreateAccountResultCode = -2
	// would create an account below the min reserve
	CREATE_ACCOUNT_LOW_RESERVE CreateAccountResultCode = -3
	// account already exists
	CREATE_ACCOUNT_ALREADY_EXIST CreateAccountResultCode = -4
)

type CreateAccountResult struct {
	// The union discriminant Code selects among the following arms:
	//   CREATE_ACCOUNT_SUCCESS:
	//      void
	//   CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
	//      void
	Code CreateAccountResultCode
	_u   interface{}
}

type PaymentResultCode int32

const (
	// payment successfully completed
	PAYMENT_SUCCESS PaymentResultCode = 0
	// bad input
	PAYMENT_MALFORMED PaymentResultCode = -1
	// not enough funds in source account
	PAYMENT_UNDERFUNDED PaymentResultCode = -2
	// no trust line on source account
	PAYMENT_SRC_NO_TRUST PaymentResultCode = -3
	// source not authorized to transfer
	PAYMENT_SRC_NOT_AUTHORIZED PaymentResultCode = -4
	// destination account does not exist
	PAYMENT_NO_DESTINATION PaymentResultCode = -5
	// destination missing a trust line for asset
	PAYMENT_NO_TRUST PaymentResultCode = -6
	// destination not authorized to hold asset
	PAYMENT_NOT_AUTHORIZED PaymentResultCode = -7
	// destination would go above their limit
	PAYMENT_LINE_FULL PaymentResultCode = -8
	// missing issuer on asset
	PAYMENT_NO_ISSUER PaymentResultCode = -9
)

type PaymentResult struct {
	// The union discriminant Code selects among the following arms:
	//   PAYMENT_SUCCESS:
	//      void
	//   PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
	//      void
	Code PaymentResultCode
	_u   interface{}
}

type PathPaymentStrictReceiveResultCode int32

const (
	// success
	PATH_PAYMENT_STRICT_RECEIVE_SUCCESS PathPaymentStrictReceiveResultCode = 0
	// bad input
	PATH_PAYMENT_STRICT_RECEIVE_MALFORMED PathPaymentStrictReceiveResultCode = -1
	// not enough funds in source account
	PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED PathPaymentStrictReceiveResultCode = -2
	// no trust line on source account
	PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST PathPaymentStrictReceiveResultCode = -3
	// source not authorized to transfer
	PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED PathPaymentStrictReceiveResultCode = -4
	// destination account does not exist
	PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION PathPaymentStrictReceiveResultCode = -5
	// dest missing a trust line for asset
	PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST PathPaymentStrictReceiveResultCode = -6
	// dest not authorized to hold asset
	PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED PathPaymentStrictReceiveResultCode = -7
	// dest would go above their limit
	PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL PathPaymentStrictReceiveResultCode = -8
	// missing issuer on one asset
	PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER PathPaymentStrictReceiveResultCode = -9
	// not enough offers to satisfy path
	PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS PathPaymentStrictReceiveResultCode = -10
	// would cross one of its own offers
	PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF PathPaymentStrictReceiveResultCode = -11
	// could not satisfy sendmax
	PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX PathPaymentStrictReceiveResultCode = -12
)

type SimplePaymentResult struct {
	Destination AccountID
	Asset       Asset
	Amount      Int64
}

type PathPaymentStrictReceiveResult struct {
	// The union discriminant Code selects among the following arms:
	//   PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
	//      Success() *XdrAnon_PathPaymentStrictReceiveResult_Success
	//   PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
	//      void
	//   PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
	//      NoIssuer() *Asset
	//   PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
	//      void
	Code PathPaymentStrictReceiveResultCode
	_u   interface{}
}
type XdrAnon_PathPaymentStrictReceiveResult_Success struct {
	Offers []ClaimAtom
	Last   SimplePaymentResult
}

type PathPaymentStrictSendResultCode int32

const (
	// success
	PATH_PAYMENT_STRICT_SEND_SUCCESS PathPaymentStrictSendResultCode = 0
	// bad input
	PATH_PAYMENT_STRICT_SEND_MALFORMED PathPaymentStrictSendResultCode = -1
	// not enough funds in source account
	PATH_PAYMENT_STRICT_SEND_UNDERFUNDED PathPaymentStrictSendResultCode = -2
	// no trust line on source account
	PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST PathPaymentStrictSendResultCode = -3
	// source not authorized to transfer
	PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED PathPaymentStrictSendResultCode = -4
	// destination account does not exist
	PATH_PAYMENT_STRICT_SEND_NO_DESTINATION PathPaymentStrictSendResultCode = -5
	// dest missing a trust line for asset
	PATH_PAYMENT_STRICT_SEND_NO_TRUST PathPaymentStrictSendResultCode = -6
	// dest not authorized to hold asset
	PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED PathPaymentStrictSendResultCode = -7
	// dest would go above their limit
	PATH_PAYMENT_STRICT_SEND_LINE_FULL PathPaymentStrictSendResultCode = -8
	// missing issuer on one asset
	PATH_PAYMENT_STRICT_SEND_NO_ISSUER PathPaymentStrictSendResultCode = -9
	// not enough offers to satisfy path
	PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS PathPaymentStrictSendResultCode = -10
	// would cross one of its own offers
	PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF PathPaymentStrictSendResultCode = -11
	// could not satisfy destMin
	PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN PathPaymentStrictSendResultCode = -12
)

type PathPaymentStrictSendResult struct {
	// The union discriminant Code selects among the following arms:
	//   PATH_PAYMENT_STRICT_SEND_SUCCESS:
	//      Success() *XdrAnon_PathPaymentStrictSendResult_Success
	//   PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL:
	//      void
	//   PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
	//      NoIssuer() *Asset
	//   PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
	//      void
	Code PathPaymentStrictSendResultCode
	_u   interface{}
}
type XdrAnon_PathPaymentStrictSendResult_Success struct {
	Offers []ClaimAtom
	Last   SimplePaymentResult
}

type ManageSellOfferResultCode int32

const (
	// codes considered as "success" for the operation
	MANAGE_SELL_OFFER_SUCCESS ManageSellOfferResultCode = 0
	// generated offer would be invalid
	MANAGE_SELL_OFFER_MALFORMED ManageSellOfferResultCode = -1
	// no trust line for what we're selling
	MANAGE_SELL_OFFER_SELL_NO_TRUST ManageSellOfferResultCode = -2
	// no trust line for what we're buying
	MANAGE_SELL_OFFER_BUY_NO_TRUST ManageSellOfferResultCode = -3
	// not authorized to sell
	MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED ManageSellOfferResultCode = -4
	// not authorized to buy
	MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED ManageSellOfferResultCode = -5
	// can't receive more of what it's buying
	MANAGE_SELL_OFFER_LINE_FULL ManageSellOfferResultCode = -6
	// doesn't hold what it's trying to sell
	MANAGE_SELL_OFFER_UNDERFUNDED ManageSellOfferResultCode = -7
	// would cross an offer from the same user
	MANAGE_SELL_OFFER_CROSS_SELF ManageSellOfferResultCode = -8
	// no issuer for what we're selling
	MANAGE_SELL_OFFER_SELL_NO_ISSUER ManageSellOfferResultCode = -9
	// no issuer for what we're buying
	MANAGE_SELL_OFFER_BUY_NO_ISSUER ManageSellOfferResultCode = -10
	// offerID does not match an existing offer
	MANAGE_SELL_OFFER_NOT_FOUND ManageSellOfferResultCode = -11
	// not enough funds to create a new Offer
	MANAGE_SELL_OFFER_LOW_RESERVE ManageSellOfferResultCode = -12
)

type ManageOfferEffect int32

const (
	MANAGE_OFFER_CREATED ManageOfferEffect = 0
	MANAGE_OFFER_UPDATED ManageOfferEffect = 1
	MANAGE_OFFER_DELETED ManageOfferEffect = 2
)

type ManageOfferSuccessResult struct {
	// offers that got claimed while creating this offer
	OffersClaimed []ClaimAtom
	Offer         XdrAnon_ManageOfferSuccessResult_Offer
}
type XdrAnon_ManageOfferSuccessResult_Offer struct {
	// The union discriminant Effect selects among the following arms:
	//   MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
	//      Offer() *OfferEntry
	//   MANAGE_OFFER_DELETED:
	//      void
	Effect ManageOfferEffect
	_u     interface{}
}

type ManageSellOfferResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_SELL_OFFER_SUCCESS:
	//      Success() *ManageOfferSuccessResult
	//   MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
	//      void
	Code ManageSellOfferResultCode
	_u   interface{}
}

type ManageBuyOfferResultCode int32

const (
	// codes considered as "success" for the operation
	MANAGE_BUY_OFFER_SUCCESS ManageBuyOfferResultCode = 0
	// generated offer would be invalid
	MANAGE_BUY_OFFER_MALFORMED ManageBuyOfferResultCode = -1
	// no trust line for what we're selling
	MANAGE_BUY_OFFER_SELL_NO_TRUST ManageBuyOfferResultCode = -2
	// no trust line for what we're buying
	MANAGE_BUY_OFFER_BUY_NO_TRUST ManageBuyOfferResultCode = -3
	// not authorized to sell
	MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED ManageBuyOfferResultCode = -4
	// not authorized to buy
	MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED ManageBuyOfferResultCode = -5
	// can't receive more of what it's buying
	MANAGE_BUY_OFFER_LINE_FULL ManageBuyOfferResultCode = -6
	// doesn't hold what it's trying to sell
	MANAGE_BUY_OFFER_UNDERFUNDED ManageBuyOfferResultCode = -7
	// would cross an offer from the same user
	MANAGE_BUY_OFFER_CROSS_SELF ManageBuyOfferResultCode = -8
	// no issuer for what we're selling
	MANAGE_BUY_OFFER_SELL_NO_ISSUER ManageBuyOfferResultCode = -9
	// no issuer for what we're buying
	MANAGE_BUY_OFFER_BUY_NO_ISSUER ManageBuyOfferResultCode = -10
	// offerID does not match an existing offer
	MANAGE_BUY_OFFER_NOT_FOUND ManageBuyOfferResultCode = -11
	// not enough funds to create a new Offer
	MANAGE_BUY_OFFER_LOW_RESERVE ManageBuyOfferResultCode = -12
)

type ManageBuyOfferResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_BUY_OFFER_SUCCESS:
	//      Success() *ManageOfferSuccessResult
	//   MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
	//      void
	Code ManageBuyOfferResultCode
	_u   interface{}
}

type SetOptionsResultCode int32

const (
	// codes considered as "success" for the operation
	SET_OPTIONS_SUCCESS SetOptionsResultCode = 0
	// not enough funds to add a signer
	SET_OPTIONS_LOW_RESERVE SetOptionsResultCode = -1
	// max number of signers already reached
	SET_OPTIONS_TOO_MANY_SIGNERS SetOptionsResultCode = -2
	// invalid combination of clear/set flags
	SET_OPTIONS_BAD_FLAGS SetOptionsResultCode = -3
	// inflation account does not exist
	SET_OPTIONS_INVALID_INFLATION SetOptionsResultCode = -4
	// can no longer change this option
	SET_OPTIONS_CANT_CHANGE SetOptionsResultCode = -5
	// can't set an unknown flag
	SET_OPTIONS_UNKNOWN_FLAG SetOptionsResultCode = -6
	// bad value for weight/threshold
	SET_OPTIONS_THRESHOLD_OUT_OF_RANGE SetOptionsResultCode = -7
	// signer cannot be masterkey
	SET_OPTIONS_BAD_SIGNER SetOptionsResultCode = -8
	// malformed home domain
	SET_OPTIONS_INVALID_HOME_DOMAIN SetOptionsResultCode = -9
	// auth revocable is required for clawback
	SET_OPTIONS_AUTH_REVOCABLE_REQUIRED SetOptionsResultCode = -10
)

type SetOptionsResult struct {
	// The union discriminant Code selects among the following arms:
	//   SET_OPTIONS_SUCCESS:
	//      void
	//   SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
	//      void
	Code SetOptionsResultCode
	_u   interface{}
}

type ChangeTrustResultCode int32

const (
	// codes considered as "success" for the operation
	CHANGE_TRUST_SUCCESS ChangeTrustResultCode = 0
	// bad input
	CHANGE_TRUST_MALFORMED ChangeTrustResultCode = -1
	// could not find issuer
	CHANGE_TRUST_NO_ISSUER ChangeTrustResultCode = -2
	// cannot drop limit below balance
	CHANGE_TRUST_INVALID_LIMIT ChangeTrustResultCode = -3
	// not enough funds to create a new trust line,
	CHANGE_TRUST_LOW_RESERVE ChangeTrustResultCode = -4
	// trusting self is not allowed
	CHANGE_TRUST_SELF_NOT_ALLOWED ChangeTrustResultCode = -5
	// Asset trustline is missing for pool
	CHANGE_TRUST_TRUST_LINE_MISSING ChangeTrustResultCode = -6
	// Asset trustline is still referenced in a pool
	CHANGE_TRUST_CANNOT_DELETE ChangeTrustResultCode = -7
	// Asset trustline is deauthorized
	CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES ChangeTrustResultCode = -8
)

type ChangeTrustResult struct {
	// The union discriminant Code selects among the following arms:
	//   CHANGE_TRUST_SUCCESS:
	//      void
	//   CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
	//      void
	Code ChangeTrustResultCode
	_u   interface{}
}

type AllowTrustResultCode int32

const (
	// codes considered as "success" for the operation
	ALLOW_TRUST_SUCCESS AllowTrustResultCode = 0
	// asset is not ASSET_TYPE_ALPHANUM
	ALLOW_TRUST_MALFORMED AllowTrustResultCode = -1
	// trustor does not have a trustline
	ALLOW_TRUST_NO_TRUST_LINE AllowTrustResultCode = -2
	// source account does not require trust
	ALLOW_TRUST_TRUST_NOT_REQUIRED AllowTrustResultCode = -3
	// source account can't revoke trust,
	ALLOW_TRUST_CANT_REVOKE AllowTrustResultCode = -4
	// trusting self is not allowed
	ALLOW_TRUST_SELF_NOT_ALLOWED AllowTrustResultCode = -5
	// claimable balances can't be created
	ALLOW_TRUST_LOW_RESERVE AllowTrustResultCode = -6
)

type AllowTrustResult struct {
	// The union discriminant Code selects among the following arms:
	//   ALLOW_TRUST_SUCCESS:
	//      void
	//   ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
	//      void
	Code AllowTrustResultCode
	_u   interface{}
}

type AccountMergeResultCode int32

const (
	// codes considered as "success" for the operation
	ACCOUNT_MERGE_SUCCESS AccountMergeResultCode = 0
	// can't merge onto itself
	ACCOUNT_MERGE_MALFORMED AccountMergeResultCode = -1
	// destination does not exist
	ACCOUNT_MERGE_NO_ACCOUNT AccountMergeResultCode = -2
	// source account has AUTH_IMMUTABLE set
	ACCOUNT_MERGE_IMMUTABLE_SET AccountMergeResultCode = -3
	// account has trust lines/offers
	ACCOUNT_MERGE_HAS_SUB_ENTRIES AccountMergeResultCode = -4
	// sequence number is over max allowed
	ACCOUNT_MERGE_SEQNUM_TOO_FAR AccountMergeResultCode = -5
	// can't add source balance to
	ACCOUNT_MERGE_DEST_FULL AccountMergeResultCode = -6
	// destination balance
	ACCOUNT_MERGE_IS_SPONSOR AccountMergeResultCode = -7
)

type AccountMergeResult struct {
	// The union discriminant Code selects among the following arms:
	//   ACCOUNT_MERGE_SUCCESS:
	//      SourceAccountBalance() *Int64
	//   ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
	//      void
	Code AccountMergeResultCode
	_u   interface{}
}

type InflationResultCode int32

const (
	// codes considered as "success" for the operation
	INFLATION_SUCCESS InflationResultCode = 0
	// codes considered as "failure" for the operation
	INFLATION_NOT_TIME InflationResultCode = -1
)

type InflationPayout struct {
	Destination AccountID
	Amount      Int64
}

type InflationResult struct {
	// The union discriminant Code selects among the following arms:
	//   INFLATION_SUCCESS:
	//      Payouts() *[]InflationPayout
	//   INFLATION_NOT_TIME:
	//      void
	Code InflationResultCode
	_u   interface{}
}

type ManageDataResultCode int32

const (
	// codes considered as "success" for the operation
	MANAGE_DATA_SUCCESS ManageDataResultCode = 0
	// The network hasn't moved to this protocol change yet
	MANAGE_DATA_NOT_SUPPORTED_YET ManageDataResultCode = -1
	// Trying to remove a Data Entry that isn't there
	MANAGE_DATA_NAME_NOT_FOUND ManageDataResultCode = -2
	// not enough funds to create a new Data Entry
	MANAGE_DATA_LOW_RESERVE ManageDataResultCode = -3
	// Name not a valid string
	MANAGE_DATA_INVALID_NAME ManageDataResultCode = -4
)

type ManageDataResult struct {
	// The union discriminant Code selects among the following arms:
	//   MANAGE_DATA_SUCCESS:
	//      void
	//   MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
	//      void
	Code ManageDataResultCode
	_u   interface{}
}

type BumpSequenceResultCode int32

const (
	// codes considered as "success" for the operation
	BUMP_SEQUENCE_SUCCESS BumpSequenceResultCode = 0
	// codes considered as "failure" for the operation
	BUMP_SEQUENCE_BAD_SEQ BumpSequenceResultCode = -1
)

type BumpSequenceResult struct {
	// The union discriminant Code selects among the following arms:
	//   BUMP_SEQUENCE_SUCCESS:
	//      void
	//   BUMP_SEQUENCE_BAD_SEQ:
	//      void
	Code BumpSequenceResultCode
	_u   interface{}
}

type CreateClaimableBalanceResultCode int32

const (
	CREATE_CLAIMABLE_BALANCE_SUCCESS        CreateClaimableBalanceResultCode = 0
	CREATE_CLAIMABLE_BALANCE_MALFORMED      CreateClaimableBalanceResultCode = -1
	CREATE_CLAIMABLE_BALANCE_LOW_RESERVE    CreateClaimableBalanceResultCode = -2
	CREATE_CLAIMABLE_BALANCE_NO_TRUST       CreateClaimableBalanceResultCode = -3
	CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED CreateClaimableBalanceResultCode = -4
	CREATE_CLAIMABLE_BALANCE_UNDERFUNDED    CreateClaimableBalanceResultCode = -5
)

type CreateClaimableBalanceResult struct {
	// The union discriminant Code selects among the following arms:
	//   CREATE_CLAIMABLE_BALANCE_SUCCESS:
	//      BalanceID() *ClaimableBalanceID
	//   CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
	//      void
	Code CreateClaimableBalanceResultCode
	_u   interface{}
}

type ClaimClaimableBalanceResultCode int32

const (
	CLAIM_CLAIMABLE_BALANCE_SUCCESS        ClaimClaimableBalanceResultCode = 0
	CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST ClaimClaimableBalanceResultCode = -1
	CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM   ClaimClaimableBalanceResultCode = -2
	CLAIM_CLAIMABLE_BALANCE_LINE_FULL      ClaimClaimableBalanceResultCode = -3
	CLAIM_CLAIMABLE_BALANCE_NO_TRUST       ClaimClaimableBalanceResultCode = -4
	CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED ClaimClaimableBalanceResultCode = -5
)

type ClaimClaimableBalanceResult struct {
	// The union discriminant Code selects among the following arms:
	//   CLAIM_CLAIMABLE_BALANCE_SUCCESS:
	//      void
	//   CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
	//      void
	Code ClaimClaimableBalanceResultCode
	_u   interface{}
}

type BeginSponsoringFutureReservesResultCode int32

const (
	// codes considered as "success" for the operation
	BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS BeginSponsoringFutureReservesResultCode = 0
	// codes considered as "failure" for the operation
	BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED         BeginSponsoringFutureReservesResultCode = -1
	BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED BeginSponsoringFutureReservesResultCode = -2
	BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE         BeginSponsoringFutureReservesResultCode = -3
)

type BeginSponsoringFutureReservesResult struct {
	// The union discriminant Code selects among the following arms:
	//   BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
	//      void
	//   BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
	//      void
	Code BeginSponsoringFutureReservesResultCode
	_u   interface{}
}

type EndSponsoringFutureReservesResultCode int32

const (
	// codes considered as "success" for the operation
	END_SPONSORING_FUTURE_RESERVES_SUCCESS EndSponsoringFutureReservesResultCode = 0
	// codes considered as "failure" for the operation
	END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED EndSponsoringFutureReservesResultCode = -1
)

type EndSponsoringFutureReservesResult struct {
	// The union discriminant Code selects among the following arms:
	//   END_SPONSORING_FUTURE_RESERVES_SUCCESS:
	//      void
	//   END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
	//      void
	Code EndSponsoringFutureReservesResultCode
	_u   interface{}
}

type RevokeSponsorshipResultCode int32

const (
	// codes considered as "success" for the operation
	REVOKE_SPONSORSHIP_SUCCESS RevokeSponsorshipResultCode = 0
	// codes considered as "failure" for the operation
	REVOKE_SPONSORSHIP_DOES_NOT_EXIST    RevokeSponsorshipResultCode = -1
	REVOKE_SPONSORSHIP_NOT_SPONSOR       RevokeSponsorshipResultCode = -2
	REVOKE_SPONSORSHIP_LOW_RESERVE       RevokeSponsorshipResultCode = -3
	REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE RevokeSponsorshipResultCode = -4
	REVOKE_SPONSORSHIP_MALFORMED         RevokeSponsorshipResultCode = -5
)

type RevokeSponsorshipResult struct {
	// The union discriminant Code selects among the following arms:
	//   REVOKE_SPONSORSHIP_SUCCESS:
	//      void
	//   REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
	//      void
	Code RevokeSponsorshipResultCode
	_u   interface{}
}

type ClawbackResultCode int32

const (
	// codes considered as "success" for the operation
	CLAWBACK_SUCCESS ClawbackResultCode = 0
	// codes considered as "failure" for the operation
	CLAWBACK_MALFORMED            ClawbackResultCode = -1
	CLAWBACK_NOT_CLAWBACK_ENABLED ClawbackResultCode = -2
	CLAWBACK_NO_TRUST             ClawbackResultCode = -3
	CLAWBACK_UNDERFUNDED          ClawbackResultCode = -4
)

type ClawbackResult struct {
	// The union discriminant Code selects among the following arms:
	//   CLAWBACK_SUCCESS:
	//      void
	//   CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
	//      void
	Code ClawbackResultCode
	_u   interface{}
}

type ClawbackClaimableBalanceResultCode int32

const (
	// codes considered as "success" for the operation
	CLAWBACK_CLAIMABLE_BALANCE_SUCCESS ClawbackClaimableBalanceResultCode = 0
	// codes considered as "failure" for the operation
	CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST       ClawbackClaimableBalanceResultCode = -1
	CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER           ClawbackClaimableBalanceResultCode = -2
	CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED ClawbackClaimableBalanceResultCode = -3
)

type ClawbackClaimableBalanceResult struct {
	// The union discriminant Code selects among the following arms:
	//   CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
	//      void
	//   CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
	//      void
	Code ClawbackClaimableBalanceResultCode
	_u   interface{}
}

type SetTrustLineFlagsResultCode int32

const (
	// codes considered as "success" for the operation
	SET_TRUST_LINE_FLAGS_SUCCESS SetTrustLineFlagsResultCode = 0
	// codes considered as "failure" for the operation
	SET_TRUST_LINE_FLAGS_MALFORMED     SetTrustLineFlagsResultCode = -1
	SET_TRUST_LINE_FLAGS_NO_TRUST_LINE SetTrustLineFlagsResultCode = -2
	SET_TRUST_LINE_FLAGS_CANT_REVOKE   SetTrustLineFlagsResultCode = -3
	SET_TRUST_LINE_FLAGS_INVALID_STATE SetTrustLineFlagsResultCode = -4
	// claimable balances can't be created
	SET_TRUST_LINE_FLAGS_LOW_RESERVE SetTrustLineFlagsResultCode = -5
)

type SetTrustLineFlagsResult struct {
	// The union discriminant Code selects among the following arms:
	//   SET_TRUST_LINE_FLAGS_SUCCESS:
	//      void
	//   SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
	//      void
	Code SetTrustLineFlagsResultCode
	_u   interface{}
}

type LiquidityPoolDepositResultCode int32

const (
	// codes considered as "success" for the operation
	LIQUIDITY_POOL_DEPOSIT_SUCCESS LiquidityPoolDepositResultCode = 0
	// bad input
	LIQUIDITY_POOL_DEPOSIT_MALFORMED LiquidityPoolDepositResultCode = -1
	// no trust line for one of the
	LIQUIDITY_POOL_DEPOSIT_NO_TRUST LiquidityPoolDepositResultCode = -2
	// not authorized for one of the
	LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED LiquidityPoolDepositResultCode = -3
	// not enough balance for one of
	LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED LiquidityPoolDepositResultCode = -4
	// pool share trust line doesn't
	LIQUIDITY_POOL_DEPOSIT_LINE_FULL LiquidityPoolDepositResultCode = -5
	// deposit price outside bounds
	LIQUIDITY_POOL_DEPOSIT_BAD_PRICE LiquidityPoolDepositResultCode = -6
	// pool reserves are full
	LIQUIDITY_POOL_DEPOSIT_POOL_FULL LiquidityPoolDepositResultCode = -7
)

type LiquidityPoolDepositResult struct {
	// The union discriminant Code selects among the following arms:
	//   LIQUIDITY_POOL_DEPOSIT_SUCCESS:
	//      void
	//   LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
	//      void
	Code LiquidityPoolDepositResultCode
	_u   interface{}
}

type LiquidityPoolWithdrawResultCode int32

const (
	// codes considered as "success" for the operation
	LIQUIDITY_POOL_WITHDRAW_SUCCESS LiquidityPoolWithdrawResultCode = 0
	// bad input
	LIQUIDITY_POOL_WITHDRAW_MALFORMED LiquidityPoolWithdrawResultCode = -1
	// no trust line for one of the
	LIQUIDITY_POOL_WITHDRAW_NO_TRUST LiquidityPoolWithdrawResultCode = -2
	// not enough balance of the
	LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED LiquidityPoolWithdrawResultCode = -3
	// would go above limit for one
	LIQUIDITY_POOL_WITHDRAW_LINE_FULL LiquidityPoolWithdrawResultCode = -4
	// of the assets
	LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM LiquidityPoolWithdrawResultCode = -5
)

type LiquidityPoolWithdrawResult struct {
	// The union discriminant Code selects among the following arms:
	//   LIQUIDITY_POOL_WITHDRAW_SUCCESS:
	//      void
	//   LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
	//      void
	Code LiquidityPoolWithdrawResultCode
	_u   interface{}
}

type InvokeHostFunctionResultCode int32

const (
	// codes considered as "success" for the operation
	INVOKE_HOST_FUNCTION_SUCCESS InvokeHostFunctionResultCode = 0
	// codes considered as "failure" for the operation
	INVOKE_HOST_FUNCTION_MALFORMED InvokeHostFunctionResultCode = -1
	INVOKE_HOST_FUNCTION_TRAPPED   InvokeHostFunctionResultCode = -2
)

type InvokeHostFunctionResult struct {
	// The union discriminant Code selects among the following arms:
	//   INVOKE_HOST_FUNCTION_SUCCESS:
	//      Success() *SCVal
	//   INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED:
	//      void
	Code InvokeHostFunctionResultCode
	_u   interface{}
}

/* High level Operation Result */
type OperationResultCode int32

const (
	// inner object result is valid
	OpINNER OperationResultCode = 0
	// too few valid signatures / wrong network
	OpBAD_AUTH OperationResultCode = -1
	// source account was not found
	OpNO_ACCOUNT OperationResultCode = -2
	// operation not supported at this time
	OpNOT_SUPPORTED OperationResultCode = -3
	// max number of subentries already reached
	OpTOO_MANY_SUBENTRIES OperationResultCode = -4
	// operation did too much work
	OpEXCEEDED_WORK_LIMIT OperationResultCode = -5
	// account is sponsoring too many entries
	OpTOO_MANY_SPONSORING OperationResultCode = -6
)

type OperationResult struct {
	// The union discriminant Code selects among the following arms:
	//   OpINNER:
	//      Tr() *XdrAnon_OperationResult_Tr
	//   OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
	//      void
	Code OperationResultCode
	_u   interface{}
}
type XdrAnon_OperationResult_Tr struct {
	// The union discriminant Type selects among the following arms:
	//   CREATE_ACCOUNT:
	//      CreateAccountResult() *CreateAccountResult
	//   PAYMENT:
	//      PaymentResult() *PaymentResult
	//   PATH_PAYMENT_STRICT_RECEIVE:
	//      PathPaymentStrictReceiveResult() *PathPaymentStrictReceiveResult
	//   MANAGE_SELL_OFFER:
	//      ManageSellOfferResult() *ManageSellOfferResult
	//   CREATE_PASSIVE_SELL_OFFER:
	//      CreatePassiveSellOfferResult() *ManageSellOfferResult
	//   SET_OPTIONS:
	//      SetOptionsResult() *SetOptionsResult
	//   CHANGE_TRUST:
	//      ChangeTrustResult() *ChangeTrustResult
	//   ALLOW_TRUST:
	//      AllowTrustResult() *AllowTrustResult
	//   ACCOUNT_MERGE:
	//      AccountMergeResult() *AccountMergeResult
	//   INFLATION:
	//      InflationResult() *InflationResult
	//   MANAGE_DATA:
	//      ManageDataResult() *ManageDataResult
	//   BUMP_SEQUENCE:
	//      BumpSeqResult() *BumpSequenceResult
	//   MANAGE_BUY_OFFER:
	//      ManageBuyOfferResult() *ManageBuyOfferResult
	//   PATH_PAYMENT_STRICT_SEND:
	//      PathPaymentStrictSendResult() *PathPaymentStrictSendResult
	//   CREATE_CLAIMABLE_BALANCE:
	//      CreateClaimableBalanceResult() *CreateClaimableBalanceResult
	//   CLAIM_CLAIMABLE_BALANCE:
	//      ClaimClaimableBalanceResult() *ClaimClaimableBalanceResult
	//   BEGIN_SPONSORING_FUTURE_RESERVES:
	//      BeginSponsoringFutureReservesResult() *BeginSponsoringFutureReservesResult
	//   END_SPONSORING_FUTURE_RESERVES:
	//      EndSponsoringFutureReservesResult() *EndSponsoringFutureReservesResult
	//   REVOKE_SPONSORSHIP:
	//      RevokeSponsorshipResult() *RevokeSponsorshipResult
	//   CLAWBACK:
	//      ClawbackResult() *ClawbackResult
	//   CLAWBACK_CLAIMABLE_BALANCE:
	//      ClawbackClaimableBalanceResult() *ClawbackClaimableBalanceResult
	//   SET_TRUST_LINE_FLAGS:
	//      SetTrustLineFlagsResult() *SetTrustLineFlagsResult
	//   LIQUIDITY_POOL_DEPOSIT:
	//      LiquidityPoolDepositResult() *LiquidityPoolDepositResult
	//   LIQUIDITY_POOL_WITHDRAW:
	//      LiquidityPoolWithdrawResult() *LiquidityPoolWithdrawResult
	//   INVOKE_HOST_FUNCTION:
	//      InvokeHostFunctionResult() *InvokeHostFunctionResult
	Type OperationType
	_u   interface{}
}

type TransactionResultCode int32

const (
	// fee bump inner transaction succeeded
	TxFEE_BUMP_INNER_SUCCESS TransactionResultCode = 1
	// all operations succeeded
	TxSUCCESS TransactionResultCode = 0
	// one of the operations failed (none were applied)
	TxFAILED TransactionResultCode = -1
	// ledger closeTime before minTime
	TxTOO_EARLY TransactionResultCode = -2
	// ledger closeTime after maxTime
	TxTOO_LATE TransactionResultCode = -3
	// no operation was specified
	TxMISSING_OPERATION TransactionResultCode = -4
	// sequence number does not match source account
	TxBAD_SEQ TransactionResultCode = -5
	// too few valid signatures / wrong network
	TxBAD_AUTH TransactionResultCode = -6
	// fee would bring account below reserve
	TxINSUFFICIENT_BALANCE TransactionResultCode = -7
	// source account not found
	TxNO_ACCOUNT TransactionResultCode = -8
	// fee is too small
	TxINSUFFICIENT_FEE TransactionResultCode = -9
	// unused signatures attached to transaction
	TxBAD_AUTH_EXTRA TransactionResultCode = -10
	// an unknown error occurred
	TxINTERNAL_ERROR TransactionResultCode = -11
	// transaction type not supported
	TxNOT_SUPPORTED TransactionResultCode = -12
	// fee bump inner transaction failed
	TxFEE_BUMP_INNER_FAILED TransactionResultCode = -13
	// sponsorship not confirmed
	TxBAD_SPONSORSHIP TransactionResultCode = -14
	// minSeqAge or minSeqLedgerGap conditions not met
	TxBAD_MIN_SEQ_AGE_OR_GAP TransactionResultCode = -15
	// precondition is invalid
	TxMALFORMED TransactionResultCode = -16
)

// InnerTransactionResult must be binary compatible with TransactionResult
// because it is be used to represent the result of a Transaction.
type InnerTransactionResult struct {
	// Always 0. Here for binary compatibility.
	FeeCharged Int64
	Result     XdrAnon_InnerTransactionResult_Result
	Ext        XdrAnon_InnerTransactionResult_Ext
}
type XdrAnon_InnerTransactionResult_Result struct {
	// The union discriminant Code selects among the following arms:
	//   TxSUCCESS, TxFAILED:
	//      Results() *[]OperationResult
	//   TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
	//      void
	Code TransactionResultCode
	_u   interface{}
}

// reserved for future use
type XdrAnon_InnerTransactionResult_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type InnerTransactionResultPair struct {
	// hash of the inner transaction
	TransactionHash Hash
	// result for the inner transaction
	Result InnerTransactionResult
}

type TransactionResult struct {
	// actual fee charged for the transaction
	FeeCharged Int64
	Result     XdrAnon_TransactionResult_Result
	Ext        XdrAnon_TransactionResult_Ext
}
type XdrAnon_TransactionResult_Result struct {
	// The union discriminant Code selects among the following arms:
	//   TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
	//      InnerResultPair() *InnerTransactionResultPair
	//   TxSUCCESS, TxFAILED:
	//      Results() *[]OperationResult
	//   TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
	//      void
	Code TransactionResultCode
	_u   interface{}
}

// reserved for future use
type XdrAnon_TransactionResult_Ext struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type Hash = [32]byte

type Uint256 = [32]byte

type Uint32 = uint32

type Int32 = int32

type Uint64 = uint64

type Int64 = int64

// An ExtensionPoint is always marshaled as a 32-bit 0 value.  At a
// later point, it can be replaced by a different union so as to
// extend a structure.
type ExtensionPoint struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      void
	V  int32
	_u interface{}
}

type CryptoKeyType int32

const (
	KEY_TYPE_ED25519                CryptoKeyType = 0
	KEY_TYPE_PRE_AUTH_TX            CryptoKeyType = 1
	KEY_TYPE_HASH_X                 CryptoKeyType = 2
	KEY_TYPE_ED25519_SIGNED_PAYLOAD CryptoKeyType = 3
	// MUXED enum values for supported type are derived from the enum values
	// above by ORing them with 0x100
	KEY_TYPE_MUXED_ED25519 CryptoKeyType = CryptoKeyType(0x100)
)

type PublicKeyType int32

const (
	PUBLIC_KEY_TYPE_ED25519 PublicKeyType = PublicKeyType(KEY_TYPE_ED25519)
)

type SignerKeyType int32

const (
	SIGNER_KEY_TYPE_ED25519                SignerKeyType = SignerKeyType(KEY_TYPE_ED25519)
	SIGNER_KEY_TYPE_PRE_AUTH_TX            SignerKeyType = SignerKeyType(KEY_TYPE_PRE_AUTH_TX)
	SIGNER_KEY_TYPE_HASH_X                 SignerKeyType = SignerKeyType(KEY_TYPE_HASH_X)
	SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD SignerKeyType = SignerKeyType(KEY_TYPE_ED25519_SIGNED_PAYLOAD)
)

type PublicKey struct {
	// The union discriminant Type selects among the following arms:
	//   PUBLIC_KEY_TYPE_ED25519:
	//      Ed25519() *Uint256
	Type PublicKeyType
	_u   interface{}
}

type SignerKey struct {
	// The union discriminant Type selects among the following arms:
	//   SIGNER_KEY_TYPE_ED25519:
	//      Ed25519() *Uint256
	//   SIGNER_KEY_TYPE_PRE_AUTH_TX:
	//      PreAuthTx() *Uint256
	//   SIGNER_KEY_TYPE_HASH_X:
	//      HashX() *Uint256
	//   SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
	//      Ed25519SignedPayload() *XdrAnon_SignerKey_Ed25519SignedPayload
	Type SignerKeyType
	_u   interface{}
}
type XdrAnon_SignerKey_Ed25519SignedPayload struct {
	/* Public key that must sign the payload. */
	Ed25519 Uint256
	/* Payload to be raw signed by ed25519. */
	Payload []byte // bound 64
}

// variable size as the size depends on the signature scheme used
type Signature = []byte // bound 64

type SignatureHint = [4]byte

type NodeID = PublicKey

type AccountID = PublicKey

type Curve25519Secret struct {
	Key [32]byte
}

type Curve25519Public struct {
	Key [32]byte
}

type HmacSha256Key struct {
	Key [32]byte
}

type HmacSha256Mac struct {
	Mac [32]byte
}

type SCEnvMetaKind int32

const (
	SC_ENV_META_KIND_INTERFACE_VERSION SCEnvMetaKind = 0
)

type SCEnvMetaEntry struct {
	// The union discriminant Kind selects among the following arms:
	//   SC_ENV_META_KIND_INTERFACE_VERSION:
	//      InterfaceVersion() *Uint64
	Kind SCEnvMetaKind
	_u   interface{}
}

type SCSpecType int32

const (
	SC_SPEC_TYPE_VAL SCSpecType = 0
	// Types with no parameters.
	SC_SPEC_TYPE_U32        SCSpecType = 1
	SC_SPEC_TYPE_I32        SCSpecType = 2
	SC_SPEC_TYPE_U64        SCSpecType = 3
	SC_SPEC_TYPE_I64        SCSpecType = 4
	SC_SPEC_TYPE_BOOL       SCSpecType = 5
	SC_SPEC_TYPE_SYMBOL     SCSpecType = 6
	SC_SPEC_TYPE_BITSET     SCSpecType = 7
	SC_SPEC_TYPE_STATUS     SCSpecType = 8
	SC_SPEC_TYPE_BYTES      SCSpecType = 9
	SC_SPEC_TYPE_BIG_INT    SCSpecType = 10
	SC_SPEC_TYPE_INVOKER    SCSpecType = 11
	SC_SPEC_TYPE_ACCOUNT_ID SCSpecType = 12
	// Types with parameters.
	SC_SPEC_TYPE_OPTION  SCSpecType = 1000
	SC_SPEC_TYPE_RESULT  SCSpecType = 1001
	SC_SPEC_TYPE_VEC     SCSpecType = 1002
	SC_SPEC_TYPE_SET     SCSpecType = 1003
	SC_SPEC_TYPE_MAP     SCSpecType = 1004
	SC_SPEC_TYPE_TUPLE   SCSpecType = 1005
	SC_SPEC_TYPE_BYTES_N SCSpecType = 1006
	// User defined types.
	SC_SPEC_TYPE_UDT SCSpecType = 2000
)

type SCSpecTypeOption struct {
	ValueType SCSpecTypeDef
}

type SCSpecTypeResult struct {
	OkType    SCSpecTypeDef
	ErrorType SCSpecTypeDef
}

type SCSpecTypeVec struct {
	ElementType SCSpecTypeDef
}

type SCSpecTypeMap struct {
	KeyType   SCSpecTypeDef
	ValueType SCSpecTypeDef
}

type SCSpecTypeSet struct {
	ElementType SCSpecTypeDef
}

type SCSpecTypeTuple struct {
	ValueTypes []SCSpecTypeDef // bound 12
}

type SCSpecTypeBytesN struct {
	N Uint32
}

type SCSpecTypeUDT struct {
	Name string // bound 60
}

type SCSpecTypeDef struct {
	// The union discriminant Type selects among the following arms:
	//   SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_BITSET, SC_SPEC_TYPE_STATUS, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_BIG_INT, SC_SPEC_TYPE_INVOKER, SC_SPEC_TYPE_ACCOUNT_ID:
	//      void
	//   SC_SPEC_TYPE_OPTION:
	//      Option() *SCSpecTypeOption
	//   SC_SPEC_TYPE_RESULT:
	//      Result() *SCSpecTypeResult
	//   SC_SPEC_TYPE_VEC:
	//      Vec() *SCSpecTypeVec
	//   SC_SPEC_TYPE_MAP:
	//      Map() *SCSpecTypeMap
	//   SC_SPEC_TYPE_SET:
	//      Set() *SCSpecTypeSet
	//   SC_SPEC_TYPE_TUPLE:
	//      Tuple() *SCSpecTypeTuple
	//   SC_SPEC_TYPE_BYTES_N:
	//      BytesN() *SCSpecTypeBytesN
	//   SC_SPEC_TYPE_UDT:
	//      Udt() *SCSpecTypeUDT
	Type SCSpecType
	_u   interface{}
}

type SCSpecUDTStructFieldV0 struct {
	Name string // bound 30
	Type SCSpecTypeDef
}

type SCSpecUDTStructV0 struct {
	Lib    string                   // bound 80
	Name   string                   // bound 60
	Fields []SCSpecUDTStructFieldV0 // bound 40
}

type SCSpecUDTUnionCaseV0 struct {
	Name string // bound 60
	Type *SCSpecTypeDef
}

type SCSpecUDTUnionV0 struct {
	Lib   string                 // bound 80
	Name  string                 // bound 60
	Cases []SCSpecUDTUnionCaseV0 // bound 50
}

type SCSpecUDTEnumCaseV0 struct {
	Name  string // bound 60
	Value Uint32
}

type SCSpecUDTEnumV0 struct {
	Lib   string                // bound 80
	Name  string                // bound 60
	Cases []SCSpecUDTEnumCaseV0 // bound 50
}

type SCSpecUDTErrorEnumCaseV0 struct {
	Name  string // bound 60
	Value Uint32
}

type SCSpecUDTErrorEnumV0 struct {
	Lib   string                     // bound 80
	Name  string                     // bound 60
	Cases []SCSpecUDTErrorEnumCaseV0 // bound 50
}

type SCSpecFunctionInputV0 struct {
	Name string // bound 30
	Type SCSpecTypeDef
}

type SCSpecFunctionV0 struct {
	Name    SCSymbol
	Inputs  []SCSpecFunctionInputV0 // bound 10
	Outputs []SCSpecTypeDef         // bound 1
}

type SCSpecEntryKind int32

const (
	SC_SPEC_ENTRY_FUNCTION_V0       SCSpecEntryKind = 0
	SC_SPEC_ENTRY_UDT_STRUCT_V0     SCSpecEntryKind = 1
	SC_SPEC_ENTRY_UDT_UNION_V0      SCSpecEntryKind = 2
	SC_SPEC_ENTRY_UDT_ENUM_V0       SCSpecEntryKind = 3
	SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0 SCSpecEntryKind = 4
)

type SCSpecEntry struct {
	// The union discriminant Kind selects among the following arms:
	//   SC_SPEC_ENTRY_FUNCTION_V0:
	//      FunctionV0() *SCSpecFunctionV0
	//   SC_SPEC_ENTRY_UDT_STRUCT_V0:
	//      UdtStructV0() *SCSpecUDTStructV0
	//   SC_SPEC_ENTRY_UDT_UNION_V0:
	//      UdtUnionV0() *SCSpecUDTUnionV0
	//   SC_SPEC_ENTRY_UDT_ENUM_V0:
	//      UdtEnumV0() *SCSpecUDTEnumV0
	//   SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
	//      UdtErrorEnumV0() *SCSpecUDTErrorEnumV0
	Kind SCSpecEntryKind
	_u   interface{}
}

// A symbol is up to 10 chars drawn from [a-zA-Z0-9_], which can be packed
// into 60 bits with a 6-bit-per-character code, usable as a small key type
// to specify function, argument, tx-local environment and map entries
// efficiently.
type SCSymbol = string // bound 10

type SCValType int32

const (
	SCV_U63    SCValType = 0
	SCV_U32    SCValType = 1
	SCV_I32    SCValType = 2
	SCV_STATIC SCValType = 3
	SCV_OBJECT SCValType = 4
	SCV_SYMBOL SCValType = 5
	SCV_BITSET SCValType = 6
	SCV_STATUS SCValType = 7
)

type SCStatic int32

const (
	SCS_VOID                     SCStatic = 0
	SCS_TRUE                     SCStatic = 1
	SCS_FALSE                    SCStatic = 2
	SCS_LEDGER_KEY_CONTRACT_CODE SCStatic = 3
)

type SCStatusType int32

const (
	SST_OK                  SCStatusType = 0
	SST_UNKNOWN_ERROR       SCStatusType = 1
	SST_HOST_VALUE_ERROR    SCStatusType = 2
	SST_HOST_OBJECT_ERROR   SCStatusType = 3
	SST_HOST_FUNCTION_ERROR SCStatusType = 4
	SST_HOST_STORAGE_ERROR  SCStatusType = 5
	SST_HOST_CONTEXT_ERROR  SCStatusType = 6
	SST_VM_ERROR            SCStatusType = 7
	SST_CONTRACT_ERROR      SCStatusType = 8
)

type SCHostValErrorCode int32

const (
	HOST_VALUE_UNKNOWN_ERROR            SCHostValErrorCode = 0
	HOST_VALUE_RESERVED_TAG_VALUE       SCHostValErrorCode = 1
	HOST_VALUE_UNEXPECTED_VAL_TYPE      SCHostValErrorCode = 2
	HOST_VALUE_U63_OUT_OF_RANGE         SCHostValErrorCode = 3
	HOST_VALUE_U32_OUT_OF_RANGE         SCHostValErrorCode = 4
	HOST_VALUE_STATIC_UNKNOWN           SCHostValErrorCode = 5
	HOST_VALUE_MISSING_OBJECT           SCHostValErrorCode = 6
	HOST_VALUE_SYMBOL_TOO_LONG          SCHostValErrorCode = 7
	HOST_VALUE_SYMBOL_BAD_CHAR          SCHostValErrorCode = 8
	HOST_VALUE_SYMBOL_CONTAINS_NON_UTF8 SCHostValErrorCode = 9
	HOST_VALUE_BITSET_TOO_MANY_BITS     SCHostValErrorCode = 10
	HOST_VALUE_STATUS_UNKNOWN           SCHostValErrorCode = 11
)

type SCHostObjErrorCode int32

const (
	HOST_OBJECT_UNKNOWN_ERROR                SCHostObjErrorCode = 0
	HOST_OBJECT_UNKNOWN_REFERENCE            SCHostObjErrorCode = 1
	HOST_OBJECT_UNEXPECTED_TYPE              SCHostObjErrorCode = 2
	HOST_OBJECT_OBJECT_COUNT_EXCEEDS_U32_MAX SCHostObjErrorCode = 3
	HOST_OBJECT_OBJECT_NOT_EXIST             SCHostObjErrorCode = 4
	HOST_OBJECT_VEC_INDEX_OUT_OF_BOUND       SCHostObjErrorCode = 5
	HOST_OBJECT_CONTRACT_HASH_WRONG_LENGTH   SCHostObjErrorCode = 6
)

type SCHostFnErrorCode int32

const (
	HOST_FN_UNKNOWN_ERROR                   SCHostFnErrorCode = 0
	HOST_FN_UNEXPECTED_HOST_FUNCTION_ACTION SCHostFnErrorCode = 1
	HOST_FN_INPUT_ARGS_WRONG_LENGTH         SCHostFnErrorCode = 2
	HOST_FN_INPUT_ARGS_WRONG_TYPE           SCHostFnErrorCode = 3
	HOST_FN_INPUT_ARGS_INVALID              SCHostFnErrorCode = 4
)

type SCHostStorageErrorCode int32

const (
	HOST_STORAGE_UNKNOWN_ERROR                      SCHostStorageErrorCode = 0
	HOST_STORAGE_EXPECT_CONTRACT_DATA               SCHostStorageErrorCode = 1
	HOST_STORAGE_READWRITE_ACCESS_TO_READONLY_ENTRY SCHostStorageErrorCode = 2
	HOST_STORAGE_ACCESS_TO_UNKNOWN_ENTRY            SCHostStorageErrorCode = 3
	HOST_STORAGE_MISSING_KEY_IN_GET                 SCHostStorageErrorCode = 4
	HOST_STORAGE_GET_ON_DELETED_KEY                 SCHostStorageErrorCode = 5
)

type SCHostContextErrorCode int32

const (
	HOST_CONTEXT_UNKNOWN_ERROR       SCHostContextErrorCode = 0
	HOST_CONTEXT_NO_CONTRACT_RUNNING SCHostContextErrorCode = 1
)

type SCVmErrorCode int32

const (
	VM_UNKNOWN                          SCVmErrorCode = 0
	VM_VALIDATION                       SCVmErrorCode = 1
	VM_INSTANTIATION                    SCVmErrorCode = 2
	VM_FUNCTION                         SCVmErrorCode = 3
	VM_TABLE                            SCVmErrorCode = 4
	VM_MEMORY                           SCVmErrorCode = 5
	VM_GLOBAL                           SCVmErrorCode = 6
	VM_VALUE                            SCVmErrorCode = 7
	VM_TRAP_UNREACHABLE                 SCVmErrorCode = 8
	VM_TRAP_MEMORY_ACCESS_OUT_OF_BOUNDS SCVmErrorCode = 9
	VM_TRAP_TABLE_ACCESS_OUT_OF_BOUNDS  SCVmErrorCode = 10
	VM_TRAP_ELEM_UNINITIALIZED          SCVmErrorCode = 11
	VM_TRAP_DIVISION_BY_ZERO            SCVmErrorCode = 12
	VM_TRAP_INTEGER_OVERFLOW            SCVmErrorCode = 13
	VM_TRAP_INVALID_CONVERSION_TO_INT   SCVmErrorCode = 14
	VM_TRAP_STACK_OVERFLOW              SCVmErrorCode = 15
	VM_TRAP_UNEXPECTED_SIGNATURE        SCVmErrorCode = 16
	VM_TRAP_MEM_LIMIT_EXCEEDED          SCVmErrorCode = 17
	VM_TRAP_CPU_LIMIT_EXCEEDED          SCVmErrorCode = 18
)

type SCUnknownErrorCode int32

const (
	UNKNOWN_ERROR_GENERAL SCUnknownErrorCode = 0
	UNKNOWN_ERROR_XDR     SCUnknownErrorCode = 1
)

type SCStatus struct {
	// The union discriminant Type selects among the following arms:
	//   SST_OK:
	//      void
	//   SST_UNKNOWN_ERROR:
	//      UnknownCode() *SCUnknownErrorCode
	//   SST_HOST_VALUE_ERROR:
	//      ValCode() *SCHostValErrorCode
	//   SST_HOST_OBJECT_ERROR:
	//      ObjCode() *SCHostObjErrorCode
	//   SST_HOST_FUNCTION_ERROR:
	//      FnCode() *SCHostFnErrorCode
	//   SST_HOST_STORAGE_ERROR:
	//      StorageCode() *SCHostStorageErrorCode
	//   SST_HOST_CONTEXT_ERROR:
	//      ContextCode() *SCHostContextErrorCode
	//   SST_VM_ERROR:
	//      VmCode() *SCVmErrorCode
	//   SST_CONTRACT_ERROR:
	//      ContractCode() *Uint32
	Type SCStatusType
	_u   interface{}
}

type SCVal struct {
	// The union discriminant Type selects among the following arms:
	//   SCV_U63:
	//      U63() *Int64
	//   SCV_U32:
	//      U32() *Uint32
	//   SCV_I32:
	//      I32() *Int32
	//   SCV_STATIC:
	//      Ic() *SCStatic
	//   SCV_OBJECT:
	//      Obj() **SCObject
	//   SCV_SYMBOL:
	//      Sym() *SCSymbol
	//   SCV_BITSET:
	//      Bits() *Uint64
	//   SCV_STATUS:
	//      Status() *SCStatus
	Type SCValType
	_u   interface{}
}

type SCObjectType int32

const (
	SCO_VEC           SCObjectType = 0
	SCO_MAP           SCObjectType = 1
	SCO_U64           SCObjectType = 2
	SCO_I64           SCObjectType = 3
	SCO_BYTES         SCObjectType = 4
	SCO_BIG_INT       SCObjectType = 5
	SCO_CONTRACT_CODE SCObjectType = 6
	SCO_ACCOUNT_ID    SCObjectType = 7
)

type SCMapEntry struct {
	Key SCVal
	Val SCVal
}

const SCVAL_LIMIT = 256000

type SCVec = []SCVal // bound SCVAL_LIMIT

type SCMap = []SCMapEntry // bound SCVAL_LIMIT

type SCNumSign int32

const (
	NEGATIVE SCNumSign = -1
	ZERO     SCNumSign = 0
	POSITIVE SCNumSign = 1
)

type SCBigInt struct {
	// The union discriminant Sign selects among the following arms:
	//   ZERO:
	//      void
	//   POSITIVE, NEGATIVE:
	//      Magnitude() *[]byte // bound 256000
	Sign SCNumSign
	_u   interface{}
}

type SCContractCodeType int32

const (
	SCCONTRACT_CODE_WASM  SCContractCodeType = 0
	SCCONTRACT_CODE_TOKEN SCContractCodeType = 1
)

type SCContractCode struct {
	// The union discriminant Type selects among the following arms:
	//   SCCONTRACT_CODE_WASM:
	//      Wasm() *[]byte // bound SCVAL_LIMIT
	//   SCCONTRACT_CODE_TOKEN:
	//      void
	Type SCContractCodeType
	_u   interface{}
}

type SCObject struct {
	// The union discriminant Type selects among the following arms:
	//   SCO_VEC:
	//      Vec() *SCVec
	//   SCO_MAP:
	//      Map() *SCMap
	//   SCO_U64:
	//      U64() *Uint64
	//   SCO_I64:
	//      I64() *Int64
	//   SCO_BYTES:
	//      Bin() *[]byte // bound SCVAL_LIMIT
	//   SCO_BIG_INT:
	//      BigInt() *SCBigInt
	//   SCO_CONTRACT_CODE:
	//      ContractCode() *SCContractCode
	//   SCO_ACCOUNT_ID:
	//      AccountID() *AccountID
	Type SCObjectType
	_u   interface{}
}

type StoredTransactionSet struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      TxSet() *TransactionSet
	//   1:
	//      GeneralizedTxSet() *GeneralizedTransactionSet
	V  int32
	_u interface{}
}

type PersistedSCPStateV0 struct {
	ScpEnvelopes []SCPEnvelope
	QuorumSets   []SCPQuorumSet
	TxSets       []StoredTransactionSet
}

type PersistedSCPStateV1 struct {
	// Tx sets are saved separately
	ScpEnvelopes []SCPEnvelope
	QuorumSets   []SCPQuorumSet
}

type PersistedSCPState struct {
	// The union discriminant V selects among the following arms:
	//   0:
	//      V0() *PersistedSCPStateV0
	//   1:
	//      V1() *PersistedSCPStateV1
	V  int32
	_u interface{}
}

//
// Helper types and generated marshaling functions
//

type XdrType_Value struct {
	XdrVecOpaque
}

func XDR_Value(v *Value) XdrType_Value {
	return XdrType_Value{XdrVecOpaque{v, 0xffffffff}}
}
func (XdrType_Value) XdrTypeName() string  { return "Value" }
func (v XdrType_Value) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_SCPBallot = *SCPBallot

func (v *SCPBallot) XdrPointer() interface{}       { return v }
func (SCPBallot) XdrTypeName() string              { return "SCPBallot" }
func (v SCPBallot) XdrValue() interface{}          { return v }
func (v *SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPBallot) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scounter", name), XDR_Uint32(&v.Counter))
	x.Marshal(x.Sprintf("%svalue", name), XDR_Value(&v.Value))
}
func XDR_SCPBallot(v *SCPBallot) *SCPBallot { return v }

var _XdrNames_SCPStatementType = map[int32]string{
	int32(SCP_ST_PREPARE):     "SCP_ST_PREPARE",
	int32(SCP_ST_CONFIRM):     "SCP_ST_CONFIRM",
	int32(SCP_ST_EXTERNALIZE): "SCP_ST_EXTERNALIZE",
	int32(SCP_ST_NOMINATE):    "SCP_ST_NOMINATE",
}
var _XdrValues_SCPStatementType = map[string]int32{
	"SCP_ST_PREPARE":     int32(SCP_ST_PREPARE),
	"SCP_ST_CONFIRM":     int32(SCP_ST_CONFIRM),
	"SCP_ST_EXTERNALIZE": int32(SCP_ST_EXTERNALIZE),
	"SCP_ST_NOMINATE":    int32(SCP_ST_NOMINATE),
}

func (SCPStatementType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCPStatementType
}
func (v SCPStatementType) String() string {
	if s, ok := _XdrNames_SCPStatementType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCPStatementType#%d", v)
}
func (v *SCPStatementType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCPStatementType[stok]; ok {
			*v = SCPStatementType(val)
			return nil
		} else if stok == "SCPStatementType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCPStatementType.", stok))
	}
}
func (v SCPStatementType) GetU32() uint32                 { return uint32(v) }
func (v *SCPStatementType) SetU32(n uint32)               { *v = SCPStatementType(n) }
func (v *SCPStatementType) XdrPointer() interface{}       { return v }
func (SCPStatementType) XdrTypeName() string              { return "SCPStatementType" }
func (v SCPStatementType) XdrValue() interface{}          { return v }
func (v *SCPStatementType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCPStatementType = *SCPStatementType

func XDR_SCPStatementType(v *SCPStatementType) *SCPStatementType { return v }

type _XdrVec_unbounded_Value []Value

func (_XdrVec_unbounded_Value) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Value) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Value length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Value length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Value) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Value) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Value, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Value) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Value(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Value) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Value) XdrTypeName() string              { return "Value<>" }
func (v *_XdrVec_unbounded_Value) XdrPointer() interface{}       { return (*[]Value)(v) }
func (v _XdrVec_unbounded_Value) XdrValue() interface{}          { return ([]Value)(v) }
func (v *_XdrVec_unbounded_Value) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCPNomination = *SCPNomination

func (v *SCPNomination) XdrPointer() interface{}       { return v }
func (SCPNomination) XdrTypeName() string              { return "SCPNomination" }
func (v SCPNomination) XdrValue() interface{}          { return v }
func (v *SCPNomination) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPNomination) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%squorumSetHash", name), XDR_Hash(&v.QuorumSetHash))
	x.Marshal(x.Sprintf("%svotes", name), (*_XdrVec_unbounded_Value)(&v.Votes))
	x.Marshal(x.Sprintf("%saccepted", name), (*_XdrVec_unbounded_Value)(&v.Accepted))
}
func XDR_SCPNomination(v *SCPNomination) *SCPNomination { return v }

type _XdrPtr_SCPBallot struct {
	p **SCPBallot
}
type _ptrflag_SCPBallot _XdrPtr_SCPBallot

func (v _ptrflag_SCPBallot) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SCPBallot) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SCPBallot flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SCPBallot) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SCPBallot) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SCPBallot)
		}
	default:
		XdrPanic("*SCPBallot present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SCPBallot) XdrTypeName() string             { return "SCPBallot?" }
func (v _ptrflag_SCPBallot) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SCPBallot) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SCPBallot) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SCPBallot) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SCPBallot) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SCPBallot)
	}
}
func (v _XdrPtr_SCPBallot) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SCPBallot(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SCPBallot) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SCPBallot) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SCPBallot(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SCPBallot) XdrTypeName() string       { return "SCPBallot*" }
func (v _XdrPtr_SCPBallot) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SCPBallot) XdrValue() interface{}   { return *v.p }

type XdrType_XdrAnon_SCPStatement_Pledges_Prepare = *XdrAnon_SCPStatement_Pledges_Prepare

func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrPointer() interface{} { return v }
func (XdrAnon_SCPStatement_Pledges_Prepare) XdrTypeName() string {
	return "XdrAnon_SCPStatement_Pledges_Prepare"
}
func (v XdrAnon_SCPStatement_Pledges_Prepare) XdrValue() interface{}          { return v }
func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Prepare) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%squorumSetHash", name), XDR_Hash(&v.QuorumSetHash))
	x.Marshal(x.Sprintf("%sballot", name), XDR_SCPBallot(&v.Ballot))
	x.Marshal(x.Sprintf("%sprepared", name), _XdrPtr_SCPBallot{&v.Prepared})
	x.Marshal(x.Sprintf("%spreparedPrime", name), _XdrPtr_SCPBallot{&v.PreparedPrime})
	x.Marshal(x.Sprintf("%snC", name), XDR_Uint32(&v.NC))
	x.Marshal(x.Sprintf("%snH", name), XDR_Uint32(&v.NH))
}
func XDR_XdrAnon_SCPStatement_Pledges_Prepare(v *XdrAnon_SCPStatement_Pledges_Prepare) *XdrAnon_SCPStatement_Pledges_Prepare {
	return v
}

type XdrType_XdrAnon_SCPStatement_Pledges_Confirm = *XdrAnon_SCPStatement_Pledges_Confirm

func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrPointer() interface{} { return v }
func (XdrAnon_SCPStatement_Pledges_Confirm) XdrTypeName() string {
	return "XdrAnon_SCPStatement_Pledges_Confirm"
}
func (v XdrAnon_SCPStatement_Pledges_Confirm) XdrValue() interface{}          { return v }
func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Confirm) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sballot", name), XDR_SCPBallot(&v.Ballot))
	x.Marshal(x.Sprintf("%snPrepared", name), XDR_Uint32(&v.NPrepared))
	x.Marshal(x.Sprintf("%snCommit", name), XDR_Uint32(&v.NCommit))
	x.Marshal(x.Sprintf("%snH", name), XDR_Uint32(&v.NH))
	x.Marshal(x.Sprintf("%squorumSetHash", name), XDR_Hash(&v.QuorumSetHash))
}
func XDR_XdrAnon_SCPStatement_Pledges_Confirm(v *XdrAnon_SCPStatement_Pledges_Confirm) *XdrAnon_SCPStatement_Pledges_Confirm {
	return v
}

type XdrType_XdrAnon_SCPStatement_Pledges_Externalize = *XdrAnon_SCPStatement_Pledges_Externalize

func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrPointer() interface{} { return v }
func (XdrAnon_SCPStatement_Pledges_Externalize) XdrTypeName() string {
	return "XdrAnon_SCPStatement_Pledges_Externalize"
}
func (v XdrAnon_SCPStatement_Pledges_Externalize) XdrValue() interface{}          { return v }
func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SCPStatement_Pledges_Externalize) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scommit", name), XDR_SCPBallot(&v.Commit))
	x.Marshal(x.Sprintf("%snH", name), XDR_Uint32(&v.NH))
	x.Marshal(x.Sprintf("%scommitQuorumSetHash", name), XDR_Hash(&v.CommitQuorumSetHash))
}
func XDR_XdrAnon_SCPStatement_Pledges_Externalize(v *XdrAnon_SCPStatement_Pledges_Externalize) *XdrAnon_SCPStatement_Pledges_Externalize {
	return v
}

var _XdrTags_XdrAnon_SCPStatement_Pledges = map[int32]bool{
	XdrToI32(SCP_ST_PREPARE):     true,
	XdrToI32(SCP_ST_CONFIRM):     true,
	XdrToI32(SCP_ST_EXTERNALIZE): true,
	XdrToI32(SCP_ST_NOMINATE):    true,
}

func (_ XdrAnon_SCPStatement_Pledges) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_SCPStatement_Pledges
}
func (u *XdrAnon_SCPStatement_Pledges) Prepare() *XdrAnon_SCPStatement_Pledges_Prepare {
	switch u.Type {
	case SCP_ST_PREPARE:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Prepare); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Prepare
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Prepare accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Confirm() *XdrAnon_SCPStatement_Pledges_Confirm {
	switch u.Type {
	case SCP_ST_CONFIRM:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Confirm); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Confirm
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Confirm accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Externalize() *XdrAnon_SCPStatement_Pledges_Externalize {
	switch u.Type {
	case SCP_ST_EXTERNALIZE:
		if v, ok := u._u.(*XdrAnon_SCPStatement_Pledges_Externalize); ok {
			return v
		} else {
			var zero XdrAnon_SCPStatement_Pledges_Externalize
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Externalize accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_SCPStatement_Pledges) Nominate() *SCPNomination {
	switch u.Type {
	case SCP_ST_NOMINATE:
		if v, ok := u._u.(*SCPNomination); ok {
			return v
		} else {
			var zero SCPNomination
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_SCPStatement_Pledges.Nominate accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_SCPStatement_Pledges) XdrValid() bool {
	switch u.Type {
	case SCP_ST_PREPARE, SCP_ST_CONFIRM, SCP_ST_EXTERNALIZE, SCP_ST_NOMINATE:
		return true
	}
	return false
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionTag() XdrNum32 {
	return XDR_SCPStatementType(&u.Type)
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionBody() XdrType {
	switch u.Type {
	case SCP_ST_PREPARE:
		return XDR_XdrAnon_SCPStatement_Pledges_Prepare(u.Prepare())
	case SCP_ST_CONFIRM:
		return XDR_XdrAnon_SCPStatement_Pledges_Confirm(u.Confirm())
	case SCP_ST_EXTERNALIZE:
		return XDR_XdrAnon_SCPStatement_Pledges_Externalize(u.Externalize())
	case SCP_ST_NOMINATE:
		return XDR_SCPNomination(u.Nominate())
	}
	return nil
}
func (u *XdrAnon_SCPStatement_Pledges) XdrUnionBodyName() string {
	switch u.Type {
	case SCP_ST_PREPARE:
		return "Prepare"
	case SCP_ST_CONFIRM:
		return "Confirm"
	case SCP_ST_EXTERNALIZE:
		return "Externalize"
	case SCP_ST_NOMINATE:
		return "Nominate"
	}
	return ""
}

type XdrType_XdrAnon_SCPStatement_Pledges = *XdrAnon_SCPStatement_Pledges

func (v *XdrAnon_SCPStatement_Pledges) XdrPointer() interface{}       { return v }
func (XdrAnon_SCPStatement_Pledges) XdrTypeName() string              { return "XdrAnon_SCPStatement_Pledges" }
func (v XdrAnon_SCPStatement_Pledges) XdrValue() interface{}          { return v }
func (v *XdrAnon_SCPStatement_Pledges) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_SCPStatement_Pledges) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPStatementType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SCP_ST_PREPARE:
		x.Marshal(x.Sprintf("%sprepare", name), XDR_XdrAnon_SCPStatement_Pledges_Prepare(u.Prepare()))
		return
	case SCP_ST_CONFIRM:
		x.Marshal(x.Sprintf("%sconfirm", name), XDR_XdrAnon_SCPStatement_Pledges_Confirm(u.Confirm()))
		return
	case SCP_ST_EXTERNALIZE:
		x.Marshal(x.Sprintf("%sexternalize", name), XDR_XdrAnon_SCPStatement_Pledges_Externalize(u.Externalize()))
		return
	case SCP_ST_NOMINATE:
		x.Marshal(x.Sprintf("%snominate", name), XDR_SCPNomination(u.Nominate()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_SCPStatement_Pledges", u.Type)
}
func XDR_XdrAnon_SCPStatement_Pledges(v *XdrAnon_SCPStatement_Pledges) *XdrAnon_SCPStatement_Pledges {
	return v
}

type XdrType_SCPStatement = *SCPStatement

func (v *SCPStatement) XdrPointer() interface{}       { return v }
func (SCPStatement) XdrTypeName() string              { return "SCPStatement" }
func (v SCPStatement) XdrValue() interface{}          { return v }
func (v *SCPStatement) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPStatement) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snodeID", name), XDR_NodeID(&v.NodeID))
	x.Marshal(x.Sprintf("%sslotIndex", name), XDR_Uint64(&v.SlotIndex))
	x.Marshal(x.Sprintf("%spledges", name), XDR_XdrAnon_SCPStatement_Pledges(&v.Pledges))
}
func XDR_SCPStatement(v *SCPStatement) *SCPStatement { return v }

type XdrType_SCPEnvelope = *SCPEnvelope

func (v *SCPEnvelope) XdrPointer() interface{}       { return v }
func (SCPEnvelope) XdrTypeName() string              { return "SCPEnvelope" }
func (v SCPEnvelope) XdrValue() interface{}          { return v }
func (v *SCPEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPEnvelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatement", name), XDR_SCPStatement(&v.Statement))
	x.Marshal(x.Sprintf("%ssignature", name), XDR_Signature(&v.Signature))
}
func XDR_SCPEnvelope(v *SCPEnvelope) *SCPEnvelope { return v }

type _XdrVec_unbounded_NodeID []NodeID

func (_XdrVec_unbounded_NodeID) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_NodeID) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_NodeID length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_NodeID length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_NodeID) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_NodeID) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]NodeID, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_NodeID) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_NodeID(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_NodeID) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_NodeID) XdrTypeName() string              { return "NodeID<>" }
func (v *_XdrVec_unbounded_NodeID) XdrPointer() interface{}       { return (*[]NodeID)(v) }
func (v _XdrVec_unbounded_NodeID) XdrValue() interface{}          { return ([]NodeID)(v) }
func (v *_XdrVec_unbounded_NodeID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_unbounded_SCPQuorumSet []SCPQuorumSet

func (_XdrVec_unbounded_SCPQuorumSet) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCPQuorumSet) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCPQuorumSet length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCPQuorumSet length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCPQuorumSet) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCPQuorumSet) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPQuorumSet, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCPQuorumSet(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SCPQuorumSet) XdrTypeName() string              { return "SCPQuorumSet<>" }
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrPointer() interface{}       { return (*[]SCPQuorumSet)(v) }
func (v _XdrVec_unbounded_SCPQuorumSet) XdrValue() interface{}          { return ([]SCPQuorumSet)(v) }
func (v *_XdrVec_unbounded_SCPQuorumSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCPQuorumSet = *SCPQuorumSet

func (v *SCPQuorumSet) XdrPointer() interface{}       { return v }
func (SCPQuorumSet) XdrTypeName() string              { return "SCPQuorumSet" }
func (v SCPQuorumSet) XdrValue() interface{}          { return v }
func (v *SCPQuorumSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPQuorumSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sthreshold", name), XDR_Uint32(&v.Threshold))
	x.Marshal(x.Sprintf("%svalidators", name), (*_XdrVec_unbounded_NodeID)(&v.Validators))
	x.Marshal(x.Sprintf("%sinnerSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.InnerSets))
}
func XDR_SCPQuorumSet(v *SCPQuorumSet) *SCPQuorumSet { return v }

type _XdrArray_4_opaque [4]byte

func (v *_XdrArray_4_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_4_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_4_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_4_opaque) XdrPointer() interface{}       { return (*[4]byte)(v) }
func (v *_XdrArray_4_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_4_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_4_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_4_opaque) XdrArraySize() uint32 {
	const bound uint32 = 4 // Force error if not const or doesn't fit
	return bound
}

type XdrType_Thresholds struct {
	*_XdrArray_4_opaque
}

func XDR_Thresholds(v *Thresholds) XdrType_Thresholds {
	return XdrType_Thresholds{(*_XdrArray_4_opaque)(v)}
}
func (XdrType_Thresholds) XdrTypeName() string  { return "Thresholds" }
func (v XdrType_Thresholds) XdrUnwrap() XdrType { return v._XdrArray_4_opaque }

type XdrType_String32 struct {
	XdrString
}

func XDR_String32(v *String32) XdrType_String32 {
	return XdrType_String32{XdrString{v, 32}}
}
func (XdrType_String32) XdrTypeName() string  { return "String32" }
func (v XdrType_String32) XdrUnwrap() XdrType { return v.XdrString }

type XdrType_String64 struct {
	XdrString
}

func XDR_String64(v *String64) XdrType_String64 {
	return XdrType_String64{XdrString{v, 64}}
}
func (XdrType_String64) XdrTypeName() string  { return "String64" }
func (v XdrType_String64) XdrUnwrap() XdrType { return v.XdrString }

type XdrType_SequenceNumber struct {
	XdrType_Int64
}

func XDR_SequenceNumber(v *SequenceNumber) XdrType_SequenceNumber {
	return XdrType_SequenceNumber{XDR_Int64(v)}
}
func (XdrType_SequenceNumber) XdrTypeName() string  { return "SequenceNumber" }
func (v XdrType_SequenceNumber) XdrUnwrap() XdrType { return v.XdrType_Int64 }

type XdrType_TimePoint struct {
	XdrType_Uint64
}

func XDR_TimePoint(v *TimePoint) XdrType_TimePoint {
	return XdrType_TimePoint{XDR_Uint64(v)}
}
func (XdrType_TimePoint) XdrTypeName() string  { return "TimePoint" }
func (v XdrType_TimePoint) XdrUnwrap() XdrType { return v.XdrType_Uint64 }

type XdrType_Duration struct {
	XdrType_Uint64
}

func XDR_Duration(v *Duration) XdrType_Duration {
	return XdrType_Duration{XDR_Uint64(v)}
}
func (XdrType_Duration) XdrTypeName() string  { return "Duration" }
func (v XdrType_Duration) XdrUnwrap() XdrType { return v.XdrType_Uint64 }

type XdrType_DataValue struct {
	XdrVecOpaque
}

func XDR_DataValue(v *DataValue) XdrType_DataValue {
	return XdrType_DataValue{XdrVecOpaque{v, 64}}
}
func (XdrType_DataValue) XdrTypeName() string  { return "DataValue" }
func (v XdrType_DataValue) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_PoolID struct {
	XdrType_Hash
}

func XDR_PoolID(v *PoolID) XdrType_PoolID {
	return XdrType_PoolID{XDR_Hash(v)}
}
func (XdrType_PoolID) XdrTypeName() string  { return "PoolID" }
func (v XdrType_PoolID) XdrUnwrap() XdrType { return v.XdrType_Hash }

type XdrType_AssetCode4 struct {
	*_XdrArray_4_opaque
}

func XDR_AssetCode4(v *AssetCode4) XdrType_AssetCode4 {
	return XdrType_AssetCode4{(*_XdrArray_4_opaque)(v)}
}
func (XdrType_AssetCode4) XdrTypeName() string  { return "AssetCode4" }
func (v XdrType_AssetCode4) XdrUnwrap() XdrType { return v._XdrArray_4_opaque }

type _XdrArray_12_opaque [12]byte

func (v *_XdrArray_12_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_12_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_12_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_12_opaque) XdrPointer() interface{}       { return (*[12]byte)(v) }
func (v *_XdrArray_12_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_12_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_12_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_12_opaque) XdrArraySize() uint32 {
	const bound uint32 = 12 // Force error if not const or doesn't fit
	return bound
}

type XdrType_AssetCode12 struct {
	*_XdrArray_12_opaque
}

func XDR_AssetCode12(v *AssetCode12) XdrType_AssetCode12 {
	return XdrType_AssetCode12{(*_XdrArray_12_opaque)(v)}
}
func (XdrType_AssetCode12) XdrTypeName() string  { return "AssetCode12" }
func (v XdrType_AssetCode12) XdrUnwrap() XdrType { return v._XdrArray_12_opaque }

var _XdrNames_AssetType = map[int32]string{
	int32(ASSET_TYPE_NATIVE):            "ASSET_TYPE_NATIVE",
	int32(ASSET_TYPE_CREDIT_ALPHANUM4):  "ASSET_TYPE_CREDIT_ALPHANUM4",
	int32(ASSET_TYPE_CREDIT_ALPHANUM12): "ASSET_TYPE_CREDIT_ALPHANUM12",
	int32(ASSET_TYPE_POOL_SHARE):        "ASSET_TYPE_POOL_SHARE",
}
var _XdrValues_AssetType = map[string]int32{
	"ASSET_TYPE_NATIVE":            int32(ASSET_TYPE_NATIVE),
	"ASSET_TYPE_CREDIT_ALPHANUM4":  int32(ASSET_TYPE_CREDIT_ALPHANUM4),
	"ASSET_TYPE_CREDIT_ALPHANUM12": int32(ASSET_TYPE_CREDIT_ALPHANUM12),
	"ASSET_TYPE_POOL_SHARE":        int32(ASSET_TYPE_POOL_SHARE),
}

func (AssetType) XdrEnumNames() map[int32]string {
	return _XdrNames_AssetType
}
func (v AssetType) String() string {
	if s, ok := _XdrNames_AssetType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AssetType#%d", v)
}
func (v *AssetType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AssetType[stok]; ok {
			*v = AssetType(val)
			return nil
		} else if stok == "AssetType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AssetType.", stok))
	}
}
func (v AssetType) GetU32() uint32                 { return uint32(v) }
func (v *AssetType) SetU32(n uint32)               { *v = AssetType(n) }
func (v *AssetType) XdrPointer() interface{}       { return v }
func (AssetType) XdrTypeName() string              { return "AssetType" }
func (v AssetType) XdrValue() interface{}          { return v }
func (v *AssetType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AssetType = *AssetType

func XDR_AssetType(v *AssetType) *AssetType { return v }

var _XdrTags_AssetCode = map[int32]bool{
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM4):  true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM12): true,
}

func (_ AssetCode) XdrValidTags() map[int32]bool {
	return _XdrTags_AssetCode
}
func (u *AssetCode) AssetCode4() *AssetCode4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AssetCode4); ok {
			return v
		} else {
			var zero AssetCode4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AssetCode.AssetCode4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *AssetCode) AssetCode12() *AssetCode12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AssetCode12); ok {
			return v
		} else {
			var zero AssetCode12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AssetCode.AssetCode12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u AssetCode) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12:
		return true
	}
	return false
}
func (u *AssetCode) XdrUnionTag() XdrNum32 {
	return XDR_AssetType(&u.Type)
}
func (u *AssetCode) XdrUnionTagName() string {
	return "Type"
}
func (u *AssetCode) XdrUnionBody() XdrType {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return XDR_AssetCode4(u.AssetCode4())
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return XDR_AssetCode12(u.AssetCode12())
	}
	return nil
}
func (u *AssetCode) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AssetCode4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AssetCode12"
	}
	return ""
}

type XdrType_AssetCode = *AssetCode

func (v *AssetCode) XdrPointer() interface{}       { return v }
func (AssetCode) XdrTypeName() string              { return "AssetCode" }
func (v AssetCode) XdrValue() interface{}          { return v }
func (v *AssetCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AssetCode) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		x.Marshal(x.Sprintf("%sassetCode4", name), XDR_AssetCode4(u.AssetCode4()))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		x.Marshal(x.Sprintf("%sassetCode12", name), XDR_AssetCode12(u.AssetCode12()))
		return
	}
	XdrPanic("invalid Type (%v) in AssetCode", u.Type)
}
func (v *AssetCode) XdrInitialize() {
	var zero AssetType
	switch zero {
	case ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12:
	default:
		if v.Type == zero {
			v.Type = ASSET_TYPE_CREDIT_ALPHANUM4
		}
	}
}
func XDR_AssetCode(v *AssetCode) *AssetCode { return v }

type XdrType_AlphaNum4 = *AlphaNum4

func (v *AlphaNum4) XdrPointer() interface{}       { return v }
func (AlphaNum4) XdrTypeName() string              { return "AlphaNum4" }
func (v AlphaNum4) XdrValue() interface{}          { return v }
func (v *AlphaNum4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AlphaNum4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sassetCode", name), XDR_AssetCode4(&v.AssetCode))
	x.Marshal(x.Sprintf("%sissuer", name), XDR_AccountID(&v.Issuer))
}
func XDR_AlphaNum4(v *AlphaNum4) *AlphaNum4 { return v }

type XdrType_AlphaNum12 = *AlphaNum12

func (v *AlphaNum12) XdrPointer() interface{}       { return v }
func (AlphaNum12) XdrTypeName() string              { return "AlphaNum12" }
func (v AlphaNum12) XdrValue() interface{}          { return v }
func (v *AlphaNum12) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AlphaNum12) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sassetCode", name), XDR_AssetCode12(&v.AssetCode))
	x.Marshal(x.Sprintf("%sissuer", name), XDR_AccountID(&v.Issuer))
}
func XDR_AlphaNum12(v *AlphaNum12) *AlphaNum12 { return v }

var _XdrTags_Asset = map[int32]bool{
	XdrToI32(ASSET_TYPE_NATIVE):            true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM4):  true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM12): true,
}

func (_ Asset) XdrValidTags() map[int32]bool {
	return _XdrTags_Asset
}
func (u *Asset) AlphaNum4() *AlphaNum4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AlphaNum4); ok {
			return v
		} else {
			var zero AlphaNum4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Asset.AlphaNum4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Asset) AlphaNum12() *AlphaNum12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AlphaNum12); ok {
			return v
		} else {
			var zero AlphaNum12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Asset.AlphaNum12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Asset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_NATIVE, ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12:
		return true
	}
	return false
}
func (u *Asset) XdrUnionTag() XdrNum32 {
	return XDR_AssetType(&u.Type)
}
func (u *Asset) XdrUnionTagName() string {
	return "Type"
}
func (u *Asset) XdrUnionBody() XdrType {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return nil
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return XDR_AlphaNum4(u.AlphaNum4())
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return XDR_AlphaNum12(u.AlphaNum12())
	}
	return nil
}
func (u *Asset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return ""
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AlphaNum4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AlphaNum12"
	}
	return ""
}

type XdrType_Asset = *Asset

func (v *Asset) XdrPointer() interface{}       { return v }
func (Asset) XdrTypeName() string              { return "Asset" }
func (v Asset) XdrValue() interface{}          { return v }
func (v *Asset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Asset) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		x.Marshal(x.Sprintf("%salphaNum4", name), XDR_AlphaNum4(u.AlphaNum4()))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		x.Marshal(x.Sprintf("%salphaNum12", name), XDR_AlphaNum12(u.AlphaNum12()))
		return
	}
	XdrPanic("invalid Type (%v) in Asset", u.Type)
}
func XDR_Asset(v *Asset) *Asset { return v }

type XdrType_Price = *Price

func (v *Price) XdrPointer() interface{}       { return v }
func (Price) XdrTypeName() string              { return "Price" }
func (v Price) XdrValue() interface{}          { return v }
func (v *Price) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Price) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sn", name), XDR_Int32(&v.N))
	x.Marshal(x.Sprintf("%sd", name), XDR_Int32(&v.D))
}
func XDR_Price(v *Price) *Price { return v }

type XdrType_Liabilities = *Liabilities

func (v *Liabilities) XdrPointer() interface{}       { return v }
func (Liabilities) XdrTypeName() string              { return "Liabilities" }
func (v Liabilities) XdrValue() interface{}          { return v }
func (v *Liabilities) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Liabilities) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Int64(&v.Buying))
	x.Marshal(x.Sprintf("%sselling", name), XDR_Int64(&v.Selling))
}
func XDR_Liabilities(v *Liabilities) *Liabilities { return v }

var _XdrNames_ThresholdIndexes = map[int32]string{
	int32(THRESHOLD_MASTER_WEIGHT): "THRESHOLD_MASTER_WEIGHT",
	int32(THRESHOLD_LOW):           "THRESHOLD_LOW",
	int32(THRESHOLD_MED):           "THRESHOLD_MED",
	int32(THRESHOLD_HIGH):          "THRESHOLD_HIGH",
}
var _XdrValues_ThresholdIndexes = map[string]int32{
	"THRESHOLD_MASTER_WEIGHT": int32(THRESHOLD_MASTER_WEIGHT),
	"THRESHOLD_LOW":           int32(THRESHOLD_LOW),
	"THRESHOLD_MED":           int32(THRESHOLD_MED),
	"THRESHOLD_HIGH":          int32(THRESHOLD_HIGH),
}

func (ThresholdIndexes) XdrEnumNames() map[int32]string {
	return _XdrNames_ThresholdIndexes
}
func (v ThresholdIndexes) String() string {
	if s, ok := _XdrNames_ThresholdIndexes[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ThresholdIndexes#%d", v)
}
func (v *ThresholdIndexes) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ThresholdIndexes[stok]; ok {
			*v = ThresholdIndexes(val)
			return nil
		} else if stok == "ThresholdIndexes" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ThresholdIndexes.", stok))
	}
}
func (v ThresholdIndexes) GetU32() uint32                 { return uint32(v) }
func (v *ThresholdIndexes) SetU32(n uint32)               { *v = ThresholdIndexes(n) }
func (v *ThresholdIndexes) XdrPointer() interface{}       { return v }
func (ThresholdIndexes) XdrTypeName() string              { return "ThresholdIndexes" }
func (v ThresholdIndexes) XdrValue() interface{}          { return v }
func (v *ThresholdIndexes) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ThresholdIndexes = *ThresholdIndexes

func XDR_ThresholdIndexes(v *ThresholdIndexes) *ThresholdIndexes { return v }

var _XdrNames_LedgerEntryType = map[int32]string{
	int32(ACCOUNT):           "ACCOUNT",
	int32(TRUSTLINE):         "TRUSTLINE",
	int32(OFFER):             "OFFER",
	int32(DATA):              "DATA",
	int32(CLAIMABLE_BALANCE): "CLAIMABLE_BALANCE",
	int32(LIQUIDITY_POOL):    "LIQUIDITY_POOL",
	int32(CONTRACT_DATA):     "CONTRACT_DATA",
	int32(CONFIG_SETTING):    "CONFIG_SETTING",
}
var _XdrValues_LedgerEntryType = map[string]int32{
	"ACCOUNT":           int32(ACCOUNT),
	"TRUSTLINE":         int32(TRUSTLINE),
	"OFFER":             int32(OFFER),
	"DATA":              int32(DATA),
	"CLAIMABLE_BALANCE": int32(CLAIMABLE_BALANCE),
	"LIQUIDITY_POOL":    int32(LIQUIDITY_POOL),
	"CONTRACT_DATA":     int32(CONTRACT_DATA),
	"CONFIG_SETTING":    int32(CONFIG_SETTING),
}

func (LedgerEntryType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerEntryType
}
func (v LedgerEntryType) String() string {
	if s, ok := _XdrNames_LedgerEntryType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerEntryType#%d", v)
}
func (v *LedgerEntryType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerEntryType[stok]; ok {
			*v = LedgerEntryType(val)
			return nil
		} else if stok == "LedgerEntryType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerEntryType.", stok))
	}
}
func (v LedgerEntryType) GetU32() uint32                 { return uint32(v) }
func (v *LedgerEntryType) SetU32(n uint32)               { *v = LedgerEntryType(n) }
func (v *LedgerEntryType) XdrPointer() interface{}       { return v }
func (LedgerEntryType) XdrTypeName() string              { return "LedgerEntryType" }
func (v LedgerEntryType) XdrValue() interface{}          { return v }
func (v *LedgerEntryType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerEntryType = *LedgerEntryType

func XDR_LedgerEntryType(v *LedgerEntryType) *LedgerEntryType { return v }

type XdrType_Signer = *Signer

func (v *Signer) XdrPointer() interface{}       { return v }
func (Signer) XdrTypeName() string              { return "Signer" }
func (v Signer) XdrValue() interface{}          { return v }
func (v *Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Signer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XDR_SignerKey(&v.Key))
	x.Marshal(x.Sprintf("%sweight", name), XDR_Uint32(&v.Weight))
}
func XDR_Signer(v *Signer) *Signer { return v }

var _XdrNames_AccountFlags = map[int32]string{
	int32(AUTH_REQUIRED_FLAG):         "AUTH_REQUIRED_FLAG",
	int32(AUTH_REVOCABLE_FLAG):        "AUTH_REVOCABLE_FLAG",
	int32(AUTH_IMMUTABLE_FLAG):        "AUTH_IMMUTABLE_FLAG",
	int32(AUTH_CLAWBACK_ENABLED_FLAG): "AUTH_CLAWBACK_ENABLED_FLAG",
}
var _XdrValues_AccountFlags = map[string]int32{
	"AUTH_REQUIRED_FLAG":         int32(AUTH_REQUIRED_FLAG),
	"AUTH_REVOCABLE_FLAG":        int32(AUTH_REVOCABLE_FLAG),
	"AUTH_IMMUTABLE_FLAG":        int32(AUTH_IMMUTABLE_FLAG),
	"AUTH_CLAWBACK_ENABLED_FLAG": int32(AUTH_CLAWBACK_ENABLED_FLAG),
}

func (AccountFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_AccountFlags
}
func (v AccountFlags) String() string {
	if s, ok := _XdrNames_AccountFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AccountFlags#%d", v)
}
func (v *AccountFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AccountFlags[stok]; ok {
			*v = AccountFlags(val)
			return nil
		} else if stok == "AccountFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AccountFlags.", stok))
	}
}
func (v AccountFlags) GetU32() uint32                 { return uint32(v) }
func (v *AccountFlags) SetU32(n uint32)               { *v = AccountFlags(n) }
func (v *AccountFlags) XdrPointer() interface{}       { return v }
func (AccountFlags) XdrTypeName() string              { return "AccountFlags" }
func (v AccountFlags) XdrValue() interface{}          { return v }
func (v *AccountFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AccountFlags = *AccountFlags

func XDR_AccountFlags(v *AccountFlags) *AccountFlags { return v }

var _XdrComments_AccountFlags = map[int32]string{
	int32(AUTH_REQUIRED_FLAG):         "Flags set on issuer accounts TrustLines are created with authorized set to \"false\" requiring the issuer to set it for each TrustLine",
	int32(AUTH_REVOCABLE_FLAG):        "If set, the authorized flag in TrustLines can be cleared otherwise, authorization cannot be revoked",
	int32(AUTH_IMMUTABLE_FLAG):        "Once set, causes all AUTH_* flags to be read-only",
	int32(AUTH_CLAWBACK_ENABLED_FLAG): "Trustlines are created with clawback enabled set to \"true\", and claimable balances created from those trustlines are created with clawback enabled set to \"true\"",
}

func (e AccountFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_AccountFlags
}
func (v *AccountFlags) XdrInitialize() {
	switch AccountFlags(0) {
	case AUTH_REQUIRED_FLAG, AUTH_REVOCABLE_FLAG, AUTH_IMMUTABLE_FLAG, AUTH_CLAWBACK_ENABLED_FLAG:
	default:
		if *v == AccountFlags(0) {
			*v = AUTH_REQUIRED_FLAG
		}
	}
}

type _XdrPtr_AccountID struct {
	p **AccountID
}
type _ptrflag_AccountID _XdrPtr_AccountID

func (v _ptrflag_AccountID) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_AccountID) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("AccountID flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_AccountID) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_AccountID) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(AccountID)
		}
	default:
		XdrPanic("*AccountID present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_AccountID) XdrTypeName() string             { return "AccountID?" }
func (v _ptrflag_AccountID) XdrPointer() interface{}       { return nil }
func (v _ptrflag_AccountID) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_AccountID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_AccountID) XdrBound() uint32              { return 1 }
func (v _XdrPtr_AccountID) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_AccountID) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(AccountID)
	}
}
func (v _XdrPtr_AccountID) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_AccountID(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_AccountID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_AccountID) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_AccountID(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_AccountID) XdrTypeName() string       { return "AccountID*" }
func (v _XdrPtr_AccountID) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_AccountID) XdrValue() interface{}   { return *v.p }

type XdrType_SponsorshipDescriptor struct {
	_XdrPtr_AccountID
}

func XDR_SponsorshipDescriptor(v *SponsorshipDescriptor) XdrType_SponsorshipDescriptor {
	return XdrType_SponsorshipDescriptor{_XdrPtr_AccountID{v}}
}
func (XdrType_SponsorshipDescriptor) XdrTypeName() string  { return "SponsorshipDescriptor" }
func (v XdrType_SponsorshipDescriptor) XdrUnwrap() XdrType { return v._XdrPtr_AccountID }

type XdrType_AccountEntryExtensionV3 = *AccountEntryExtensionV3

func (v *AccountEntryExtensionV3) XdrPointer() interface{}       { return v }
func (AccountEntryExtensionV3) XdrTypeName() string              { return "AccountEntryExtensionV3" }
func (v AccountEntryExtensionV3) XdrValue() interface{}          { return v }
func (v *AccountEntryExtensionV3) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntryExtensionV3) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%sseqLedger", name), XDR_Uint32(&v.SeqLedger))
	x.Marshal(x.Sprintf("%sseqTime", name), XDR_TimePoint(&v.SeqTime))
}
func XDR_AccountEntryExtensionV3(v *AccountEntryExtensionV3) *AccountEntryExtensionV3 { return v }

var _XdrTags_XdrAnon_AccountEntryExtensionV2_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(3): true,
}

func (_ XdrAnon_AccountEntryExtensionV2_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_AccountEntryExtensionV2_Ext
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) V3() *AccountEntryExtensionV3 {
	switch u.V {
	case 3:
		if v, ok := u._u.(*AccountEntryExtensionV3); ok {
			return v
		} else {
			var zero AccountEntryExtensionV3
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AccountEntryExtensionV2_Ext.V3 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_AccountEntryExtensionV2_Ext) XdrValid() bool {
	switch u.V {
	case 0, 3:
		return true
	}
	return false
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 3:
		return XDR_AccountEntryExtensionV3(u.V3())
	}
	return nil
}
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 3:
		return "V3"
	}
	return ""
}

type XdrType_XdrAnon_AccountEntryExtensionV2_Ext = *XdrAnon_AccountEntryExtensionV2_Ext

func (v *XdrAnon_AccountEntryExtensionV2_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_AccountEntryExtensionV2_Ext) XdrTypeName() string {
	return "XdrAnon_AccountEntryExtensionV2_Ext"
}
func (v XdrAnon_AccountEntryExtensionV2_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_AccountEntryExtensionV2_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AccountEntryExtensionV2_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 3:
		x.Marshal(x.Sprintf("%sv3", name), XDR_AccountEntryExtensionV3(u.V3()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_AccountEntryExtensionV2_Ext", u.V)
}
func XDR_XdrAnon_AccountEntryExtensionV2_Ext(v *XdrAnon_AccountEntryExtensionV2_Ext) *XdrAnon_AccountEntryExtensionV2_Ext {
	return v
}

type _XdrVec_20_SponsorshipDescriptor []SponsorshipDescriptor

func (_XdrVec_20_SponsorshipDescriptor) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_20_SponsorshipDescriptor) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		XdrPanic("_XdrVec_20_SponsorshipDescriptor length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_20_SponsorshipDescriptor length %d exceeds max int", length)
	}
}
func (v _XdrVec_20_SponsorshipDescriptor) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_20_SponsorshipDescriptor) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SponsorshipDescriptor, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_20_SponsorshipDescriptor) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SponsorshipDescriptor(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_20_SponsorshipDescriptor) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 20}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_20_SponsorshipDescriptor) XdrTypeName() string { return "SponsorshipDescriptor<>" }
func (v *_XdrVec_20_SponsorshipDescriptor) XdrPointer() interface{} {
	return (*[]SponsorshipDescriptor)(v)
}
func (v _XdrVec_20_SponsorshipDescriptor) XdrValue() interface{}          { return ([]SponsorshipDescriptor)(v) }
func (v *_XdrVec_20_SponsorshipDescriptor) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AccountEntryExtensionV2 = *AccountEntryExtensionV2

func (v *AccountEntryExtensionV2) XdrPointer() interface{}       { return v }
func (AccountEntryExtensionV2) XdrTypeName() string              { return "AccountEntryExtensionV2" }
func (v AccountEntryExtensionV2) XdrValue() interface{}          { return v }
func (v *AccountEntryExtensionV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntryExtensionV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snumSponsored", name), XDR_Uint32(&v.NumSponsored))
	x.Marshal(x.Sprintf("%snumSponsoring", name), XDR_Uint32(&v.NumSponsoring))
	x.Marshal(x.Sprintf("%ssignerSponsoringIDs", name), (*_XdrVec_20_SponsorshipDescriptor)(&v.SignerSponsoringIDs))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_AccountEntryExtensionV2_Ext(&v.Ext))
}
func XDR_AccountEntryExtensionV2(v *AccountEntryExtensionV2) *AccountEntryExtensionV2 { return v }

var _XdrTags_XdrAnon_AccountEntryExtensionV1_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(2): true,
}

func (_ XdrAnon_AccountEntryExtensionV1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_AccountEntryExtensionV1_Ext
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) V2() *AccountEntryExtensionV2 {
	switch u.V {
	case 2:
		if v, ok := u._u.(*AccountEntryExtensionV2); ok {
			return v
		} else {
			var zero AccountEntryExtensionV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AccountEntryExtensionV1_Ext.V2 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_AccountEntryExtensionV1_Ext) XdrValid() bool {
	switch u.V {
	case 0, 2:
		return true
	}
	return false
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 2:
		return XDR_AccountEntryExtensionV2(u.V2())
	}
	return nil
}
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 2:
		return "V2"
	}
	return ""
}

type XdrType_XdrAnon_AccountEntryExtensionV1_Ext = *XdrAnon_AccountEntryExtensionV1_Ext

func (v *XdrAnon_AccountEntryExtensionV1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_AccountEntryExtensionV1_Ext) XdrTypeName() string {
	return "XdrAnon_AccountEntryExtensionV1_Ext"
}
func (v XdrAnon_AccountEntryExtensionV1_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_AccountEntryExtensionV1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AccountEntryExtensionV1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_AccountEntryExtensionV2(u.V2()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_AccountEntryExtensionV1_Ext", u.V)
}
func XDR_XdrAnon_AccountEntryExtensionV1_Ext(v *XdrAnon_AccountEntryExtensionV1_Ext) *XdrAnon_AccountEntryExtensionV1_Ext {
	return v
}

type XdrType_AccountEntryExtensionV1 = *AccountEntryExtensionV1

func (v *AccountEntryExtensionV1) XdrPointer() interface{}       { return v }
func (AccountEntryExtensionV1) XdrTypeName() string              { return "AccountEntryExtensionV1" }
func (v AccountEntryExtensionV1) XdrValue() interface{}          { return v }
func (v *AccountEntryExtensionV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntryExtensionV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliabilities", name), XDR_Liabilities(&v.Liabilities))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_AccountEntryExtensionV1_Ext(&v.Ext))
}
func XDR_AccountEntryExtensionV1(v *AccountEntryExtensionV1) *AccountEntryExtensionV1 { return v }

var _XdrTags_XdrAnon_AccountEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_AccountEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_AccountEntry_Ext
}
func (u *XdrAnon_AccountEntry_Ext) V1() *AccountEntryExtensionV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*AccountEntryExtensionV1); ok {
			return v
		} else {
			var zero AccountEntryExtensionV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_AccountEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_AccountEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_AccountEntryExtensionV1(u.V1())
	}
	return nil
}
func (u *XdrAnon_AccountEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_AccountEntry_Ext = *XdrAnon_AccountEntry_Ext

func (v *XdrAnon_AccountEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_AccountEntry_Ext) XdrTypeName() string              { return "XdrAnon_AccountEntry_Ext" }
func (v XdrAnon_AccountEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_AccountEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_AccountEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_AccountEntryExtensionV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_AccountEntry_Ext", u.V)
}
func XDR_XdrAnon_AccountEntry_Ext(v *XdrAnon_AccountEntry_Ext) *XdrAnon_AccountEntry_Ext { return v }

type _XdrVec_20_Signer []Signer

func (_XdrVec_20_Signer) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_20_Signer) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		XdrPanic("_XdrVec_20_Signer length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_20_Signer length %d exceeds max int", length)
	}
}
func (v _XdrVec_20_Signer) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_20_Signer) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Signer, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_20_Signer) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Signer(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_20_Signer) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 20}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_20_Signer) XdrTypeName() string              { return "Signer<>" }
func (v *_XdrVec_20_Signer) XdrPointer() interface{}       { return (*[]Signer)(v) }
func (v _XdrVec_20_Signer) XdrValue() interface{}          { return ([]Signer)(v) }
func (v *_XdrVec_20_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AccountEntry = *AccountEntry

func (v *AccountEntry) XdrPointer() interface{}       { return v }
func (AccountEntry) XdrTypeName() string              { return "AccountEntry" }
func (v AccountEntry) XdrValue() interface{}          { return v }
func (v *AccountEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AccountEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sbalance", name), XDR_Int64(&v.Balance))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%snumSubEntries", name), XDR_Uint32(&v.NumSubEntries))
	x.Marshal(x.Sprintf("%sinflationDest", name), _XdrPtr_AccountID{&v.InflationDest})
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
	x.Marshal(x.Sprintf("%shomeDomain", name), XDR_String32(&v.HomeDomain))
	x.Marshal(x.Sprintf("%sthresholds", name), XDR_Thresholds(&v.Thresholds))
	x.Marshal(x.Sprintf("%ssigners", name), (*_XdrVec_20_Signer)(&v.Signers))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_AccountEntry_Ext(&v.Ext))
}
func XDR_AccountEntry(v *AccountEntry) *AccountEntry { return v }

var _XdrNames_TrustLineFlags = map[int32]string{
	int32(AUTHORIZED_FLAG):                         "AUTHORIZED_FLAG",
	int32(AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG): "AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG",
	int32(TRUSTLINE_CLAWBACK_ENABLED_FLAG):         "TRUSTLINE_CLAWBACK_ENABLED_FLAG",
}
var _XdrValues_TrustLineFlags = map[string]int32{
	"AUTHORIZED_FLAG":                         int32(AUTHORIZED_FLAG),
	"AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG": int32(AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG),
	"TRUSTLINE_CLAWBACK_ENABLED_FLAG":         int32(TRUSTLINE_CLAWBACK_ENABLED_FLAG),
}

func (TrustLineFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_TrustLineFlags
}
func (v TrustLineFlags) String() string {
	if s, ok := _XdrNames_TrustLineFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("TrustLineFlags#%d", v)
}
func (v *TrustLineFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TrustLineFlags[stok]; ok {
			*v = TrustLineFlags(val)
			return nil
		} else if stok == "TrustLineFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid TrustLineFlags.", stok))
	}
}
func (v TrustLineFlags) GetU32() uint32                 { return uint32(v) }
func (v *TrustLineFlags) SetU32(n uint32)               { *v = TrustLineFlags(n) }
func (v *TrustLineFlags) XdrPointer() interface{}       { return v }
func (TrustLineFlags) XdrTypeName() string              { return "TrustLineFlags" }
func (v TrustLineFlags) XdrValue() interface{}          { return v }
func (v *TrustLineFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TrustLineFlags = *TrustLineFlags

func XDR_TrustLineFlags(v *TrustLineFlags) *TrustLineFlags { return v }

var _XdrComments_TrustLineFlags = map[int32]string{
	int32(AUTHORIZED_FLAG):                         "issuer has authorized account to perform transactions with its credit",
	int32(AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG): "issuer has authorized account to maintain and reduce liabilities for its credit",
	int32(TRUSTLINE_CLAWBACK_ENABLED_FLAG):         "issuer has specified that it may clawback its credit, and that claimable balances created with its credit may also be clawed back",
}

func (e TrustLineFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_TrustLineFlags
}
func (v *TrustLineFlags) XdrInitialize() {
	switch TrustLineFlags(0) {
	case AUTHORIZED_FLAG, AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG, TRUSTLINE_CLAWBACK_ENABLED_FLAG:
	default:
		if *v == TrustLineFlags(0) {
			*v = AUTHORIZED_FLAG
		}
	}
}

var _XdrNames_LiquidityPoolType = map[int32]string{
	int32(LIQUIDITY_POOL_CONSTANT_PRODUCT): "LIQUIDITY_POOL_CONSTANT_PRODUCT",
}
var _XdrValues_LiquidityPoolType = map[string]int32{
	"LIQUIDITY_POOL_CONSTANT_PRODUCT": int32(LIQUIDITY_POOL_CONSTANT_PRODUCT),
}

func (LiquidityPoolType) XdrEnumNames() map[int32]string {
	return _XdrNames_LiquidityPoolType
}
func (v LiquidityPoolType) String() string {
	if s, ok := _XdrNames_LiquidityPoolType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LiquidityPoolType#%d", v)
}
func (v *LiquidityPoolType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LiquidityPoolType[stok]; ok {
			*v = LiquidityPoolType(val)
			return nil
		} else if stok == "LiquidityPoolType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LiquidityPoolType.", stok))
	}
}
func (v LiquidityPoolType) GetU32() uint32                 { return uint32(v) }
func (v *LiquidityPoolType) SetU32(n uint32)               { *v = LiquidityPoolType(n) }
func (v *LiquidityPoolType) XdrPointer() interface{}       { return v }
func (LiquidityPoolType) XdrTypeName() string              { return "LiquidityPoolType" }
func (v LiquidityPoolType) XdrValue() interface{}          { return v }
func (v *LiquidityPoolType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LiquidityPoolType = *LiquidityPoolType

func XDR_LiquidityPoolType(v *LiquidityPoolType) *LiquidityPoolType { return v }

var _XdrTags_TrustLineAsset = map[int32]bool{
	XdrToI32(ASSET_TYPE_NATIVE):            true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM4):  true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM12): true,
	XdrToI32(ASSET_TYPE_POOL_SHARE):        true,
}

func (_ TrustLineAsset) XdrValidTags() map[int32]bool {
	return _XdrTags_TrustLineAsset
}
func (u *TrustLineAsset) AlphaNum4() *AlphaNum4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AlphaNum4); ok {
			return v
		} else {
			var zero AlphaNum4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TrustLineAsset.AlphaNum4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *TrustLineAsset) AlphaNum12() *AlphaNum12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AlphaNum12); ok {
			return v
		} else {
			var zero AlphaNum12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TrustLineAsset.AlphaNum12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *TrustLineAsset) LiquidityPoolID() *PoolID {
	switch u.Type {
	case ASSET_TYPE_POOL_SHARE:
		if v, ok := u._u.(*PoolID); ok {
			return v
		} else {
			var zero PoolID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TrustLineAsset.LiquidityPoolID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u TrustLineAsset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_NATIVE, ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12, ASSET_TYPE_POOL_SHARE:
		return true
	}
	return false
}
func (u *TrustLineAsset) XdrUnionTag() XdrNum32 {
	return XDR_AssetType(&u.Type)
}
func (u *TrustLineAsset) XdrUnionTagName() string {
	return "Type"
}
func (u *TrustLineAsset) XdrUnionBody() XdrType {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return nil
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return XDR_AlphaNum4(u.AlphaNum4())
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return XDR_AlphaNum12(u.AlphaNum12())
	case ASSET_TYPE_POOL_SHARE:
		return XDR_PoolID(u.LiquidityPoolID())
	}
	return nil
}
func (u *TrustLineAsset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return ""
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AlphaNum4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AlphaNum12"
	case ASSET_TYPE_POOL_SHARE:
		return "LiquidityPoolID"
	}
	return ""
}

type XdrType_TrustLineAsset = *TrustLineAsset

func (v *TrustLineAsset) XdrPointer() interface{}       { return v }
func (TrustLineAsset) XdrTypeName() string              { return "TrustLineAsset" }
func (v TrustLineAsset) XdrValue() interface{}          { return v }
func (v *TrustLineAsset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TrustLineAsset) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		x.Marshal(x.Sprintf("%salphaNum4", name), XDR_AlphaNum4(u.AlphaNum4()))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		x.Marshal(x.Sprintf("%salphaNum12", name), XDR_AlphaNum12(u.AlphaNum12()))
		return
	case ASSET_TYPE_POOL_SHARE:
		x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(u.LiquidityPoolID()))
		return
	}
	XdrPanic("invalid Type (%v) in TrustLineAsset", u.Type)
}
func XDR_TrustLineAsset(v *TrustLineAsset) *TrustLineAsset { return v }

var _XdrTags_XdrAnon_TrustLineEntryExtensionV2_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TrustLineEntryExtensionV2_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TrustLineEntryExtensionV2_Ext
}
func (u XdrAnon_TrustLineEntryExtensionV2_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TrustLineEntryExtensionV2_Ext = *XdrAnon_TrustLineEntryExtensionV2_Ext

func (v *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TrustLineEntryExtensionV2_Ext) XdrTypeName() string {
	return "XdrAnon_TrustLineEntryExtensionV2_Ext"
}
func (v XdrAnon_TrustLineEntryExtensionV2_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TrustLineEntryExtensionV2_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TrustLineEntryExtensionV2_Ext", u.V)
}
func XDR_XdrAnon_TrustLineEntryExtensionV2_Ext(v *XdrAnon_TrustLineEntryExtensionV2_Ext) *XdrAnon_TrustLineEntryExtensionV2_Ext {
	return v
}

type XdrType_TrustLineEntryExtensionV2 = *TrustLineEntryExtensionV2

func (v *TrustLineEntryExtensionV2) XdrPointer() interface{}       { return v }
func (TrustLineEntryExtensionV2) XdrTypeName() string              { return "TrustLineEntryExtensionV2" }
func (v TrustLineEntryExtensionV2) XdrValue() interface{}          { return v }
func (v *TrustLineEntryExtensionV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TrustLineEntryExtensionV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolUseCount", name), XDR_Int32(&v.LiquidityPoolUseCount))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TrustLineEntryExtensionV2_Ext(&v.Ext))
}
func XDR_TrustLineEntryExtensionV2(v *TrustLineEntryExtensionV2) *TrustLineEntryExtensionV2 { return v }

var _XdrTags_XdrAnon_TrustLineEntry_Ext_V1_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(2): true,
}

func (_ XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TrustLineEntry_Ext_V1_Ext
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) V2() *TrustLineEntryExtensionV2 {
	switch u.V {
	case 2:
		if v, ok := u._u.(*TrustLineEntryExtensionV2); ok {
			return v
		} else {
			var zero TrustLineEntryExtensionV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TrustLineEntry_Ext_V1_Ext.V2 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrValid() bool {
	switch u.V {
	case 0, 2:
		return true
	}
	return false
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 2:
		return XDR_TrustLineEntryExtensionV2(u.V2())
	}
	return nil
}
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 2:
		return "V2"
	}
	return ""
}

type XdrType_XdrAnon_TrustLineEntry_Ext_V1_Ext = *XdrAnon_TrustLineEntry_Ext_V1_Ext

func (v *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrTypeName() string {
	return "XdrAnon_TrustLineEntry_Ext_V1_Ext"
}
func (v XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TrustLineEntry_Ext_V1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_TrustLineEntryExtensionV2(u.V2()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TrustLineEntry_Ext_V1_Ext", u.V)
}
func XDR_XdrAnon_TrustLineEntry_Ext_V1_Ext(v *XdrAnon_TrustLineEntry_Ext_V1_Ext) *XdrAnon_TrustLineEntry_Ext_V1_Ext {
	return v
}

type XdrType_XdrAnon_TrustLineEntry_Ext_V1 = *XdrAnon_TrustLineEntry_Ext_V1

func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrPointer() interface{}       { return v }
func (XdrAnon_TrustLineEntry_Ext_V1) XdrTypeName() string              { return "XdrAnon_TrustLineEntry_Ext_V1" }
func (v XdrAnon_TrustLineEntry_Ext_V1) XdrValue() interface{}          { return v }
func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_TrustLineEntry_Ext_V1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliabilities", name), XDR_Liabilities(&v.Liabilities))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TrustLineEntry_Ext_V1_Ext(&v.Ext))
}
func XDR_XdrAnon_TrustLineEntry_Ext_V1(v *XdrAnon_TrustLineEntry_Ext_V1) *XdrAnon_TrustLineEntry_Ext_V1 {
	return v
}

var _XdrTags_XdrAnon_TrustLineEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_TrustLineEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TrustLineEntry_Ext
}
func (u *XdrAnon_TrustLineEntry_Ext) V1() *XdrAnon_TrustLineEntry_Ext_V1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*XdrAnon_TrustLineEntry_Ext_V1); ok {
			return v
		} else {
			var zero XdrAnon_TrustLineEntry_Ext_V1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TrustLineEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_TrustLineEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_XdrAnon_TrustLineEntry_Ext_V1(u.V1())
	}
	return nil
}
func (u *XdrAnon_TrustLineEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_TrustLineEntry_Ext = *XdrAnon_TrustLineEntry_Ext

func (v *XdrAnon_TrustLineEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_TrustLineEntry_Ext) XdrTypeName() string              { return "XdrAnon_TrustLineEntry_Ext" }
func (v XdrAnon_TrustLineEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TrustLineEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TrustLineEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_XdrAnon_TrustLineEntry_Ext_V1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TrustLineEntry_Ext", u.V)
}
func XDR_XdrAnon_TrustLineEntry_Ext(v *XdrAnon_TrustLineEntry_Ext) *XdrAnon_TrustLineEntry_Ext {
	return v
}

type XdrType_TrustLineEntry = *TrustLineEntry

func (v *TrustLineEntry) XdrPointer() interface{}       { return v }
func (TrustLineEntry) XdrTypeName() string              { return "TrustLineEntry" }
func (v TrustLineEntry) XdrValue() interface{}          { return v }
func (v *TrustLineEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TrustLineEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sasset", name), XDR_TrustLineAsset(&v.Asset))
	x.Marshal(x.Sprintf("%sbalance", name), XDR_Int64(&v.Balance))
	x.Marshal(x.Sprintf("%slimit", name), XDR_Int64(&v.Limit))
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TrustLineEntry_Ext(&v.Ext))
}
func XDR_TrustLineEntry(v *TrustLineEntry) *TrustLineEntry { return v }

var _XdrNames_OfferEntryFlags = map[int32]string{
	int32(PASSIVE_FLAG): "PASSIVE_FLAG",
}
var _XdrValues_OfferEntryFlags = map[string]int32{
	"PASSIVE_FLAG": int32(PASSIVE_FLAG),
}

func (OfferEntryFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_OfferEntryFlags
}
func (v OfferEntryFlags) String() string {
	if s, ok := _XdrNames_OfferEntryFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OfferEntryFlags#%d", v)
}
func (v *OfferEntryFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OfferEntryFlags[stok]; ok {
			*v = OfferEntryFlags(val)
			return nil
		} else if stok == "OfferEntryFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OfferEntryFlags.", stok))
	}
}
func (v OfferEntryFlags) GetU32() uint32                 { return uint32(v) }
func (v *OfferEntryFlags) SetU32(n uint32)               { *v = OfferEntryFlags(n) }
func (v *OfferEntryFlags) XdrPointer() interface{}       { return v }
func (OfferEntryFlags) XdrTypeName() string              { return "OfferEntryFlags" }
func (v OfferEntryFlags) XdrValue() interface{}          { return v }
func (v *OfferEntryFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_OfferEntryFlags = *OfferEntryFlags

func XDR_OfferEntryFlags(v *OfferEntryFlags) *OfferEntryFlags { return v }

var _XdrComments_OfferEntryFlags = map[int32]string{
	int32(PASSIVE_FLAG): "an offer with this flag will not act on and take a reverse offer of equal price",
}

func (e OfferEntryFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_OfferEntryFlags
}
func (v *OfferEntryFlags) XdrInitialize() {
	switch OfferEntryFlags(0) {
	case PASSIVE_FLAG:
	default:
		if *v == OfferEntryFlags(0) {
			*v = PASSIVE_FLAG
		}
	}
}

var _XdrTags_XdrAnon_OfferEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_OfferEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_OfferEntry_Ext
}
func (u XdrAnon_OfferEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_OfferEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_OfferEntry_Ext = *XdrAnon_OfferEntry_Ext

func (v *XdrAnon_OfferEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_OfferEntry_Ext) XdrTypeName() string              { return "XdrAnon_OfferEntry_Ext" }
func (v XdrAnon_OfferEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_OfferEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_OfferEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_OfferEntry_Ext", u.V)
}
func XDR_XdrAnon_OfferEntry_Ext(v *XdrAnon_OfferEntry_Ext) *XdrAnon_OfferEntry_Ext { return v }

type XdrType_OfferEntry = *OfferEntry

func (v *OfferEntry) XdrPointer() interface{}       { return v }
func (OfferEntry) XdrTypeName() string              { return "OfferEntry" }
func (v OfferEntry) XdrValue() interface{}          { return v }
func (v *OfferEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OfferEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssellerID", name), XDR_AccountID(&v.SellerID))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
	x.Marshal(x.Sprintf("%sselling", name), XDR_Asset(&v.Selling))
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Asset(&v.Buying))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sprice", name), XDR_Price(&v.Price))
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_OfferEntry_Ext(&v.Ext))
}
func XDR_OfferEntry(v *OfferEntry) *OfferEntry { return v }

var _XdrTags_XdrAnon_DataEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_DataEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_DataEntry_Ext
}
func (u XdrAnon_DataEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_DataEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_DataEntry_Ext = *XdrAnon_DataEntry_Ext

func (v *XdrAnon_DataEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_DataEntry_Ext) XdrTypeName() string              { return "XdrAnon_DataEntry_Ext" }
func (v XdrAnon_DataEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_DataEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_DataEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_DataEntry_Ext", u.V)
}
func XDR_XdrAnon_DataEntry_Ext(v *XdrAnon_DataEntry_Ext) *XdrAnon_DataEntry_Ext { return v }

type XdrType_DataEntry = *DataEntry

func (v *DataEntry) XdrPointer() interface{}       { return v }
func (DataEntry) XdrTypeName() string              { return "DataEntry" }
func (v DataEntry) XdrValue() interface{}          { return v }
func (v *DataEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DataEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sdataName", name), XDR_String64(&v.DataName))
	x.Marshal(x.Sprintf("%sdataValue", name), XDR_DataValue(&v.DataValue))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_DataEntry_Ext(&v.Ext))
}
func XDR_DataEntry(v *DataEntry) *DataEntry { return v }

var _XdrNames_ClaimPredicateType = map[int32]string{
	int32(CLAIM_PREDICATE_UNCONDITIONAL):        "CLAIM_PREDICATE_UNCONDITIONAL",
	int32(CLAIM_PREDICATE_AND):                  "CLAIM_PREDICATE_AND",
	int32(CLAIM_PREDICATE_OR):                   "CLAIM_PREDICATE_OR",
	int32(CLAIM_PREDICATE_NOT):                  "CLAIM_PREDICATE_NOT",
	int32(CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME): "CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME",
	int32(CLAIM_PREDICATE_BEFORE_RELATIVE_TIME): "CLAIM_PREDICATE_BEFORE_RELATIVE_TIME",
}
var _XdrValues_ClaimPredicateType = map[string]int32{
	"CLAIM_PREDICATE_UNCONDITIONAL":        int32(CLAIM_PREDICATE_UNCONDITIONAL),
	"CLAIM_PREDICATE_AND":                  int32(CLAIM_PREDICATE_AND),
	"CLAIM_PREDICATE_OR":                   int32(CLAIM_PREDICATE_OR),
	"CLAIM_PREDICATE_NOT":                  int32(CLAIM_PREDICATE_NOT),
	"CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME": int32(CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME),
	"CLAIM_PREDICATE_BEFORE_RELATIVE_TIME": int32(CLAIM_PREDICATE_BEFORE_RELATIVE_TIME),
}

func (ClaimPredicateType) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimPredicateType
}
func (v ClaimPredicateType) String() string {
	if s, ok := _XdrNames_ClaimPredicateType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimPredicateType#%d", v)
}
func (v *ClaimPredicateType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimPredicateType[stok]; ok {
			*v = ClaimPredicateType(val)
			return nil
		} else if stok == "ClaimPredicateType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimPredicateType.", stok))
	}
}
func (v ClaimPredicateType) GetU32() uint32                 { return uint32(v) }
func (v *ClaimPredicateType) SetU32(n uint32)               { *v = ClaimPredicateType(n) }
func (v *ClaimPredicateType) XdrPointer() interface{}       { return v }
func (ClaimPredicateType) XdrTypeName() string              { return "ClaimPredicateType" }
func (v ClaimPredicateType) XdrValue() interface{}          { return v }
func (v *ClaimPredicateType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimPredicateType = *ClaimPredicateType

func XDR_ClaimPredicateType(v *ClaimPredicateType) *ClaimPredicateType { return v }

type _XdrVec_2_ClaimPredicate []ClaimPredicate

func (_XdrVec_2_ClaimPredicate) XdrBound() uint32 {
	const bound uint32 = 2 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_2_ClaimPredicate) XdrCheckLen(length uint32) {
	if length > uint32(2) {
		XdrPanic("_XdrVec_2_ClaimPredicate length %d exceeds bound 2", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_2_ClaimPredicate length %d exceeds max int", length)
	}
}
func (v _XdrVec_2_ClaimPredicate) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_2_ClaimPredicate) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(2); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ClaimPredicate, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_2_ClaimPredicate) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_ClaimPredicate(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_2_ClaimPredicate) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 2}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_2_ClaimPredicate) XdrTypeName() string              { return "ClaimPredicate<>" }
func (v *_XdrVec_2_ClaimPredicate) XdrPointer() interface{}       { return (*[]ClaimPredicate)(v) }
func (v _XdrVec_2_ClaimPredicate) XdrValue() interface{}          { return ([]ClaimPredicate)(v) }
func (v *_XdrVec_2_ClaimPredicate) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrPtr_ClaimPredicate struct {
	p **ClaimPredicate
}
type _ptrflag_ClaimPredicate _XdrPtr_ClaimPredicate

func (v _ptrflag_ClaimPredicate) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_ClaimPredicate) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("ClaimPredicate flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_ClaimPredicate) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_ClaimPredicate) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(ClaimPredicate)
		}
	default:
		XdrPanic("*ClaimPredicate present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_ClaimPredicate) XdrTypeName() string             { return "ClaimPredicate?" }
func (v _ptrflag_ClaimPredicate) XdrPointer() interface{}       { return nil }
func (v _ptrflag_ClaimPredicate) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_ClaimPredicate) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_ClaimPredicate) XdrBound() uint32              { return 1 }
func (v _XdrPtr_ClaimPredicate) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_ClaimPredicate) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(ClaimPredicate)
	}
}
func (v _XdrPtr_ClaimPredicate) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_ClaimPredicate(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_ClaimPredicate) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_ClaimPredicate) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_ClaimPredicate(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_ClaimPredicate) XdrTypeName() string       { return "ClaimPredicate*" }
func (v _XdrPtr_ClaimPredicate) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_ClaimPredicate) XdrValue() interface{}   { return *v.p }

var _XdrTags_ClaimPredicate = map[int32]bool{
	XdrToI32(CLAIM_PREDICATE_UNCONDITIONAL):        true,
	XdrToI32(CLAIM_PREDICATE_AND):                  true,
	XdrToI32(CLAIM_PREDICATE_OR):                   true,
	XdrToI32(CLAIM_PREDICATE_NOT):                  true,
	XdrToI32(CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME): true,
	XdrToI32(CLAIM_PREDICATE_BEFORE_RELATIVE_TIME): true,
}

func (_ ClaimPredicate) XdrValidTags() map[int32]bool {
	return _XdrTags_ClaimPredicate
}
func (u *ClaimPredicate) AndPredicates() *[]ClaimPredicate {
	switch u.Type {
	case CLAIM_PREDICATE_AND:
		if v, ok := u._u.(*[]ClaimPredicate); ok {
			return v
		} else {
			var zero []ClaimPredicate
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.AndPredicates accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ClaimPredicate) OrPredicates() *[]ClaimPredicate {
	switch u.Type {
	case CLAIM_PREDICATE_OR:
		if v, ok := u._u.(*[]ClaimPredicate); ok {
			return v
		} else {
			var zero []ClaimPredicate
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.OrPredicates accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ClaimPredicate) NotPredicate() **ClaimPredicate {
	switch u.Type {
	case CLAIM_PREDICATE_NOT:
		if v, ok := u._u.(**ClaimPredicate); ok {
			return v
		} else {
			var zero *ClaimPredicate
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.NotPredicate accessed when Type == %v", u.Type)
		return nil
	}
}

// Predicate will be true if closeTime < absBefore
func (u *ClaimPredicate) AbsBefore() *Int64 {
	switch u.Type {
	case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.AbsBefore accessed when Type == %v", u.Type)
		return nil
	}
}

// Seconds since closeTime of the ledger in which the
func (u *ClaimPredicate) RelBefore() *Int64 {
	switch u.Type {
	case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimPredicate.RelBefore accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ClaimPredicate) XdrValid() bool {
	switch u.Type {
	case CLAIM_PREDICATE_UNCONDITIONAL, CLAIM_PREDICATE_AND, CLAIM_PREDICATE_OR, CLAIM_PREDICATE_NOT, CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME, CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		return true
	}
	return false
}
func (u *ClaimPredicate) XdrUnionTag() XdrNum32 {
	return XDR_ClaimPredicateType(&u.Type)
}
func (u *ClaimPredicate) XdrUnionTagName() string {
	return "Type"
}
func (u *ClaimPredicate) XdrUnionBody() XdrType {
	switch u.Type {
	case CLAIM_PREDICATE_UNCONDITIONAL:
		return nil
	case CLAIM_PREDICATE_AND:
		return (*_XdrVec_2_ClaimPredicate)(u.AndPredicates())
	case CLAIM_PREDICATE_OR:
		return (*_XdrVec_2_ClaimPredicate)(u.OrPredicates())
	case CLAIM_PREDICATE_NOT:
		return _XdrPtr_ClaimPredicate{u.NotPredicate()}
	case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
		return XDR_Int64(u.AbsBefore())
	case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		return XDR_Int64(u.RelBefore())
	}
	return nil
}
func (u *ClaimPredicate) XdrUnionBodyName() string {
	switch u.Type {
	case CLAIM_PREDICATE_UNCONDITIONAL:
		return ""
	case CLAIM_PREDICATE_AND:
		return "AndPredicates"
	case CLAIM_PREDICATE_OR:
		return "OrPredicates"
	case CLAIM_PREDICATE_NOT:
		return "NotPredicate"
	case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
		return "AbsBefore"
	case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		return "RelBefore"
	}
	return ""
}

type XdrType_ClaimPredicate = *ClaimPredicate

func (v *ClaimPredicate) XdrPointer() interface{}       { return v }
func (ClaimPredicate) XdrTypeName() string              { return "ClaimPredicate" }
func (v ClaimPredicate) XdrValue() interface{}          { return v }
func (v *ClaimPredicate) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClaimPredicate) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimPredicateType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CLAIM_PREDICATE_UNCONDITIONAL:
		return
	case CLAIM_PREDICATE_AND:
		x.Marshal(x.Sprintf("%sandPredicates", name), (*_XdrVec_2_ClaimPredicate)(u.AndPredicates()))
		return
	case CLAIM_PREDICATE_OR:
		x.Marshal(x.Sprintf("%sorPredicates", name), (*_XdrVec_2_ClaimPredicate)(u.OrPredicates()))
		return
	case CLAIM_PREDICATE_NOT:
		x.Marshal(x.Sprintf("%snotPredicate", name), _XdrPtr_ClaimPredicate{u.NotPredicate()})
		return
	case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
		x.Marshal(x.Sprintf("%sabsBefore", name), XDR_Int64(u.AbsBefore()))
		return
	case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
		x.Marshal(x.Sprintf("%srelBefore", name), XDR_Int64(u.RelBefore()))
		return
	}
	XdrPanic("invalid Type (%v) in ClaimPredicate", u.Type)
}
func XDR_ClaimPredicate(v *ClaimPredicate) *ClaimPredicate { return v }

var _XdrNames_ClaimantType = map[int32]string{
	int32(CLAIMANT_TYPE_V0): "CLAIMANT_TYPE_V0",
}
var _XdrValues_ClaimantType = map[string]int32{
	"CLAIMANT_TYPE_V0": int32(CLAIMANT_TYPE_V0),
}

func (ClaimantType) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimantType
}
func (v ClaimantType) String() string {
	if s, ok := _XdrNames_ClaimantType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimantType#%d", v)
}
func (v *ClaimantType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimantType[stok]; ok {
			*v = ClaimantType(val)
			return nil
		} else if stok == "ClaimantType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimantType.", stok))
	}
}
func (v ClaimantType) GetU32() uint32                 { return uint32(v) }
func (v *ClaimantType) SetU32(n uint32)               { *v = ClaimantType(n) }
func (v *ClaimantType) XdrPointer() interface{}       { return v }
func (ClaimantType) XdrTypeName() string              { return "ClaimantType" }
func (v ClaimantType) XdrValue() interface{}          { return v }
func (v *ClaimantType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimantType = *ClaimantType

func XDR_ClaimantType(v *ClaimantType) *ClaimantType { return v }

type XdrType_XdrAnon_Claimant_V0 = *XdrAnon_Claimant_V0

func (v *XdrAnon_Claimant_V0) XdrPointer() interface{}       { return v }
func (XdrAnon_Claimant_V0) XdrTypeName() string              { return "XdrAnon_Claimant_V0" }
func (v XdrAnon_Claimant_V0) XdrValue() interface{}          { return v }
func (v *XdrAnon_Claimant_V0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_Claimant_V0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_AccountID(&v.Destination))
	x.Marshal(x.Sprintf("%spredicate", name), XDR_ClaimPredicate(&v.Predicate))
}
func XDR_XdrAnon_Claimant_V0(v *XdrAnon_Claimant_V0) *XdrAnon_Claimant_V0 { return v }

var _XdrTags_Claimant = map[int32]bool{
	XdrToI32(CLAIMANT_TYPE_V0): true,
}

func (_ Claimant) XdrValidTags() map[int32]bool {
	return _XdrTags_Claimant
}
func (u *Claimant) V0() *XdrAnon_Claimant_V0 {
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		if v, ok := u._u.(*XdrAnon_Claimant_V0); ok {
			return v
		} else {
			var zero XdrAnon_Claimant_V0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Claimant.V0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Claimant) XdrValid() bool {
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		return true
	}
	return false
}
func (u *Claimant) XdrUnionTag() XdrNum32 {
	return XDR_ClaimantType(&u.Type)
}
func (u *Claimant) XdrUnionTagName() string {
	return "Type"
}
func (u *Claimant) XdrUnionBody() XdrType {
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		return XDR_XdrAnon_Claimant_V0(u.V0())
	}
	return nil
}
func (u *Claimant) XdrUnionBodyName() string {
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		return "V0"
	}
	return ""
}

type XdrType_Claimant = *Claimant

func (v *Claimant) XdrPointer() interface{}       { return v }
func (Claimant) XdrTypeName() string              { return "Claimant" }
func (v Claimant) XdrValue() interface{}          { return v }
func (v *Claimant) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Claimant) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimantType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CLAIMANT_TYPE_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_XdrAnon_Claimant_V0(u.V0()))
		return
	}
	XdrPanic("invalid Type (%v) in Claimant", u.Type)
}
func XDR_Claimant(v *Claimant) *Claimant { return v }

var _XdrNames_ClaimableBalanceIDType = map[int32]string{
	int32(CLAIMABLE_BALANCE_ID_TYPE_V0): "CLAIMABLE_BALANCE_ID_TYPE_V0",
}
var _XdrValues_ClaimableBalanceIDType = map[string]int32{
	"CLAIMABLE_BALANCE_ID_TYPE_V0": int32(CLAIMABLE_BALANCE_ID_TYPE_V0),
}

func (ClaimableBalanceIDType) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimableBalanceIDType
}
func (v ClaimableBalanceIDType) String() string {
	if s, ok := _XdrNames_ClaimableBalanceIDType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimableBalanceIDType#%d", v)
}
func (v *ClaimableBalanceIDType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimableBalanceIDType[stok]; ok {
			*v = ClaimableBalanceIDType(val)
			return nil
		} else if stok == "ClaimableBalanceIDType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimableBalanceIDType.", stok))
	}
}
func (v ClaimableBalanceIDType) GetU32() uint32                 { return uint32(v) }
func (v *ClaimableBalanceIDType) SetU32(n uint32)               { *v = ClaimableBalanceIDType(n) }
func (v *ClaimableBalanceIDType) XdrPointer() interface{}       { return v }
func (ClaimableBalanceIDType) XdrTypeName() string              { return "ClaimableBalanceIDType" }
func (v ClaimableBalanceIDType) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceIDType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimableBalanceIDType = *ClaimableBalanceIDType

func XDR_ClaimableBalanceIDType(v *ClaimableBalanceIDType) *ClaimableBalanceIDType { return v }

var _XdrTags_ClaimableBalanceID = map[int32]bool{
	XdrToI32(CLAIMABLE_BALANCE_ID_TYPE_V0): true,
}

func (_ ClaimableBalanceID) XdrValidTags() map[int32]bool {
	return _XdrTags_ClaimableBalanceID
}
func (u *ClaimableBalanceID) V0() *Hash {
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimableBalanceID.V0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ClaimableBalanceID) XdrValid() bool {
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		return true
	}
	return false
}
func (u *ClaimableBalanceID) XdrUnionTag() XdrNum32 {
	return XDR_ClaimableBalanceIDType(&u.Type)
}
func (u *ClaimableBalanceID) XdrUnionTagName() string {
	return "Type"
}
func (u *ClaimableBalanceID) XdrUnionBody() XdrType {
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		return XDR_Hash(u.V0())
	}
	return nil
}
func (u *ClaimableBalanceID) XdrUnionBodyName() string {
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		return "V0"
	}
	return ""
}

type XdrType_ClaimableBalanceID = *ClaimableBalanceID

func (v *ClaimableBalanceID) XdrPointer() interface{}       { return v }
func (ClaimableBalanceID) XdrTypeName() string              { return "ClaimableBalanceID" }
func (v ClaimableBalanceID) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClaimableBalanceID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimableBalanceIDType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CLAIMABLE_BALANCE_ID_TYPE_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_Hash(u.V0()))
		return
	}
	XdrPanic("invalid Type (%v) in ClaimableBalanceID", u.Type)
}
func XDR_ClaimableBalanceID(v *ClaimableBalanceID) *ClaimableBalanceID { return v }

var _XdrNames_ClaimableBalanceFlags = map[int32]string{
	int32(CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG): "CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG",
}
var _XdrValues_ClaimableBalanceFlags = map[string]int32{
	"CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG": int32(CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG),
}

func (ClaimableBalanceFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimableBalanceFlags
}
func (v ClaimableBalanceFlags) String() string {
	if s, ok := _XdrNames_ClaimableBalanceFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimableBalanceFlags#%d", v)
}
func (v *ClaimableBalanceFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimableBalanceFlags[stok]; ok {
			*v = ClaimableBalanceFlags(val)
			return nil
		} else if stok == "ClaimableBalanceFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimableBalanceFlags.", stok))
	}
}
func (v ClaimableBalanceFlags) GetU32() uint32                 { return uint32(v) }
func (v *ClaimableBalanceFlags) SetU32(n uint32)               { *v = ClaimableBalanceFlags(n) }
func (v *ClaimableBalanceFlags) XdrPointer() interface{}       { return v }
func (ClaimableBalanceFlags) XdrTypeName() string              { return "ClaimableBalanceFlags" }
func (v ClaimableBalanceFlags) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimableBalanceFlags = *ClaimableBalanceFlags

func XDR_ClaimableBalanceFlags(v *ClaimableBalanceFlags) *ClaimableBalanceFlags { return v }

var _XdrComments_ClaimableBalanceFlags = map[int32]string{
	int32(CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG): "If set, the issuer account of the asset held by the claimable balance may clawback the claimable balance",
}

func (e ClaimableBalanceFlags) XdrEnumComments() map[int32]string {
	return _XdrComments_ClaimableBalanceFlags
}
func (v *ClaimableBalanceFlags) XdrInitialize() {
	switch ClaimableBalanceFlags(0) {
	case CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG:
	default:
		if *v == ClaimableBalanceFlags(0) {
			*v = CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG
		}
	}
}

var _XdrTags_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext
}
func (u XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext = *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext

func (v *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrTypeName() string {
	return "XdrAnon_ClaimableBalanceEntryExtensionV1_Ext"
}
func (v XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (u *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_ClaimableBalanceEntryExtensionV1_Ext", u.V)
}
func XDR_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext(v *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext) *XdrAnon_ClaimableBalanceEntryExtensionV1_Ext {
	return v
}

type XdrType_ClaimableBalanceEntryExtensionV1 = *ClaimableBalanceEntryExtensionV1

func (v *ClaimableBalanceEntryExtensionV1) XdrPointer() interface{} { return v }
func (ClaimableBalanceEntryExtensionV1) XdrTypeName() string {
	return "ClaimableBalanceEntryExtensionV1"
}
func (v ClaimableBalanceEntryExtensionV1) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceEntryExtensionV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimableBalanceEntryExtensionV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_ClaimableBalanceEntryExtensionV1_Ext(&v.Ext))
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
}
func XDR_ClaimableBalanceEntryExtensionV1(v *ClaimableBalanceEntryExtensionV1) *ClaimableBalanceEntryExtensionV1 {
	return v
}

var _XdrTags_XdrAnon_ClaimableBalanceEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_ClaimableBalanceEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ClaimableBalanceEntry_Ext
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) V1() *ClaimableBalanceEntryExtensionV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*ClaimableBalanceEntryExtensionV1); ok {
			return v
		} else {
			var zero ClaimableBalanceEntryExtensionV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_ClaimableBalanceEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_ClaimableBalanceEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_ClaimableBalanceEntryExtensionV1(u.V1())
	}
	return nil
}
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_ClaimableBalanceEntry_Ext = *XdrAnon_ClaimableBalanceEntry_Ext

func (v *XdrAnon_ClaimableBalanceEntry_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_ClaimableBalanceEntry_Ext) XdrTypeName() string {
	return "XdrAnon_ClaimableBalanceEntry_Ext"
}
func (v XdrAnon_ClaimableBalanceEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_ClaimableBalanceEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ClaimableBalanceEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_ClaimableBalanceEntryExtensionV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_ClaimableBalanceEntry_Ext", u.V)
}
func XDR_XdrAnon_ClaimableBalanceEntry_Ext(v *XdrAnon_ClaimableBalanceEntry_Ext) *XdrAnon_ClaimableBalanceEntry_Ext {
	return v
}

type _XdrVec_10_Claimant []Claimant

func (_XdrVec_10_Claimant) XdrBound() uint32 {
	const bound uint32 = 10 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_10_Claimant) XdrCheckLen(length uint32) {
	if length > uint32(10) {
		XdrPanic("_XdrVec_10_Claimant length %d exceeds bound 10", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_10_Claimant length %d exceeds max int", length)
	}
}
func (v _XdrVec_10_Claimant) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_10_Claimant) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(10); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Claimant, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_10_Claimant) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Claimant(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_10_Claimant) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 10}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_10_Claimant) XdrTypeName() string              { return "Claimant<>" }
func (v *_XdrVec_10_Claimant) XdrPointer() interface{}       { return (*[]Claimant)(v) }
func (v _XdrVec_10_Claimant) XdrValue() interface{}          { return ([]Claimant)(v) }
func (v *_XdrVec_10_Claimant) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimableBalanceEntry = *ClaimableBalanceEntry

func (v *ClaimableBalanceEntry) XdrPointer() interface{}       { return v }
func (ClaimableBalanceEntry) XdrTypeName() string              { return "ClaimableBalanceEntry" }
func (v ClaimableBalanceEntry) XdrValue() interface{}          { return v }
func (v *ClaimableBalanceEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimableBalanceEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(&v.BalanceID))
	x.Marshal(x.Sprintf("%sclaimants", name), (*_XdrVec_10_Claimant)(&v.Claimants))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_ClaimableBalanceEntry_Ext(&v.Ext))
}
func XDR_ClaimableBalanceEntry(v *ClaimableBalanceEntry) *ClaimableBalanceEntry { return v }

type XdrType_LiquidityPoolConstantProductParameters = *LiquidityPoolConstantProductParameters

func (v *LiquidityPoolConstantProductParameters) XdrPointer() interface{} { return v }
func (LiquidityPoolConstantProductParameters) XdrTypeName() string {
	return "LiquidityPoolConstantProductParameters"
}
func (v LiquidityPoolConstantProductParameters) XdrValue() interface{}          { return v }
func (v *LiquidityPoolConstantProductParameters) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LiquidityPoolConstantProductParameters) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sassetA", name), XDR_Asset(&v.AssetA))
	x.Marshal(x.Sprintf("%sassetB", name), XDR_Asset(&v.AssetB))
	x.Marshal(x.Sprintf("%sfee", name), XDR_Int32(&v.Fee))
}
func XDR_LiquidityPoolConstantProductParameters(v *LiquidityPoolConstantProductParameters) *LiquidityPoolConstantProductParameters {
	return v
}

type XdrType_XdrAnon_LiquidityPoolEntry_Body_ConstantProduct = *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct

func (v *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrPointer() interface{} { return v }
func (XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrTypeName() string {
	return "XdrAnon_LiquidityPoolEntry_Body_ConstantProduct"
}
func (v XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrValue() interface{} { return v }
func (v *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sparams", name), XDR_LiquidityPoolConstantProductParameters(&v.Params))
	x.Marshal(x.Sprintf("%sreserveA", name), XDR_Int64(&v.ReserveA))
	x.Marshal(x.Sprintf("%sreserveB", name), XDR_Int64(&v.ReserveB))
	x.Marshal(x.Sprintf("%stotalPoolShares", name), XDR_Int64(&v.TotalPoolShares))
	x.Marshal(x.Sprintf("%spoolSharesTrustLineCount", name), XDR_Int64(&v.PoolSharesTrustLineCount))
}
func XDR_XdrAnon_LiquidityPoolEntry_Body_ConstantProduct(v *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct) *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct {
	return v
}

var _XdrTags_XdrAnon_LiquidityPoolEntry_Body = map[int32]bool{
	XdrToI32(LIQUIDITY_POOL_CONSTANT_PRODUCT): true,
}

func (_ XdrAnon_LiquidityPoolEntry_Body) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LiquidityPoolEntry_Body
}
func (u *XdrAnon_LiquidityPoolEntry_Body) ConstantProduct() *XdrAnon_LiquidityPoolEntry_Body_ConstantProduct {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		if v, ok := u._u.(*XdrAnon_LiquidityPoolEntry_Body_ConstantProduct); ok {
			return v
		} else {
			var zero XdrAnon_LiquidityPoolEntry_Body_ConstantProduct
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LiquidityPoolEntry_Body.ConstantProduct accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_LiquidityPoolEntry_Body) XdrValid() bool {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return true
	}
	return false
}
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrUnionTag() XdrNum32 {
	return XDR_LiquidityPoolType(&u.Type)
}
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrUnionBody() XdrType {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return XDR_XdrAnon_LiquidityPoolEntry_Body_ConstantProduct(u.ConstantProduct())
	}
	return nil
}
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrUnionBodyName() string {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return "ConstantProduct"
	}
	return ""
}

type XdrType_XdrAnon_LiquidityPoolEntry_Body = *XdrAnon_LiquidityPoolEntry_Body

func (v *XdrAnon_LiquidityPoolEntry_Body) XdrPointer() interface{}       { return v }
func (XdrAnon_LiquidityPoolEntry_Body) XdrTypeName() string              { return "XdrAnon_LiquidityPoolEntry_Body" }
func (v XdrAnon_LiquidityPoolEntry_Body) XdrValue() interface{}          { return v }
func (v *XdrAnon_LiquidityPoolEntry_Body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LiquidityPoolEntry_Body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LiquidityPoolType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		x.Marshal(x.Sprintf("%sconstantProduct", name), XDR_XdrAnon_LiquidityPoolEntry_Body_ConstantProduct(u.ConstantProduct()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_LiquidityPoolEntry_Body", u.Type)
}
func XDR_XdrAnon_LiquidityPoolEntry_Body(v *XdrAnon_LiquidityPoolEntry_Body) *XdrAnon_LiquidityPoolEntry_Body {
	return v
}

type XdrType_LiquidityPoolEntry = *LiquidityPoolEntry

func (v *LiquidityPoolEntry) XdrPointer() interface{}       { return v }
func (LiquidityPoolEntry) XdrTypeName() string              { return "LiquidityPoolEntry" }
func (v LiquidityPoolEntry) XdrValue() interface{}          { return v }
func (v *LiquidityPoolEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LiquidityPoolEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%sbody", name), XDR_XdrAnon_LiquidityPoolEntry_Body(&v.Body))
}
func XDR_LiquidityPoolEntry(v *LiquidityPoolEntry) *LiquidityPoolEntry { return v }

type XdrType_ContractDataEntry = *ContractDataEntry

func (v *ContractDataEntry) XdrPointer() interface{}       { return v }
func (ContractDataEntry) XdrTypeName() string              { return "ContractDataEntry" }
func (v ContractDataEntry) XdrValue() interface{}          { return v }
func (v *ContractDataEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ContractDataEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scontractID", name), XDR_Hash(&v.ContractID))
	x.Marshal(x.Sprintf("%skey", name), XDR_SCVal(&v.Key))
	x.Marshal(x.Sprintf("%sval", name), XDR_SCVal(&v.Val))
}
func XDR_ContractDataEntry(v *ContractDataEntry) *ContractDataEntry { return v }

var _XdrNames_ConfigSettingType = map[int32]string{
	int32(CONFIG_SETTING_TYPE_UINT32): "CONFIG_SETTING_TYPE_UINT32",
}
var _XdrValues_ConfigSettingType = map[string]int32{
	"CONFIG_SETTING_TYPE_UINT32": int32(CONFIG_SETTING_TYPE_UINT32),
}

func (ConfigSettingType) XdrEnumNames() map[int32]string {
	return _XdrNames_ConfigSettingType
}
func (v ConfigSettingType) String() string {
	if s, ok := _XdrNames_ConfigSettingType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ConfigSettingType#%d", v)
}
func (v *ConfigSettingType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ConfigSettingType[stok]; ok {
			*v = ConfigSettingType(val)
			return nil
		} else if stok == "ConfigSettingType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ConfigSettingType.", stok))
	}
}
func (v ConfigSettingType) GetU32() uint32                 { return uint32(v) }
func (v *ConfigSettingType) SetU32(n uint32)               { *v = ConfigSettingType(n) }
func (v *ConfigSettingType) XdrPointer() interface{}       { return v }
func (ConfigSettingType) XdrTypeName() string              { return "ConfigSettingType" }
func (v ConfigSettingType) XdrValue() interface{}          { return v }
func (v *ConfigSettingType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ConfigSettingType = *ConfigSettingType

func XDR_ConfigSettingType(v *ConfigSettingType) *ConfigSettingType { return v }

var _XdrTags_ConfigSetting = map[int32]bool{
	XdrToI32(CONFIG_SETTING_TYPE_UINT32): true,
}

func (_ ConfigSetting) XdrValidTags() map[int32]bool {
	return _XdrTags_ConfigSetting
}
func (u *ConfigSetting) Uint32Val() *Uint32 {
	switch u.Type {
	case CONFIG_SETTING_TYPE_UINT32:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ConfigSetting.Uint32Val accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ConfigSetting) XdrValid() bool {
	switch u.Type {
	case CONFIG_SETTING_TYPE_UINT32:
		return true
	}
	return false
}
func (u *ConfigSetting) XdrUnionTag() XdrNum32 {
	return XDR_ConfigSettingType(&u.Type)
}
func (u *ConfigSetting) XdrUnionTagName() string {
	return "Type"
}
func (u *ConfigSetting) XdrUnionBody() XdrType {
	switch u.Type {
	case CONFIG_SETTING_TYPE_UINT32:
		return XDR_Uint32(u.Uint32Val())
	}
	return nil
}
func (u *ConfigSetting) XdrUnionBodyName() string {
	switch u.Type {
	case CONFIG_SETTING_TYPE_UINT32:
		return "Uint32Val"
	}
	return ""
}

type XdrType_ConfigSetting = *ConfigSetting

func (v *ConfigSetting) XdrPointer() interface{}       { return v }
func (ConfigSetting) XdrTypeName() string              { return "ConfigSetting" }
func (v ConfigSetting) XdrValue() interface{}          { return v }
func (v *ConfigSetting) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ConfigSetting) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ConfigSettingType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CONFIG_SETTING_TYPE_UINT32:
		x.Marshal(x.Sprintf("%suint32Val", name), XDR_Uint32(u.Uint32Val()))
		return
	}
	XdrPanic("invalid Type (%v) in ConfigSetting", u.Type)
}
func XDR_ConfigSetting(v *ConfigSetting) *ConfigSetting { return v }

var _XdrNames_ConfigSettingID = map[int32]string{
	int32(CONFIG_SETTING_CONTRACT_MAX_SIZE): "CONFIG_SETTING_CONTRACT_MAX_SIZE",
}
var _XdrValues_ConfigSettingID = map[string]int32{
	"CONFIG_SETTING_CONTRACT_MAX_SIZE": int32(CONFIG_SETTING_CONTRACT_MAX_SIZE),
}

func (ConfigSettingID) XdrEnumNames() map[int32]string {
	return _XdrNames_ConfigSettingID
}
func (v ConfigSettingID) String() string {
	if s, ok := _XdrNames_ConfigSettingID[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ConfigSettingID#%d", v)
}
func (v *ConfigSettingID) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ConfigSettingID[stok]; ok {
			*v = ConfigSettingID(val)
			return nil
		} else if stok == "ConfigSettingID" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ConfigSettingID.", stok))
	}
}
func (v ConfigSettingID) GetU32() uint32                 { return uint32(v) }
func (v *ConfigSettingID) SetU32(n uint32)               { *v = ConfigSettingID(n) }
func (v *ConfigSettingID) XdrPointer() interface{}       { return v }
func (ConfigSettingID) XdrTypeName() string              { return "ConfigSettingID" }
func (v ConfigSettingID) XdrValue() interface{}          { return v }
func (v *ConfigSettingID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ConfigSettingID = *ConfigSettingID

func XDR_ConfigSettingID(v *ConfigSettingID) *ConfigSettingID { return v }

var _XdrTags_XdrAnon_ConfigSettingEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_ConfigSettingEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ConfigSettingEntry_Ext
}
func (u XdrAnon_ConfigSettingEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_ConfigSettingEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_ConfigSettingEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_ConfigSettingEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_ConfigSettingEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_ConfigSettingEntry_Ext = *XdrAnon_ConfigSettingEntry_Ext

func (v *XdrAnon_ConfigSettingEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_ConfigSettingEntry_Ext) XdrTypeName() string              { return "XdrAnon_ConfigSettingEntry_Ext" }
func (v XdrAnon_ConfigSettingEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_ConfigSettingEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ConfigSettingEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_ConfigSettingEntry_Ext", u.V)
}
func XDR_XdrAnon_ConfigSettingEntry_Ext(v *XdrAnon_ConfigSettingEntry_Ext) *XdrAnon_ConfigSettingEntry_Ext {
	return v
}

type XdrType_ConfigSettingEntry = *ConfigSettingEntry

func (v *ConfigSettingEntry) XdrPointer() interface{}       { return v }
func (ConfigSettingEntry) XdrTypeName() string              { return "ConfigSettingEntry" }
func (v ConfigSettingEntry) XdrValue() interface{}          { return v }
func (v *ConfigSettingEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ConfigSettingEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_ConfigSettingEntry_Ext(&v.Ext))
	x.Marshal(x.Sprintf("%sconfigSettingID", name), XDR_ConfigSettingID(&v.ConfigSettingID))
	x.Marshal(x.Sprintf("%ssetting", name), XDR_ConfigSetting(&v.Setting))
}
func XDR_ConfigSettingEntry(v *ConfigSettingEntry) *ConfigSettingEntry { return v }

var _XdrTags_XdrAnon_LedgerEntryExtensionV1_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_LedgerEntryExtensionV1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerEntryExtensionV1_Ext
}
func (u XdrAnon_LedgerEntryExtensionV1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_LedgerEntryExtensionV1_Ext = *XdrAnon_LedgerEntryExtensionV1_Ext

func (v *XdrAnon_LedgerEntryExtensionV1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerEntryExtensionV1_Ext) XdrTypeName() string {
	return "XdrAnon_LedgerEntryExtensionV1_Ext"
}
func (v XdrAnon_LedgerEntryExtensionV1_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerEntryExtensionV1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerEntryExtensionV1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerEntryExtensionV1_Ext", u.V)
}
func XDR_XdrAnon_LedgerEntryExtensionV1_Ext(v *XdrAnon_LedgerEntryExtensionV1_Ext) *XdrAnon_LedgerEntryExtensionV1_Ext {
	return v
}

type XdrType_LedgerEntryExtensionV1 = *LedgerEntryExtensionV1

func (v *LedgerEntryExtensionV1) XdrPointer() interface{}       { return v }
func (LedgerEntryExtensionV1) XdrTypeName() string              { return "LedgerEntryExtensionV1" }
func (v LedgerEntryExtensionV1) XdrValue() interface{}          { return v }
func (v *LedgerEntryExtensionV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerEntryExtensionV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssponsoringID", name), XDR_SponsorshipDescriptor(&v.SponsoringID))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerEntryExtensionV1_Ext(&v.Ext))
}
func XDR_LedgerEntryExtensionV1(v *LedgerEntryExtensionV1) *LedgerEntryExtensionV1 { return v }

var _XdrTags_XdrAnon_LedgerEntry_Data = map[int32]bool{
	XdrToI32(ACCOUNT):           true,
	XdrToI32(TRUSTLINE):         true,
	XdrToI32(OFFER):             true,
	XdrToI32(DATA):              true,
	XdrToI32(CLAIMABLE_BALANCE): true,
	XdrToI32(LIQUIDITY_POOL):    true,
	XdrToI32(CONTRACT_DATA):     true,
	XdrToI32(CONFIG_SETTING):    true,
}

func (_ XdrAnon_LedgerEntry_Data) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerEntry_Data
}
func (u *XdrAnon_LedgerEntry_Data) Account() *AccountEntry {
	switch u.Type {
	case ACCOUNT:
		if v, ok := u._u.(*AccountEntry); ok {
			return v
		} else {
			var zero AccountEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Account accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) TrustLine() *TrustLineEntry {
	switch u.Type {
	case TRUSTLINE:
		if v, ok := u._u.(*TrustLineEntry); ok {
			return v
		} else {
			var zero TrustLineEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.TrustLine accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) Offer() *OfferEntry {
	switch u.Type {
	case OFFER:
		if v, ok := u._u.(*OfferEntry); ok {
			return v
		} else {
			var zero OfferEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Offer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) Data() *DataEntry {
	switch u.Type {
	case DATA:
		if v, ok := u._u.(*DataEntry); ok {
			return v
		} else {
			var zero DataEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.Data accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) ClaimableBalance() *ClaimableBalanceEntry {
	switch u.Type {
	case CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClaimableBalanceEntry); ok {
			return v
		} else {
			var zero ClaimableBalanceEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.ClaimableBalance accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) LiquidityPool() *LiquidityPoolEntry {
	switch u.Type {
	case LIQUIDITY_POOL:
		if v, ok := u._u.(*LiquidityPoolEntry); ok {
			return v
		} else {
			var zero LiquidityPoolEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.LiquidityPool accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) ContractData() *ContractDataEntry {
	switch u.Type {
	case CONTRACT_DATA:
		if v, ok := u._u.(*ContractDataEntry); ok {
			return v
		} else {
			var zero ContractDataEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.ContractData accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_LedgerEntry_Data) ConfigSetting() *ConfigSettingEntry {
	switch u.Type {
	case CONFIG_SETTING:
		if v, ok := u._u.(*ConfigSettingEntry); ok {
			return v
		} else {
			var zero ConfigSettingEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Data.ConfigSetting accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_LedgerEntry_Data) XdrValid() bool {
	switch u.Type {
	case ACCOUNT, TRUSTLINE, OFFER, DATA, CLAIMABLE_BALANCE, LIQUIDITY_POOL, CONTRACT_DATA, CONFIG_SETTING:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionTag() XdrNum32 {
	return XDR_LedgerEntryType(&u.Type)
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionBody() XdrType {
	switch u.Type {
	case ACCOUNT:
		return XDR_AccountEntry(u.Account())
	case TRUSTLINE:
		return XDR_TrustLineEntry(u.TrustLine())
	case OFFER:
		return XDR_OfferEntry(u.Offer())
	case DATA:
		return XDR_DataEntry(u.Data())
	case CLAIMABLE_BALANCE:
		return XDR_ClaimableBalanceEntry(u.ClaimableBalance())
	case LIQUIDITY_POOL:
		return XDR_LiquidityPoolEntry(u.LiquidityPool())
	case CONTRACT_DATA:
		return XDR_ContractDataEntry(u.ContractData())
	case CONFIG_SETTING:
		return XDR_ConfigSettingEntry(u.ConfigSetting())
	}
	return nil
}
func (u *XdrAnon_LedgerEntry_Data) XdrUnionBodyName() string {
	switch u.Type {
	case ACCOUNT:
		return "Account"
	case TRUSTLINE:
		return "TrustLine"
	case OFFER:
		return "Offer"
	case DATA:
		return "Data"
	case CLAIMABLE_BALANCE:
		return "ClaimableBalance"
	case LIQUIDITY_POOL:
		return "LiquidityPool"
	case CONTRACT_DATA:
		return "ContractData"
	case CONFIG_SETTING:
		return "ConfigSetting"
	}
	return ""
}

type XdrType_XdrAnon_LedgerEntry_Data = *XdrAnon_LedgerEntry_Data

func (v *XdrAnon_LedgerEntry_Data) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerEntry_Data) XdrTypeName() string              { return "XdrAnon_LedgerEntry_Data" }
func (v XdrAnon_LedgerEntry_Data) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerEntry_Data) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerEntry_Data) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ACCOUNT:
		x.Marshal(x.Sprintf("%saccount", name), XDR_AccountEntry(u.Account()))
		return
	case TRUSTLINE:
		x.Marshal(x.Sprintf("%strustLine", name), XDR_TrustLineEntry(u.TrustLine()))
		return
	case OFFER:
		x.Marshal(x.Sprintf("%soffer", name), XDR_OfferEntry(u.Offer()))
		return
	case DATA:
		x.Marshal(x.Sprintf("%sdata", name), XDR_DataEntry(u.Data()))
		return
	case CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclaimableBalance", name), XDR_ClaimableBalanceEntry(u.ClaimableBalance()))
		return
	case LIQUIDITY_POOL:
		x.Marshal(x.Sprintf("%sliquidityPool", name), XDR_LiquidityPoolEntry(u.LiquidityPool()))
		return
	case CONTRACT_DATA:
		x.Marshal(x.Sprintf("%scontractData", name), XDR_ContractDataEntry(u.ContractData()))
		return
	case CONFIG_SETTING:
		x.Marshal(x.Sprintf("%sconfigSetting", name), XDR_ConfigSettingEntry(u.ConfigSetting()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_LedgerEntry_Data", u.Type)
}
func XDR_XdrAnon_LedgerEntry_Data(v *XdrAnon_LedgerEntry_Data) *XdrAnon_LedgerEntry_Data { return v }

var _XdrTags_XdrAnon_LedgerEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_LedgerEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerEntry_Ext
}
func (u *XdrAnon_LedgerEntry_Ext) V1() *LedgerEntryExtensionV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*LedgerEntryExtensionV1); ok {
			return v
		} else {
			var zero LedgerEntryExtensionV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_LedgerEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_LedgerEntryExtensionV1(u.V1())
	}
	return nil
}
func (u *XdrAnon_LedgerEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_LedgerEntry_Ext = *XdrAnon_LedgerEntry_Ext

func (v *XdrAnon_LedgerEntry_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerEntry_Ext) XdrTypeName() string              { return "XdrAnon_LedgerEntry_Ext" }
func (v XdrAnon_LedgerEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_LedgerEntryExtensionV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerEntry_Ext", u.V)
}
func XDR_XdrAnon_LedgerEntry_Ext(v *XdrAnon_LedgerEntry_Ext) *XdrAnon_LedgerEntry_Ext { return v }

type XdrType_LedgerEntry = *LedgerEntry

func (v *LedgerEntry) XdrPointer() interface{}       { return v }
func (LedgerEntry) XdrTypeName() string              { return "LedgerEntry" }
func (v LedgerEntry) XdrValue() interface{}          { return v }
func (v *LedgerEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slastModifiedLedgerSeq", name), XDR_Uint32(&v.LastModifiedLedgerSeq))
	x.Marshal(x.Sprintf("%sdata", name), XDR_XdrAnon_LedgerEntry_Data(&v.Data))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerEntry_Ext(&v.Ext))
}
func XDR_LedgerEntry(v *LedgerEntry) *LedgerEntry { return v }

type XdrType_XdrAnon_LedgerKey_Account = *XdrAnon_LedgerKey_Account

func (v *XdrAnon_LedgerKey_Account) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_Account) XdrTypeName() string              { return "XdrAnon_LedgerKey_Account" }
func (v XdrAnon_LedgerKey_Account) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_Account) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Account) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
}
func XDR_XdrAnon_LedgerKey_Account(v *XdrAnon_LedgerKey_Account) *XdrAnon_LedgerKey_Account { return v }

type XdrType_XdrAnon_LedgerKey_TrustLine = *XdrAnon_LedgerKey_TrustLine

func (v *XdrAnon_LedgerKey_TrustLine) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_TrustLine) XdrTypeName() string              { return "XdrAnon_LedgerKey_TrustLine" }
func (v XdrAnon_LedgerKey_TrustLine) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_TrustLine) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_TrustLine) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sasset", name), XDR_TrustLineAsset(&v.Asset))
}
func XDR_XdrAnon_LedgerKey_TrustLine(v *XdrAnon_LedgerKey_TrustLine) *XdrAnon_LedgerKey_TrustLine {
	return v
}

type XdrType_XdrAnon_LedgerKey_Offer = *XdrAnon_LedgerKey_Offer

func (v *XdrAnon_LedgerKey_Offer) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_Offer) XdrTypeName() string              { return "XdrAnon_LedgerKey_Offer" }
func (v XdrAnon_LedgerKey_Offer) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_Offer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Offer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssellerID", name), XDR_AccountID(&v.SellerID))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
}
func XDR_XdrAnon_LedgerKey_Offer(v *XdrAnon_LedgerKey_Offer) *XdrAnon_LedgerKey_Offer { return v }

type XdrType_XdrAnon_LedgerKey_Data = *XdrAnon_LedgerKey_Data

func (v *XdrAnon_LedgerKey_Data) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_Data) XdrTypeName() string              { return "XdrAnon_LedgerKey_Data" }
func (v XdrAnon_LedgerKey_Data) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_Data) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_Data) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%sdataName", name), XDR_String64(&v.DataName))
}
func XDR_XdrAnon_LedgerKey_Data(v *XdrAnon_LedgerKey_Data) *XdrAnon_LedgerKey_Data { return v }

type XdrType_XdrAnon_LedgerKey_ClaimableBalance = *XdrAnon_LedgerKey_ClaimableBalance

func (v *XdrAnon_LedgerKey_ClaimableBalance) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerKey_ClaimableBalance) XdrTypeName() string {
	return "XdrAnon_LedgerKey_ClaimableBalance"
}
func (v XdrAnon_LedgerKey_ClaimableBalance) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_ClaimableBalance) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_ClaimableBalance) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(&v.BalanceID))
}
func XDR_XdrAnon_LedgerKey_ClaimableBalance(v *XdrAnon_LedgerKey_ClaimableBalance) *XdrAnon_LedgerKey_ClaimableBalance {
	return v
}

type XdrType_XdrAnon_LedgerKey_LiquidityPool = *XdrAnon_LedgerKey_LiquidityPool

func (v *XdrAnon_LedgerKey_LiquidityPool) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_LiquidityPool) XdrTypeName() string              { return "XdrAnon_LedgerKey_LiquidityPool" }
func (v XdrAnon_LedgerKey_LiquidityPool) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_LiquidityPool) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_LiquidityPool) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
}
func XDR_XdrAnon_LedgerKey_LiquidityPool(v *XdrAnon_LedgerKey_LiquidityPool) *XdrAnon_LedgerKey_LiquidityPool {
	return v
}

type XdrType_XdrAnon_LedgerKey_ContractData = *XdrAnon_LedgerKey_ContractData

func (v *XdrAnon_LedgerKey_ContractData) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_ContractData) XdrTypeName() string              { return "XdrAnon_LedgerKey_ContractData" }
func (v XdrAnon_LedgerKey_ContractData) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_ContractData) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_ContractData) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scontractID", name), XDR_Hash(&v.ContractID))
	x.Marshal(x.Sprintf("%skey", name), XDR_SCVal(&v.Key))
}
func XDR_XdrAnon_LedgerKey_ContractData(v *XdrAnon_LedgerKey_ContractData) *XdrAnon_LedgerKey_ContractData {
	return v
}

type XdrType_XdrAnon_LedgerKey_ConfigSetting = *XdrAnon_LedgerKey_ConfigSetting

func (v *XdrAnon_LedgerKey_ConfigSetting) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerKey_ConfigSetting) XdrTypeName() string              { return "XdrAnon_LedgerKey_ConfigSetting" }
func (v XdrAnon_LedgerKey_ConfigSetting) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerKey_ConfigSetting) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerKey_ConfigSetting) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sconfigSettingID", name), XDR_ConfigSettingID(&v.ConfigSettingID))
}
func XDR_XdrAnon_LedgerKey_ConfigSetting(v *XdrAnon_LedgerKey_ConfigSetting) *XdrAnon_LedgerKey_ConfigSetting {
	return v
}

var _XdrTags_LedgerKey = map[int32]bool{
	XdrToI32(ACCOUNT):           true,
	XdrToI32(TRUSTLINE):         true,
	XdrToI32(OFFER):             true,
	XdrToI32(DATA):              true,
	XdrToI32(CLAIMABLE_BALANCE): true,
	XdrToI32(LIQUIDITY_POOL):    true,
	XdrToI32(CONTRACT_DATA):     true,
	XdrToI32(CONFIG_SETTING):    true,
}

func (_ LedgerKey) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerKey
}
func (u *LedgerKey) Account() *XdrAnon_LedgerKey_Account {
	switch u.Type {
	case ACCOUNT:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Account); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Account
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Account accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) TrustLine() *XdrAnon_LedgerKey_TrustLine {
	switch u.Type {
	case TRUSTLINE:
		if v, ok := u._u.(*XdrAnon_LedgerKey_TrustLine); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_TrustLine
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.TrustLine accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Offer() *XdrAnon_LedgerKey_Offer {
	switch u.Type {
	case OFFER:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Offer); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Offer
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Offer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Data() *XdrAnon_LedgerKey_Data {
	switch u.Type {
	case DATA:
		if v, ok := u._u.(*XdrAnon_LedgerKey_Data); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_Data
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.Data accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) ClaimableBalance() *XdrAnon_LedgerKey_ClaimableBalance {
	switch u.Type {
	case CLAIMABLE_BALANCE:
		if v, ok := u._u.(*XdrAnon_LedgerKey_ClaimableBalance); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_ClaimableBalance
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.ClaimableBalance accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) LiquidityPool() *XdrAnon_LedgerKey_LiquidityPool {
	switch u.Type {
	case LIQUIDITY_POOL:
		if v, ok := u._u.(*XdrAnon_LedgerKey_LiquidityPool); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_LiquidityPool
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.LiquidityPool accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) ContractData() *XdrAnon_LedgerKey_ContractData {
	switch u.Type {
	case CONTRACT_DATA:
		if v, ok := u._u.(*XdrAnon_LedgerKey_ContractData); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_ContractData
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.ContractData accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) ConfigSetting() *XdrAnon_LedgerKey_ConfigSetting {
	switch u.Type {
	case CONFIG_SETTING:
		if v, ok := u._u.(*XdrAnon_LedgerKey_ConfigSetting); ok {
			return v
		} else {
			var zero XdrAnon_LedgerKey_ConfigSetting
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerKey.ConfigSetting accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerKey) XdrValid() bool {
	switch u.Type {
	case ACCOUNT, TRUSTLINE, OFFER, DATA, CLAIMABLE_BALANCE, LIQUIDITY_POOL, CONTRACT_DATA, CONFIG_SETTING:
		return true
	}
	return false
}
func (u *LedgerKey) XdrUnionTag() XdrNum32 {
	return XDR_LedgerEntryType(&u.Type)
}
func (u *LedgerKey) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerKey) XdrUnionBody() XdrType {
	switch u.Type {
	case ACCOUNT:
		return XDR_XdrAnon_LedgerKey_Account(u.Account())
	case TRUSTLINE:
		return XDR_XdrAnon_LedgerKey_TrustLine(u.TrustLine())
	case OFFER:
		return XDR_XdrAnon_LedgerKey_Offer(u.Offer())
	case DATA:
		return XDR_XdrAnon_LedgerKey_Data(u.Data())
	case CLAIMABLE_BALANCE:
		return XDR_XdrAnon_LedgerKey_ClaimableBalance(u.ClaimableBalance())
	case LIQUIDITY_POOL:
		return XDR_XdrAnon_LedgerKey_LiquidityPool(u.LiquidityPool())
	case CONTRACT_DATA:
		return XDR_XdrAnon_LedgerKey_ContractData(u.ContractData())
	case CONFIG_SETTING:
		return XDR_XdrAnon_LedgerKey_ConfigSetting(u.ConfigSetting())
	}
	return nil
}
func (u *LedgerKey) XdrUnionBodyName() string {
	switch u.Type {
	case ACCOUNT:
		return "Account"
	case TRUSTLINE:
		return "TrustLine"
	case OFFER:
		return "Offer"
	case DATA:
		return "Data"
	case CLAIMABLE_BALANCE:
		return "ClaimableBalance"
	case LIQUIDITY_POOL:
		return "LiquidityPool"
	case CONTRACT_DATA:
		return "ContractData"
	case CONFIG_SETTING:
		return "ConfigSetting"
	}
	return ""
}

type XdrType_LedgerKey = *LedgerKey

func (v *LedgerKey) XdrPointer() interface{}       { return v }
func (LedgerKey) XdrTypeName() string              { return "LedgerKey" }
func (v LedgerKey) XdrValue() interface{}          { return v }
func (v *LedgerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ACCOUNT:
		x.Marshal(x.Sprintf("%saccount", name), XDR_XdrAnon_LedgerKey_Account(u.Account()))
		return
	case TRUSTLINE:
		x.Marshal(x.Sprintf("%strustLine", name), XDR_XdrAnon_LedgerKey_TrustLine(u.TrustLine()))
		return
	case OFFER:
		x.Marshal(x.Sprintf("%soffer", name), XDR_XdrAnon_LedgerKey_Offer(u.Offer()))
		return
	case DATA:
		x.Marshal(x.Sprintf("%sdata", name), XDR_XdrAnon_LedgerKey_Data(u.Data()))
		return
	case CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclaimableBalance", name), XDR_XdrAnon_LedgerKey_ClaimableBalance(u.ClaimableBalance()))
		return
	case LIQUIDITY_POOL:
		x.Marshal(x.Sprintf("%sliquidityPool", name), XDR_XdrAnon_LedgerKey_LiquidityPool(u.LiquidityPool()))
		return
	case CONTRACT_DATA:
		x.Marshal(x.Sprintf("%scontractData", name), XDR_XdrAnon_LedgerKey_ContractData(u.ContractData()))
		return
	case CONFIG_SETTING:
		x.Marshal(x.Sprintf("%sconfigSetting", name), XDR_XdrAnon_LedgerKey_ConfigSetting(u.ConfigSetting()))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerKey", u.Type)
}
func XDR_LedgerKey(v *LedgerKey) *LedgerKey { return v }

var _XdrNames_EnvelopeType = map[int32]string{
	int32(ENVELOPE_TYPE_TX_V0):                           "ENVELOPE_TYPE_TX_V0",
	int32(ENVELOPE_TYPE_SCP):                             "ENVELOPE_TYPE_SCP",
	int32(ENVELOPE_TYPE_TX):                              "ENVELOPE_TYPE_TX",
	int32(ENVELOPE_TYPE_AUTH):                            "ENVELOPE_TYPE_AUTH",
	int32(ENVELOPE_TYPE_SCPVALUE):                        "ENVELOPE_TYPE_SCPVALUE",
	int32(ENVELOPE_TYPE_TX_FEE_BUMP):                     "ENVELOPE_TYPE_TX_FEE_BUMP",
	int32(ENVELOPE_TYPE_OP_ID):                           "ENVELOPE_TYPE_OP_ID",
	int32(ENVELOPE_TYPE_POOL_REVOKE_OP_ID):               "ENVELOPE_TYPE_POOL_REVOKE_OP_ID",
	int32(ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519):        "ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519",
	int32(ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT):       "ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT",
	int32(ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET):          "ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET",
	int32(ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT): "ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT",
}
var _XdrValues_EnvelopeType = map[string]int32{
	"ENVELOPE_TYPE_TX_V0":                           int32(ENVELOPE_TYPE_TX_V0),
	"ENVELOPE_TYPE_SCP":                             int32(ENVELOPE_TYPE_SCP),
	"ENVELOPE_TYPE_TX":                              int32(ENVELOPE_TYPE_TX),
	"ENVELOPE_TYPE_AUTH":                            int32(ENVELOPE_TYPE_AUTH),
	"ENVELOPE_TYPE_SCPVALUE":                        int32(ENVELOPE_TYPE_SCPVALUE),
	"ENVELOPE_TYPE_TX_FEE_BUMP":                     int32(ENVELOPE_TYPE_TX_FEE_BUMP),
	"ENVELOPE_TYPE_OP_ID":                           int32(ENVELOPE_TYPE_OP_ID),
	"ENVELOPE_TYPE_POOL_REVOKE_OP_ID":               int32(ENVELOPE_TYPE_POOL_REVOKE_OP_ID),
	"ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519":        int32(ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519),
	"ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT":       int32(ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT),
	"ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET":          int32(ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET),
	"ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT": int32(ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT),
}

func (EnvelopeType) XdrEnumNames() map[int32]string {
	return _XdrNames_EnvelopeType
}
func (v EnvelopeType) String() string {
	if s, ok := _XdrNames_EnvelopeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("EnvelopeType#%d", v)
}
func (v *EnvelopeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_EnvelopeType[stok]; ok {
			*v = EnvelopeType(val)
			return nil
		} else if stok == "EnvelopeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid EnvelopeType.", stok))
	}
}
func (v EnvelopeType) GetU32() uint32                 { return uint32(v) }
func (v *EnvelopeType) SetU32(n uint32)               { *v = EnvelopeType(n) }
func (v *EnvelopeType) XdrPointer() interface{}       { return v }
func (EnvelopeType) XdrTypeName() string              { return "EnvelopeType" }
func (v EnvelopeType) XdrValue() interface{}          { return v }
func (v *EnvelopeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_EnvelopeType = *EnvelopeType

func XDR_EnvelopeType(v *EnvelopeType) *EnvelopeType { return v }

type XdrType_UpgradeType struct {
	XdrVecOpaque
}

func XDR_UpgradeType(v *UpgradeType) XdrType_UpgradeType {
	return XdrType_UpgradeType{XdrVecOpaque{v, 128}}
}
func (XdrType_UpgradeType) XdrTypeName() string  { return "UpgradeType" }
func (v XdrType_UpgradeType) XdrUnwrap() XdrType { return v.XdrVecOpaque }

var _XdrNames_StellarValueType = map[int32]string{
	int32(STELLAR_VALUE_BASIC):  "STELLAR_VALUE_BASIC",
	int32(STELLAR_VALUE_SIGNED): "STELLAR_VALUE_SIGNED",
}
var _XdrValues_StellarValueType = map[string]int32{
	"STELLAR_VALUE_BASIC":  int32(STELLAR_VALUE_BASIC),
	"STELLAR_VALUE_SIGNED": int32(STELLAR_VALUE_SIGNED),
}

func (StellarValueType) XdrEnumNames() map[int32]string {
	return _XdrNames_StellarValueType
}
func (v StellarValueType) String() string {
	if s, ok := _XdrNames_StellarValueType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("StellarValueType#%d", v)
}
func (v *StellarValueType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_StellarValueType[stok]; ok {
			*v = StellarValueType(val)
			return nil
		} else if stok == "StellarValueType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid StellarValueType.", stok))
	}
}
func (v StellarValueType) GetU32() uint32                 { return uint32(v) }
func (v *StellarValueType) SetU32(n uint32)               { *v = StellarValueType(n) }
func (v *StellarValueType) XdrPointer() interface{}       { return v }
func (StellarValueType) XdrTypeName() string              { return "StellarValueType" }
func (v StellarValueType) XdrValue() interface{}          { return v }
func (v *StellarValueType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_StellarValueType = *StellarValueType

func XDR_StellarValueType(v *StellarValueType) *StellarValueType { return v }

type XdrType_LedgerCloseValueSignature = *LedgerCloseValueSignature

func (v *LedgerCloseValueSignature) XdrPointer() interface{}       { return v }
func (LedgerCloseValueSignature) XdrTypeName() string              { return "LedgerCloseValueSignature" }
func (v LedgerCloseValueSignature) XdrValue() interface{}          { return v }
func (v *LedgerCloseValueSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseValueSignature) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snodeID", name), XDR_NodeID(&v.NodeID))
	x.Marshal(x.Sprintf("%ssignature", name), XDR_Signature(&v.Signature))
}
func XDR_LedgerCloseValueSignature(v *LedgerCloseValueSignature) *LedgerCloseValueSignature { return v }

var _XdrTags_XdrAnon_StellarValue_Ext = map[int32]bool{
	XdrToI32(STELLAR_VALUE_BASIC):  true,
	XdrToI32(STELLAR_VALUE_SIGNED): true,
}

func (_ XdrAnon_StellarValue_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_StellarValue_Ext
}
func (u *XdrAnon_StellarValue_Ext) LcValueSignature() *LedgerCloseValueSignature {
	switch u.V {
	case STELLAR_VALUE_SIGNED:
		if v, ok := u._u.(*LedgerCloseValueSignature); ok {
			return v
		} else {
			var zero LedgerCloseValueSignature
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_StellarValue_Ext.LcValueSignature accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_StellarValue_Ext) XdrValid() bool {
	switch u.V {
	case STELLAR_VALUE_BASIC, STELLAR_VALUE_SIGNED:
		return true
	}
	return false
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionTag() XdrNum32 {
	return XDR_StellarValueType(&u.V)
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return nil
	case STELLAR_VALUE_SIGNED:
		return XDR_LedgerCloseValueSignature(u.LcValueSignature())
	}
	return nil
}
func (u *XdrAnon_StellarValue_Ext) XdrUnionBodyName() string {
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return ""
	case STELLAR_VALUE_SIGNED:
		return "LcValueSignature"
	}
	return ""
}

type XdrType_XdrAnon_StellarValue_Ext = *XdrAnon_StellarValue_Ext

func (v *XdrAnon_StellarValue_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_StellarValue_Ext) XdrTypeName() string              { return "XdrAnon_StellarValue_Ext" }
func (v XdrAnon_StellarValue_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_StellarValue_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_StellarValue_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_StellarValueType(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case STELLAR_VALUE_BASIC:
		return
	case STELLAR_VALUE_SIGNED:
		x.Marshal(x.Sprintf("%slcValueSignature", name), XDR_LedgerCloseValueSignature(u.LcValueSignature()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_StellarValue_Ext", u.V)
}
func XDR_XdrAnon_StellarValue_Ext(v *XdrAnon_StellarValue_Ext) *XdrAnon_StellarValue_Ext { return v }

type _XdrVec_6_UpgradeType []UpgradeType

func (_XdrVec_6_UpgradeType) XdrBound() uint32 {
	const bound uint32 = 6 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_6_UpgradeType) XdrCheckLen(length uint32) {
	if length > uint32(6) {
		XdrPanic("_XdrVec_6_UpgradeType length %d exceeds bound 6", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_6_UpgradeType length %d exceeds max int", length)
	}
}
func (v _XdrVec_6_UpgradeType) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_6_UpgradeType) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(6); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]UpgradeType, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_6_UpgradeType) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_UpgradeType(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_6_UpgradeType) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 6}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_6_UpgradeType) XdrTypeName() string              { return "UpgradeType<>" }
func (v *_XdrVec_6_UpgradeType) XdrPointer() interface{}       { return (*[]UpgradeType)(v) }
func (v _XdrVec_6_UpgradeType) XdrValue() interface{}          { return ([]UpgradeType)(v) }
func (v *_XdrVec_6_UpgradeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_StellarValue = *StellarValue

func (v *StellarValue) XdrPointer() interface{}       { return v }
func (StellarValue) XdrTypeName() string              { return "StellarValue" }
func (v StellarValue) XdrValue() interface{}          { return v }
func (v *StellarValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *StellarValue) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxSetHash", name), XDR_Hash(&v.TxSetHash))
	x.Marshal(x.Sprintf("%scloseTime", name), XDR_TimePoint(&v.CloseTime))
	x.Marshal(x.Sprintf("%supgrades", name), (*_XdrVec_6_UpgradeType)(&v.Upgrades))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_StellarValue_Ext(&v.Ext))
}
func XDR_StellarValue(v *StellarValue) *StellarValue { return v }

var _XdrNames_LedgerHeaderFlags = map[int32]string{
	int32(DISABLE_LIQUIDITY_POOL_TRADING_FLAG):    "DISABLE_LIQUIDITY_POOL_TRADING_FLAG",
	int32(DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG):    "DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG",
	int32(DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG): "DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG",
	int32(DISABLE_CONTRACT_CREATE):                "DISABLE_CONTRACT_CREATE",
	int32(DISABLE_CONTRACT_UPDATE):                "DISABLE_CONTRACT_UPDATE",
	int32(DISABLE_CONTRACT_REMOVE):                "DISABLE_CONTRACT_REMOVE",
	int32(DISABLE_CONTRACT_INVOKE):                "DISABLE_CONTRACT_INVOKE",
}
var _XdrValues_LedgerHeaderFlags = map[string]int32{
	"DISABLE_LIQUIDITY_POOL_TRADING_FLAG":    int32(DISABLE_LIQUIDITY_POOL_TRADING_FLAG),
	"DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG":    int32(DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG),
	"DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG": int32(DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG),
	"DISABLE_CONTRACT_CREATE":                int32(DISABLE_CONTRACT_CREATE),
	"DISABLE_CONTRACT_UPDATE":                int32(DISABLE_CONTRACT_UPDATE),
	"DISABLE_CONTRACT_REMOVE":                int32(DISABLE_CONTRACT_REMOVE),
	"DISABLE_CONTRACT_INVOKE":                int32(DISABLE_CONTRACT_INVOKE),
}

func (LedgerHeaderFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerHeaderFlags
}
func (v LedgerHeaderFlags) String() string {
	if s, ok := _XdrNames_LedgerHeaderFlags[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerHeaderFlags#%d", v)
}
func (v *LedgerHeaderFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerHeaderFlags[stok]; ok {
			*v = LedgerHeaderFlags(val)
			return nil
		} else if stok == "LedgerHeaderFlags" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerHeaderFlags.", stok))
	}
}
func (v LedgerHeaderFlags) GetU32() uint32                 { return uint32(v) }
func (v *LedgerHeaderFlags) SetU32(n uint32)               { *v = LedgerHeaderFlags(n) }
func (v *LedgerHeaderFlags) XdrPointer() interface{}       { return v }
func (LedgerHeaderFlags) XdrTypeName() string              { return "LedgerHeaderFlags" }
func (v LedgerHeaderFlags) XdrValue() interface{}          { return v }
func (v *LedgerHeaderFlags) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerHeaderFlags = *LedgerHeaderFlags

func XDR_LedgerHeaderFlags(v *LedgerHeaderFlags) *LedgerHeaderFlags { return v }
func (v *LedgerHeaderFlags) XdrInitialize() {
	switch LedgerHeaderFlags(0) {
	case DISABLE_LIQUIDITY_POOL_TRADING_FLAG, DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG, DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG, DISABLE_CONTRACT_CREATE, DISABLE_CONTRACT_UPDATE, DISABLE_CONTRACT_REMOVE, DISABLE_CONTRACT_INVOKE:
	default:
		if *v == LedgerHeaderFlags(0) {
			*v = DISABLE_LIQUIDITY_POOL_TRADING_FLAG
		}
	}
}

var _XdrTags_XdrAnon_LedgerHeaderExtensionV1_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_LedgerHeaderExtensionV1_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerHeaderExtensionV1_Ext
}
func (u XdrAnon_LedgerHeaderExtensionV1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_LedgerHeaderExtensionV1_Ext = *XdrAnon_LedgerHeaderExtensionV1_Ext

func (v *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerHeaderExtensionV1_Ext) XdrTypeName() string {
	return "XdrAnon_LedgerHeaderExtensionV1_Ext"
}
func (v XdrAnon_LedgerHeaderExtensionV1_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerHeaderExtensionV1_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerHeaderExtensionV1_Ext", u.V)
}
func XDR_XdrAnon_LedgerHeaderExtensionV1_Ext(v *XdrAnon_LedgerHeaderExtensionV1_Ext) *XdrAnon_LedgerHeaderExtensionV1_Ext {
	return v
}

type XdrType_LedgerHeaderExtensionV1 = *LedgerHeaderExtensionV1

func (v *LedgerHeaderExtensionV1) XdrPointer() interface{}       { return v }
func (LedgerHeaderExtensionV1) XdrTypeName() string              { return "LedgerHeaderExtensionV1" }
func (v LedgerHeaderExtensionV1) XdrValue() interface{}          { return v }
func (v *LedgerHeaderExtensionV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeaderExtensionV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sflags", name), XDR_Uint32(&v.Flags))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerHeaderExtensionV1_Ext(&v.Ext))
}
func XDR_LedgerHeaderExtensionV1(v *LedgerHeaderExtensionV1) *LedgerHeaderExtensionV1 { return v }

var _XdrTags_XdrAnon_LedgerHeader_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_LedgerHeader_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerHeader_Ext
}
func (u *XdrAnon_LedgerHeader_Ext) V1() *LedgerHeaderExtensionV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*LedgerHeaderExtensionV1); ok {
			return v
		} else {
			var zero LedgerHeaderExtensionV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_LedgerHeader_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_LedgerHeader_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_LedgerHeaderExtensionV1(u.V1())
	}
	return nil
}
func (u *XdrAnon_LedgerHeader_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_LedgerHeader_Ext = *XdrAnon_LedgerHeader_Ext

func (v *XdrAnon_LedgerHeader_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_LedgerHeader_Ext) XdrTypeName() string              { return "XdrAnon_LedgerHeader_Ext" }
func (v XdrAnon_LedgerHeader_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerHeader_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerHeader_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_LedgerHeaderExtensionV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerHeader_Ext", u.V)
}
func XDR_XdrAnon_LedgerHeader_Ext(v *XdrAnon_LedgerHeader_Ext) *XdrAnon_LedgerHeader_Ext { return v }

type _XdrArray_4_Hash [4]Hash

func (_XdrArray_4_Hash) XdrArraySize() uint32 {
	const bound uint32 = 4 // Force error if not const or doesn't fit
	return bound
}
func (v *_XdrArray_4_Hash) XdrRecurse(x XDR, name string) {
	for i := 0; i < len(*v); i++ {
		XDR_Hash(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
}
func (v *_XdrArray_4_Hash) XdrPointer() interface{}       { return (*[4]Hash)(v) }
func (_XdrArray_4_Hash) XdrTypeName() string              { return "Hash[]" }
func (v *_XdrArray_4_Hash) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_4_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerHeader = *LedgerHeader

func (v *LedgerHeader) XdrPointer() interface{}       { return v }
func (LedgerHeader) XdrTypeName() string              { return "LedgerHeader" }
func (v LedgerHeader) XdrValue() interface{}          { return v }
func (v *LedgerHeader) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeader) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerVersion", name), XDR_Uint32(&v.LedgerVersion))
	x.Marshal(x.Sprintf("%spreviousLedgerHash", name), XDR_Hash(&v.PreviousLedgerHash))
	x.Marshal(x.Sprintf("%sscpValue", name), XDR_StellarValue(&v.ScpValue))
	x.Marshal(x.Sprintf("%stxSetResultHash", name), XDR_Hash(&v.TxSetResultHash))
	x.Marshal(x.Sprintf("%sbucketListHash", name), XDR_Hash(&v.BucketListHash))
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%stotalCoins", name), XDR_Int64(&v.TotalCoins))
	x.Marshal(x.Sprintf("%sfeePool", name), XDR_Int64(&v.FeePool))
	x.Marshal(x.Sprintf("%sinflationSeq", name), XDR_Uint32(&v.InflationSeq))
	x.Marshal(x.Sprintf("%sidPool", name), XDR_Uint64(&v.IdPool))
	x.Marshal(x.Sprintf("%sbaseFee", name), XDR_Uint32(&v.BaseFee))
	x.Marshal(x.Sprintf("%sbaseReserve", name), XDR_Uint32(&v.BaseReserve))
	x.Marshal(x.Sprintf("%smaxTxSetSize", name), XDR_Uint32(&v.MaxTxSetSize))
	x.Marshal(x.Sprintf("%sskipList", name), (*_XdrArray_4_Hash)(&v.SkipList))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerHeader_Ext(&v.Ext))
}
func XDR_LedgerHeader(v *LedgerHeader) *LedgerHeader { return v }

var _XdrNames_LedgerUpgradeType = map[int32]string{
	int32(LEDGER_UPGRADE_VERSION):         "LEDGER_UPGRADE_VERSION",
	int32(LEDGER_UPGRADE_BASE_FEE):        "LEDGER_UPGRADE_BASE_FEE",
	int32(LEDGER_UPGRADE_MAX_TX_SET_SIZE): "LEDGER_UPGRADE_MAX_TX_SET_SIZE",
	int32(LEDGER_UPGRADE_BASE_RESERVE):    "LEDGER_UPGRADE_BASE_RESERVE",
	int32(LEDGER_UPGRADE_FLAGS):           "LEDGER_UPGRADE_FLAGS",
	int32(LEDGER_UPGRADE_CONFIG):          "LEDGER_UPGRADE_CONFIG",
}
var _XdrValues_LedgerUpgradeType = map[string]int32{
	"LEDGER_UPGRADE_VERSION":         int32(LEDGER_UPGRADE_VERSION),
	"LEDGER_UPGRADE_BASE_FEE":        int32(LEDGER_UPGRADE_BASE_FEE),
	"LEDGER_UPGRADE_MAX_TX_SET_SIZE": int32(LEDGER_UPGRADE_MAX_TX_SET_SIZE),
	"LEDGER_UPGRADE_BASE_RESERVE":    int32(LEDGER_UPGRADE_BASE_RESERVE),
	"LEDGER_UPGRADE_FLAGS":           int32(LEDGER_UPGRADE_FLAGS),
	"LEDGER_UPGRADE_CONFIG":          int32(LEDGER_UPGRADE_CONFIG),
}

func (LedgerUpgradeType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerUpgradeType
}
func (v LedgerUpgradeType) String() string {
	if s, ok := _XdrNames_LedgerUpgradeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerUpgradeType#%d", v)
}
func (v *LedgerUpgradeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerUpgradeType[stok]; ok {
			*v = LedgerUpgradeType(val)
			return nil
		} else if stok == "LedgerUpgradeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerUpgradeType.", stok))
	}
}
func (v LedgerUpgradeType) GetU32() uint32                 { return uint32(v) }
func (v *LedgerUpgradeType) SetU32(n uint32)               { *v = LedgerUpgradeType(n) }
func (v *LedgerUpgradeType) XdrPointer() interface{}       { return v }
func (LedgerUpgradeType) XdrTypeName() string              { return "LedgerUpgradeType" }
func (v LedgerUpgradeType) XdrValue() interface{}          { return v }
func (v *LedgerUpgradeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerUpgradeType = *LedgerUpgradeType

func XDR_LedgerUpgradeType(v *LedgerUpgradeType) *LedgerUpgradeType { return v }
func (v *LedgerUpgradeType) XdrInitialize() {
	switch LedgerUpgradeType(0) {
	case LEDGER_UPGRADE_VERSION, LEDGER_UPGRADE_BASE_FEE, LEDGER_UPGRADE_MAX_TX_SET_SIZE, LEDGER_UPGRADE_BASE_RESERVE, LEDGER_UPGRADE_FLAGS, LEDGER_UPGRADE_CONFIG:
	default:
		if *v == LedgerUpgradeType(0) {
			*v = LEDGER_UPGRADE_VERSION
		}
	}
}

type XdrType_XdrAnon_LedgerUpgrade_ConfigSetting = *XdrAnon_LedgerUpgrade_ConfigSetting

func (v *XdrAnon_LedgerUpgrade_ConfigSetting) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerUpgrade_ConfigSetting) XdrTypeName() string {
	return "XdrAnon_LedgerUpgrade_ConfigSetting"
}
func (v XdrAnon_LedgerUpgrade_ConfigSetting) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerUpgrade_ConfigSetting) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_LedgerUpgrade_ConfigSetting) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sid", name), XDR_ConfigSettingID(&v.Id))
	x.Marshal(x.Sprintf("%ssetting", name), XDR_ConfigSetting(&v.Setting))
}
func XDR_XdrAnon_LedgerUpgrade_ConfigSetting(v *XdrAnon_LedgerUpgrade_ConfigSetting) *XdrAnon_LedgerUpgrade_ConfigSetting {
	return v
}

var _XdrTags_LedgerUpgrade = map[int32]bool{
	XdrToI32(LEDGER_UPGRADE_VERSION):         true,
	XdrToI32(LEDGER_UPGRADE_BASE_FEE):        true,
	XdrToI32(LEDGER_UPGRADE_MAX_TX_SET_SIZE): true,
	XdrToI32(LEDGER_UPGRADE_BASE_RESERVE):    true,
	XdrToI32(LEDGER_UPGRADE_FLAGS):           true,
	XdrToI32(LEDGER_UPGRADE_CONFIG):          true,
}

func (_ LedgerUpgrade) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerUpgrade
}

// update ledgerVersion
func (u *LedgerUpgrade) NewLedgerVersion() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewLedgerVersion accessed when Type == %v", u.Type)
		return nil
	}
}

// update baseFee
func (u *LedgerUpgrade) NewBaseFee() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_BASE_FEE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewBaseFee accessed when Type == %v", u.Type)
		return nil
	}
}

// update maxTxSetSize
func (u *LedgerUpgrade) NewMaxTxSetSize() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewMaxTxSetSize accessed when Type == %v", u.Type)
		return nil
	}
}

// update baseReserve
func (u *LedgerUpgrade) NewBaseReserve() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_BASE_RESERVE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewBaseReserve accessed when Type == %v", u.Type)
		return nil
	}
}

// update flags
func (u *LedgerUpgrade) NewFlags() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_FLAGS:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.NewFlags accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerUpgrade) ConfigSetting() *XdrAnon_LedgerUpgrade_ConfigSetting {
	switch u.Type {
	case LEDGER_UPGRADE_CONFIG:
		if v, ok := u._u.(*XdrAnon_LedgerUpgrade_ConfigSetting); ok {
			return v
		} else {
			var zero XdrAnon_LedgerUpgrade_ConfigSetting
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerUpgrade.ConfigSetting accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerUpgrade) XdrValid() bool {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION, LEDGER_UPGRADE_BASE_FEE, LEDGER_UPGRADE_MAX_TX_SET_SIZE, LEDGER_UPGRADE_BASE_RESERVE, LEDGER_UPGRADE_FLAGS, LEDGER_UPGRADE_CONFIG:
		return true
	}
	return false
}
func (u *LedgerUpgrade) XdrUnionTag() XdrNum32 {
	return XDR_LedgerUpgradeType(&u.Type)
}
func (u *LedgerUpgrade) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerUpgrade) XdrUnionBody() XdrType {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		return XDR_Uint32(u.NewLedgerVersion())
	case LEDGER_UPGRADE_BASE_FEE:
		return XDR_Uint32(u.NewBaseFee())
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		return XDR_Uint32(u.NewMaxTxSetSize())
	case LEDGER_UPGRADE_BASE_RESERVE:
		return XDR_Uint32(u.NewBaseReserve())
	case LEDGER_UPGRADE_FLAGS:
		return XDR_Uint32(u.NewFlags())
	case LEDGER_UPGRADE_CONFIG:
		return XDR_XdrAnon_LedgerUpgrade_ConfigSetting(u.ConfigSetting())
	}
	return nil
}
func (u *LedgerUpgrade) XdrUnionBodyName() string {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		return "NewLedgerVersion"
	case LEDGER_UPGRADE_BASE_FEE:
		return "NewBaseFee"
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		return "NewMaxTxSetSize"
	case LEDGER_UPGRADE_BASE_RESERVE:
		return "NewBaseReserve"
	case LEDGER_UPGRADE_FLAGS:
		return "NewFlags"
	case LEDGER_UPGRADE_CONFIG:
		return "ConfigSetting"
	}
	return ""
}

type XdrType_LedgerUpgrade = *LedgerUpgrade

func (v *LedgerUpgrade) XdrPointer() interface{}       { return v }
func (LedgerUpgrade) XdrTypeName() string              { return "LedgerUpgrade" }
func (v LedgerUpgrade) XdrValue() interface{}          { return v }
func (v *LedgerUpgrade) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerUpgrade) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerUpgradeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		x.Marshal(x.Sprintf("%snewLedgerVersion", name), XDR_Uint32(u.NewLedgerVersion()))
		return
	case LEDGER_UPGRADE_BASE_FEE:
		x.Marshal(x.Sprintf("%snewBaseFee", name), XDR_Uint32(u.NewBaseFee()))
		return
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		x.Marshal(x.Sprintf("%snewMaxTxSetSize", name), XDR_Uint32(u.NewMaxTxSetSize()))
		return
	case LEDGER_UPGRADE_BASE_RESERVE:
		x.Marshal(x.Sprintf("%snewBaseReserve", name), XDR_Uint32(u.NewBaseReserve()))
		return
	case LEDGER_UPGRADE_FLAGS:
		x.Marshal(x.Sprintf("%snewFlags", name), XDR_Uint32(u.NewFlags()))
		return
	case LEDGER_UPGRADE_CONFIG:
		x.Marshal(x.Sprintf("%sconfigSetting", name), XDR_XdrAnon_LedgerUpgrade_ConfigSetting(u.ConfigSetting()))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerUpgrade", u.Type)
}
func (v *LedgerUpgrade) XdrInitialize() {
	var zero LedgerUpgradeType
	switch zero {
	case LEDGER_UPGRADE_VERSION, LEDGER_UPGRADE_BASE_FEE, LEDGER_UPGRADE_MAX_TX_SET_SIZE, LEDGER_UPGRADE_BASE_RESERVE, LEDGER_UPGRADE_FLAGS, LEDGER_UPGRADE_CONFIG:
	default:
		if v.Type == zero {
			v.Type = LEDGER_UPGRADE_VERSION
		}
	}
}
func XDR_LedgerUpgrade(v *LedgerUpgrade) *LedgerUpgrade { return v }

var _XdrNames_BucketEntryType = map[int32]string{
	int32(METAENTRY): "METAENTRY",
	int32(LIVEENTRY): "LIVEENTRY",
	int32(DEADENTRY): "DEADENTRY",
	int32(INITENTRY): "INITENTRY",
}
var _XdrValues_BucketEntryType = map[string]int32{
	"METAENTRY": int32(METAENTRY),
	"LIVEENTRY": int32(LIVEENTRY),
	"DEADENTRY": int32(DEADENTRY),
	"INITENTRY": int32(INITENTRY),
}

func (BucketEntryType) XdrEnumNames() map[int32]string {
	return _XdrNames_BucketEntryType
}
func (v BucketEntryType) String() string {
	if s, ok := _XdrNames_BucketEntryType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("BucketEntryType#%d", v)
}
func (v *BucketEntryType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BucketEntryType[stok]; ok {
			*v = BucketEntryType(val)
			return nil
		} else if stok == "BucketEntryType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid BucketEntryType.", stok))
	}
}
func (v BucketEntryType) GetU32() uint32                 { return uint32(v) }
func (v *BucketEntryType) SetU32(n uint32)               { *v = BucketEntryType(n) }
func (v *BucketEntryType) XdrPointer() interface{}       { return v }
func (BucketEntryType) XdrTypeName() string              { return "BucketEntryType" }
func (v BucketEntryType) XdrValue() interface{}          { return v }
func (v *BucketEntryType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_BucketEntryType = *BucketEntryType

func XDR_BucketEntryType(v *BucketEntryType) *BucketEntryType { return v }

var _XdrComments_BucketEntryType = map[int32]string{
	int32(METAENTRY): "At-and-after protocol 11: bucket metadata, should come first.",
	int32(LIVEENTRY): "Before protocol 11: created-or-updated;",
	int32(DEADENTRY): "At-and-after protocol 11: only updated.",
	int32(INITENTRY): "At-and-after protocol 11: only created.",
}

func (e BucketEntryType) XdrEnumComments() map[int32]string {
	return _XdrComments_BucketEntryType
}

var _XdrTags_XdrAnon_BucketMetadata_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_BucketMetadata_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_BucketMetadata_Ext
}
func (u XdrAnon_BucketMetadata_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_BucketMetadata_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_BucketMetadata_Ext = *XdrAnon_BucketMetadata_Ext

func (v *XdrAnon_BucketMetadata_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_BucketMetadata_Ext) XdrTypeName() string              { return "XdrAnon_BucketMetadata_Ext" }
func (v XdrAnon_BucketMetadata_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_BucketMetadata_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_BucketMetadata_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_BucketMetadata_Ext", u.V)
}
func XDR_XdrAnon_BucketMetadata_Ext(v *XdrAnon_BucketMetadata_Ext) *XdrAnon_BucketMetadata_Ext {
	return v
}

type XdrType_BucketMetadata = *BucketMetadata

func (v *BucketMetadata) XdrPointer() interface{}       { return v }
func (BucketMetadata) XdrTypeName() string              { return "BucketMetadata" }
func (v BucketMetadata) XdrValue() interface{}          { return v }
func (v *BucketMetadata) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BucketMetadata) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerVersion", name), XDR_Uint32(&v.LedgerVersion))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_BucketMetadata_Ext(&v.Ext))
}
func XDR_BucketMetadata(v *BucketMetadata) *BucketMetadata { return v }

var _XdrTags_BucketEntry = map[int32]bool{
	XdrToI32(LIVEENTRY): true,
	XdrToI32(INITENTRY): true,
	XdrToI32(DEADENTRY): true,
	XdrToI32(METAENTRY): true,
}

func (_ BucketEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_BucketEntry
}
func (u *BucketEntry) LiveEntry() *LedgerEntry {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.LiveEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *BucketEntry) DeadEntry() *LedgerKey {
	switch u.Type {
	case DEADENTRY:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.DeadEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *BucketEntry) MetaEntry() *BucketMetadata {
	switch u.Type {
	case METAENTRY:
		if v, ok := u._u.(*BucketMetadata); ok {
			return v
		} else {
			var zero BucketMetadata
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("BucketEntry.MetaEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u BucketEntry) XdrValid() bool {
	switch u.Type {
	case LIVEENTRY, INITENTRY, DEADENTRY, METAENTRY:
		return true
	}
	return false
}
func (u *BucketEntry) XdrUnionTag() XdrNum32 {
	return XDR_BucketEntryType(&u.Type)
}
func (u *BucketEntry) XdrUnionTagName() string {
	return "Type"
}
func (u *BucketEntry) XdrUnionBody() XdrType {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		return XDR_LedgerEntry(u.LiveEntry())
	case DEADENTRY:
		return XDR_LedgerKey(u.DeadEntry())
	case METAENTRY:
		return XDR_BucketMetadata(u.MetaEntry())
	}
	return nil
}
func (u *BucketEntry) XdrUnionBodyName() string {
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		return "LiveEntry"
	case DEADENTRY:
		return "DeadEntry"
	case METAENTRY:
		return "MetaEntry"
	}
	return ""
}

type XdrType_BucketEntry = *BucketEntry

func (v *BucketEntry) XdrPointer() interface{}       { return v }
func (BucketEntry) XdrTypeName() string              { return "BucketEntry" }
func (v BucketEntry) XdrValue() interface{}          { return v }
func (v *BucketEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *BucketEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BucketEntryType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LIVEENTRY, INITENTRY:
		x.Marshal(x.Sprintf("%sliveEntry", name), XDR_LedgerEntry(u.LiveEntry()))
		return
	case DEADENTRY:
		x.Marshal(x.Sprintf("%sdeadEntry", name), XDR_LedgerKey(u.DeadEntry()))
		return
	case METAENTRY:
		x.Marshal(x.Sprintf("%smetaEntry", name), XDR_BucketMetadata(u.MetaEntry()))
		return
	}
	XdrPanic("invalid Type (%v) in BucketEntry", u.Type)
}
func XDR_BucketEntry(v *BucketEntry) *BucketEntry { return v }

var _XdrNames_TxSetComponentType = map[int32]string{
	int32(TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE): "TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE",
}
var _XdrValues_TxSetComponentType = map[string]int32{
	"TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE": int32(TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE),
}

func (TxSetComponentType) XdrEnumNames() map[int32]string {
	return _XdrNames_TxSetComponentType
}
func (v TxSetComponentType) String() string {
	if s, ok := _XdrNames_TxSetComponentType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("TxSetComponentType#%d", v)
}
func (v *TxSetComponentType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TxSetComponentType[stok]; ok {
			*v = TxSetComponentType(val)
			return nil
		} else if stok == "TxSetComponentType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid TxSetComponentType.", stok))
	}
}
func (v TxSetComponentType) GetU32() uint32                 { return uint32(v) }
func (v *TxSetComponentType) SetU32(n uint32)               { *v = TxSetComponentType(n) }
func (v *TxSetComponentType) XdrPointer() interface{}       { return v }
func (TxSetComponentType) XdrTypeName() string              { return "TxSetComponentType" }
func (v TxSetComponentType) XdrValue() interface{}          { return v }
func (v *TxSetComponentType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TxSetComponentType = *TxSetComponentType

func XDR_TxSetComponentType(v *TxSetComponentType) *TxSetComponentType { return v }

var _XdrComments_TxSetComponentType = map[int32]string{
	int32(TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE): "txs with effective fee <= bid derived from a base fee (if any). If base fee is not specified, no discount is applied.",
}

func (e TxSetComponentType) XdrEnumComments() map[int32]string {
	return _XdrComments_TxSetComponentType
}

type _XdrPtr_Int64 struct {
	p **Int64
}
type _ptrflag_Int64 _XdrPtr_Int64

func (v _ptrflag_Int64) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Int64) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Int64 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Int64) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Int64) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Int64)
		}
	default:
		XdrPanic("*Int64 present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Int64) XdrTypeName() string             { return "Int64?" }
func (v _ptrflag_Int64) XdrPointer() interface{}       { return nil }
func (v _ptrflag_Int64) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_Int64) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Int64) XdrBound() uint32              { return 1 }
func (v _XdrPtr_Int64) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_Int64) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Int64)
	}
}
func (v _XdrPtr_Int64) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Int64(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Int64) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Int64) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Int64(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Int64) XdrTypeName() string       { return "Int64*" }
func (v _XdrPtr_Int64) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Int64) XdrValue() interface{}   { return *v.p }

type _XdrVec_unbounded_TransactionEnvelope []TransactionEnvelope

func (_XdrVec_unbounded_TransactionEnvelope) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionEnvelope) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionEnvelope length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionEnvelope length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionEnvelope) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionEnvelope) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionEnvelope, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionEnvelope(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionEnvelope) XdrTypeName() string { return "TransactionEnvelope<>" }
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrPointer() interface{} {
	return (*[]TransactionEnvelope)(v)
}
func (v _XdrVec_unbounded_TransactionEnvelope) XdrValue() interface{} {
	return ([]TransactionEnvelope)(v)
}
func (v *_XdrVec_unbounded_TransactionEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_XdrAnon_TxSetComponent_TxsMaybeDiscountedFee = *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee

func (v *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrPointer() interface{} { return v }
func (XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrTypeName() string {
	return "XdrAnon_TxSetComponent_TxsMaybeDiscountedFee"
}
func (v XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrValue() interface{} { return v }
func (v *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbaseFee", name), _XdrPtr_Int64{&v.BaseFee})
	x.Marshal(x.Sprintf("%stxs", name), (*_XdrVec_unbounded_TransactionEnvelope)(&v.Txs))
}
func XDR_XdrAnon_TxSetComponent_TxsMaybeDiscountedFee(v *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee) *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee {
	return v
}

var _XdrTags_TxSetComponent = map[int32]bool{
	XdrToI32(TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE): true,
}

func (_ TxSetComponent) XdrValidTags() map[int32]bool {
	return _XdrTags_TxSetComponent
}
func (u *TxSetComponent) TxsMaybeDiscountedFee() *XdrAnon_TxSetComponent_TxsMaybeDiscountedFee {
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		if v, ok := u._u.(*XdrAnon_TxSetComponent_TxsMaybeDiscountedFee); ok {
			return v
		} else {
			var zero XdrAnon_TxSetComponent_TxsMaybeDiscountedFee
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TxSetComponent.TxsMaybeDiscountedFee accessed when Type == %v", u.Type)
		return nil
	}
}
func (u TxSetComponent) XdrValid() bool {
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		return true
	}
	return false
}
func (u *TxSetComponent) XdrUnionTag() XdrNum32 {
	return XDR_TxSetComponentType(&u.Type)
}
func (u *TxSetComponent) XdrUnionTagName() string {
	return "Type"
}
func (u *TxSetComponent) XdrUnionBody() XdrType {
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		return XDR_XdrAnon_TxSetComponent_TxsMaybeDiscountedFee(u.TxsMaybeDiscountedFee())
	}
	return nil
}
func (u *TxSetComponent) XdrUnionBodyName() string {
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		return "TxsMaybeDiscountedFee"
	}
	return ""
}

type XdrType_TxSetComponent = *TxSetComponent

func (v *TxSetComponent) XdrPointer() interface{}       { return v }
func (TxSetComponent) XdrTypeName() string              { return "TxSetComponent" }
func (v TxSetComponent) XdrValue() interface{}          { return v }
func (v *TxSetComponent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TxSetComponent) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TxSetComponentType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
		x.Marshal(x.Sprintf("%stxsMaybeDiscountedFee", name), XDR_XdrAnon_TxSetComponent_TxsMaybeDiscountedFee(u.TxsMaybeDiscountedFee()))
		return
	}
	XdrPanic("invalid Type (%v) in TxSetComponent", u.Type)
}
func XDR_TxSetComponent(v *TxSetComponent) *TxSetComponent { return v }

type _XdrVec_unbounded_TxSetComponent []TxSetComponent

func (_XdrVec_unbounded_TxSetComponent) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TxSetComponent) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TxSetComponent length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TxSetComponent length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TxSetComponent) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TxSetComponent) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TxSetComponent, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TxSetComponent) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TxSetComponent(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TxSetComponent) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TxSetComponent) XdrTypeName() string              { return "TxSetComponent<>" }
func (v *_XdrVec_unbounded_TxSetComponent) XdrPointer() interface{}       { return (*[]TxSetComponent)(v) }
func (v _XdrVec_unbounded_TxSetComponent) XdrValue() interface{}          { return ([]TxSetComponent)(v) }
func (v *_XdrVec_unbounded_TxSetComponent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_TransactionPhase = map[int32]bool{
	XdrToI32(0): true,
}

func (_ TransactionPhase) XdrValidTags() map[int32]bool {
	return _XdrTags_TransactionPhase
}
func (u *TransactionPhase) V0Components() *[]TxSetComponent {
	switch u.V {
	case 0:
		if v, ok := u._u.(*[]TxSetComponent); ok {
			return v
		} else {
			var zero []TxSetComponent
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionPhase.V0Components accessed when V == %v", u.V)
		return nil
	}
}
func (u TransactionPhase) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *TransactionPhase) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *TransactionPhase) XdrUnionTagName() string {
	return "V"
}
func (u *TransactionPhase) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return (*_XdrVec_unbounded_TxSetComponent)(u.V0Components())
	}
	return nil
}
func (u *TransactionPhase) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0Components"
	}
	return ""
}

type XdrType_TransactionPhase = *TransactionPhase

func (v *TransactionPhase) XdrPointer() interface{}       { return v }
func (TransactionPhase) XdrTypeName() string              { return "TransactionPhase" }
func (v TransactionPhase) XdrValue() interface{}          { return v }
func (v *TransactionPhase) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TransactionPhase) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0Components", name), (*_XdrVec_unbounded_TxSetComponent)(u.V0Components()))
		return
	}
	XdrPanic("invalid V (%v) in TransactionPhase", u.V)
}
func XDR_TransactionPhase(v *TransactionPhase) *TransactionPhase { return v }

type XdrType_TransactionSet = *TransactionSet

func (v *TransactionSet) XdrPointer() interface{}       { return v }
func (TransactionSet) XdrTypeName() string              { return "TransactionSet" }
func (v TransactionSet) XdrValue() interface{}          { return v }
func (v *TransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%spreviousLedgerHash", name), XDR_Hash(&v.PreviousLedgerHash))
	x.Marshal(x.Sprintf("%stxs", name), (*_XdrVec_unbounded_TransactionEnvelope)(&v.Txs))
}
func XDR_TransactionSet(v *TransactionSet) *TransactionSet { return v }

type _XdrVec_unbounded_TransactionPhase []TransactionPhase

func (_XdrVec_unbounded_TransactionPhase) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionPhase) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionPhase length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionPhase length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionPhase) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionPhase) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionPhase, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionPhase) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionPhase(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionPhase) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionPhase) XdrTypeName() string { return "TransactionPhase<>" }
func (v *_XdrVec_unbounded_TransactionPhase) XdrPointer() interface{} {
	return (*[]TransactionPhase)(v)
}
func (v _XdrVec_unbounded_TransactionPhase) XdrValue() interface{}          { return ([]TransactionPhase)(v) }
func (v *_XdrVec_unbounded_TransactionPhase) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionSetV1 = *TransactionSetV1

func (v *TransactionSetV1) XdrPointer() interface{}       { return v }
func (TransactionSetV1) XdrTypeName() string              { return "TransactionSetV1" }
func (v TransactionSetV1) XdrValue() interface{}          { return v }
func (v *TransactionSetV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSetV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%spreviousLedgerHash", name), XDR_Hash(&v.PreviousLedgerHash))
	x.Marshal(x.Sprintf("%sphases", name), (*_XdrVec_unbounded_TransactionPhase)(&v.Phases))
}
func XDR_TransactionSetV1(v *TransactionSetV1) *TransactionSetV1 { return v }

var _XdrTags_GeneralizedTransactionSet = map[int32]bool{
	XdrToI32(1): true,
}

func (_ GeneralizedTransactionSet) XdrValidTags() map[int32]bool {
	return _XdrTags_GeneralizedTransactionSet
}
func (u *GeneralizedTransactionSet) V1TxSet() *TransactionSetV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*TransactionSetV1); ok {
			return v
		} else {
			var zero TransactionSetV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("GeneralizedTransactionSet.V1TxSet accessed when V == %v", u.V)
		return nil
	}
}
func (u GeneralizedTransactionSet) XdrValid() bool {
	switch u.V {
	case 1:
		return true
	}
	return false
}
func (u *GeneralizedTransactionSet) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *GeneralizedTransactionSet) XdrUnionTagName() string {
	return "V"
}
func (u *GeneralizedTransactionSet) XdrUnionBody() XdrType {
	switch u.V {
	case 1:
		return XDR_TransactionSetV1(u.V1TxSet())
	}
	return nil
}
func (u *GeneralizedTransactionSet) XdrUnionBodyName() string {
	switch u.V {
	case 1:
		return "V1TxSet"
	}
	return ""
}

type XdrType_GeneralizedTransactionSet = *GeneralizedTransactionSet

func (v *GeneralizedTransactionSet) XdrPointer() interface{}       { return v }
func (GeneralizedTransactionSet) XdrTypeName() string              { return "GeneralizedTransactionSet" }
func (v GeneralizedTransactionSet) XdrValue() interface{}          { return v }
func (v *GeneralizedTransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *GeneralizedTransactionSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 1:
		x.Marshal(x.Sprintf("%sv1TxSet", name), XDR_TransactionSetV1(u.V1TxSet()))
		return
	}
	XdrPanic("invalid V (%v) in GeneralizedTransactionSet", u.V)
}
func (v *GeneralizedTransactionSet) XdrInitialize() {
	var zero int32
	switch zero {
	case 1:
	default:
		if v.V == zero {
			v.V = 1
		}
	}
}
func XDR_GeneralizedTransactionSet(v *GeneralizedTransactionSet) *GeneralizedTransactionSet { return v }

type XdrType_TransactionResultPair = *TransactionResultPair

func (v *TransactionResultPair) XdrPointer() interface{}       { return v }
func (TransactionResultPair) XdrTypeName() string              { return "TransactionResultPair" }
func (v TransactionResultPair) XdrValue() interface{}          { return v }
func (v *TransactionResultPair) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultPair) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stransactionHash", name), XDR_Hash(&v.TransactionHash))
	x.Marshal(x.Sprintf("%sresult", name), XDR_TransactionResult(&v.Result))
}
func XDR_TransactionResultPair(v *TransactionResultPair) *TransactionResultPair { return v }

type _XdrVec_unbounded_TransactionResultPair []TransactionResultPair

func (_XdrVec_unbounded_TransactionResultPair) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionResultPair) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionResultPair length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionResultPair length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionResultPair) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionResultPair) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionResultPair, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionResultPair(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionResultPair) XdrTypeName() string { return "TransactionResultPair<>" }
func (v *_XdrVec_unbounded_TransactionResultPair) XdrPointer() interface{} {
	return (*[]TransactionResultPair)(v)
}
func (v _XdrVec_unbounded_TransactionResultPair) XdrValue() interface{} {
	return ([]TransactionResultPair)(v)
}
func (v *_XdrVec_unbounded_TransactionResultPair) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionResultSet = *TransactionResultSet

func (v *TransactionResultSet) XdrPointer() interface{}       { return v }
func (TransactionResultSet) XdrTypeName() string              { return "TransactionResultSet" }
func (v TransactionResultSet) XdrValue() interface{}          { return v }
func (v *TransactionResultSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_TransactionResultPair)(&v.Results))
}
func XDR_TransactionResultSet(v *TransactionResultSet) *TransactionResultSet { return v }

var _XdrTags_XdrAnon_TransactionHistoryEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ XdrAnon_TransactionHistoryEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionHistoryEntry_Ext
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) GeneralizedTxSet() *GeneralizedTransactionSet {
	switch u.V {
	case 1:
		if v, ok := u._u.(*GeneralizedTransactionSet); ok {
			return v
		} else {
			var zero GeneralizedTransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionHistoryEntry_Ext.GeneralizedTxSet accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_TransactionHistoryEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	case 1:
		return XDR_GeneralizedTransactionSet(u.GeneralizedTxSet())
	}
	return nil
}
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "GeneralizedTxSet"
	}
	return ""
}

type XdrType_XdrAnon_TransactionHistoryEntry_Ext = *XdrAnon_TransactionHistoryEntry_Ext

func (v *XdrAnon_TransactionHistoryEntry_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionHistoryEntry_Ext) XdrTypeName() string {
	return "XdrAnon_TransactionHistoryEntry_Ext"
}
func (v XdrAnon_TransactionHistoryEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TransactionHistoryEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionHistoryEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	case 1:
		x.Marshal(x.Sprintf("%sgeneralizedTxSet", name), XDR_GeneralizedTransactionSet(u.GeneralizedTxSet()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionHistoryEntry_Ext", u.V)
}
func XDR_XdrAnon_TransactionHistoryEntry_Ext(v *XdrAnon_TransactionHistoryEntry_Ext) *XdrAnon_TransactionHistoryEntry_Ext {
	return v
}

type XdrType_TransactionHistoryEntry = *TransactionHistoryEntry

func (v *TransactionHistoryEntry) XdrPointer() interface{}       { return v }
func (TransactionHistoryEntry) XdrTypeName() string              { return "TransactionHistoryEntry" }
func (v TransactionHistoryEntry) XdrValue() interface{}          { return v }
func (v *TransactionHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%stxSet", name), XDR_TransactionSet(&v.TxSet))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionHistoryEntry_Ext(&v.Ext))
}
func XDR_TransactionHistoryEntry(v *TransactionHistoryEntry) *TransactionHistoryEntry { return v }

var _XdrTags_XdrAnon_TransactionHistoryResultEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TransactionHistoryResultEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionHistoryResultEntry_Ext
}
func (u XdrAnon_TransactionHistoryResultEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionHistoryResultEntry_Ext = *XdrAnon_TransactionHistoryResultEntry_Ext

func (v *XdrAnon_TransactionHistoryResultEntry_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionHistoryResultEntry_Ext) XdrTypeName() string {
	return "XdrAnon_TransactionHistoryResultEntry_Ext"
}
func (v XdrAnon_TransactionHistoryResultEntry_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionHistoryResultEntry_Ext) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (u *XdrAnon_TransactionHistoryResultEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionHistoryResultEntry_Ext", u.V)
}
func XDR_XdrAnon_TransactionHistoryResultEntry_Ext(v *XdrAnon_TransactionHistoryResultEntry_Ext) *XdrAnon_TransactionHistoryResultEntry_Ext {
	return v
}

type XdrType_TransactionHistoryResultEntry = *TransactionHistoryResultEntry

func (v *TransactionHistoryResultEntry) XdrPointer() interface{}       { return v }
func (TransactionHistoryResultEntry) XdrTypeName() string              { return "TransactionHistoryResultEntry" }
func (v TransactionHistoryResultEntry) XdrValue() interface{}          { return v }
func (v *TransactionHistoryResultEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionHistoryResultEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%stxResultSet", name), XDR_TransactionResultSet(&v.TxResultSet))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionHistoryResultEntry_Ext(&v.Ext))
}
func XDR_TransactionHistoryResultEntry(v *TransactionHistoryResultEntry) *TransactionHistoryResultEntry {
	return v
}

type XdrType_TransactionResultPairV2 = *TransactionResultPairV2

func (v *TransactionResultPairV2) XdrPointer() interface{}       { return v }
func (TransactionResultPairV2) XdrTypeName() string              { return "TransactionResultPairV2" }
func (v TransactionResultPairV2) XdrValue() interface{}          { return v }
func (v *TransactionResultPairV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultPairV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stransactionHash", name), XDR_Hash(&v.TransactionHash))
	x.Marshal(x.Sprintf("%shashOfMetaHashes", name), XDR_Hash(&v.HashOfMetaHashes))
}
func XDR_TransactionResultPairV2(v *TransactionResultPairV2) *TransactionResultPairV2 { return v }

type _XdrVec_unbounded_TransactionResultPairV2 []TransactionResultPairV2

func (_XdrVec_unbounded_TransactionResultPairV2) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionResultPairV2) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionResultPairV2 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionResultPairV2 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionResultPairV2) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionResultPairV2) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionResultPairV2, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionResultPairV2) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionResultPairV2(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionResultPairV2) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionResultPairV2) XdrTypeName() string {
	return "TransactionResultPairV2<>"
}
func (v *_XdrVec_unbounded_TransactionResultPairV2) XdrPointer() interface{} {
	return (*[]TransactionResultPairV2)(v)
}
func (v _XdrVec_unbounded_TransactionResultPairV2) XdrValue() interface{} {
	return ([]TransactionResultPairV2)(v)
}
func (v *_XdrVec_unbounded_TransactionResultPairV2) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}

type XdrType_TransactionResultSetV2 = *TransactionResultSetV2

func (v *TransactionResultSetV2) XdrPointer() interface{}       { return v }
func (TransactionResultSetV2) XdrTypeName() string              { return "TransactionResultSetV2" }
func (v TransactionResultSetV2) XdrValue() interface{}          { return v }
func (v *TransactionResultSetV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultSetV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_TransactionResultPairV2)(&v.Results))
}
func XDR_TransactionResultSetV2(v *TransactionResultSetV2) *TransactionResultSetV2 { return v }

var _XdrTags_XdrAnon_TransactionHistoryResultEntryV2_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionHistoryResultEntryV2_Ext
}
func (u XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionHistoryResultEntryV2_Ext = *XdrAnon_TransactionHistoryResultEntryV2_Ext

func (v *XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrTypeName() string {
	return "XdrAnon_TransactionHistoryResultEntryV2_Ext"
}
func (v XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (u *XdrAnon_TransactionHistoryResultEntryV2_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionHistoryResultEntryV2_Ext", u.V)
}
func XDR_XdrAnon_TransactionHistoryResultEntryV2_Ext(v *XdrAnon_TransactionHistoryResultEntryV2_Ext) *XdrAnon_TransactionHistoryResultEntryV2_Ext {
	return v
}

type XdrType_TransactionHistoryResultEntryV2 = *TransactionHistoryResultEntryV2

func (v *TransactionHistoryResultEntryV2) XdrPointer() interface{}       { return v }
func (TransactionHistoryResultEntryV2) XdrTypeName() string              { return "TransactionHistoryResultEntryV2" }
func (v TransactionHistoryResultEntryV2) XdrValue() interface{}          { return v }
func (v *TransactionHistoryResultEntryV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionHistoryResultEntryV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%stxResultSet", name), XDR_TransactionResultSetV2(&v.TxResultSet))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionHistoryResultEntryV2_Ext(&v.Ext))
}
func XDR_TransactionHistoryResultEntryV2(v *TransactionHistoryResultEntryV2) *TransactionHistoryResultEntryV2 {
	return v
}

var _XdrTags_XdrAnon_LedgerHeaderHistoryEntry_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_LedgerHeaderHistoryEntry_Ext
}
func (u XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_LedgerHeaderHistoryEntry_Ext = *XdrAnon_LedgerHeaderHistoryEntry_Ext

func (v *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrTypeName() string {
	return "XdrAnon_LedgerHeaderHistoryEntry_Ext"
}
func (v XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_LedgerHeaderHistoryEntry_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_LedgerHeaderHistoryEntry_Ext", u.V)
}
func XDR_XdrAnon_LedgerHeaderHistoryEntry_Ext(v *XdrAnon_LedgerHeaderHistoryEntry_Ext) *XdrAnon_LedgerHeaderHistoryEntry_Ext {
	return v
}

type XdrType_LedgerHeaderHistoryEntry = *LedgerHeaderHistoryEntry

func (v *LedgerHeaderHistoryEntry) XdrPointer() interface{}       { return v }
func (LedgerHeaderHistoryEntry) XdrTypeName() string              { return "LedgerHeaderHistoryEntry" }
func (v LedgerHeaderHistoryEntry) XdrValue() interface{}          { return v }
func (v *LedgerHeaderHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerHeaderHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shash", name), XDR_Hash(&v.Hash))
	x.Marshal(x.Sprintf("%sheader", name), XDR_LedgerHeader(&v.Header))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_LedgerHeaderHistoryEntry_Ext(&v.Ext))
}
func XDR_LedgerHeaderHistoryEntry(v *LedgerHeaderHistoryEntry) *LedgerHeaderHistoryEntry { return v }

type _XdrVec_unbounded_SCPEnvelope []SCPEnvelope

func (_XdrVec_unbounded_SCPEnvelope) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCPEnvelope) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCPEnvelope length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCPEnvelope length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCPEnvelope) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCPEnvelope) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPEnvelope, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCPEnvelope) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCPEnvelope(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCPEnvelope) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SCPEnvelope) XdrTypeName() string              { return "SCPEnvelope<>" }
func (v *_XdrVec_unbounded_SCPEnvelope) XdrPointer() interface{}       { return (*[]SCPEnvelope)(v) }
func (v _XdrVec_unbounded_SCPEnvelope) XdrValue() interface{}          { return ([]SCPEnvelope)(v) }
func (v *_XdrVec_unbounded_SCPEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerSCPMessages = *LedgerSCPMessages

func (v *LedgerSCPMessages) XdrPointer() interface{}       { return v }
func (LedgerSCPMessages) XdrTypeName() string              { return "LedgerSCPMessages" }
func (v LedgerSCPMessages) XdrValue() interface{}          { return v }
func (v *LedgerSCPMessages) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerSCPMessages) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerSeq", name), XDR_Uint32(&v.LedgerSeq))
	x.Marshal(x.Sprintf("%smessages", name), (*_XdrVec_unbounded_SCPEnvelope)(&v.Messages))
}
func XDR_LedgerSCPMessages(v *LedgerSCPMessages) *LedgerSCPMessages { return v }

type XdrType_SCPHistoryEntryV0 = *SCPHistoryEntryV0

func (v *SCPHistoryEntryV0) XdrPointer() interface{}       { return v }
func (SCPHistoryEntryV0) XdrTypeName() string              { return "SCPHistoryEntryV0" }
func (v SCPHistoryEntryV0) XdrValue() interface{}          { return v }
func (v *SCPHistoryEntryV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCPHistoryEntryV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%squorumSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.QuorumSets))
	x.Marshal(x.Sprintf("%sledgerMessages", name), XDR_LedgerSCPMessages(&v.LedgerMessages))
}
func XDR_SCPHistoryEntryV0(v *SCPHistoryEntryV0) *SCPHistoryEntryV0 { return v }

var _XdrTags_SCPHistoryEntry = map[int32]bool{
	XdrToI32(0): true,
}

func (_ SCPHistoryEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_SCPHistoryEntry
}
func (u *SCPHistoryEntry) V0() *SCPHistoryEntryV0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*SCPHistoryEntryV0); ok {
			return v
		} else {
			var zero SCPHistoryEntryV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCPHistoryEntry.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u SCPHistoryEntry) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *SCPHistoryEntry) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *SCPHistoryEntry) XdrUnionTagName() string {
	return "V"
}
func (u *SCPHistoryEntry) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_SCPHistoryEntryV0(u.V0())
	}
	return nil
}
func (u *SCPHistoryEntry) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}

type XdrType_SCPHistoryEntry = *SCPHistoryEntry

func (v *SCPHistoryEntry) XdrPointer() interface{}       { return v }
func (SCPHistoryEntry) XdrTypeName() string              { return "SCPHistoryEntry" }
func (v SCPHistoryEntry) XdrValue() interface{}          { return v }
func (v *SCPHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCPHistoryEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_SCPHistoryEntryV0(u.V0()))
		return
	}
	XdrPanic("invalid V (%v) in SCPHistoryEntry", u.V)
}
func XDR_SCPHistoryEntry(v *SCPHistoryEntry) *SCPHistoryEntry { return v }

var _XdrNames_LedgerEntryChangeType = map[int32]string{
	int32(LEDGER_ENTRY_CREATED): "LEDGER_ENTRY_CREATED",
	int32(LEDGER_ENTRY_UPDATED): "LEDGER_ENTRY_UPDATED",
	int32(LEDGER_ENTRY_REMOVED): "LEDGER_ENTRY_REMOVED",
	int32(LEDGER_ENTRY_STATE):   "LEDGER_ENTRY_STATE",
}
var _XdrValues_LedgerEntryChangeType = map[string]int32{
	"LEDGER_ENTRY_CREATED": int32(LEDGER_ENTRY_CREATED),
	"LEDGER_ENTRY_UPDATED": int32(LEDGER_ENTRY_UPDATED),
	"LEDGER_ENTRY_REMOVED": int32(LEDGER_ENTRY_REMOVED),
	"LEDGER_ENTRY_STATE":   int32(LEDGER_ENTRY_STATE),
}

func (LedgerEntryChangeType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerEntryChangeType
}
func (v LedgerEntryChangeType) String() string {
	if s, ok := _XdrNames_LedgerEntryChangeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerEntryChangeType#%d", v)
}
func (v *LedgerEntryChangeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerEntryChangeType[stok]; ok {
			*v = LedgerEntryChangeType(val)
			return nil
		} else if stok == "LedgerEntryChangeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerEntryChangeType.", stok))
	}
}
func (v LedgerEntryChangeType) GetU32() uint32                 { return uint32(v) }
func (v *LedgerEntryChangeType) SetU32(n uint32)               { *v = LedgerEntryChangeType(n) }
func (v *LedgerEntryChangeType) XdrPointer() interface{}       { return v }
func (LedgerEntryChangeType) XdrTypeName() string              { return "LedgerEntryChangeType" }
func (v LedgerEntryChangeType) XdrValue() interface{}          { return v }
func (v *LedgerEntryChangeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerEntryChangeType = *LedgerEntryChangeType

func XDR_LedgerEntryChangeType(v *LedgerEntryChangeType) *LedgerEntryChangeType { return v }

var _XdrComments_LedgerEntryChangeType = map[int32]string{
	int32(LEDGER_ENTRY_CREATED): "entry was added to the ledger",
	int32(LEDGER_ENTRY_UPDATED): "entry was modified in the ledger",
	int32(LEDGER_ENTRY_REMOVED): "entry was removed from the ledger",
	int32(LEDGER_ENTRY_STATE):   "value of the entry",
}

func (e LedgerEntryChangeType) XdrEnumComments() map[int32]string {
	return _XdrComments_LedgerEntryChangeType
}

var _XdrTags_LedgerEntryChange = map[int32]bool{
	XdrToI32(LEDGER_ENTRY_CREATED): true,
	XdrToI32(LEDGER_ENTRY_UPDATED): true,
	XdrToI32(LEDGER_ENTRY_REMOVED): true,
	XdrToI32(LEDGER_ENTRY_STATE):   true,
}

func (_ LedgerEntryChange) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerEntryChange
}
func (u *LedgerEntryChange) Created() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Created accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) Updated() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_UPDATED:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Updated accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) Removed() *LedgerKey {
	switch u.Type {
	case LEDGER_ENTRY_REMOVED:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.Removed accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) State() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_STATE:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerEntryChange.State accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LedgerEntryChange) XdrValid() bool {
	switch u.Type {
	case LEDGER_ENTRY_CREATED, LEDGER_ENTRY_UPDATED, LEDGER_ENTRY_REMOVED, LEDGER_ENTRY_STATE:
		return true
	}
	return false
}
func (u *LedgerEntryChange) XdrUnionTag() XdrNum32 {
	return XDR_LedgerEntryChangeType(&u.Type)
}
func (u *LedgerEntryChange) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerEntryChange) XdrUnionBody() XdrType {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		return XDR_LedgerEntry(u.Created())
	case LEDGER_ENTRY_UPDATED:
		return XDR_LedgerEntry(u.Updated())
	case LEDGER_ENTRY_REMOVED:
		return XDR_LedgerKey(u.Removed())
	case LEDGER_ENTRY_STATE:
		return XDR_LedgerEntry(u.State())
	}
	return nil
}
func (u *LedgerEntryChange) XdrUnionBodyName() string {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		return "Created"
	case LEDGER_ENTRY_UPDATED:
		return "Updated"
	case LEDGER_ENTRY_REMOVED:
		return "Removed"
	case LEDGER_ENTRY_STATE:
		return "State"
	}
	return ""
}

type XdrType_LedgerEntryChange = *LedgerEntryChange

func (v *LedgerEntryChange) XdrPointer() interface{}       { return v }
func (LedgerEntryChange) XdrTypeName() string              { return "LedgerEntryChange" }
func (v LedgerEntryChange) XdrValue() interface{}          { return v }
func (v *LedgerEntryChange) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerEntryChange) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChangeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		x.Marshal(x.Sprintf("%screated", name), XDR_LedgerEntry(u.Created()))
		return
	case LEDGER_ENTRY_UPDATED:
		x.Marshal(x.Sprintf("%supdated", name), XDR_LedgerEntry(u.Updated()))
		return
	case LEDGER_ENTRY_REMOVED:
		x.Marshal(x.Sprintf("%sremoved", name), XDR_LedgerKey(u.Removed()))
		return
	case LEDGER_ENTRY_STATE:
		x.Marshal(x.Sprintf("%sstate", name), XDR_LedgerEntry(u.State()))
		return
	}
	XdrPanic("invalid Type (%v) in LedgerEntryChange", u.Type)
}
func XDR_LedgerEntryChange(v *LedgerEntryChange) *LedgerEntryChange { return v }

type _XdrVec_unbounded_LedgerEntryChange []LedgerEntryChange

func (_XdrVec_unbounded_LedgerEntryChange) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_LedgerEntryChange) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_LedgerEntryChange length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_LedgerEntryChange length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_LedgerEntryChange) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_LedgerEntryChange) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]LedgerEntryChange, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_LedgerEntryChange(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_LedgerEntryChange) XdrTypeName() string { return "LedgerEntryChange<>" }
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrPointer() interface{} {
	return (*[]LedgerEntryChange)(v)
}
func (v _XdrVec_unbounded_LedgerEntryChange) XdrValue() interface{}          { return ([]LedgerEntryChange)(v) }
func (v *_XdrVec_unbounded_LedgerEntryChange) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerEntryChanges struct {
	*_XdrVec_unbounded_LedgerEntryChange
}

func XDR_LedgerEntryChanges(v *LedgerEntryChanges) XdrType_LedgerEntryChanges {
	return XdrType_LedgerEntryChanges{(*_XdrVec_unbounded_LedgerEntryChange)(v)}
}
func (XdrType_LedgerEntryChanges) XdrTypeName() string  { return "LedgerEntryChanges" }
func (v XdrType_LedgerEntryChanges) XdrUnwrap() XdrType { return v._XdrVec_unbounded_LedgerEntryChange }

type XdrType_OperationMeta = *OperationMeta

func (v *OperationMeta) XdrPointer() interface{}       { return v }
func (OperationMeta) XdrTypeName() string              { return "OperationMeta" }
func (v OperationMeta) XdrValue() interface{}          { return v }
func (v *OperationMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OperationMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%schanges", name), XDR_LedgerEntryChanges(&v.Changes))
}
func XDR_OperationMeta(v *OperationMeta) *OperationMeta { return v }

type _XdrVec_unbounded_OperationMeta []OperationMeta

func (_XdrVec_unbounded_OperationMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_OperationMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_OperationMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_OperationMeta length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_OperationMeta) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_OperationMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]OperationMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_OperationMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_OperationMeta(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_OperationMeta) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_OperationMeta) XdrTypeName() string              { return "OperationMeta<>" }
func (v *_XdrVec_unbounded_OperationMeta) XdrPointer() interface{}       { return (*[]OperationMeta)(v) }
func (v _XdrVec_unbounded_OperationMeta) XdrValue() interface{}          { return ([]OperationMeta)(v) }
func (v *_XdrVec_unbounded_OperationMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionMetaV1 = *TransactionMetaV1

func (v *TransactionMetaV1) XdrPointer() interface{}       { return v }
func (TransactionMetaV1) XdrTypeName() string              { return "TransactionMetaV1" }
func (v TransactionMetaV1) XdrValue() interface{}          { return v }
func (v *TransactionMetaV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxChanges", name), XDR_LedgerEntryChanges(&v.TxChanges))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(&v.Operations))
}
func XDR_TransactionMetaV1(v *TransactionMetaV1) *TransactionMetaV1 { return v }

type XdrType_TransactionMetaV2 = *TransactionMetaV2

func (v *TransactionMetaV2) XdrPointer() interface{}       { return v }
func (TransactionMetaV2) XdrTypeName() string              { return "TransactionMetaV2" }
func (v TransactionMetaV2) XdrValue() interface{}          { return v }
func (v *TransactionMetaV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxChangesBefore", name), XDR_LedgerEntryChanges(&v.TxChangesBefore))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(&v.Operations))
	x.Marshal(x.Sprintf("%stxChangesAfter", name), XDR_LedgerEntryChanges(&v.TxChangesAfter))
}
func XDR_TransactionMetaV2(v *TransactionMetaV2) *TransactionMetaV2 { return v }

var _XdrNames_ContractEventType = map[int32]string{
	int32(SYSTEM):   "SYSTEM",
	int32(CONTRACT): "CONTRACT",
}
var _XdrValues_ContractEventType = map[string]int32{
	"SYSTEM":   int32(SYSTEM),
	"CONTRACT": int32(CONTRACT),
}

func (ContractEventType) XdrEnumNames() map[int32]string {
	return _XdrNames_ContractEventType
}
func (v ContractEventType) String() string {
	if s, ok := _XdrNames_ContractEventType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ContractEventType#%d", v)
}
func (v *ContractEventType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ContractEventType[stok]; ok {
			*v = ContractEventType(val)
			return nil
		} else if stok == "ContractEventType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ContractEventType.", stok))
	}
}
func (v ContractEventType) GetU32() uint32                 { return uint32(v) }
func (v *ContractEventType) SetU32(n uint32)               { *v = ContractEventType(n) }
func (v *ContractEventType) XdrPointer() interface{}       { return v }
func (ContractEventType) XdrTypeName() string              { return "ContractEventType" }
func (v ContractEventType) XdrValue() interface{}          { return v }
func (v *ContractEventType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ContractEventType = *ContractEventType

func XDR_ContractEventType(v *ContractEventType) *ContractEventType { return v }

type XdrType_XdrAnon_ContractEvent_Body_V0 = *XdrAnon_ContractEvent_Body_V0

func (v *XdrAnon_ContractEvent_Body_V0) XdrPointer() interface{}       { return v }
func (XdrAnon_ContractEvent_Body_V0) XdrTypeName() string              { return "XdrAnon_ContractEvent_Body_V0" }
func (v XdrAnon_ContractEvent_Body_V0) XdrValue() interface{}          { return v }
func (v *XdrAnon_ContractEvent_Body_V0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_ContractEvent_Body_V0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stopics", name), XDR_SCVec(&v.Topics))
	x.Marshal(x.Sprintf("%sdata", name), XDR_SCVal(&v.Data))
}
func XDR_XdrAnon_ContractEvent_Body_V0(v *XdrAnon_ContractEvent_Body_V0) *XdrAnon_ContractEvent_Body_V0 {
	return v
}

var _XdrTags_XdrAnon_ContractEvent_Body = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_ContractEvent_Body) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ContractEvent_Body
}
func (u *XdrAnon_ContractEvent_Body) V0() *XdrAnon_ContractEvent_Body_V0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*XdrAnon_ContractEvent_Body_V0); ok {
			return v
		} else {
			var zero XdrAnon_ContractEvent_Body_V0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_ContractEvent_Body.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u XdrAnon_ContractEvent_Body) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_ContractEvent_Body) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_ContractEvent_Body) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_ContractEvent_Body) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_XdrAnon_ContractEvent_Body_V0(u.V0())
	}
	return nil
}
func (u *XdrAnon_ContractEvent_Body) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}

type XdrType_XdrAnon_ContractEvent_Body = *XdrAnon_ContractEvent_Body

func (v *XdrAnon_ContractEvent_Body) XdrPointer() interface{}       { return v }
func (XdrAnon_ContractEvent_Body) XdrTypeName() string              { return "XdrAnon_ContractEvent_Body" }
func (v XdrAnon_ContractEvent_Body) XdrValue() interface{}          { return v }
func (v *XdrAnon_ContractEvent_Body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ContractEvent_Body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_XdrAnon_ContractEvent_Body_V0(u.V0()))
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_ContractEvent_Body", u.V)
}
func XDR_XdrAnon_ContractEvent_Body(v *XdrAnon_ContractEvent_Body) *XdrAnon_ContractEvent_Body {
	return v
}

type _XdrPtr_Hash struct {
	p **Hash
}
type _ptrflag_Hash _XdrPtr_Hash

func (v _ptrflag_Hash) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Hash) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Hash flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Hash) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Hash) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Hash)
		}
	default:
		XdrPanic("*Hash present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Hash) XdrTypeName() string             { return "Hash?" }
func (v _ptrflag_Hash) XdrPointer() interface{}       { return nil }
func (v _ptrflag_Hash) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Hash) XdrBound() uint32              { return 1 }
func (v _XdrPtr_Hash) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_Hash) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Hash)
	}
}
func (v _XdrPtr_Hash) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Hash(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Hash) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Hash(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Hash) XdrTypeName() string       { return "Hash*" }
func (v _XdrPtr_Hash) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Hash) XdrValue() interface{}   { return *v.p }

type XdrType_ContractEvent = *ContractEvent

func (v *ContractEvent) XdrPointer() interface{}       { return v }
func (ContractEvent) XdrTypeName() string              { return "ContractEvent" }
func (v ContractEvent) XdrValue() interface{}          { return v }
func (v *ContractEvent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ContractEvent) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sext", name), XDR_ExtensionPoint(&v.Ext))
	x.Marshal(x.Sprintf("%scontractID", name), _XdrPtr_Hash{&v.ContractID})
	x.Marshal(x.Sprintf("%stype", name), XDR_ContractEventType(&v.Type))
	x.Marshal(x.Sprintf("%sbody", name), XDR_XdrAnon_ContractEvent_Body(&v.Body))
}
func XDR_ContractEvent(v *ContractEvent) *ContractEvent { return v }

type _XdrVec_unbounded_ContractEvent []ContractEvent

func (_XdrVec_unbounded_ContractEvent) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_ContractEvent) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_ContractEvent length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_ContractEvent length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_ContractEvent) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_ContractEvent) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ContractEvent, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_ContractEvent) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_ContractEvent(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_ContractEvent) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_ContractEvent) XdrTypeName() string              { return "ContractEvent<>" }
func (v *_XdrVec_unbounded_ContractEvent) XdrPointer() interface{}       { return (*[]ContractEvent)(v) }
func (v _XdrVec_unbounded_ContractEvent) XdrValue() interface{}          { return ([]ContractEvent)(v) }
func (v *_XdrVec_unbounded_ContractEvent) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrArray_3_Hash [3]Hash

func (_XdrArray_3_Hash) XdrArraySize() uint32 {
	const bound uint32 = 3 // Force error if not const or doesn't fit
	return bound
}
func (v *_XdrArray_3_Hash) XdrRecurse(x XDR, name string) {
	for i := 0; i < len(*v); i++ {
		XDR_Hash(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
}
func (v *_XdrArray_3_Hash) XdrPointer() interface{}       { return (*[3]Hash)(v) }
func (_XdrArray_3_Hash) XdrTypeName() string              { return "Hash[]" }
func (v *_XdrArray_3_Hash) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_3_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionMetaV3 = *TransactionMetaV3

func (v *TransactionMetaV3) XdrPointer() interface{}       { return v }
func (TransactionMetaV3) XdrTypeName() string              { return "TransactionMetaV3" }
func (v TransactionMetaV3) XdrValue() interface{}          { return v }
func (v *TransactionMetaV3) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionMetaV3) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxChangesBefore", name), XDR_LedgerEntryChanges(&v.TxChangesBefore))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(&v.Operations))
	x.Marshal(x.Sprintf("%stxChangesAfter", name), XDR_LedgerEntryChanges(&v.TxChangesAfter))
	x.Marshal(x.Sprintf("%sevents", name), (*_XdrVec_unbounded_ContractEvent)(&v.Events))
	x.Marshal(x.Sprintf("%stxResult", name), XDR_TransactionResult(&v.TxResult))
	x.Marshal(x.Sprintf("%shashes", name), (*_XdrArray_3_Hash)(&v.Hashes))
}
func XDR_TransactionMetaV3(v *TransactionMetaV3) *TransactionMetaV3 { return v }

var _XdrTags_TransactionMeta = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
	XdrToI32(2): true,
	XdrToI32(3): true,
}

func (_ TransactionMeta) XdrValidTags() map[int32]bool {
	return _XdrTags_TransactionMeta
}
func (u *TransactionMeta) Operations() *[]OperationMeta {
	switch u.V {
	case 0:
		if v, ok := u._u.(*[]OperationMeta); ok {
			return v
		} else {
			var zero []OperationMeta
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.Operations accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V1() *TransactionMetaV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*TransactionMetaV1); ok {
			return v
		} else {
			var zero TransactionMetaV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V2() *TransactionMetaV2 {
	switch u.V {
	case 2:
		if v, ok := u._u.(*TransactionMetaV2); ok {
			return v
		} else {
			var zero TransactionMetaV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.V2 accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V3() *TransactionMetaV3 {
	switch u.V {
	case 3:
		if v, ok := u._u.(*TransactionMetaV3); ok {
			return v
		} else {
			var zero TransactionMetaV3
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionMeta.V3 accessed when V == %v", u.V)
		return nil
	}
}
func (u TransactionMeta) XdrValid() bool {
	switch u.V {
	case 0, 1, 2, 3:
		return true
	}
	return false
}
func (u *TransactionMeta) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *TransactionMeta) XdrUnionTagName() string {
	return "V"
}
func (u *TransactionMeta) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return (*_XdrVec_unbounded_OperationMeta)(u.Operations())
	case 1:
		return XDR_TransactionMetaV1(u.V1())
	case 2:
		return XDR_TransactionMetaV2(u.V2())
	case 3:
		return XDR_TransactionMetaV3(u.V3())
	}
	return nil
}
func (u *TransactionMeta) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "Operations"
	case 1:
		return "V1"
	case 2:
		return "V2"
	case 3:
		return "V3"
	}
	return ""
}

type XdrType_TransactionMeta = *TransactionMeta

func (v *TransactionMeta) XdrPointer() interface{}       { return v }
func (TransactionMeta) XdrTypeName() string              { return "TransactionMeta" }
func (v TransactionMeta) XdrValue() interface{}          { return v }
func (v *TransactionMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TransactionMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_unbounded_OperationMeta)(u.Operations()))
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_TransactionMetaV1(u.V1()))
		return
	case 2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_TransactionMetaV2(u.V2()))
		return
	case 3:
		x.Marshal(x.Sprintf("%sv3", name), XDR_TransactionMetaV3(u.V3()))
		return
	}
	XdrPanic("invalid V (%v) in TransactionMeta", u.V)
}
func XDR_TransactionMeta(v *TransactionMeta) *TransactionMeta { return v }

type XdrType_TransactionResultMeta = *TransactionResultMeta

func (v *TransactionResultMeta) XdrPointer() interface{}       { return v }
func (TransactionResultMeta) XdrTypeName() string              { return "TransactionResultMeta" }
func (v TransactionResultMeta) XdrValue() interface{}          { return v }
func (v *TransactionResultMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresult", name), XDR_TransactionResultPair(&v.Result))
	x.Marshal(x.Sprintf("%sfeeProcessing", name), XDR_LedgerEntryChanges(&v.FeeProcessing))
	x.Marshal(x.Sprintf("%stxApplyProcessing", name), XDR_TransactionMeta(&v.TxApplyProcessing))
}
func XDR_TransactionResultMeta(v *TransactionResultMeta) *TransactionResultMeta { return v }

type XdrType_TransactionResultMetaV2 = *TransactionResultMetaV2

func (v *TransactionResultMetaV2) XdrPointer() interface{}       { return v }
func (TransactionResultMetaV2) XdrTypeName() string              { return "TransactionResultMetaV2" }
func (v TransactionResultMetaV2) XdrValue() interface{}          { return v }
func (v *TransactionResultMetaV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResultMetaV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresult", name), XDR_TransactionResultPairV2(&v.Result))
	x.Marshal(x.Sprintf("%sfeeProcessing", name), XDR_LedgerEntryChanges(&v.FeeProcessing))
	x.Marshal(x.Sprintf("%stxApplyProcessing", name), XDR_TransactionMeta(&v.TxApplyProcessing))
}
func XDR_TransactionResultMetaV2(v *TransactionResultMetaV2) *TransactionResultMetaV2 { return v }

type XdrType_UpgradeEntryMeta = *UpgradeEntryMeta

func (v *UpgradeEntryMeta) XdrPointer() interface{}       { return v }
func (UpgradeEntryMeta) XdrTypeName() string              { return "UpgradeEntryMeta" }
func (v UpgradeEntryMeta) XdrValue() interface{}          { return v }
func (v *UpgradeEntryMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *UpgradeEntryMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%supgrade", name), XDR_LedgerUpgrade(&v.Upgrade))
	x.Marshal(x.Sprintf("%schanges", name), XDR_LedgerEntryChanges(&v.Changes))
}
func XDR_UpgradeEntryMeta(v *UpgradeEntryMeta) *UpgradeEntryMeta { return v }

type _XdrVec_unbounded_TransactionResultMeta []TransactionResultMeta

func (_XdrVec_unbounded_TransactionResultMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionResultMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionResultMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionResultMeta length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionResultMeta) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionResultMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionResultMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionResultMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionResultMeta(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionResultMeta) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionResultMeta) XdrTypeName() string { return "TransactionResultMeta<>" }
func (v *_XdrVec_unbounded_TransactionResultMeta) XdrPointer() interface{} {
	return (*[]TransactionResultMeta)(v)
}
func (v _XdrVec_unbounded_TransactionResultMeta) XdrValue() interface{} {
	return ([]TransactionResultMeta)(v)
}
func (v *_XdrVec_unbounded_TransactionResultMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_unbounded_UpgradeEntryMeta []UpgradeEntryMeta

func (_XdrVec_unbounded_UpgradeEntryMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_UpgradeEntryMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_UpgradeEntryMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_UpgradeEntryMeta length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_UpgradeEntryMeta) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_UpgradeEntryMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]UpgradeEntryMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_UpgradeEntryMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_UpgradeEntryMeta(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_UpgradeEntryMeta) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_UpgradeEntryMeta) XdrTypeName() string { return "UpgradeEntryMeta<>" }
func (v *_XdrVec_unbounded_UpgradeEntryMeta) XdrPointer() interface{} {
	return (*[]UpgradeEntryMeta)(v)
}
func (v _XdrVec_unbounded_UpgradeEntryMeta) XdrValue() interface{}          { return ([]UpgradeEntryMeta)(v) }
func (v *_XdrVec_unbounded_UpgradeEntryMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_unbounded_SCPHistoryEntry []SCPHistoryEntry

func (_XdrVec_unbounded_SCPHistoryEntry) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_SCPHistoryEntry) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_SCPHistoryEntry length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_SCPHistoryEntry length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_SCPHistoryEntry) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_SCPHistoryEntry) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPHistoryEntry, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_SCPHistoryEntry) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCPHistoryEntry(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_SCPHistoryEntry) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_SCPHistoryEntry) XdrTypeName() string              { return "SCPHistoryEntry<>" }
func (v *_XdrVec_unbounded_SCPHistoryEntry) XdrPointer() interface{}       { return (*[]SCPHistoryEntry)(v) }
func (v _XdrVec_unbounded_SCPHistoryEntry) XdrValue() interface{}          { return ([]SCPHistoryEntry)(v) }
func (v *_XdrVec_unbounded_SCPHistoryEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerCloseMetaV0 = *LedgerCloseMetaV0

func (v *LedgerCloseMetaV0) XdrPointer() interface{}       { return v }
func (LedgerCloseMetaV0) XdrTypeName() string              { return "LedgerCloseMetaV0" }
func (v LedgerCloseMetaV0) XdrValue() interface{}          { return v }
func (v *LedgerCloseMetaV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseMetaV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerHeader", name), XDR_LedgerHeaderHistoryEntry(&v.LedgerHeader))
	x.Marshal(x.Sprintf("%stxSet", name), XDR_TransactionSet(&v.TxSet))
	x.Marshal(x.Sprintf("%stxProcessing", name), (*_XdrVec_unbounded_TransactionResultMeta)(&v.TxProcessing))
	x.Marshal(x.Sprintf("%supgradesProcessing", name), (*_XdrVec_unbounded_UpgradeEntryMeta)(&v.UpgradesProcessing))
	x.Marshal(x.Sprintf("%sscpInfo", name), (*_XdrVec_unbounded_SCPHistoryEntry)(&v.ScpInfo))
}
func XDR_LedgerCloseMetaV0(v *LedgerCloseMetaV0) *LedgerCloseMetaV0 { return v }

type XdrType_LedgerCloseMetaV1 = *LedgerCloseMetaV1

func (v *LedgerCloseMetaV1) XdrPointer() interface{}       { return v }
func (LedgerCloseMetaV1) XdrTypeName() string              { return "LedgerCloseMetaV1" }
func (v LedgerCloseMetaV1) XdrValue() interface{}          { return v }
func (v *LedgerCloseMetaV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseMetaV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerHeader", name), XDR_LedgerHeaderHistoryEntry(&v.LedgerHeader))
	x.Marshal(x.Sprintf("%stxSet", name), XDR_GeneralizedTransactionSet(&v.TxSet))
	x.Marshal(x.Sprintf("%stxProcessing", name), (*_XdrVec_unbounded_TransactionResultMeta)(&v.TxProcessing))
	x.Marshal(x.Sprintf("%supgradesProcessing", name), (*_XdrVec_unbounded_UpgradeEntryMeta)(&v.UpgradesProcessing))
	x.Marshal(x.Sprintf("%sscpInfo", name), (*_XdrVec_unbounded_SCPHistoryEntry)(&v.ScpInfo))
}
func XDR_LedgerCloseMetaV1(v *LedgerCloseMetaV1) *LedgerCloseMetaV1 { return v }

type _XdrVec_unbounded_TransactionResultMetaV2 []TransactionResultMetaV2

func (_XdrVec_unbounded_TransactionResultMetaV2) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_TransactionResultMetaV2) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_TransactionResultMetaV2 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_TransactionResultMetaV2 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_TransactionResultMetaV2) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_TransactionResultMetaV2) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionResultMetaV2, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_TransactionResultMetaV2) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_TransactionResultMetaV2(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_TransactionResultMetaV2) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_TransactionResultMetaV2) XdrTypeName() string {
	return "TransactionResultMetaV2<>"
}
func (v *_XdrVec_unbounded_TransactionResultMetaV2) XdrPointer() interface{} {
	return (*[]TransactionResultMetaV2)(v)
}
func (v _XdrVec_unbounded_TransactionResultMetaV2) XdrValue() interface{} {
	return ([]TransactionResultMetaV2)(v)
}
func (v *_XdrVec_unbounded_TransactionResultMetaV2) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}

type XdrType_LedgerCloseMetaV2 = *LedgerCloseMetaV2

func (v *LedgerCloseMetaV2) XdrPointer() interface{}       { return v }
func (LedgerCloseMetaV2) XdrTypeName() string              { return "LedgerCloseMetaV2" }
func (v LedgerCloseMetaV2) XdrValue() interface{}          { return v }
func (v *LedgerCloseMetaV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerCloseMetaV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerHeader", name), XDR_LedgerHeaderHistoryEntry(&v.LedgerHeader))
	x.Marshal(x.Sprintf("%stxSet", name), XDR_GeneralizedTransactionSet(&v.TxSet))
	x.Marshal(x.Sprintf("%stxProcessing", name), (*_XdrVec_unbounded_TransactionResultMetaV2)(&v.TxProcessing))
	x.Marshal(x.Sprintf("%supgradesProcessing", name), (*_XdrVec_unbounded_UpgradeEntryMeta)(&v.UpgradesProcessing))
	x.Marshal(x.Sprintf("%sscpInfo", name), (*_XdrVec_unbounded_SCPHistoryEntry)(&v.ScpInfo))
}
func XDR_LedgerCloseMetaV2(v *LedgerCloseMetaV2) *LedgerCloseMetaV2 { return v }

var _XdrTags_LedgerCloseMeta = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
	XdrToI32(2): true,
}

func (_ LedgerCloseMeta) XdrValidTags() map[int32]bool {
	return _XdrTags_LedgerCloseMeta
}
func (u *LedgerCloseMeta) V0() *LedgerCloseMetaV0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*LedgerCloseMetaV0); ok {
			return v
		} else {
			var zero LedgerCloseMetaV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerCloseMeta.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u *LedgerCloseMeta) V1() *LedgerCloseMetaV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*LedgerCloseMetaV1); ok {
			return v
		} else {
			var zero LedgerCloseMetaV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerCloseMeta.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u *LedgerCloseMeta) V2() *LedgerCloseMetaV2 {
	switch u.V {
	case 2:
		if v, ok := u._u.(*LedgerCloseMetaV2); ok {
			return v
		} else {
			var zero LedgerCloseMetaV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LedgerCloseMeta.V2 accessed when V == %v", u.V)
		return nil
	}
}
func (u LedgerCloseMeta) XdrValid() bool {
	switch u.V {
	case 0, 1, 2:
		return true
	}
	return false
}
func (u *LedgerCloseMeta) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *LedgerCloseMeta) XdrUnionTagName() string {
	return "V"
}
func (u *LedgerCloseMeta) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_LedgerCloseMetaV0(u.V0())
	case 1:
		return XDR_LedgerCloseMetaV1(u.V1())
	case 2:
		return XDR_LedgerCloseMetaV2(u.V2())
	}
	return nil
}
func (u *LedgerCloseMeta) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	case 1:
		return "V1"
	case 2:
		return "V2"
	}
	return ""
}

type XdrType_LedgerCloseMeta = *LedgerCloseMeta

func (v *LedgerCloseMeta) XdrPointer() interface{}       { return v }
func (LedgerCloseMeta) XdrTypeName() string              { return "LedgerCloseMeta" }
func (v LedgerCloseMeta) XdrValue() interface{}          { return v }
func (v *LedgerCloseMeta) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LedgerCloseMeta) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_LedgerCloseMetaV0(u.V0()))
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_LedgerCloseMetaV1(u.V1()))
		return
	case 2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_LedgerCloseMetaV2(u.V2()))
		return
	}
	XdrPanic("invalid V (%v) in LedgerCloseMeta", u.V)
}
func XDR_LedgerCloseMeta(v *LedgerCloseMeta) *LedgerCloseMeta { return v }

var _XdrNames_ErrorCode = map[int32]string{
	int32(ERR_MISC): "ERR_MISC",
	int32(ERR_DATA): "ERR_DATA",
	int32(ERR_CONF): "ERR_CONF",
	int32(ERR_AUTH): "ERR_AUTH",
	int32(ERR_LOAD): "ERR_LOAD",
}
var _XdrValues_ErrorCode = map[string]int32{
	"ERR_MISC": int32(ERR_MISC),
	"ERR_DATA": int32(ERR_DATA),
	"ERR_CONF": int32(ERR_CONF),
	"ERR_AUTH": int32(ERR_AUTH),
	"ERR_LOAD": int32(ERR_LOAD),
}

func (ErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ErrorCode
}
func (v ErrorCode) String() string {
	if s, ok := _XdrNames_ErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ErrorCode#%d", v)
}
func (v *ErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ErrorCode[stok]; ok {
			*v = ErrorCode(val)
			return nil
		} else if stok == "ErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ErrorCode.", stok))
	}
}
func (v ErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *ErrorCode) SetU32(n uint32)               { *v = ErrorCode(n) }
func (v *ErrorCode) XdrPointer() interface{}       { return v }
func (ErrorCode) XdrTypeName() string              { return "ErrorCode" }
func (v ErrorCode) XdrValue() interface{}          { return v }
func (v *ErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ErrorCode = *ErrorCode

func XDR_ErrorCode(v *ErrorCode) *ErrorCode { return v }

var _XdrComments_ErrorCode = map[int32]string{
	int32(ERR_MISC): "Unspecific error",
	int32(ERR_DATA): "Malformed data",
	int32(ERR_CONF): "Misconfiguration error",
	int32(ERR_AUTH): "Authentication failure",
	int32(ERR_LOAD): "System overloaded",
}

func (e ErrorCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ErrorCode
}

type XdrType_Error = *Error

func (v *Error) XdrPointer() interface{}       { return v }
func (Error) XdrTypeName() string              { return "Error" }
func (v Error) XdrValue() interface{}          { return v }
func (v *Error) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Error) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scode", name), XDR_ErrorCode(&v.Code))
	x.Marshal(x.Sprintf("%smsg", name), XdrString{&v.Msg, 100})
}
func XDR_Error(v *Error) *Error { return v }

type XdrType_SendMore = *SendMore

func (v *SendMore) XdrPointer() interface{}       { return v }
func (SendMore) XdrTypeName() string              { return "SendMore" }
func (v SendMore) XdrValue() interface{}          { return v }
func (v *SendMore) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SendMore) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snumMessages", name), XDR_Uint32(&v.NumMessages))
}
func XDR_SendMore(v *SendMore) *SendMore { return v }

type XdrType_AuthCert = *AuthCert

func (v *AuthCert) XdrPointer() interface{}       { return v }
func (AuthCert) XdrTypeName() string              { return "AuthCert" }
func (v AuthCert) XdrValue() interface{}          { return v }
func (v *AuthCert) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AuthCert) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%spubkey", name), XDR_Curve25519Public(&v.Pubkey))
	x.Marshal(x.Sprintf("%sexpiration", name), XDR_Uint64(&v.Expiration))
	x.Marshal(x.Sprintf("%ssig", name), XDR_Signature(&v.Sig))
}
func XDR_AuthCert(v *AuthCert) *AuthCert { return v }

type XdrType_Hello = *Hello

func (v *Hello) XdrPointer() interface{}       { return v }
func (Hello) XdrTypeName() string              { return "Hello" }
func (v Hello) XdrValue() interface{}          { return v }
func (v *Hello) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Hello) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sledgerVersion", name), XDR_Uint32(&v.LedgerVersion))
	x.Marshal(x.Sprintf("%soverlayVersion", name), XDR_Uint32(&v.OverlayVersion))
	x.Marshal(x.Sprintf("%soverlayMinVersion", name), XDR_Uint32(&v.OverlayMinVersion))
	x.Marshal(x.Sprintf("%snetworkID", name), XDR_Hash(&v.NetworkID))
	x.Marshal(x.Sprintf("%sversionStr", name), XdrString{&v.VersionStr, 100})
	x.Marshal(x.Sprintf("%slisteningPort", name), XDR_int32(&v.ListeningPort))
	x.Marshal(x.Sprintf("%speerID", name), XDR_NodeID(&v.PeerID))
	x.Marshal(x.Sprintf("%scert", name), XDR_AuthCert(&v.Cert))
	x.Marshal(x.Sprintf("%snonce", name), XDR_Uint256(&v.Nonce))
}
func XDR_Hello(v *Hello) *Hello { return v }

type XdrType_Auth = *Auth

func (v *Auth) XdrPointer() interface{}       { return v }
func (Auth) XdrTypeName() string              { return "Auth" }
func (v Auth) XdrValue() interface{}          { return v }
func (v *Auth) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Auth) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sflags", name), XDR_int32(&v.Flags))
}
func XDR_Auth(v *Auth) *Auth { return v }

var _XdrNames_IPAddrType = map[int32]string{
	int32(IPv4): "IPv4",
	int32(IPv6): "IPv6",
}
var _XdrValues_IPAddrType = map[string]int32{
	"IPv4": int32(IPv4),
	"IPv6": int32(IPv6),
}

func (IPAddrType) XdrEnumNames() map[int32]string {
	return _XdrNames_IPAddrType
}
func (v IPAddrType) String() string {
	if s, ok := _XdrNames_IPAddrType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("IPAddrType#%d", v)
}
func (v *IPAddrType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_IPAddrType[stok]; ok {
			*v = IPAddrType(val)
			return nil
		} else if stok == "IPAddrType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid IPAddrType.", stok))
	}
}
func (v IPAddrType) GetU32() uint32                 { return uint32(v) }
func (v *IPAddrType) SetU32(n uint32)               { *v = IPAddrType(n) }
func (v *IPAddrType) XdrPointer() interface{}       { return v }
func (IPAddrType) XdrTypeName() string              { return "IPAddrType" }
func (v IPAddrType) XdrValue() interface{}          { return v }
func (v *IPAddrType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_IPAddrType = *IPAddrType

func XDR_IPAddrType(v *IPAddrType) *IPAddrType { return v }

type _XdrArray_16_opaque [16]byte

func (v *_XdrArray_16_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_16_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_16_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_16_opaque) XdrPointer() interface{}       { return (*[16]byte)(v) }
func (v *_XdrArray_16_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_16_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_16_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_16_opaque) XdrArraySize() uint32 {
	const bound uint32 = 16 // Force error if not const or doesn't fit
	return bound
}

var _XdrTags_XdrAnon_PeerAddress_Ip = map[int32]bool{
	XdrToI32(IPv4): true,
	XdrToI32(IPv6): true,
}

func (_ XdrAnon_PeerAddress_Ip) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_PeerAddress_Ip
}
func (u *XdrAnon_PeerAddress_Ip) Ipv4() *[4]byte {
	switch u.Type {
	case IPv4:
		if v, ok := u._u.(*[4]byte); ok {
			return v
		} else {
			var zero [4]byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_PeerAddress_Ip.Ipv4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_PeerAddress_Ip) Ipv6() *[16]byte {
	switch u.Type {
	case IPv6:
		if v, ok := u._u.(*[16]byte); ok {
			return v
		} else {
			var zero [16]byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_PeerAddress_Ip.Ipv6 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_PeerAddress_Ip) XdrValid() bool {
	switch u.Type {
	case IPv4, IPv6:
		return true
	}
	return false
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionTag() XdrNum32 {
	return XDR_IPAddrType(&u.Type)
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionBody() XdrType {
	switch u.Type {
	case IPv4:
		return (*_XdrArray_4_opaque)(u.Ipv4())
	case IPv6:
		return (*_XdrArray_16_opaque)(u.Ipv6())
	}
	return nil
}
func (u *XdrAnon_PeerAddress_Ip) XdrUnionBodyName() string {
	switch u.Type {
	case IPv4:
		return "Ipv4"
	case IPv6:
		return "Ipv6"
	}
	return ""
}

type XdrType_XdrAnon_PeerAddress_Ip = *XdrAnon_PeerAddress_Ip

func (v *XdrAnon_PeerAddress_Ip) XdrPointer() interface{}       { return v }
func (XdrAnon_PeerAddress_Ip) XdrTypeName() string              { return "XdrAnon_PeerAddress_Ip" }
func (v XdrAnon_PeerAddress_Ip) XdrValue() interface{}          { return v }
func (v *XdrAnon_PeerAddress_Ip) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_PeerAddress_Ip) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_IPAddrType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case IPv4:
		x.Marshal(x.Sprintf("%sipv4", name), (*_XdrArray_4_opaque)(u.Ipv4()))
		return
	case IPv6:
		x.Marshal(x.Sprintf("%sipv6", name), (*_XdrArray_16_opaque)(u.Ipv6()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_PeerAddress_Ip", u.Type)
}
func XDR_XdrAnon_PeerAddress_Ip(v *XdrAnon_PeerAddress_Ip) *XdrAnon_PeerAddress_Ip { return v }

type XdrType_PeerAddress = *PeerAddress

func (v *PeerAddress) XdrPointer() interface{}       { return v }
func (PeerAddress) XdrTypeName() string              { return "PeerAddress" }
func (v PeerAddress) XdrValue() interface{}          { return v }
func (v *PeerAddress) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PeerAddress) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sip", name), XDR_XdrAnon_PeerAddress_Ip(&v.Ip))
	x.Marshal(x.Sprintf("%sport", name), XDR_Uint32(&v.Port))
	x.Marshal(x.Sprintf("%snumFailures", name), XDR_Uint32(&v.NumFailures))
}
func XDR_PeerAddress(v *PeerAddress) *PeerAddress { return v }

var _XdrNames_MessageType = map[int32]string{
	int32(ERROR_MSG):          "ERROR_MSG",
	int32(AUTH):               "AUTH",
	int32(DONT_HAVE):          "DONT_HAVE",
	int32(GET_PEERS):          "GET_PEERS",
	int32(PEERS):              "PEERS",
	int32(GET_TX_SET):         "GET_TX_SET",
	int32(TX_SET):             "TX_SET",
	int32(GENERALIZED_TX_SET): "GENERALIZED_TX_SET",
	int32(TRANSACTION):        "TRANSACTION",
	int32(GET_SCP_QUORUMSET):  "GET_SCP_QUORUMSET",
	int32(SCP_QUORUMSET):      "SCP_QUORUMSET",
	int32(SCP_MESSAGE):        "SCP_MESSAGE",
	int32(GET_SCP_STATE):      "GET_SCP_STATE",
	int32(HELLO):              "HELLO",
	int32(SURVEY_REQUEST):     "SURVEY_REQUEST",
	int32(SURVEY_RESPONSE):    "SURVEY_RESPONSE",
	int32(SEND_MORE):          "SEND_MORE",
	int32(FLOOD_ADVERT):       "FLOOD_ADVERT",
	int32(FLOOD_DEMAND):       "FLOOD_DEMAND",
}
var _XdrValues_MessageType = map[string]int32{
	"ERROR_MSG":          int32(ERROR_MSG),
	"AUTH":               int32(AUTH),
	"DONT_HAVE":          int32(DONT_HAVE),
	"GET_PEERS":          int32(GET_PEERS),
	"PEERS":              int32(PEERS),
	"GET_TX_SET":         int32(GET_TX_SET),
	"TX_SET":             int32(TX_SET),
	"GENERALIZED_TX_SET": int32(GENERALIZED_TX_SET),
	"TRANSACTION":        int32(TRANSACTION),
	"GET_SCP_QUORUMSET":  int32(GET_SCP_QUORUMSET),
	"SCP_QUORUMSET":      int32(SCP_QUORUMSET),
	"SCP_MESSAGE":        int32(SCP_MESSAGE),
	"GET_SCP_STATE":      int32(GET_SCP_STATE),
	"HELLO":              int32(HELLO),
	"SURVEY_REQUEST":     int32(SURVEY_REQUEST),
	"SURVEY_RESPONSE":    int32(SURVEY_RESPONSE),
	"SEND_MORE":          int32(SEND_MORE),
	"FLOOD_ADVERT":       int32(FLOOD_ADVERT),
	"FLOOD_DEMAND":       int32(FLOOD_DEMAND),
}

func (MessageType) XdrEnumNames() map[int32]string {
	return _XdrNames_MessageType
}
func (v MessageType) String() string {
	if s, ok := _XdrNames_MessageType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("MessageType#%d", v)
}
func (v *MessageType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_MessageType[stok]; ok {
			*v = MessageType(val)
			return nil
		} else if stok == "MessageType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid MessageType.", stok))
	}
}
func (v MessageType) GetU32() uint32                 { return uint32(v) }
func (v *MessageType) SetU32(n uint32)               { *v = MessageType(n) }
func (v *MessageType) XdrPointer() interface{}       { return v }
func (MessageType) XdrTypeName() string              { return "MessageType" }
func (v MessageType) XdrValue() interface{}          { return v }
func (v *MessageType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_MessageType = *MessageType

func XDR_MessageType(v *MessageType) *MessageType { return v }

var _XdrComments_MessageType = map[int32]string{
	int32(GET_PEERS):         "gets a list of peers this guy knows about",
	int32(GET_TX_SET):        "gets a particular txset by hash",
	int32(TRANSACTION):       "pass on a tx you have heard about",
	int32(GET_SCP_QUORUMSET): "SCP",
	int32(HELLO):             "new messages",
}

func (e MessageType) XdrEnumComments() map[int32]string {
	return _XdrComments_MessageType
}

type XdrType_DontHave = *DontHave

func (v *DontHave) XdrPointer() interface{}       { return v }
func (DontHave) XdrTypeName() string              { return "DontHave" }
func (v DontHave) XdrValue() interface{}          { return v }
func (v *DontHave) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DontHave) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stype", name), XDR_MessageType(&v.Type))
	x.Marshal(x.Sprintf("%sreqHash", name), XDR_Uint256(&v.ReqHash))
}
func XDR_DontHave(v *DontHave) *DontHave { return v }

var _XdrNames_SurveyMessageCommandType = map[int32]string{
	int32(SURVEY_TOPOLOGY): "SURVEY_TOPOLOGY",
}
var _XdrValues_SurveyMessageCommandType = map[string]int32{
	"SURVEY_TOPOLOGY": int32(SURVEY_TOPOLOGY),
}

func (SurveyMessageCommandType) XdrEnumNames() map[int32]string {
	return _XdrNames_SurveyMessageCommandType
}
func (v SurveyMessageCommandType) String() string {
	if s, ok := _XdrNames_SurveyMessageCommandType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SurveyMessageCommandType#%d", v)
}
func (v *SurveyMessageCommandType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SurveyMessageCommandType[stok]; ok {
			*v = SurveyMessageCommandType(val)
			return nil
		} else if stok == "SurveyMessageCommandType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SurveyMessageCommandType.", stok))
	}
}
func (v SurveyMessageCommandType) GetU32() uint32                 { return uint32(v) }
func (v *SurveyMessageCommandType) SetU32(n uint32)               { *v = SurveyMessageCommandType(n) }
func (v *SurveyMessageCommandType) XdrPointer() interface{}       { return v }
func (SurveyMessageCommandType) XdrTypeName() string              { return "SurveyMessageCommandType" }
func (v SurveyMessageCommandType) XdrValue() interface{}          { return v }
func (v *SurveyMessageCommandType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SurveyMessageCommandType = *SurveyMessageCommandType

func XDR_SurveyMessageCommandType(v *SurveyMessageCommandType) *SurveyMessageCommandType { return v }

type XdrType_SurveyRequestMessage = *SurveyRequestMessage

func (v *SurveyRequestMessage) XdrPointer() interface{}       { return v }
func (SurveyRequestMessage) XdrTypeName() string              { return "SurveyRequestMessage" }
func (v SurveyRequestMessage) XdrValue() interface{}          { return v }
func (v *SurveyRequestMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SurveyRequestMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssurveyorPeerID", name), XDR_NodeID(&v.SurveyorPeerID))
	x.Marshal(x.Sprintf("%ssurveyedPeerID", name), XDR_NodeID(&v.SurveyedPeerID))
	x.Marshal(x.Sprintf("%sledgerNum", name), XDR_Uint32(&v.LedgerNum))
	x.Marshal(x.Sprintf("%sencryptionKey", name), XDR_Curve25519Public(&v.EncryptionKey))
	x.Marshal(x.Sprintf("%scommandType", name), XDR_SurveyMessageCommandType(&v.CommandType))
}
func XDR_SurveyRequestMessage(v *SurveyRequestMessage) *SurveyRequestMessage { return v }

type XdrType_SignedSurveyRequestMessage = *SignedSurveyRequestMessage

func (v *SignedSurveyRequestMessage) XdrPointer() interface{}       { return v }
func (SignedSurveyRequestMessage) XdrTypeName() string              { return "SignedSurveyRequestMessage" }
func (v SignedSurveyRequestMessage) XdrValue() interface{}          { return v }
func (v *SignedSurveyRequestMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SignedSurveyRequestMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%srequestSignature", name), XDR_Signature(&v.RequestSignature))
	x.Marshal(x.Sprintf("%srequest", name), XDR_SurveyRequestMessage(&v.Request))
}
func XDR_SignedSurveyRequestMessage(v *SignedSurveyRequestMessage) *SignedSurveyRequestMessage {
	return v
}

type XdrType_EncryptedBody struct {
	XdrVecOpaque
}

func XDR_EncryptedBody(v *EncryptedBody) XdrType_EncryptedBody {
	return XdrType_EncryptedBody{XdrVecOpaque{v, 64000}}
}
func (XdrType_EncryptedBody) XdrTypeName() string  { return "EncryptedBody" }
func (v XdrType_EncryptedBody) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_SurveyResponseMessage = *SurveyResponseMessage

func (v *SurveyResponseMessage) XdrPointer() interface{}       { return v }
func (SurveyResponseMessage) XdrTypeName() string              { return "SurveyResponseMessage" }
func (v SurveyResponseMessage) XdrValue() interface{}          { return v }
func (v *SurveyResponseMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SurveyResponseMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssurveyorPeerID", name), XDR_NodeID(&v.SurveyorPeerID))
	x.Marshal(x.Sprintf("%ssurveyedPeerID", name), XDR_NodeID(&v.SurveyedPeerID))
	x.Marshal(x.Sprintf("%sledgerNum", name), XDR_Uint32(&v.LedgerNum))
	x.Marshal(x.Sprintf("%scommandType", name), XDR_SurveyMessageCommandType(&v.CommandType))
	x.Marshal(x.Sprintf("%sencryptedBody", name), XDR_EncryptedBody(&v.EncryptedBody))
}
func XDR_SurveyResponseMessage(v *SurveyResponseMessage) *SurveyResponseMessage { return v }

type XdrType_SignedSurveyResponseMessage = *SignedSurveyResponseMessage

func (v *SignedSurveyResponseMessage) XdrPointer() interface{}       { return v }
func (SignedSurveyResponseMessage) XdrTypeName() string              { return "SignedSurveyResponseMessage" }
func (v SignedSurveyResponseMessage) XdrValue() interface{}          { return v }
func (v *SignedSurveyResponseMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SignedSurveyResponseMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresponseSignature", name), XDR_Signature(&v.ResponseSignature))
	x.Marshal(x.Sprintf("%sresponse", name), XDR_SurveyResponseMessage(&v.Response))
}
func XDR_SignedSurveyResponseMessage(v *SignedSurveyResponseMessage) *SignedSurveyResponseMessage {
	return v
}

type XdrType_PeerStats = *PeerStats

func (v *PeerStats) XdrPointer() interface{}       { return v }
func (PeerStats) XdrTypeName() string              { return "PeerStats" }
func (v PeerStats) XdrValue() interface{}          { return v }
func (v *PeerStats) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PeerStats) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sid", name), XDR_NodeID(&v.Id))
	x.Marshal(x.Sprintf("%sversionStr", name), XdrString{&v.VersionStr, 100})
	x.Marshal(x.Sprintf("%smessagesRead", name), XDR_Uint64(&v.MessagesRead))
	x.Marshal(x.Sprintf("%smessagesWritten", name), XDR_Uint64(&v.MessagesWritten))
	x.Marshal(x.Sprintf("%sbytesRead", name), XDR_Uint64(&v.BytesRead))
	x.Marshal(x.Sprintf("%sbytesWritten", name), XDR_Uint64(&v.BytesWritten))
	x.Marshal(x.Sprintf("%ssecondsConnected", name), XDR_Uint64(&v.SecondsConnected))
	x.Marshal(x.Sprintf("%suniqueFloodBytesRecv", name), XDR_Uint64(&v.UniqueFloodBytesRecv))
	x.Marshal(x.Sprintf("%sduplicateFloodBytesRecv", name), XDR_Uint64(&v.DuplicateFloodBytesRecv))
	x.Marshal(x.Sprintf("%suniqueFetchBytesRecv", name), XDR_Uint64(&v.UniqueFetchBytesRecv))
	x.Marshal(x.Sprintf("%sduplicateFetchBytesRecv", name), XDR_Uint64(&v.DuplicateFetchBytesRecv))
	x.Marshal(x.Sprintf("%suniqueFloodMessageRecv", name), XDR_Uint64(&v.UniqueFloodMessageRecv))
	x.Marshal(x.Sprintf("%sduplicateFloodMessageRecv", name), XDR_Uint64(&v.DuplicateFloodMessageRecv))
	x.Marshal(x.Sprintf("%suniqueFetchMessageRecv", name), XDR_Uint64(&v.UniqueFetchMessageRecv))
	x.Marshal(x.Sprintf("%sduplicateFetchMessageRecv", name), XDR_Uint64(&v.DuplicateFetchMessageRecv))
}
func XDR_PeerStats(v *PeerStats) *PeerStats { return v }

type _XdrVec_25_PeerStats []PeerStats

func (_XdrVec_25_PeerStats) XdrBound() uint32 {
	const bound uint32 = 25 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_25_PeerStats) XdrCheckLen(length uint32) {
	if length > uint32(25) {
		XdrPanic("_XdrVec_25_PeerStats length %d exceeds bound 25", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_25_PeerStats length %d exceeds max int", length)
	}
}
func (v _XdrVec_25_PeerStats) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_25_PeerStats) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(25); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]PeerStats, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_25_PeerStats) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_PeerStats(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_25_PeerStats) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 25}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_25_PeerStats) XdrTypeName() string              { return "PeerStats<>" }
func (v *_XdrVec_25_PeerStats) XdrPointer() interface{}       { return (*[]PeerStats)(v) }
func (v _XdrVec_25_PeerStats) XdrValue() interface{}          { return ([]PeerStats)(v) }
func (v *_XdrVec_25_PeerStats) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PeerStatList struct {
	*_XdrVec_25_PeerStats
}

func XDR_PeerStatList(v *PeerStatList) XdrType_PeerStatList {
	return XdrType_PeerStatList{(*_XdrVec_25_PeerStats)(v)}
}
func (XdrType_PeerStatList) XdrTypeName() string  { return "PeerStatList" }
func (v XdrType_PeerStatList) XdrUnwrap() XdrType { return v._XdrVec_25_PeerStats }

type XdrType_TopologyResponseBody = *TopologyResponseBody

func (v *TopologyResponseBody) XdrPointer() interface{}       { return v }
func (TopologyResponseBody) XdrTypeName() string              { return "TopologyResponseBody" }
func (v TopologyResponseBody) XdrValue() interface{}          { return v }
func (v *TopologyResponseBody) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TopologyResponseBody) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sinboundPeers", name), XDR_PeerStatList(&v.InboundPeers))
	x.Marshal(x.Sprintf("%soutboundPeers", name), XDR_PeerStatList(&v.OutboundPeers))
	x.Marshal(x.Sprintf("%stotalInboundPeerCount", name), XDR_Uint32(&v.TotalInboundPeerCount))
	x.Marshal(x.Sprintf("%stotalOutboundPeerCount", name), XDR_Uint32(&v.TotalOutboundPeerCount))
}
func XDR_TopologyResponseBody(v *TopologyResponseBody) *TopologyResponseBody { return v }

type _XdrVec_1000_Hash []Hash

func (_XdrVec_1000_Hash) XdrBound() uint32 {
	const bound uint32 = 1000 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_1000_Hash) XdrCheckLen(length uint32) {
	if length > uint32(1000) {
		XdrPanic("_XdrVec_1000_Hash length %d exceeds bound 1000", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_1000_Hash length %d exceeds max int", length)
	}
}
func (v _XdrVec_1000_Hash) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_1000_Hash) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(1000); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Hash, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_1000_Hash) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Hash(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_1000_Hash) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 1000}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_1000_Hash) XdrTypeName() string              { return "Hash<>" }
func (v *_XdrVec_1000_Hash) XdrPointer() interface{}       { return (*[]Hash)(v) }
func (v _XdrVec_1000_Hash) XdrValue() interface{}          { return ([]Hash)(v) }
func (v *_XdrVec_1000_Hash) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TxAdvertVector struct {
	*_XdrVec_1000_Hash
}

func XDR_TxAdvertVector(v *TxAdvertVector) XdrType_TxAdvertVector {
	return XdrType_TxAdvertVector{(*_XdrVec_1000_Hash)(v)}
}
func (XdrType_TxAdvertVector) XdrTypeName() string  { return "TxAdvertVector" }
func (v XdrType_TxAdvertVector) XdrUnwrap() XdrType { return v._XdrVec_1000_Hash }

type XdrType_FloodAdvert = *FloodAdvert

func (v *FloodAdvert) XdrPointer() interface{}       { return v }
func (FloodAdvert) XdrTypeName() string              { return "FloodAdvert" }
func (v FloodAdvert) XdrValue() interface{}          { return v }
func (v *FloodAdvert) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FloodAdvert) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxHashes", name), XDR_TxAdvertVector(&v.TxHashes))
}
func XDR_FloodAdvert(v *FloodAdvert) *FloodAdvert { return v }

type XdrType_TxDemandVector struct {
	*_XdrVec_1000_Hash
}

func XDR_TxDemandVector(v *TxDemandVector) XdrType_TxDemandVector {
	return XdrType_TxDemandVector{(*_XdrVec_1000_Hash)(v)}
}
func (XdrType_TxDemandVector) XdrTypeName() string  { return "TxDemandVector" }
func (v XdrType_TxDemandVector) XdrUnwrap() XdrType { return v._XdrVec_1000_Hash }

type XdrType_FloodDemand = *FloodDemand

func (v *FloodDemand) XdrPointer() interface{}       { return v }
func (FloodDemand) XdrTypeName() string              { return "FloodDemand" }
func (v FloodDemand) XdrValue() interface{}          { return v }
func (v *FloodDemand) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FloodDemand) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stxHashes", name), XDR_TxDemandVector(&v.TxHashes))
}
func XDR_FloodDemand(v *FloodDemand) *FloodDemand { return v }

var _XdrTags_SurveyResponseBody = map[int32]bool{
	XdrToI32(SURVEY_TOPOLOGY): true,
}

func (_ SurveyResponseBody) XdrValidTags() map[int32]bool {
	return _XdrTags_SurveyResponseBody
}
func (u *SurveyResponseBody) TopologyResponseBody() *TopologyResponseBody {
	switch u.Type {
	case SURVEY_TOPOLOGY:
		if v, ok := u._u.(*TopologyResponseBody); ok {
			return v
		} else {
			var zero TopologyResponseBody
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SurveyResponseBody.TopologyResponseBody accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SurveyResponseBody) XdrValid() bool {
	switch u.Type {
	case SURVEY_TOPOLOGY:
		return true
	}
	return false
}
func (u *SurveyResponseBody) XdrUnionTag() XdrNum32 {
	return XDR_SurveyMessageCommandType(&u.Type)
}
func (u *SurveyResponseBody) XdrUnionTagName() string {
	return "Type"
}
func (u *SurveyResponseBody) XdrUnionBody() XdrType {
	switch u.Type {
	case SURVEY_TOPOLOGY:
		return XDR_TopologyResponseBody(u.TopologyResponseBody())
	}
	return nil
}
func (u *SurveyResponseBody) XdrUnionBodyName() string {
	switch u.Type {
	case SURVEY_TOPOLOGY:
		return "TopologyResponseBody"
	}
	return ""
}

type XdrType_SurveyResponseBody = *SurveyResponseBody

func (v *SurveyResponseBody) XdrPointer() interface{}       { return v }
func (SurveyResponseBody) XdrTypeName() string              { return "SurveyResponseBody" }
func (v SurveyResponseBody) XdrValue() interface{}          { return v }
func (v *SurveyResponseBody) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SurveyResponseBody) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SurveyMessageCommandType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SURVEY_TOPOLOGY:
		x.Marshal(x.Sprintf("%stopologyResponseBody", name), XDR_TopologyResponseBody(u.TopologyResponseBody()))
		return
	}
	XdrPanic("invalid Type (%v) in SurveyResponseBody", u.Type)
}
func XDR_SurveyResponseBody(v *SurveyResponseBody) *SurveyResponseBody { return v }

type _XdrVec_100_PeerAddress []PeerAddress

func (_XdrVec_100_PeerAddress) XdrBound() uint32 {
	const bound uint32 = 100 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_100_PeerAddress) XdrCheckLen(length uint32) {
	if length > uint32(100) {
		XdrPanic("_XdrVec_100_PeerAddress length %d exceeds bound 100", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_100_PeerAddress length %d exceeds max int", length)
	}
}
func (v _XdrVec_100_PeerAddress) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_100_PeerAddress) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(100); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]PeerAddress, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_100_PeerAddress) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_PeerAddress(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_100_PeerAddress) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 100}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_100_PeerAddress) XdrTypeName() string              { return "PeerAddress<>" }
func (v *_XdrVec_100_PeerAddress) XdrPointer() interface{}       { return (*[]PeerAddress)(v) }
func (v _XdrVec_100_PeerAddress) XdrValue() interface{}          { return ([]PeerAddress)(v) }
func (v *_XdrVec_100_PeerAddress) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_StellarMessage = map[int32]bool{
	XdrToI32(ERROR_MSG):          true,
	XdrToI32(HELLO):              true,
	XdrToI32(AUTH):               true,
	XdrToI32(DONT_HAVE):          true,
	XdrToI32(GET_PEERS):          true,
	XdrToI32(PEERS):              true,
	XdrToI32(GET_TX_SET):         true,
	XdrToI32(TX_SET):             true,
	XdrToI32(GENERALIZED_TX_SET): true,
	XdrToI32(TRANSACTION):        true,
	XdrToI32(SURVEY_REQUEST):     true,
	XdrToI32(SURVEY_RESPONSE):    true,
	XdrToI32(GET_SCP_QUORUMSET):  true,
	XdrToI32(SCP_QUORUMSET):      true,
	XdrToI32(SCP_MESSAGE):        true,
	XdrToI32(GET_SCP_STATE):      true,
	XdrToI32(SEND_MORE):          true,
	XdrToI32(FLOOD_ADVERT):       true,
	XdrToI32(FLOOD_DEMAND):       true,
}

func (_ StellarMessage) XdrValidTags() map[int32]bool {
	return _XdrTags_StellarMessage
}
func (u *StellarMessage) Error() *Error {
	switch u.Type {
	case ERROR_MSG:
		if v, ok := u._u.(*Error); ok {
			return v
		} else {
			var zero Error
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Error accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Hello() *Hello {
	switch u.Type {
	case HELLO:
		if v, ok := u._u.(*Hello); ok {
			return v
		} else {
			var zero Hello
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Hello accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Auth() *Auth {
	switch u.Type {
	case AUTH:
		if v, ok := u._u.(*Auth); ok {
			return v
		} else {
			var zero Auth
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Auth accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) DontHave() *DontHave {
	switch u.Type {
	case DONT_HAVE:
		if v, ok := u._u.(*DontHave); ok {
			return v
		} else {
			var zero DontHave
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.DontHave accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Peers() *[]PeerAddress {
	switch u.Type {
	case PEERS:
		if v, ok := u._u.(*[]PeerAddress); ok {
			return v
		} else {
			var zero []PeerAddress
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Peers accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) TxSetHash() *Uint256 {
	switch u.Type {
	case GET_TX_SET:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.TxSetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) TxSet() *TransactionSet {
	switch u.Type {
	case TX_SET:
		if v, ok := u._u.(*TransactionSet); ok {
			return v
		} else {
			var zero TransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.TxSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) GeneralizedTxSet() *GeneralizedTransactionSet {
	switch u.Type {
	case GENERALIZED_TX_SET:
		if v, ok := u._u.(*GeneralizedTransactionSet); ok {
			return v
		} else {
			var zero GeneralizedTransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.GeneralizedTxSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Transaction() *TransactionEnvelope {
	switch u.Type {
	case TRANSACTION:
		if v, ok := u._u.(*TransactionEnvelope); ok {
			return v
		} else {
			var zero TransactionEnvelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Transaction accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) SignedSurveyRequestMessage() *SignedSurveyRequestMessage {
	switch u.Type {
	case SURVEY_REQUEST:
		if v, ok := u._u.(*SignedSurveyRequestMessage); ok {
			return v
		} else {
			var zero SignedSurveyRequestMessage
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.SignedSurveyRequestMessage accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) SignedSurveyResponseMessage() *SignedSurveyResponseMessage {
	switch u.Type {
	case SURVEY_RESPONSE:
		if v, ok := u._u.(*SignedSurveyResponseMessage); ok {
			return v
		} else {
			var zero SignedSurveyResponseMessage
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.SignedSurveyResponseMessage accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) QSetHash() *Uint256 {
	switch u.Type {
	case GET_SCP_QUORUMSET:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.QSetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) QSet() *SCPQuorumSet {
	switch u.Type {
	case SCP_QUORUMSET:
		if v, ok := u._u.(*SCPQuorumSet); ok {
			return v
		} else {
			var zero SCPQuorumSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.QSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Envelope() *SCPEnvelope {
	switch u.Type {
	case SCP_MESSAGE:
		if v, ok := u._u.(*SCPEnvelope); ok {
			return v
		} else {
			var zero SCPEnvelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.Envelope accessed when Type == %v", u.Type)
		return nil
	}
}

// ledger seq requested ; if 0, requests the latest
func (u *StellarMessage) GetSCPLedgerSeq() *Uint32 {
	switch u.Type {
	case GET_SCP_STATE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.GetSCPLedgerSeq accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) SendMoreMessage() *SendMore {
	switch u.Type {
	case SEND_MORE:
		if v, ok := u._u.(*SendMore); ok {
			return v
		} else {
			var zero SendMore
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.SendMoreMessage accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) FloodAdvert() *FloodAdvert {
	switch u.Type {
	case FLOOD_ADVERT:
		if v, ok := u._u.(*FloodAdvert); ok {
			return v
		} else {
			var zero FloodAdvert
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.FloodAdvert accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) FloodDemand() *FloodDemand {
	switch u.Type {
	case FLOOD_DEMAND:
		if v, ok := u._u.(*FloodDemand); ok {
			return v
		} else {
			var zero FloodDemand
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StellarMessage.FloodDemand accessed when Type == %v", u.Type)
		return nil
	}
}
func (u StellarMessage) XdrValid() bool {
	switch u.Type {
	case ERROR_MSG, HELLO, AUTH, DONT_HAVE, GET_PEERS, PEERS, GET_TX_SET, TX_SET, GENERALIZED_TX_SET, TRANSACTION, SURVEY_REQUEST, SURVEY_RESPONSE, GET_SCP_QUORUMSET, SCP_QUORUMSET, SCP_MESSAGE, GET_SCP_STATE, SEND_MORE, FLOOD_ADVERT, FLOOD_DEMAND:
		return true
	}
	return false
}
func (u *StellarMessage) XdrUnionTag() XdrNum32 {
	return XDR_MessageType(&u.Type)
}
func (u *StellarMessage) XdrUnionTagName() string {
	return "Type"
}
func (u *StellarMessage) XdrUnionBody() XdrType {
	switch u.Type {
	case ERROR_MSG:
		return XDR_Error(u.Error())
	case HELLO:
		return XDR_Hello(u.Hello())
	case AUTH:
		return XDR_Auth(u.Auth())
	case DONT_HAVE:
		return XDR_DontHave(u.DontHave())
	case GET_PEERS:
		return nil
	case PEERS:
		return (*_XdrVec_100_PeerAddress)(u.Peers())
	case GET_TX_SET:
		return XDR_Uint256(u.TxSetHash())
	case TX_SET:
		return XDR_TransactionSet(u.TxSet())
	case GENERALIZED_TX_SET:
		return XDR_GeneralizedTransactionSet(u.GeneralizedTxSet())
	case TRANSACTION:
		return XDR_TransactionEnvelope(u.Transaction())
	case SURVEY_REQUEST:
		return XDR_SignedSurveyRequestMessage(u.SignedSurveyRequestMessage())
	case SURVEY_RESPONSE:
		return XDR_SignedSurveyResponseMessage(u.SignedSurveyResponseMessage())
	case GET_SCP_QUORUMSET:
		return XDR_Uint256(u.QSetHash())
	case SCP_QUORUMSET:
		return XDR_SCPQuorumSet(u.QSet())
	case SCP_MESSAGE:
		return XDR_SCPEnvelope(u.Envelope())
	case GET_SCP_STATE:
		return XDR_Uint32(u.GetSCPLedgerSeq())
	case SEND_MORE:
		return XDR_SendMore(u.SendMoreMessage())
	case FLOOD_ADVERT:
		return XDR_FloodAdvert(u.FloodAdvert())
	case FLOOD_DEMAND:
		return XDR_FloodDemand(u.FloodDemand())
	}
	return nil
}
func (u *StellarMessage) XdrUnionBodyName() string {
	switch u.Type {
	case ERROR_MSG:
		return "Error"
	case HELLO:
		return "Hello"
	case AUTH:
		return "Auth"
	case DONT_HAVE:
		return "DontHave"
	case GET_PEERS:
		return ""
	case PEERS:
		return "Peers"
	case GET_TX_SET:
		return "TxSetHash"
	case TX_SET:
		return "TxSet"
	case GENERALIZED_TX_SET:
		return "GeneralizedTxSet"
	case TRANSACTION:
		return "Transaction"
	case SURVEY_REQUEST:
		return "SignedSurveyRequestMessage"
	case SURVEY_RESPONSE:
		return "SignedSurveyResponseMessage"
	case GET_SCP_QUORUMSET:
		return "QSetHash"
	case SCP_QUORUMSET:
		return "QSet"
	case SCP_MESSAGE:
		return "Envelope"
	case GET_SCP_STATE:
		return "GetSCPLedgerSeq"
	case SEND_MORE:
		return "SendMoreMessage"
	case FLOOD_ADVERT:
		return "FloodAdvert"
	case FLOOD_DEMAND:
		return "FloodDemand"
	}
	return ""
}

type XdrType_StellarMessage = *StellarMessage

func (v *StellarMessage) XdrPointer() interface{}       { return v }
func (StellarMessage) XdrTypeName() string              { return "StellarMessage" }
func (v StellarMessage) XdrValue() interface{}          { return v }
func (v *StellarMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *StellarMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MessageType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ERROR_MSG:
		x.Marshal(x.Sprintf("%serror", name), XDR_Error(u.Error()))
		return
	case HELLO:
		x.Marshal(x.Sprintf("%shello", name), XDR_Hello(u.Hello()))
		return
	case AUTH:
		x.Marshal(x.Sprintf("%sauth", name), XDR_Auth(u.Auth()))
		return
	case DONT_HAVE:
		x.Marshal(x.Sprintf("%sdontHave", name), XDR_DontHave(u.DontHave()))
		return
	case GET_PEERS:
		return
	case PEERS:
		x.Marshal(x.Sprintf("%speers", name), (*_XdrVec_100_PeerAddress)(u.Peers()))
		return
	case GET_TX_SET:
		x.Marshal(x.Sprintf("%stxSetHash", name), XDR_Uint256(u.TxSetHash()))
		return
	case TX_SET:
		x.Marshal(x.Sprintf("%stxSet", name), XDR_TransactionSet(u.TxSet()))
		return
	case GENERALIZED_TX_SET:
		x.Marshal(x.Sprintf("%sgeneralizedTxSet", name), XDR_GeneralizedTransactionSet(u.GeneralizedTxSet()))
		return
	case TRANSACTION:
		x.Marshal(x.Sprintf("%stransaction", name), XDR_TransactionEnvelope(u.Transaction()))
		return
	case SURVEY_REQUEST:
		x.Marshal(x.Sprintf("%ssignedSurveyRequestMessage", name), XDR_SignedSurveyRequestMessage(u.SignedSurveyRequestMessage()))
		return
	case SURVEY_RESPONSE:
		x.Marshal(x.Sprintf("%ssignedSurveyResponseMessage", name), XDR_SignedSurveyResponseMessage(u.SignedSurveyResponseMessage()))
		return
	case GET_SCP_QUORUMSET:
		x.Marshal(x.Sprintf("%sqSetHash", name), XDR_Uint256(u.QSetHash()))
		return
	case SCP_QUORUMSET:
		x.Marshal(x.Sprintf("%sqSet", name), XDR_SCPQuorumSet(u.QSet()))
		return
	case SCP_MESSAGE:
		x.Marshal(x.Sprintf("%senvelope", name), XDR_SCPEnvelope(u.Envelope()))
		return
	case GET_SCP_STATE:
		x.Marshal(x.Sprintf("%sgetSCPLedgerSeq", name), XDR_Uint32(u.GetSCPLedgerSeq()))
		return
	case SEND_MORE:
		x.Marshal(x.Sprintf("%ssendMoreMessage", name), XDR_SendMore(u.SendMoreMessage()))
		return
	case FLOOD_ADVERT:
		x.Marshal(x.Sprintf("%sfloodAdvert", name), XDR_FloodAdvert(u.FloodAdvert()))
		return
	case FLOOD_DEMAND:
		x.Marshal(x.Sprintf("%sfloodDemand", name), XDR_FloodDemand(u.FloodDemand()))
		return
	}
	XdrPanic("invalid Type (%v) in StellarMessage", u.Type)
}
func XDR_StellarMessage(v *StellarMessage) *StellarMessage { return v }

type XdrType_XdrAnon_AuthenticatedMessage_V0 = *XdrAnon_AuthenticatedMessage_V0

func (v *XdrAnon_AuthenticatedMessage_V0) XdrPointer() interface{}       { return v }
func (XdrAnon_AuthenticatedMessage_V0) XdrTypeName() string              { return "XdrAnon_AuthenticatedMessage_V0" }
func (v XdrAnon_AuthenticatedMessage_V0) XdrValue() interface{}          { return v }
func (v *XdrAnon_AuthenticatedMessage_V0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_AuthenticatedMessage_V0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssequence", name), XDR_Uint64(&v.Sequence))
	x.Marshal(x.Sprintf("%smessage", name), XDR_StellarMessage(&v.Message))
	x.Marshal(x.Sprintf("%smac", name), XDR_HmacSha256Mac(&v.Mac))
}
func XDR_XdrAnon_AuthenticatedMessage_V0(v *XdrAnon_AuthenticatedMessage_V0) *XdrAnon_AuthenticatedMessage_V0 {
	return v
}

var _XdrTags_AuthenticatedMessage = map[int32]bool{
	XdrToI32(0): true,
}

func (_ AuthenticatedMessage) XdrValidTags() map[int32]bool {
	return _XdrTags_AuthenticatedMessage
}
func (u *AuthenticatedMessage) V0() *XdrAnon_AuthenticatedMessage_V0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*XdrAnon_AuthenticatedMessage_V0); ok {
			return v
		} else {
			var zero XdrAnon_AuthenticatedMessage_V0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AuthenticatedMessage.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u AuthenticatedMessage) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *AuthenticatedMessage) XdrUnionTag() XdrNum32 {
	return XDR_Uint32(&u.V)
}
func (u *AuthenticatedMessage) XdrUnionTagName() string {
	return "V"
}
func (u *AuthenticatedMessage) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_XdrAnon_AuthenticatedMessage_V0(u.V0())
	}
	return nil
}
func (u *AuthenticatedMessage) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}

type XdrType_AuthenticatedMessage = *AuthenticatedMessage

func (v *AuthenticatedMessage) XdrPointer() interface{}       { return v }
func (AuthenticatedMessage) XdrTypeName() string              { return "AuthenticatedMessage" }
func (v AuthenticatedMessage) XdrValue() interface{}          { return v }
func (v *AuthenticatedMessage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AuthenticatedMessage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_XdrAnon_AuthenticatedMessage_V0(u.V0()))
		return
	}
	XdrPanic("invalid V (%v) in AuthenticatedMessage", u.V)
}
func XDR_AuthenticatedMessage(v *AuthenticatedMessage) *AuthenticatedMessage { return v }

var _XdrTags_LiquidityPoolParameters = map[int32]bool{
	XdrToI32(LIQUIDITY_POOL_CONSTANT_PRODUCT): true,
}

func (_ LiquidityPoolParameters) XdrValidTags() map[int32]bool {
	return _XdrTags_LiquidityPoolParameters
}
func (u *LiquidityPoolParameters) ConstantProduct() *LiquidityPoolConstantProductParameters {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		if v, ok := u._u.(*LiquidityPoolConstantProductParameters); ok {
			return v
		} else {
			var zero LiquidityPoolConstantProductParameters
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("LiquidityPoolParameters.ConstantProduct accessed when Type == %v", u.Type)
		return nil
	}
}
func (u LiquidityPoolParameters) XdrValid() bool {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return true
	}
	return false
}
func (u *LiquidityPoolParameters) XdrUnionTag() XdrNum32 {
	return XDR_LiquidityPoolType(&u.Type)
}
func (u *LiquidityPoolParameters) XdrUnionTagName() string {
	return "Type"
}
func (u *LiquidityPoolParameters) XdrUnionBody() XdrType {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return XDR_LiquidityPoolConstantProductParameters(u.ConstantProduct())
	}
	return nil
}
func (u *LiquidityPoolParameters) XdrUnionBodyName() string {
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		return "ConstantProduct"
	}
	return ""
}

type XdrType_LiquidityPoolParameters = *LiquidityPoolParameters

func (v *LiquidityPoolParameters) XdrPointer() interface{}       { return v }
func (LiquidityPoolParameters) XdrTypeName() string              { return "LiquidityPoolParameters" }
func (v LiquidityPoolParameters) XdrValue() interface{}          { return v }
func (v *LiquidityPoolParameters) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LiquidityPoolParameters) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LiquidityPoolType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case LIQUIDITY_POOL_CONSTANT_PRODUCT:
		x.Marshal(x.Sprintf("%sconstantProduct", name), XDR_LiquidityPoolConstantProductParameters(u.ConstantProduct()))
		return
	}
	XdrPanic("invalid Type (%v) in LiquidityPoolParameters", u.Type)
}
func XDR_LiquidityPoolParameters(v *LiquidityPoolParameters) *LiquidityPoolParameters { return v }

type XdrType_XdrAnon_MuxedAccount_Med25519 = *XdrAnon_MuxedAccount_Med25519

func (v *XdrAnon_MuxedAccount_Med25519) XdrPointer() interface{}       { return v }
func (XdrAnon_MuxedAccount_Med25519) XdrTypeName() string              { return "XdrAnon_MuxedAccount_Med25519" }
func (v XdrAnon_MuxedAccount_Med25519) XdrValue() interface{}          { return v }
func (v *XdrAnon_MuxedAccount_Med25519) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_MuxedAccount_Med25519) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sid", name), XDR_Uint64(&v.Id))
	x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(&v.Ed25519))
}
func XDR_XdrAnon_MuxedAccount_Med25519(v *XdrAnon_MuxedAccount_Med25519) *XdrAnon_MuxedAccount_Med25519 {
	return v
}

var _XdrTags_MuxedAccount = map[int32]bool{
	XdrToI32(KEY_TYPE_ED25519):       true,
	XdrToI32(KEY_TYPE_MUXED_ED25519): true,
}

func (_ MuxedAccount) XdrValidTags() map[int32]bool {
	return _XdrTags_MuxedAccount
}
func (u *MuxedAccount) Ed25519() *Uint256 {
	switch u.Type {
	case KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("MuxedAccount.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *MuxedAccount) Med25519() *XdrAnon_MuxedAccount_Med25519 {
	switch u.Type {
	case KEY_TYPE_MUXED_ED25519:
		if v, ok := u._u.(*XdrAnon_MuxedAccount_Med25519); ok {
			return v
		} else {
			var zero XdrAnon_MuxedAccount_Med25519
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("MuxedAccount.Med25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u MuxedAccount) XdrValid() bool {
	switch u.Type {
	case KEY_TYPE_ED25519, KEY_TYPE_MUXED_ED25519:
		return true
	}
	return false
}
func (u *MuxedAccount) XdrUnionTag() XdrNum32 {
	return XDR_CryptoKeyType(&u.Type)
}
func (u *MuxedAccount) XdrUnionTagName() string {
	return "Type"
}
func (u *MuxedAccount) XdrUnionBody() XdrType {
	switch u.Type {
	case KEY_TYPE_ED25519:
		return XDR_Uint256(u.Ed25519())
	case KEY_TYPE_MUXED_ED25519:
		return XDR_XdrAnon_MuxedAccount_Med25519(u.Med25519())
	}
	return nil
}
func (u *MuxedAccount) XdrUnionBodyName() string {
	switch u.Type {
	case KEY_TYPE_ED25519:
		return "Ed25519"
	case KEY_TYPE_MUXED_ED25519:
		return "Med25519"
	}
	return ""
}

type XdrType_MuxedAccount = *MuxedAccount

func (v *MuxedAccount) XdrPointer() interface{}       { return v }
func (MuxedAccount) XdrTypeName() string              { return "MuxedAccount" }
func (v MuxedAccount) XdrValue() interface{}          { return v }
func (v *MuxedAccount) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *MuxedAccount) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_CryptoKeyType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case KEY_TYPE_ED25519:
		x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(u.Ed25519()))
		return
	case KEY_TYPE_MUXED_ED25519:
		x.Marshal(x.Sprintf("%smed25519", name), XDR_XdrAnon_MuxedAccount_Med25519(u.Med25519()))
		return
	}
	XdrPanic("invalid Type (%v) in MuxedAccount", u.Type)
}
func XDR_MuxedAccount(v *MuxedAccount) *MuxedAccount { return v }

type XdrType_DecoratedSignature = *DecoratedSignature

func (v *DecoratedSignature) XdrPointer() interface{}       { return v }
func (DecoratedSignature) XdrTypeName() string              { return "DecoratedSignature" }
func (v DecoratedSignature) XdrValue() interface{}          { return v }
func (v *DecoratedSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DecoratedSignature) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%shint", name), XDR_SignatureHint(&v.Hint))
	x.Marshal(x.Sprintf("%ssignature", name), XDR_Signature(&v.Signature))
}
func XDR_DecoratedSignature(v *DecoratedSignature) *DecoratedSignature { return v }

type _XdrVec_unbounded_LedgerKey []LedgerKey

func (_XdrVec_unbounded_LedgerKey) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_LedgerKey) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_LedgerKey length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_LedgerKey length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_LedgerKey) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_LedgerKey) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]LedgerKey, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_LedgerKey) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_LedgerKey(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_LedgerKey) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_LedgerKey) XdrTypeName() string              { return "LedgerKey<>" }
func (v *_XdrVec_unbounded_LedgerKey) XdrPointer() interface{}       { return (*[]LedgerKey)(v) }
func (v _XdrVec_unbounded_LedgerKey) XdrValue() interface{}          { return ([]LedgerKey)(v) }
func (v *_XdrVec_unbounded_LedgerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LedgerFootprint = *LedgerFootprint

func (v *LedgerFootprint) XdrPointer() interface{}       { return v }
func (LedgerFootprint) XdrTypeName() string              { return "LedgerFootprint" }
func (v LedgerFootprint) XdrValue() interface{}          { return v }
func (v *LedgerFootprint) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerFootprint) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sreadOnly", name), (*_XdrVec_unbounded_LedgerKey)(&v.ReadOnly))
	x.Marshal(x.Sprintf("%sreadWrite", name), (*_XdrVec_unbounded_LedgerKey)(&v.ReadWrite))
}
func XDR_LedgerFootprint(v *LedgerFootprint) *LedgerFootprint { return v }

var _XdrNames_OperationType = map[int32]string{
	int32(CREATE_ACCOUNT):                   "CREATE_ACCOUNT",
	int32(PAYMENT):                          "PAYMENT",
	int32(PATH_PAYMENT_STRICT_RECEIVE):      "PATH_PAYMENT_STRICT_RECEIVE",
	int32(MANAGE_SELL_OFFER):                "MANAGE_SELL_OFFER",
	int32(CREATE_PASSIVE_SELL_OFFER):        "CREATE_PASSIVE_SELL_OFFER",
	int32(SET_OPTIONS):                      "SET_OPTIONS",
	int32(CHANGE_TRUST):                     "CHANGE_TRUST",
	int32(ALLOW_TRUST):                      "ALLOW_TRUST",
	int32(ACCOUNT_MERGE):                    "ACCOUNT_MERGE",
	int32(INFLATION):                        "INFLATION",
	int32(MANAGE_DATA):                      "MANAGE_DATA",
	int32(BUMP_SEQUENCE):                    "BUMP_SEQUENCE",
	int32(MANAGE_BUY_OFFER):                 "MANAGE_BUY_OFFER",
	int32(PATH_PAYMENT_STRICT_SEND):         "PATH_PAYMENT_STRICT_SEND",
	int32(CREATE_CLAIMABLE_BALANCE):         "CREATE_CLAIMABLE_BALANCE",
	int32(CLAIM_CLAIMABLE_BALANCE):          "CLAIM_CLAIMABLE_BALANCE",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES): "BEGIN_SPONSORING_FUTURE_RESERVES",
	int32(END_SPONSORING_FUTURE_RESERVES):   "END_SPONSORING_FUTURE_RESERVES",
	int32(REVOKE_SPONSORSHIP):               "REVOKE_SPONSORSHIP",
	int32(CLAWBACK):                         "CLAWBACK",
	int32(CLAWBACK_CLAIMABLE_BALANCE):       "CLAWBACK_CLAIMABLE_BALANCE",
	int32(SET_TRUST_LINE_FLAGS):             "SET_TRUST_LINE_FLAGS",
	int32(LIQUIDITY_POOL_DEPOSIT):           "LIQUIDITY_POOL_DEPOSIT",
	int32(LIQUIDITY_POOL_WITHDRAW):          "LIQUIDITY_POOL_WITHDRAW",
	int32(INVOKE_HOST_FUNCTION):             "INVOKE_HOST_FUNCTION",
}
var _XdrValues_OperationType = map[string]int32{
	"CREATE_ACCOUNT":                   int32(CREATE_ACCOUNT),
	"PAYMENT":                          int32(PAYMENT),
	"PATH_PAYMENT_STRICT_RECEIVE":      int32(PATH_PAYMENT_STRICT_RECEIVE),
	"MANAGE_SELL_OFFER":                int32(MANAGE_SELL_OFFER),
	"CREATE_PASSIVE_SELL_OFFER":        int32(CREATE_PASSIVE_SELL_OFFER),
	"SET_OPTIONS":                      int32(SET_OPTIONS),
	"CHANGE_TRUST":                     int32(CHANGE_TRUST),
	"ALLOW_TRUST":                      int32(ALLOW_TRUST),
	"ACCOUNT_MERGE":                    int32(ACCOUNT_MERGE),
	"INFLATION":                        int32(INFLATION),
	"MANAGE_DATA":                      int32(MANAGE_DATA),
	"BUMP_SEQUENCE":                    int32(BUMP_SEQUENCE),
	"MANAGE_BUY_OFFER":                 int32(MANAGE_BUY_OFFER),
	"PATH_PAYMENT_STRICT_SEND":         int32(PATH_PAYMENT_STRICT_SEND),
	"CREATE_CLAIMABLE_BALANCE":         int32(CREATE_CLAIMABLE_BALANCE),
	"CLAIM_CLAIMABLE_BALANCE":          int32(CLAIM_CLAIMABLE_BALANCE),
	"BEGIN_SPONSORING_FUTURE_RESERVES": int32(BEGIN_SPONSORING_FUTURE_RESERVES),
	"END_SPONSORING_FUTURE_RESERVES":   int32(END_SPONSORING_FUTURE_RESERVES),
	"REVOKE_SPONSORSHIP":               int32(REVOKE_SPONSORSHIP),
	"CLAWBACK":                         int32(CLAWBACK),
	"CLAWBACK_CLAIMABLE_BALANCE":       int32(CLAWBACK_CLAIMABLE_BALANCE),
	"SET_TRUST_LINE_FLAGS":             int32(SET_TRUST_LINE_FLAGS),
	"LIQUIDITY_POOL_DEPOSIT":           int32(LIQUIDITY_POOL_DEPOSIT),
	"LIQUIDITY_POOL_WITHDRAW":          int32(LIQUIDITY_POOL_WITHDRAW),
	"INVOKE_HOST_FUNCTION":             int32(INVOKE_HOST_FUNCTION),
}

func (OperationType) XdrEnumNames() map[int32]string {
	return _XdrNames_OperationType
}
func (v OperationType) String() string {
	if s, ok := _XdrNames_OperationType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OperationType#%d", v)
}
func (v *OperationType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OperationType[stok]; ok {
			*v = OperationType(val)
			return nil
		} else if stok == "OperationType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OperationType.", stok))
	}
}
func (v OperationType) GetU32() uint32                 { return uint32(v) }
func (v *OperationType) SetU32(n uint32)               { *v = OperationType(n) }
func (v *OperationType) XdrPointer() interface{}       { return v }
func (OperationType) XdrTypeName() string              { return "OperationType" }
func (v OperationType) XdrValue() interface{}          { return v }
func (v *OperationType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_OperationType = *OperationType

func XDR_OperationType(v *OperationType) *OperationType { return v }

type XdrType_CreateAccountOp = *CreateAccountOp

func (v *CreateAccountOp) XdrPointer() interface{}       { return v }
func (CreateAccountOp) XdrTypeName() string              { return "CreateAccountOp" }
func (v CreateAccountOp) XdrValue() interface{}          { return v }
func (v *CreateAccountOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreateAccountOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_AccountID(&v.Destination))
	x.Marshal(x.Sprintf("%sstartingBalance", name), XDR_Int64(&v.StartingBalance))
}
func XDR_CreateAccountOp(v *CreateAccountOp) *CreateAccountOp { return v }

type XdrType_PaymentOp = *PaymentOp

func (v *PaymentOp) XdrPointer() interface{}       { return v }
func (PaymentOp) XdrTypeName() string              { return "PaymentOp" }
func (v PaymentOp) XdrValue() interface{}          { return v }
func (v *PaymentOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PaymentOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_MuxedAccount(&v.Destination))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
}
func XDR_PaymentOp(v *PaymentOp) *PaymentOp { return v }

type _XdrVec_5_Asset []Asset

func (_XdrVec_5_Asset) XdrBound() uint32 {
	const bound uint32 = 5 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_5_Asset) XdrCheckLen(length uint32) {
	if length > uint32(5) {
		XdrPanic("_XdrVec_5_Asset length %d exceeds bound 5", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_5_Asset length %d exceeds max int", length)
	}
}
func (v _XdrVec_5_Asset) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_5_Asset) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(5); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Asset, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_5_Asset) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Asset(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_5_Asset) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 5}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_5_Asset) XdrTypeName() string              { return "Asset<>" }
func (v *_XdrVec_5_Asset) XdrPointer() interface{}       { return (*[]Asset)(v) }
func (v _XdrVec_5_Asset) XdrValue() interface{}          { return ([]Asset)(v) }
func (v *_XdrVec_5_Asset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PathPaymentStrictReceiveOp = *PathPaymentStrictReceiveOp

func (v *PathPaymentStrictReceiveOp) XdrPointer() interface{}       { return v }
func (PathPaymentStrictReceiveOp) XdrTypeName() string              { return "PathPaymentStrictReceiveOp" }
func (v PathPaymentStrictReceiveOp) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictReceiveOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PathPaymentStrictReceiveOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssendAsset", name), XDR_Asset(&v.SendAsset))
	x.Marshal(x.Sprintf("%ssendMax", name), XDR_Int64(&v.SendMax))
	x.Marshal(x.Sprintf("%sdestination", name), XDR_MuxedAccount(&v.Destination))
	x.Marshal(x.Sprintf("%sdestAsset", name), XDR_Asset(&v.DestAsset))
	x.Marshal(x.Sprintf("%sdestAmount", name), XDR_Int64(&v.DestAmount))
	x.Marshal(x.Sprintf("%spath", name), (*_XdrVec_5_Asset)(&v.Path))
}
func XDR_PathPaymentStrictReceiveOp(v *PathPaymentStrictReceiveOp) *PathPaymentStrictReceiveOp {
	return v
}

type XdrType_PathPaymentStrictSendOp = *PathPaymentStrictSendOp

func (v *PathPaymentStrictSendOp) XdrPointer() interface{}       { return v }
func (PathPaymentStrictSendOp) XdrTypeName() string              { return "PathPaymentStrictSendOp" }
func (v PathPaymentStrictSendOp) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictSendOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PathPaymentStrictSendOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssendAsset", name), XDR_Asset(&v.SendAsset))
	x.Marshal(x.Sprintf("%ssendAmount", name), XDR_Int64(&v.SendAmount))
	x.Marshal(x.Sprintf("%sdestination", name), XDR_MuxedAccount(&v.Destination))
	x.Marshal(x.Sprintf("%sdestAsset", name), XDR_Asset(&v.DestAsset))
	x.Marshal(x.Sprintf("%sdestMin", name), XDR_Int64(&v.DestMin))
	x.Marshal(x.Sprintf("%spath", name), (*_XdrVec_5_Asset)(&v.Path))
}
func XDR_PathPaymentStrictSendOp(v *PathPaymentStrictSendOp) *PathPaymentStrictSendOp { return v }

type XdrType_ManageSellOfferOp = *ManageSellOfferOp

func (v *ManageSellOfferOp) XdrPointer() interface{}       { return v }
func (ManageSellOfferOp) XdrTypeName() string              { return "ManageSellOfferOp" }
func (v ManageSellOfferOp) XdrValue() interface{}          { return v }
func (v *ManageSellOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageSellOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sselling", name), XDR_Asset(&v.Selling))
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Asset(&v.Buying))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sprice", name), XDR_Price(&v.Price))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
}
func XDR_ManageSellOfferOp(v *ManageSellOfferOp) *ManageSellOfferOp { return v }

type XdrType_ManageBuyOfferOp = *ManageBuyOfferOp

func (v *ManageBuyOfferOp) XdrPointer() interface{}       { return v }
func (ManageBuyOfferOp) XdrTypeName() string              { return "ManageBuyOfferOp" }
func (v ManageBuyOfferOp) XdrValue() interface{}          { return v }
func (v *ManageBuyOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageBuyOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sselling", name), XDR_Asset(&v.Selling))
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Asset(&v.Buying))
	x.Marshal(x.Sprintf("%sbuyAmount", name), XDR_Int64(&v.BuyAmount))
	x.Marshal(x.Sprintf("%sprice", name), XDR_Price(&v.Price))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
}
func XDR_ManageBuyOfferOp(v *ManageBuyOfferOp) *ManageBuyOfferOp { return v }

type XdrType_CreatePassiveSellOfferOp = *CreatePassiveSellOfferOp

func (v *CreatePassiveSellOfferOp) XdrPointer() interface{}       { return v }
func (CreatePassiveSellOfferOp) XdrTypeName() string              { return "CreatePassiveSellOfferOp" }
func (v CreatePassiveSellOfferOp) XdrValue() interface{}          { return v }
func (v *CreatePassiveSellOfferOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreatePassiveSellOfferOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sselling", name), XDR_Asset(&v.Selling))
	x.Marshal(x.Sprintf("%sbuying", name), XDR_Asset(&v.Buying))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sprice", name), XDR_Price(&v.Price))
}
func XDR_CreatePassiveSellOfferOp(v *CreatePassiveSellOfferOp) *CreatePassiveSellOfferOp { return v }

type _XdrPtr_Uint32 struct {
	p **Uint32
}
type _ptrflag_Uint32 _XdrPtr_Uint32

func (v _ptrflag_Uint32) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Uint32) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Uint32 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Uint32) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Uint32) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Uint32)
		}
	default:
		XdrPanic("*Uint32 present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Uint32) XdrTypeName() string             { return "Uint32?" }
func (v _ptrflag_Uint32) XdrPointer() interface{}       { return nil }
func (v _ptrflag_Uint32) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_Uint32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Uint32) XdrBound() uint32              { return 1 }
func (v _XdrPtr_Uint32) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_Uint32) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Uint32)
	}
}
func (v _XdrPtr_Uint32) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Uint32(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Uint32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Uint32) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Uint32(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Uint32) XdrTypeName() string       { return "Uint32*" }
func (v _XdrPtr_Uint32) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Uint32) XdrValue() interface{}   { return *v.p }

type _XdrPtr_String32 struct {
	p **String32
}
type _ptrflag_String32 _XdrPtr_String32

func (v _ptrflag_String32) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_String32) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("String32 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_String32) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_String32) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(String32)
		}
	default:
		XdrPanic("*String32 present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_String32) XdrTypeName() string             { return "String32?" }
func (v _ptrflag_String32) XdrPointer() interface{}       { return nil }
func (v _ptrflag_String32) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_String32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_String32) XdrBound() uint32              { return 1 }
func (v _XdrPtr_String32) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_String32) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(String32)
	}
}
func (v _XdrPtr_String32) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_String32(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_String32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_String32) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_String32(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_String32) XdrTypeName() string       { return "String32*" }
func (v _XdrPtr_String32) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_String32) XdrValue() interface{}   { return *v.p }

type _XdrPtr_Signer struct {
	p **Signer
}
type _ptrflag_Signer _XdrPtr_Signer

func (v _ptrflag_Signer) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Signer) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Signer flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Signer) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Signer) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Signer)
		}
	default:
		XdrPanic("*Signer present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Signer) XdrTypeName() string             { return "Signer?" }
func (v _ptrflag_Signer) XdrPointer() interface{}       { return nil }
func (v _ptrflag_Signer) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Signer) XdrBound() uint32              { return 1 }
func (v _XdrPtr_Signer) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_Signer) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Signer)
	}
}
func (v _XdrPtr_Signer) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Signer(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Signer) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Signer(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Signer) XdrTypeName() string       { return "Signer*" }
func (v _XdrPtr_Signer) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Signer) XdrValue() interface{}   { return *v.p }

type XdrType_SetOptionsOp = *SetOptionsOp

func (v *SetOptionsOp) XdrPointer() interface{}       { return v }
func (SetOptionsOp) XdrTypeName() string              { return "SetOptionsOp" }
func (v SetOptionsOp) XdrValue() interface{}          { return v }
func (v *SetOptionsOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SetOptionsOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sinflationDest", name), _XdrPtr_AccountID{&v.InflationDest})
	x.Marshal(x.Sprintf("%sclearFlags", name), _XdrPtr_Uint32{&v.ClearFlags})
	x.Marshal(x.Sprintf("%ssetFlags", name), _XdrPtr_Uint32{&v.SetFlags})
	x.Marshal(x.Sprintf("%smasterWeight", name), _XdrPtr_Uint32{&v.MasterWeight})
	x.Marshal(x.Sprintf("%slowThreshold", name), _XdrPtr_Uint32{&v.LowThreshold})
	x.Marshal(x.Sprintf("%smedThreshold", name), _XdrPtr_Uint32{&v.MedThreshold})
	x.Marshal(x.Sprintf("%shighThreshold", name), _XdrPtr_Uint32{&v.HighThreshold})
	x.Marshal(x.Sprintf("%shomeDomain", name), _XdrPtr_String32{&v.HomeDomain})
	x.Marshal(x.Sprintf("%ssigner", name), _XdrPtr_Signer{&v.Signer})
}
func XDR_SetOptionsOp(v *SetOptionsOp) *SetOptionsOp { return v }

var _XdrTags_ChangeTrustAsset = map[int32]bool{
	XdrToI32(ASSET_TYPE_NATIVE):            true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM4):  true,
	XdrToI32(ASSET_TYPE_CREDIT_ALPHANUM12): true,
	XdrToI32(ASSET_TYPE_POOL_SHARE):        true,
}

func (_ ChangeTrustAsset) XdrValidTags() map[int32]bool {
	return _XdrTags_ChangeTrustAsset
}
func (u *ChangeTrustAsset) AlphaNum4() *AlphaNum4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*AlphaNum4); ok {
			return v
		} else {
			var zero AlphaNum4
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ChangeTrustAsset.AlphaNum4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ChangeTrustAsset) AlphaNum12() *AlphaNum12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*AlphaNum12); ok {
			return v
		} else {
			var zero AlphaNum12
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ChangeTrustAsset.AlphaNum12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ChangeTrustAsset) LiquidityPool() *LiquidityPoolParameters {
	switch u.Type {
	case ASSET_TYPE_POOL_SHARE:
		if v, ok := u._u.(*LiquidityPoolParameters); ok {
			return v
		} else {
			var zero LiquidityPoolParameters
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ChangeTrustAsset.LiquidityPool accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ChangeTrustAsset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_NATIVE, ASSET_TYPE_CREDIT_ALPHANUM4, ASSET_TYPE_CREDIT_ALPHANUM12, ASSET_TYPE_POOL_SHARE:
		return true
	}
	return false
}
func (u *ChangeTrustAsset) XdrUnionTag() XdrNum32 {
	return XDR_AssetType(&u.Type)
}
func (u *ChangeTrustAsset) XdrUnionTagName() string {
	return "Type"
}
func (u *ChangeTrustAsset) XdrUnionBody() XdrType {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return nil
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return XDR_AlphaNum4(u.AlphaNum4())
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return XDR_AlphaNum12(u.AlphaNum12())
	case ASSET_TYPE_POOL_SHARE:
		return XDR_LiquidityPoolParameters(u.LiquidityPool())
	}
	return nil
}
func (u *ChangeTrustAsset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return ""
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AlphaNum4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AlphaNum12"
	case ASSET_TYPE_POOL_SHARE:
		return "LiquidityPool"
	}
	return ""
}

type XdrType_ChangeTrustAsset = *ChangeTrustAsset

func (v *ChangeTrustAsset) XdrPointer() interface{}       { return v }
func (ChangeTrustAsset) XdrTypeName() string              { return "ChangeTrustAsset" }
func (v ChangeTrustAsset) XdrValue() interface{}          { return v }
func (v *ChangeTrustAsset) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ChangeTrustAsset) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		x.Marshal(x.Sprintf("%salphaNum4", name), XDR_AlphaNum4(u.AlphaNum4()))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		x.Marshal(x.Sprintf("%salphaNum12", name), XDR_AlphaNum12(u.AlphaNum12()))
		return
	case ASSET_TYPE_POOL_SHARE:
		x.Marshal(x.Sprintf("%sliquidityPool", name), XDR_LiquidityPoolParameters(u.LiquidityPool()))
		return
	}
	XdrPanic("invalid Type (%v) in ChangeTrustAsset", u.Type)
}
func XDR_ChangeTrustAsset(v *ChangeTrustAsset) *ChangeTrustAsset { return v }

type XdrType_ChangeTrustOp = *ChangeTrustOp

func (v *ChangeTrustOp) XdrPointer() interface{}       { return v }
func (ChangeTrustOp) XdrTypeName() string              { return "ChangeTrustOp" }
func (v ChangeTrustOp) XdrValue() interface{}          { return v }
func (v *ChangeTrustOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ChangeTrustOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sline", name), XDR_ChangeTrustAsset(&v.Line))
	x.Marshal(x.Sprintf("%slimit", name), XDR_Int64(&v.Limit))
}
func XDR_ChangeTrustOp(v *ChangeTrustOp) *ChangeTrustOp { return v }

type XdrType_AllowTrustOp = *AllowTrustOp

func (v *AllowTrustOp) XdrPointer() interface{}       { return v }
func (AllowTrustOp) XdrTypeName() string              { return "AllowTrustOp" }
func (v AllowTrustOp) XdrValue() interface{}          { return v }
func (v *AllowTrustOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *AllowTrustOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%strustor", name), XDR_AccountID(&v.Trustor))
	x.Marshal(x.Sprintf("%sasset", name), XDR_AssetCode(&v.Asset))
	x.Marshal(x.Sprintf("%sauthorize", name), XDR_Uint32(&v.Authorize))
}
func XDR_AllowTrustOp(v *AllowTrustOp) *AllowTrustOp { return v }

type _XdrPtr_DataValue struct {
	p **DataValue
}
type _ptrflag_DataValue _XdrPtr_DataValue

func (v _ptrflag_DataValue) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_DataValue) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("DataValue flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_DataValue) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_DataValue) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(DataValue)
		}
	default:
		XdrPanic("*DataValue present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_DataValue) XdrTypeName() string             { return "DataValue?" }
func (v _ptrflag_DataValue) XdrPointer() interface{}       { return nil }
func (v _ptrflag_DataValue) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_DataValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_DataValue) XdrBound() uint32              { return 1 }
func (v _XdrPtr_DataValue) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_DataValue) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(DataValue)
	}
}
func (v _XdrPtr_DataValue) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_DataValue(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_DataValue) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_DataValue) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_DataValue(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_DataValue) XdrTypeName() string       { return "DataValue*" }
func (v _XdrPtr_DataValue) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_DataValue) XdrValue() interface{}   { return *v.p }

type XdrType_ManageDataOp = *ManageDataOp

func (v *ManageDataOp) XdrPointer() interface{}       { return v }
func (ManageDataOp) XdrTypeName() string              { return "ManageDataOp" }
func (v ManageDataOp) XdrValue() interface{}          { return v }
func (v *ManageDataOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageDataOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdataName", name), XDR_String64(&v.DataName))
	x.Marshal(x.Sprintf("%sdataValue", name), _XdrPtr_DataValue{&v.DataValue})
}
func XDR_ManageDataOp(v *ManageDataOp) *ManageDataOp { return v }

type XdrType_BumpSequenceOp = *BumpSequenceOp

func (v *BumpSequenceOp) XdrPointer() interface{}       { return v }
func (BumpSequenceOp) XdrTypeName() string              { return "BumpSequenceOp" }
func (v BumpSequenceOp) XdrValue() interface{}          { return v }
func (v *BumpSequenceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BumpSequenceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbumpTo", name), XDR_SequenceNumber(&v.BumpTo))
}
func XDR_BumpSequenceOp(v *BumpSequenceOp) *BumpSequenceOp { return v }

type XdrType_CreateClaimableBalanceOp = *CreateClaimableBalanceOp

func (v *CreateClaimableBalanceOp) XdrPointer() interface{}       { return v }
func (CreateClaimableBalanceOp) XdrTypeName() string              { return "CreateClaimableBalanceOp" }
func (v CreateClaimableBalanceOp) XdrValue() interface{}          { return v }
func (v *CreateClaimableBalanceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CreateClaimableBalanceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sclaimants", name), (*_XdrVec_10_Claimant)(&v.Claimants))
}
func XDR_CreateClaimableBalanceOp(v *CreateClaimableBalanceOp) *CreateClaimableBalanceOp { return v }

type XdrType_ClaimClaimableBalanceOp = *ClaimClaimableBalanceOp

func (v *ClaimClaimableBalanceOp) XdrPointer() interface{}       { return v }
func (ClaimClaimableBalanceOp) XdrTypeName() string              { return "ClaimClaimableBalanceOp" }
func (v ClaimClaimableBalanceOp) XdrValue() interface{}          { return v }
func (v *ClaimClaimableBalanceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimClaimableBalanceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(&v.BalanceID))
}
func XDR_ClaimClaimableBalanceOp(v *ClaimClaimableBalanceOp) *ClaimClaimableBalanceOp { return v }

type XdrType_BeginSponsoringFutureReservesOp = *BeginSponsoringFutureReservesOp

func (v *BeginSponsoringFutureReservesOp) XdrPointer() interface{}       { return v }
func (BeginSponsoringFutureReservesOp) XdrTypeName() string              { return "BeginSponsoringFutureReservesOp" }
func (v BeginSponsoringFutureReservesOp) XdrValue() interface{}          { return v }
func (v *BeginSponsoringFutureReservesOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *BeginSponsoringFutureReservesOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssponsoredID", name), XDR_AccountID(&v.SponsoredID))
}
func XDR_BeginSponsoringFutureReservesOp(v *BeginSponsoringFutureReservesOp) *BeginSponsoringFutureReservesOp {
	return v
}

var _XdrNames_RevokeSponsorshipType = map[int32]string{
	int32(REVOKE_SPONSORSHIP_LEDGER_ENTRY): "REVOKE_SPONSORSHIP_LEDGER_ENTRY",
	int32(REVOKE_SPONSORSHIP_SIGNER):       "REVOKE_SPONSORSHIP_SIGNER",
}
var _XdrValues_RevokeSponsorshipType = map[string]int32{
	"REVOKE_SPONSORSHIP_LEDGER_ENTRY": int32(REVOKE_SPONSORSHIP_LEDGER_ENTRY),
	"REVOKE_SPONSORSHIP_SIGNER":       int32(REVOKE_SPONSORSHIP_SIGNER),
}

func (RevokeSponsorshipType) XdrEnumNames() map[int32]string {
	return _XdrNames_RevokeSponsorshipType
}
func (v RevokeSponsorshipType) String() string {
	if s, ok := _XdrNames_RevokeSponsorshipType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("RevokeSponsorshipType#%d", v)
}
func (v *RevokeSponsorshipType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_RevokeSponsorshipType[stok]; ok {
			*v = RevokeSponsorshipType(val)
			return nil
		} else if stok == "RevokeSponsorshipType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid RevokeSponsorshipType.", stok))
	}
}
func (v RevokeSponsorshipType) GetU32() uint32                 { return uint32(v) }
func (v *RevokeSponsorshipType) SetU32(n uint32)               { *v = RevokeSponsorshipType(n) }
func (v *RevokeSponsorshipType) XdrPointer() interface{}       { return v }
func (RevokeSponsorshipType) XdrTypeName() string              { return "RevokeSponsorshipType" }
func (v RevokeSponsorshipType) XdrValue() interface{}          { return v }
func (v *RevokeSponsorshipType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_RevokeSponsorshipType = *RevokeSponsorshipType

func XDR_RevokeSponsorshipType(v *RevokeSponsorshipType) *RevokeSponsorshipType { return v }

type XdrType_XdrAnon_RevokeSponsorshipOp_Signer = *XdrAnon_RevokeSponsorshipOp_Signer

func (v *XdrAnon_RevokeSponsorshipOp_Signer) XdrPointer() interface{} { return v }
func (XdrAnon_RevokeSponsorshipOp_Signer) XdrTypeName() string {
	return "XdrAnon_RevokeSponsorshipOp_Signer"
}
func (v XdrAnon_RevokeSponsorshipOp_Signer) XdrValue() interface{}          { return v }
func (v *XdrAnon_RevokeSponsorshipOp_Signer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_RevokeSponsorshipOp_Signer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(&v.AccountID))
	x.Marshal(x.Sprintf("%ssignerKey", name), XDR_SignerKey(&v.SignerKey))
}
func XDR_XdrAnon_RevokeSponsorshipOp_Signer(v *XdrAnon_RevokeSponsorshipOp_Signer) *XdrAnon_RevokeSponsorshipOp_Signer {
	return v
}

var _XdrTags_RevokeSponsorshipOp = map[int32]bool{
	XdrToI32(REVOKE_SPONSORSHIP_LEDGER_ENTRY): true,
	XdrToI32(REVOKE_SPONSORSHIP_SIGNER):       true,
}

func (_ RevokeSponsorshipOp) XdrValidTags() map[int32]bool {
	return _XdrTags_RevokeSponsorshipOp
}
func (u *RevokeSponsorshipOp) LedgerKey() *LedgerKey {
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("RevokeSponsorshipOp.LedgerKey accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *RevokeSponsorshipOp) Signer() *XdrAnon_RevokeSponsorshipOp_Signer {
	switch u.Type {
	case REVOKE_SPONSORSHIP_SIGNER:
		if v, ok := u._u.(*XdrAnon_RevokeSponsorshipOp_Signer); ok {
			return v
		} else {
			var zero XdrAnon_RevokeSponsorshipOp_Signer
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("RevokeSponsorshipOp.Signer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u RevokeSponsorshipOp) XdrValid() bool {
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY, REVOKE_SPONSORSHIP_SIGNER:
		return true
	}
	return false
}
func (u *RevokeSponsorshipOp) XdrUnionTag() XdrNum32 {
	return XDR_RevokeSponsorshipType(&u.Type)
}
func (u *RevokeSponsorshipOp) XdrUnionTagName() string {
	return "Type"
}
func (u *RevokeSponsorshipOp) XdrUnionBody() XdrType {
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
		return XDR_LedgerKey(u.LedgerKey())
	case REVOKE_SPONSORSHIP_SIGNER:
		return XDR_XdrAnon_RevokeSponsorshipOp_Signer(u.Signer())
	}
	return nil
}
func (u *RevokeSponsorshipOp) XdrUnionBodyName() string {
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
		return "LedgerKey"
	case REVOKE_SPONSORSHIP_SIGNER:
		return "Signer"
	}
	return ""
}

type XdrType_RevokeSponsorshipOp = *RevokeSponsorshipOp

func (v *RevokeSponsorshipOp) XdrPointer() interface{}       { return v }
func (RevokeSponsorshipOp) XdrTypeName() string              { return "RevokeSponsorshipOp" }
func (v RevokeSponsorshipOp) XdrValue() interface{}          { return v }
func (v *RevokeSponsorshipOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *RevokeSponsorshipOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_RevokeSponsorshipType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
		x.Marshal(x.Sprintf("%sledgerKey", name), XDR_LedgerKey(u.LedgerKey()))
		return
	case REVOKE_SPONSORSHIP_SIGNER:
		x.Marshal(x.Sprintf("%ssigner", name), XDR_XdrAnon_RevokeSponsorshipOp_Signer(u.Signer()))
		return
	}
	XdrPanic("invalid Type (%v) in RevokeSponsorshipOp", u.Type)
}
func XDR_RevokeSponsorshipOp(v *RevokeSponsorshipOp) *RevokeSponsorshipOp { return v }

type XdrType_ClawbackOp = *ClawbackOp

func (v *ClawbackOp) XdrPointer() interface{}       { return v }
func (ClawbackOp) XdrTypeName() string              { return "ClawbackOp" }
func (v ClawbackOp) XdrValue() interface{}          { return v }
func (v *ClawbackOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClawbackOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%sfrom", name), XDR_MuxedAccount(&v.From))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
}
func XDR_ClawbackOp(v *ClawbackOp) *ClawbackOp { return v }

type XdrType_ClawbackClaimableBalanceOp = *ClawbackClaimableBalanceOp

func (v *ClawbackClaimableBalanceOp) XdrPointer() interface{}       { return v }
func (ClawbackClaimableBalanceOp) XdrTypeName() string              { return "ClawbackClaimableBalanceOp" }
func (v ClawbackClaimableBalanceOp) XdrValue() interface{}          { return v }
func (v *ClawbackClaimableBalanceOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClawbackClaimableBalanceOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(&v.BalanceID))
}
func XDR_ClawbackClaimableBalanceOp(v *ClawbackClaimableBalanceOp) *ClawbackClaimableBalanceOp {
	return v
}

type XdrType_SetTrustLineFlagsOp = *SetTrustLineFlagsOp

func (v *SetTrustLineFlagsOp) XdrPointer() interface{}       { return v }
func (SetTrustLineFlagsOp) XdrTypeName() string              { return "SetTrustLineFlagsOp" }
func (v SetTrustLineFlagsOp) XdrValue() interface{}          { return v }
func (v *SetTrustLineFlagsOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SetTrustLineFlagsOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%strustor", name), XDR_AccountID(&v.Trustor))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%sclearFlags", name), XDR_Uint32(&v.ClearFlags))
	x.Marshal(x.Sprintf("%ssetFlags", name), XDR_Uint32(&v.SetFlags))
}
func XDR_SetTrustLineFlagsOp(v *SetTrustLineFlagsOp) *SetTrustLineFlagsOp { return v }

type XdrType_LiquidityPoolDepositOp = *LiquidityPoolDepositOp

func (v *LiquidityPoolDepositOp) XdrPointer() interface{}       { return v }
func (LiquidityPoolDepositOp) XdrTypeName() string              { return "LiquidityPoolDepositOp" }
func (v LiquidityPoolDepositOp) XdrValue() interface{}          { return v }
func (v *LiquidityPoolDepositOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LiquidityPoolDepositOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%smaxAmountA", name), XDR_Int64(&v.MaxAmountA))
	x.Marshal(x.Sprintf("%smaxAmountB", name), XDR_Int64(&v.MaxAmountB))
	x.Marshal(x.Sprintf("%sminPrice", name), XDR_Price(&v.MinPrice))
	x.Marshal(x.Sprintf("%smaxPrice", name), XDR_Price(&v.MaxPrice))
}
func XDR_LiquidityPoolDepositOp(v *LiquidityPoolDepositOp) *LiquidityPoolDepositOp { return v }

type XdrType_LiquidityPoolWithdrawOp = *LiquidityPoolWithdrawOp

func (v *LiquidityPoolWithdrawOp) XdrPointer() interface{}       { return v }
func (LiquidityPoolWithdrawOp) XdrTypeName() string              { return "LiquidityPoolWithdrawOp" }
func (v LiquidityPoolWithdrawOp) XdrValue() interface{}          { return v }
func (v *LiquidityPoolWithdrawOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LiquidityPoolWithdrawOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
	x.Marshal(x.Sprintf("%sminAmountA", name), XDR_Int64(&v.MinAmountA))
	x.Marshal(x.Sprintf("%sminAmountB", name), XDR_Int64(&v.MinAmountB))
}
func XDR_LiquidityPoolWithdrawOp(v *LiquidityPoolWithdrawOp) *LiquidityPoolWithdrawOp { return v }

var _XdrNames_HostFunction = map[int32]string{
	int32(HOST_FN_INVOKE_CONTRACT):                           "HOST_FN_INVOKE_CONTRACT",
	int32(HOST_FN_CREATE_CONTRACT_WITH_ED25519):              "HOST_FN_CREATE_CONTRACT_WITH_ED25519",
	int32(HOST_FN_CREATE_CONTRACT_WITH_SOURCE_ACCOUNT):       "HOST_FN_CREATE_CONTRACT_WITH_SOURCE_ACCOUNT",
	int32(HOST_FN_CREATE_TOKEN_CONTRACT_WITH_SOURCE_ACCOUNT): "HOST_FN_CREATE_TOKEN_CONTRACT_WITH_SOURCE_ACCOUNT",
	int32(HOST_FN_CREATE_TOKEN_CONTRACT_WITH_ASSET):          "HOST_FN_CREATE_TOKEN_CONTRACT_WITH_ASSET",
}
var _XdrValues_HostFunction = map[string]int32{
	"HOST_FN_INVOKE_CONTRACT":                           int32(HOST_FN_INVOKE_CONTRACT),
	"HOST_FN_CREATE_CONTRACT_WITH_ED25519":              int32(HOST_FN_CREATE_CONTRACT_WITH_ED25519),
	"HOST_FN_CREATE_CONTRACT_WITH_SOURCE_ACCOUNT":       int32(HOST_FN_CREATE_CONTRACT_WITH_SOURCE_ACCOUNT),
	"HOST_FN_CREATE_TOKEN_CONTRACT_WITH_SOURCE_ACCOUNT": int32(HOST_FN_CREATE_TOKEN_CONTRACT_WITH_SOURCE_ACCOUNT),
	"HOST_FN_CREATE_TOKEN_CONTRACT_WITH_ASSET":          int32(HOST_FN_CREATE_TOKEN_CONTRACT_WITH_ASSET),
}

func (HostFunction) XdrEnumNames() map[int32]string {
	return _XdrNames_HostFunction
}
func (v HostFunction) String() string {
	if s, ok := _XdrNames_HostFunction[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("HostFunction#%d", v)
}
func (v *HostFunction) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_HostFunction[stok]; ok {
			*v = HostFunction(val)
			return nil
		} else if stok == "HostFunction" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid HostFunction.", stok))
	}
}
func (v HostFunction) GetU32() uint32                 { return uint32(v) }
func (v *HostFunction) SetU32(n uint32)               { *v = HostFunction(n) }
func (v *HostFunction) XdrPointer() interface{}       { return v }
func (HostFunction) XdrTypeName() string              { return "HostFunction" }
func (v HostFunction) XdrValue() interface{}          { return v }
func (v *HostFunction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_HostFunction = *HostFunction

func XDR_HostFunction(v *HostFunction) *HostFunction { return v }

type XdrType_InvokeHostFunctionOp = *InvokeHostFunctionOp

func (v *InvokeHostFunctionOp) XdrPointer() interface{}       { return v }
func (InvokeHostFunctionOp) XdrTypeName() string              { return "InvokeHostFunctionOp" }
func (v InvokeHostFunctionOp) XdrValue() interface{}          { return v }
func (v *InvokeHostFunctionOp) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InvokeHostFunctionOp) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfunction", name), XDR_HostFunction(&v.Function))
	x.Marshal(x.Sprintf("%sparameters", name), XDR_SCVec(&v.Parameters))
	x.Marshal(x.Sprintf("%sfootprint", name), XDR_LedgerFootprint(&v.Footprint))
}
func XDR_InvokeHostFunctionOp(v *InvokeHostFunctionOp) *InvokeHostFunctionOp { return v }

var _XdrTags_XdrAnon_Operation_Body = map[int32]bool{
	XdrToI32(CREATE_ACCOUNT):                   true,
	XdrToI32(PAYMENT):                          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE):      true,
	XdrToI32(MANAGE_SELL_OFFER):                true,
	XdrToI32(CREATE_PASSIVE_SELL_OFFER):        true,
	XdrToI32(SET_OPTIONS):                      true,
	XdrToI32(CHANGE_TRUST):                     true,
	XdrToI32(ALLOW_TRUST):                      true,
	XdrToI32(ACCOUNT_MERGE):                    true,
	XdrToI32(INFLATION):                        true,
	XdrToI32(MANAGE_DATA):                      true,
	XdrToI32(BUMP_SEQUENCE):                    true,
	XdrToI32(MANAGE_BUY_OFFER):                 true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND):         true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE):         true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE):          true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES): true,
	XdrToI32(END_SPONSORING_FUTURE_RESERVES):   true,
	XdrToI32(REVOKE_SPONSORSHIP):               true,
	XdrToI32(CLAWBACK):                         true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE):       true,
	XdrToI32(SET_TRUST_LINE_FLAGS):             true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT):           true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW):          true,
	XdrToI32(INVOKE_HOST_FUNCTION):             true,
}

func (_ XdrAnon_Operation_Body) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_Operation_Body
}
func (u *XdrAnon_Operation_Body) CreateAccountOp() *CreateAccountOp {
	switch u.Type {
	case CREATE_ACCOUNT:
		if v, ok := u._u.(*CreateAccountOp); ok {
			return v
		} else {
			var zero CreateAccountOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.CreateAccountOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PaymentOp() *PaymentOp {
	switch u.Type {
	case PAYMENT:
		if v, ok := u._u.(*PaymentOp); ok {
			return v
		} else {
			var zero PaymentOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PaymentOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PathPaymentStrictReceiveOp() *PathPaymentStrictReceiveOp {
	switch u.Type {
	case PATH_PAYMENT_STRICT_RECEIVE:
		if v, ok := u._u.(*PathPaymentStrictReceiveOp); ok {
			return v
		} else {
			var zero PathPaymentStrictReceiveOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PathPaymentStrictReceiveOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageSellOfferOp() *ManageSellOfferOp {
	switch u.Type {
	case MANAGE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferOp); ok {
			return v
		} else {
			var zero ManageSellOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageSellOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) CreatePassiveSellOfferOp() *CreatePassiveSellOfferOp {
	switch u.Type {
	case CREATE_PASSIVE_SELL_OFFER:
		if v, ok := u._u.(*CreatePassiveSellOfferOp); ok {
			return v
		} else {
			var zero CreatePassiveSellOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.CreatePassiveSellOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) SetOptionsOp() *SetOptionsOp {
	switch u.Type {
	case SET_OPTIONS:
		if v, ok := u._u.(*SetOptionsOp); ok {
			return v
		} else {
			var zero SetOptionsOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.SetOptionsOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ChangeTrustOp() *ChangeTrustOp {
	switch u.Type {
	case CHANGE_TRUST:
		if v, ok := u._u.(*ChangeTrustOp); ok {
			return v
		} else {
			var zero ChangeTrustOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ChangeTrustOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) AllowTrustOp() *AllowTrustOp {
	switch u.Type {
	case ALLOW_TRUST:
		if v, ok := u._u.(*AllowTrustOp); ok {
			return v
		} else {
			var zero AllowTrustOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.AllowTrustOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) Destination() *MuxedAccount {
	switch u.Type {
	case ACCOUNT_MERGE:
		if v, ok := u._u.(*MuxedAccount); ok {
			return v
		} else {
			var zero MuxedAccount
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.Destination accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageDataOp() *ManageDataOp {
	switch u.Type {
	case MANAGE_DATA:
		if v, ok := u._u.(*ManageDataOp); ok {
			return v
		} else {
			var zero ManageDataOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageDataOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) BumpSequenceOp() *BumpSequenceOp {
	switch u.Type {
	case BUMP_SEQUENCE:
		if v, ok := u._u.(*BumpSequenceOp); ok {
			return v
		} else {
			var zero BumpSequenceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.BumpSequenceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ManageBuyOfferOp() *ManageBuyOfferOp {
	switch u.Type {
	case MANAGE_BUY_OFFER:
		if v, ok := u._u.(*ManageBuyOfferOp); ok {
			return v
		} else {
			var zero ManageBuyOfferOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ManageBuyOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) PathPaymentStrictSendOp() *PathPaymentStrictSendOp {
	switch u.Type {
	case PATH_PAYMENT_STRICT_SEND:
		if v, ok := u._u.(*PathPaymentStrictSendOp); ok {
			return v
		} else {
			var zero PathPaymentStrictSendOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.PathPaymentStrictSendOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) CreateClaimableBalanceOp() *CreateClaimableBalanceOp {
	switch u.Type {
	case CREATE_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*CreateClaimableBalanceOp); ok {
			return v
		} else {
			var zero CreateClaimableBalanceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.CreateClaimableBalanceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ClaimClaimableBalanceOp() *ClaimClaimableBalanceOp {
	switch u.Type {
	case CLAIM_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClaimClaimableBalanceOp); ok {
			return v
		} else {
			var zero ClaimClaimableBalanceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ClaimClaimableBalanceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) BeginSponsoringFutureReservesOp() *BeginSponsoringFutureReservesOp {
	switch u.Type {
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		if v, ok := u._u.(*BeginSponsoringFutureReservesOp); ok {
			return v
		} else {
			var zero BeginSponsoringFutureReservesOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.BeginSponsoringFutureReservesOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) RevokeSponsorshipOp() *RevokeSponsorshipOp {
	switch u.Type {
	case REVOKE_SPONSORSHIP:
		if v, ok := u._u.(*RevokeSponsorshipOp); ok {
			return v
		} else {
			var zero RevokeSponsorshipOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.RevokeSponsorshipOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ClawbackOp() *ClawbackOp {
	switch u.Type {
	case CLAWBACK:
		if v, ok := u._u.(*ClawbackOp); ok {
			return v
		} else {
			var zero ClawbackOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ClawbackOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) ClawbackClaimableBalanceOp() *ClawbackClaimableBalanceOp {
	switch u.Type {
	case CLAWBACK_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClawbackClaimableBalanceOp); ok {
			return v
		} else {
			var zero ClawbackClaimableBalanceOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.ClawbackClaimableBalanceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) SetTrustLineFlagsOp() *SetTrustLineFlagsOp {
	switch u.Type {
	case SET_TRUST_LINE_FLAGS:
		if v, ok := u._u.(*SetTrustLineFlagsOp); ok {
			return v
		} else {
			var zero SetTrustLineFlagsOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.SetTrustLineFlagsOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) LiquidityPoolDepositOp() *LiquidityPoolDepositOp {
	switch u.Type {
	case LIQUIDITY_POOL_DEPOSIT:
		if v, ok := u._u.(*LiquidityPoolDepositOp); ok {
			return v
		} else {
			var zero LiquidityPoolDepositOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.LiquidityPoolDepositOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) LiquidityPoolWithdrawOp() *LiquidityPoolWithdrawOp {
	switch u.Type {
	case LIQUIDITY_POOL_WITHDRAW:
		if v, ok := u._u.(*LiquidityPoolWithdrawOp); ok {
			return v
		} else {
			var zero LiquidityPoolWithdrawOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.LiquidityPoolWithdrawOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_Operation_Body) InvokeHostFunctionOp() *InvokeHostFunctionOp {
	switch u.Type {
	case INVOKE_HOST_FUNCTION:
		if v, ok := u._u.(*InvokeHostFunctionOp); ok {
			return v
		} else {
			var zero InvokeHostFunctionOp
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Operation_Body.InvokeHostFunctionOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_Operation_Body) XdrValid() bool {
	switch u.Type {
	case CREATE_ACCOUNT, PAYMENT, PATH_PAYMENT_STRICT_RECEIVE, MANAGE_SELL_OFFER, CREATE_PASSIVE_SELL_OFFER, SET_OPTIONS, CHANGE_TRUST, ALLOW_TRUST, ACCOUNT_MERGE, INFLATION, MANAGE_DATA, BUMP_SEQUENCE, MANAGE_BUY_OFFER, PATH_PAYMENT_STRICT_SEND, CREATE_CLAIMABLE_BALANCE, CLAIM_CLAIMABLE_BALANCE, BEGIN_SPONSORING_FUTURE_RESERVES, END_SPONSORING_FUTURE_RESERVES, REVOKE_SPONSORSHIP, CLAWBACK, CLAWBACK_CLAIMABLE_BALANCE, SET_TRUST_LINE_FLAGS, LIQUIDITY_POOL_DEPOSIT, LIQUIDITY_POOL_WITHDRAW, INVOKE_HOST_FUNCTION:
		return true
	}
	return false
}
func (u *XdrAnon_Operation_Body) XdrUnionTag() XdrNum32 {
	return XDR_OperationType(&u.Type)
}
func (u *XdrAnon_Operation_Body) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_Operation_Body) XdrUnionBody() XdrType {
	switch u.Type {
	case CREATE_ACCOUNT:
		return XDR_CreateAccountOp(u.CreateAccountOp())
	case PAYMENT:
		return XDR_PaymentOp(u.PaymentOp())
	case PATH_PAYMENT_STRICT_RECEIVE:
		return XDR_PathPaymentStrictReceiveOp(u.PathPaymentStrictReceiveOp())
	case MANAGE_SELL_OFFER:
		return XDR_ManageSellOfferOp(u.ManageSellOfferOp())
	case CREATE_PASSIVE_SELL_OFFER:
		return XDR_CreatePassiveSellOfferOp(u.CreatePassiveSellOfferOp())
	case SET_OPTIONS:
		return XDR_SetOptionsOp(u.SetOptionsOp())
	case CHANGE_TRUST:
		return XDR_ChangeTrustOp(u.ChangeTrustOp())
	case ALLOW_TRUST:
		return XDR_AllowTrustOp(u.AllowTrustOp())
	case ACCOUNT_MERGE:
		return XDR_MuxedAccount(u.Destination())
	case INFLATION:
		return nil
	case MANAGE_DATA:
		return XDR_ManageDataOp(u.ManageDataOp())
	case BUMP_SEQUENCE:
		return XDR_BumpSequenceOp(u.BumpSequenceOp())
	case MANAGE_BUY_OFFER:
		return XDR_ManageBuyOfferOp(u.ManageBuyOfferOp())
	case PATH_PAYMENT_STRICT_SEND:
		return XDR_PathPaymentStrictSendOp(u.PathPaymentStrictSendOp())
	case CREATE_CLAIMABLE_BALANCE:
		return XDR_CreateClaimableBalanceOp(u.CreateClaimableBalanceOp())
	case CLAIM_CLAIMABLE_BALANCE:
		return XDR_ClaimClaimableBalanceOp(u.ClaimClaimableBalanceOp())
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		return XDR_BeginSponsoringFutureReservesOp(u.BeginSponsoringFutureReservesOp())
	case END_SPONSORING_FUTURE_RESERVES:
		return nil
	case REVOKE_SPONSORSHIP:
		return XDR_RevokeSponsorshipOp(u.RevokeSponsorshipOp())
	case CLAWBACK:
		return XDR_ClawbackOp(u.ClawbackOp())
	case CLAWBACK_CLAIMABLE_BALANCE:
		return XDR_ClawbackClaimableBalanceOp(u.ClawbackClaimableBalanceOp())
	case SET_TRUST_LINE_FLAGS:
		return XDR_SetTrustLineFlagsOp(u.SetTrustLineFlagsOp())
	case LIQUIDITY_POOL_DEPOSIT:
		return XDR_LiquidityPoolDepositOp(u.LiquidityPoolDepositOp())
	case LIQUIDITY_POOL_WITHDRAW:
		return XDR_LiquidityPoolWithdrawOp(u.LiquidityPoolWithdrawOp())
	case INVOKE_HOST_FUNCTION:
		return XDR_InvokeHostFunctionOp(u.InvokeHostFunctionOp())
	}
	return nil
}
func (u *XdrAnon_Operation_Body) XdrUnionBodyName() string {
	switch u.Type {
	case CREATE_ACCOUNT:
		return "CreateAccountOp"
	case PAYMENT:
		return "PaymentOp"
	case PATH_PAYMENT_STRICT_RECEIVE:
		return "PathPaymentStrictReceiveOp"
	case MANAGE_SELL_OFFER:
		return "ManageSellOfferOp"
	case CREATE_PASSIVE_SELL_OFFER:
		return "CreatePassiveSellOfferOp"
	case SET_OPTIONS:
		return "SetOptionsOp"
	case CHANGE_TRUST:
		return "ChangeTrustOp"
	case ALLOW_TRUST:
		return "AllowTrustOp"
	case ACCOUNT_MERGE:
		return "Destination"
	case INFLATION:
		return ""
	case MANAGE_DATA:
		return "ManageDataOp"
	case BUMP_SEQUENCE:
		return "BumpSequenceOp"
	case MANAGE_BUY_OFFER:
		return "ManageBuyOfferOp"
	case PATH_PAYMENT_STRICT_SEND:
		return "PathPaymentStrictSendOp"
	case CREATE_CLAIMABLE_BALANCE:
		return "CreateClaimableBalanceOp"
	case CLAIM_CLAIMABLE_BALANCE:
		return "ClaimClaimableBalanceOp"
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		return "BeginSponsoringFutureReservesOp"
	case END_SPONSORING_FUTURE_RESERVES:
		return ""
	case REVOKE_SPONSORSHIP:
		return "RevokeSponsorshipOp"
	case CLAWBACK:
		return "ClawbackOp"
	case CLAWBACK_CLAIMABLE_BALANCE:
		return "ClawbackClaimableBalanceOp"
	case SET_TRUST_LINE_FLAGS:
		return "SetTrustLineFlagsOp"
	case LIQUIDITY_POOL_DEPOSIT:
		return "LiquidityPoolDepositOp"
	case LIQUIDITY_POOL_WITHDRAW:
		return "LiquidityPoolWithdrawOp"
	case INVOKE_HOST_FUNCTION:
		return "InvokeHostFunctionOp"
	}
	return ""
}

type XdrType_XdrAnon_Operation_Body = *XdrAnon_Operation_Body

func (v *XdrAnon_Operation_Body) XdrPointer() interface{}       { return v }
func (XdrAnon_Operation_Body) XdrTypeName() string              { return "XdrAnon_Operation_Body" }
func (v XdrAnon_Operation_Body) XdrValue() interface{}          { return v }
func (v *XdrAnon_Operation_Body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_Operation_Body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CREATE_ACCOUNT:
		x.Marshal(x.Sprintf("%screateAccountOp", name), XDR_CreateAccountOp(u.CreateAccountOp()))
		return
	case PAYMENT:
		x.Marshal(x.Sprintf("%spaymentOp", name), XDR_PaymentOp(u.PaymentOp()))
		return
	case PATH_PAYMENT_STRICT_RECEIVE:
		x.Marshal(x.Sprintf("%spathPaymentStrictReceiveOp", name), XDR_PathPaymentStrictReceiveOp(u.PathPaymentStrictReceiveOp()))
		return
	case MANAGE_SELL_OFFER:
		x.Marshal(x.Sprintf("%smanageSellOfferOp", name), XDR_ManageSellOfferOp(u.ManageSellOfferOp()))
		return
	case CREATE_PASSIVE_SELL_OFFER:
		x.Marshal(x.Sprintf("%screatePassiveSellOfferOp", name), XDR_CreatePassiveSellOfferOp(u.CreatePassiveSellOfferOp()))
		return
	case SET_OPTIONS:
		x.Marshal(x.Sprintf("%ssetOptionsOp", name), XDR_SetOptionsOp(u.SetOptionsOp()))
		return
	case CHANGE_TRUST:
		x.Marshal(x.Sprintf("%schangeTrustOp", name), XDR_ChangeTrustOp(u.ChangeTrustOp()))
		return
	case ALLOW_TRUST:
		x.Marshal(x.Sprintf("%sallowTrustOp", name), XDR_AllowTrustOp(u.AllowTrustOp()))
		return
	case ACCOUNT_MERGE:
		x.Marshal(x.Sprintf("%sdestination", name), XDR_MuxedAccount(u.Destination()))
		return
	case INFLATION:
		return
	case MANAGE_DATA:
		x.Marshal(x.Sprintf("%smanageDataOp", name), XDR_ManageDataOp(u.ManageDataOp()))
		return
	case BUMP_SEQUENCE:
		x.Marshal(x.Sprintf("%sbumpSequenceOp", name), XDR_BumpSequenceOp(u.BumpSequenceOp()))
		return
	case MANAGE_BUY_OFFER:
		x.Marshal(x.Sprintf("%smanageBuyOfferOp", name), XDR_ManageBuyOfferOp(u.ManageBuyOfferOp()))
		return
	case PATH_PAYMENT_STRICT_SEND:
		x.Marshal(x.Sprintf("%spathPaymentStrictSendOp", name), XDR_PathPaymentStrictSendOp(u.PathPaymentStrictSendOp()))
		return
	case CREATE_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%screateClaimableBalanceOp", name), XDR_CreateClaimableBalanceOp(u.CreateClaimableBalanceOp()))
		return
	case CLAIM_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclaimClaimableBalanceOp", name), XDR_ClaimClaimableBalanceOp(u.ClaimClaimableBalanceOp()))
		return
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		x.Marshal(x.Sprintf("%sbeginSponsoringFutureReservesOp", name), XDR_BeginSponsoringFutureReservesOp(u.BeginSponsoringFutureReservesOp()))
		return
	case END_SPONSORING_FUTURE_RESERVES:
		return
	case REVOKE_SPONSORSHIP:
		x.Marshal(x.Sprintf("%srevokeSponsorshipOp", name), XDR_RevokeSponsorshipOp(u.RevokeSponsorshipOp()))
		return
	case CLAWBACK:
		x.Marshal(x.Sprintf("%sclawbackOp", name), XDR_ClawbackOp(u.ClawbackOp()))
		return
	case CLAWBACK_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclawbackClaimableBalanceOp", name), XDR_ClawbackClaimableBalanceOp(u.ClawbackClaimableBalanceOp()))
		return
	case SET_TRUST_LINE_FLAGS:
		x.Marshal(x.Sprintf("%ssetTrustLineFlagsOp", name), XDR_SetTrustLineFlagsOp(u.SetTrustLineFlagsOp()))
		return
	case LIQUIDITY_POOL_DEPOSIT:
		x.Marshal(x.Sprintf("%sliquidityPoolDepositOp", name), XDR_LiquidityPoolDepositOp(u.LiquidityPoolDepositOp()))
		return
	case LIQUIDITY_POOL_WITHDRAW:
		x.Marshal(x.Sprintf("%sliquidityPoolWithdrawOp", name), XDR_LiquidityPoolWithdrawOp(u.LiquidityPoolWithdrawOp()))
		return
	case INVOKE_HOST_FUNCTION:
		x.Marshal(x.Sprintf("%sinvokeHostFunctionOp", name), XDR_InvokeHostFunctionOp(u.InvokeHostFunctionOp()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_Operation_Body", u.Type)
}
func XDR_XdrAnon_Operation_Body(v *XdrAnon_Operation_Body) *XdrAnon_Operation_Body { return v }

type _XdrPtr_MuxedAccount struct {
	p **MuxedAccount
}
type _ptrflag_MuxedAccount _XdrPtr_MuxedAccount

func (v _ptrflag_MuxedAccount) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_MuxedAccount) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("MuxedAccount flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_MuxedAccount) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_MuxedAccount) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(MuxedAccount)
		}
	default:
		XdrPanic("*MuxedAccount present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_MuxedAccount) XdrTypeName() string             { return "MuxedAccount?" }
func (v _ptrflag_MuxedAccount) XdrPointer() interface{}       { return nil }
func (v _ptrflag_MuxedAccount) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_MuxedAccount) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_MuxedAccount) XdrBound() uint32              { return 1 }
func (v _XdrPtr_MuxedAccount) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_MuxedAccount) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(MuxedAccount)
	}
}
func (v _XdrPtr_MuxedAccount) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_MuxedAccount(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_MuxedAccount) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_MuxedAccount) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_MuxedAccount(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_MuxedAccount) XdrTypeName() string       { return "MuxedAccount*" }
func (v _XdrPtr_MuxedAccount) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_MuxedAccount) XdrValue() interface{}   { return *v.p }

type XdrType_Operation = *Operation

func (v *Operation) XdrPointer() interface{}       { return v }
func (Operation) XdrTypeName() string              { return "Operation" }
func (v Operation) XdrValue() interface{}          { return v }
func (v *Operation) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Operation) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), _XdrPtr_MuxedAccount{&v.SourceAccount})
	x.Marshal(x.Sprintf("%sbody", name), XDR_XdrAnon_Operation_Body(&v.Body))
}
func XDR_Operation(v *Operation) *Operation { return v }

type XdrType_XdrAnon_HashIDPreimage_OperationID = *XdrAnon_HashIDPreimage_OperationID

func (v *XdrAnon_HashIDPreimage_OperationID) XdrPointer() interface{} { return v }
func (XdrAnon_HashIDPreimage_OperationID) XdrTypeName() string {
	return "XdrAnon_HashIDPreimage_OperationID"
}
func (v XdrAnon_HashIDPreimage_OperationID) XdrValue() interface{}          { return v }
func (v *XdrAnon_HashIDPreimage_OperationID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_HashIDPreimage_OperationID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), XDR_AccountID(&v.SourceAccount))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%sopNum", name), XDR_Uint32(&v.OpNum))
}
func XDR_XdrAnon_HashIDPreimage_OperationID(v *XdrAnon_HashIDPreimage_OperationID) *XdrAnon_HashIDPreimage_OperationID {
	return v
}

type XdrType_XdrAnon_HashIDPreimage_RevokeID = *XdrAnon_HashIDPreimage_RevokeID

func (v *XdrAnon_HashIDPreimage_RevokeID) XdrPointer() interface{}       { return v }
func (XdrAnon_HashIDPreimage_RevokeID) XdrTypeName() string              { return "XdrAnon_HashIDPreimage_RevokeID" }
func (v XdrAnon_HashIDPreimage_RevokeID) XdrValue() interface{}          { return v }
func (v *XdrAnon_HashIDPreimage_RevokeID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_HashIDPreimage_RevokeID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), XDR_AccountID(&v.SourceAccount))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%sopNum", name), XDR_Uint32(&v.OpNum))
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
}
func XDR_XdrAnon_HashIDPreimage_RevokeID(v *XdrAnon_HashIDPreimage_RevokeID) *XdrAnon_HashIDPreimage_RevokeID {
	return v
}

type XdrType_XdrAnon_HashIDPreimage_Ed25519ContractID = *XdrAnon_HashIDPreimage_Ed25519ContractID

func (v *XdrAnon_HashIDPreimage_Ed25519ContractID) XdrPointer() interface{} { return v }
func (XdrAnon_HashIDPreimage_Ed25519ContractID) XdrTypeName() string {
	return "XdrAnon_HashIDPreimage_Ed25519ContractID"
}
func (v XdrAnon_HashIDPreimage_Ed25519ContractID) XdrValue() interface{}          { return v }
func (v *XdrAnon_HashIDPreimage_Ed25519ContractID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_HashIDPreimage_Ed25519ContractID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(&v.Ed25519))
	x.Marshal(x.Sprintf("%ssalt", name), XDR_Uint256(&v.Salt))
}
func XDR_XdrAnon_HashIDPreimage_Ed25519ContractID(v *XdrAnon_HashIDPreimage_Ed25519ContractID) *XdrAnon_HashIDPreimage_Ed25519ContractID {
	return v
}

type XdrType_XdrAnon_HashIDPreimage_ContractID = *XdrAnon_HashIDPreimage_ContractID

func (v *XdrAnon_HashIDPreimage_ContractID) XdrPointer() interface{} { return v }
func (XdrAnon_HashIDPreimage_ContractID) XdrTypeName() string {
	return "XdrAnon_HashIDPreimage_ContractID"
}
func (v XdrAnon_HashIDPreimage_ContractID) XdrValue() interface{}          { return v }
func (v *XdrAnon_HashIDPreimage_ContractID) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_HashIDPreimage_ContractID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scontractID", name), XDR_Hash(&v.ContractID))
	x.Marshal(x.Sprintf("%ssalt", name), XDR_Uint256(&v.Salt))
}
func XDR_XdrAnon_HashIDPreimage_ContractID(v *XdrAnon_HashIDPreimage_ContractID) *XdrAnon_HashIDPreimage_ContractID {
	return v
}

type XdrType_XdrAnon_HashIDPreimage_SourceAccountContractID = *XdrAnon_HashIDPreimage_SourceAccountContractID

func (v *XdrAnon_HashIDPreimage_SourceAccountContractID) XdrPointer() interface{} { return v }
func (XdrAnon_HashIDPreimage_SourceAccountContractID) XdrTypeName() string {
	return "XdrAnon_HashIDPreimage_SourceAccountContractID"
}
func (v XdrAnon_HashIDPreimage_SourceAccountContractID) XdrValue() interface{} { return v }
func (v *XdrAnon_HashIDPreimage_SourceAccountContractID) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_HashIDPreimage_SourceAccountContractID) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), XDR_AccountID(&v.SourceAccount))
	x.Marshal(x.Sprintf("%ssalt", name), XDR_Uint256(&v.Salt))
}
func XDR_XdrAnon_HashIDPreimage_SourceAccountContractID(v *XdrAnon_HashIDPreimage_SourceAccountContractID) *XdrAnon_HashIDPreimage_SourceAccountContractID {
	return v
}

var _XdrTags_HashIDPreimage = map[int32]bool{
	XdrToI32(ENVELOPE_TYPE_OP_ID):                           true,
	XdrToI32(ENVELOPE_TYPE_POOL_REVOKE_OP_ID):               true,
	XdrToI32(ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519):        true,
	XdrToI32(ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT):       true,
	XdrToI32(ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET):          true,
	XdrToI32(ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT): true,
}

func (_ HashIDPreimage) XdrValidTags() map[int32]bool {
	return _XdrTags_HashIDPreimage
}
func (u *HashIDPreimage) OperationID() *XdrAnon_HashIDPreimage_OperationID {
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_OperationID); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_OperationID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.OperationID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HashIDPreimage) RevokeID() *XdrAnon_HashIDPreimage_RevokeID {
	switch u.Type {
	case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_RevokeID); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_RevokeID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.RevokeID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HashIDPreimage) Ed25519ContractID() *XdrAnon_HashIDPreimage_Ed25519ContractID {
	switch u.Type {
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_Ed25519ContractID); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_Ed25519ContractID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.Ed25519ContractID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HashIDPreimage) ContractID() *XdrAnon_HashIDPreimage_ContractID {
	switch u.Type {
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_ContractID); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_ContractID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.ContractID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HashIDPreimage) FromAsset() *Asset {
	switch u.Type {
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.FromAsset accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *HashIDPreimage) SourceAccountContractID() *XdrAnon_HashIDPreimage_SourceAccountContractID {
	switch u.Type {
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT:
		if v, ok := u._u.(*XdrAnon_HashIDPreimage_SourceAccountContractID); ok {
			return v
		} else {
			var zero XdrAnon_HashIDPreimage_SourceAccountContractID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("HashIDPreimage.SourceAccountContractID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u HashIDPreimage) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID, ENVELOPE_TYPE_POOL_REVOKE_OP_ID, ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519, ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT, ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET, ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT:
		return true
	}
	return false
}
func (u *HashIDPreimage) XdrUnionTag() XdrNum32 {
	return XDR_EnvelopeType(&u.Type)
}
func (u *HashIDPreimage) XdrUnionTagName() string {
	return "Type"
}
func (u *HashIDPreimage) XdrUnionBody() XdrType {
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID:
		return XDR_XdrAnon_HashIDPreimage_OperationID(u.OperationID())
	case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
		return XDR_XdrAnon_HashIDPreimage_RevokeID(u.RevokeID())
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519:
		return XDR_XdrAnon_HashIDPreimage_Ed25519ContractID(u.Ed25519ContractID())
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT:
		return XDR_XdrAnon_HashIDPreimage_ContractID(u.ContractID())
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET:
		return XDR_Asset(u.FromAsset())
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT:
		return XDR_XdrAnon_HashIDPreimage_SourceAccountContractID(u.SourceAccountContractID())
	}
	return nil
}
func (u *HashIDPreimage) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID:
		return "OperationID"
	case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
		return "RevokeID"
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519:
		return "Ed25519ContractID"
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT:
		return "ContractID"
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET:
		return "FromAsset"
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT:
		return "SourceAccountContractID"
	}
	return ""
}

type XdrType_HashIDPreimage = *HashIDPreimage

func (v *HashIDPreimage) XdrPointer() interface{}       { return v }
func (HashIDPreimage) XdrTypeName() string              { return "HashIDPreimage" }
func (v HashIDPreimage) XdrValue() interface{}          { return v }
func (v *HashIDPreimage) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *HashIDPreimage) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_OP_ID:
		x.Marshal(x.Sprintf("%soperationID", name), XDR_XdrAnon_HashIDPreimage_OperationID(u.OperationID()))
		return
	case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
		x.Marshal(x.Sprintf("%srevokeID", name), XDR_XdrAnon_HashIDPreimage_RevokeID(u.RevokeID()))
		return
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519:
		x.Marshal(x.Sprintf("%sed25519ContractID", name), XDR_XdrAnon_HashIDPreimage_Ed25519ContractID(u.Ed25519ContractID()))
		return
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT:
		x.Marshal(x.Sprintf("%scontractID", name), XDR_XdrAnon_HashIDPreimage_ContractID(u.ContractID()))
		return
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET:
		x.Marshal(x.Sprintf("%sfromAsset", name), XDR_Asset(u.FromAsset()))
		return
	case ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT:
		x.Marshal(x.Sprintf("%ssourceAccountContractID", name), XDR_XdrAnon_HashIDPreimage_SourceAccountContractID(u.SourceAccountContractID()))
		return
	}
	XdrPanic("invalid Type (%v) in HashIDPreimage", u.Type)
}
func (v *HashIDPreimage) XdrInitialize() {
	var zero EnvelopeType
	switch zero {
	case ENVELOPE_TYPE_OP_ID, ENVELOPE_TYPE_POOL_REVOKE_OP_ID, ENVELOPE_TYPE_CONTRACT_ID_FROM_ED25519, ENVELOPE_TYPE_CONTRACT_ID_FROM_CONTRACT, ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET, ENVELOPE_TYPE_CONTRACT_ID_FROM_SOURCE_ACCOUNT:
	default:
		if v.Type == zero {
			v.Type = ENVELOPE_TYPE_OP_ID
		}
	}
}
func XDR_HashIDPreimage(v *HashIDPreimage) *HashIDPreimage { return v }

var _XdrNames_MemoType = map[int32]string{
	int32(MEMO_NONE):   "MEMO_NONE",
	int32(MEMO_TEXT):   "MEMO_TEXT",
	int32(MEMO_ID):     "MEMO_ID",
	int32(MEMO_HASH):   "MEMO_HASH",
	int32(MEMO_RETURN): "MEMO_RETURN",
}
var _XdrValues_MemoType = map[string]int32{
	"MEMO_NONE":   int32(MEMO_NONE),
	"MEMO_TEXT":   int32(MEMO_TEXT),
	"MEMO_ID":     int32(MEMO_ID),
	"MEMO_HASH":   int32(MEMO_HASH),
	"MEMO_RETURN": int32(MEMO_RETURN),
}

func (MemoType) XdrEnumNames() map[int32]string {
	return _XdrNames_MemoType
}
func (v MemoType) String() string {
	if s, ok := _XdrNames_MemoType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("MemoType#%d", v)
}
func (v *MemoType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_MemoType[stok]; ok {
			*v = MemoType(val)
			return nil
		} else if stok == "MemoType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid MemoType.", stok))
	}
}
func (v MemoType) GetU32() uint32                 { return uint32(v) }
func (v *MemoType) SetU32(n uint32)               { *v = MemoType(n) }
func (v *MemoType) XdrPointer() interface{}       { return v }
func (MemoType) XdrTypeName() string              { return "MemoType" }
func (v MemoType) XdrValue() interface{}          { return v }
func (v *MemoType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_MemoType = *MemoType

func XDR_MemoType(v *MemoType) *MemoType { return v }

var _XdrTags_Memo = map[int32]bool{
	XdrToI32(MEMO_NONE):   true,
	XdrToI32(MEMO_TEXT):   true,
	XdrToI32(MEMO_ID):     true,
	XdrToI32(MEMO_HASH):   true,
	XdrToI32(MEMO_RETURN): true,
}

func (_ Memo) XdrValidTags() map[int32]bool {
	return _XdrTags_Memo
}
func (u *Memo) Text() *string {
	switch u.Type {
	case MEMO_TEXT:
		if v, ok := u._u.(*string); ok {
			return v
		} else {
			var zero string
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Text accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Memo) Id() *Uint64 {
	switch u.Type {
	case MEMO_ID:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Id accessed when Type == %v", u.Type)
		return nil
	}
}

// the hash of what to pull from the content server
func (u *Memo) Hash() *Hash {
	switch u.Type {
	case MEMO_HASH:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.Hash accessed when Type == %v", u.Type)
		return nil
	}
}

// the hash of the tx you are rejecting
func (u *Memo) RetHash() *Hash {
	switch u.Type {
	case MEMO_RETURN:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Memo.RetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Memo) XdrValid() bool {
	switch u.Type {
	case MEMO_NONE, MEMO_TEXT, MEMO_ID, MEMO_HASH, MEMO_RETURN:
		return true
	}
	return false
}
func (u *Memo) XdrUnionTag() XdrNum32 {
	return XDR_MemoType(&u.Type)
}
func (u *Memo) XdrUnionTagName() string {
	return "Type"
}
func (u *Memo) XdrUnionBody() XdrType {
	switch u.Type {
	case MEMO_NONE:
		return nil
	case MEMO_TEXT:
		return XdrString{u.Text(), 28}
	case MEMO_ID:
		return XDR_Uint64(u.Id())
	case MEMO_HASH:
		return XDR_Hash(u.Hash())
	case MEMO_RETURN:
		return XDR_Hash(u.RetHash())
	}
	return nil
}
func (u *Memo) XdrUnionBodyName() string {
	switch u.Type {
	case MEMO_NONE:
		return ""
	case MEMO_TEXT:
		return "Text"
	case MEMO_ID:
		return "Id"
	case MEMO_HASH:
		return "Hash"
	case MEMO_RETURN:
		return "RetHash"
	}
	return ""
}

type XdrType_Memo = *Memo

func (v *Memo) XdrPointer() interface{}       { return v }
func (Memo) XdrTypeName() string              { return "Memo" }
func (v Memo) XdrValue() interface{}          { return v }
func (v *Memo) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Memo) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MemoType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case MEMO_NONE:
		return
	case MEMO_TEXT:
		x.Marshal(x.Sprintf("%stext", name), XdrString{u.Text(), 28})
		return
	case MEMO_ID:
		x.Marshal(x.Sprintf("%sid", name), XDR_Uint64(u.Id()))
		return
	case MEMO_HASH:
		x.Marshal(x.Sprintf("%shash", name), XDR_Hash(u.Hash()))
		return
	case MEMO_RETURN:
		x.Marshal(x.Sprintf("%sretHash", name), XDR_Hash(u.RetHash()))
		return
	}
	XdrPanic("invalid Type (%v) in Memo", u.Type)
}
func XDR_Memo(v *Memo) *Memo { return v }

type XdrType_TimeBounds = *TimeBounds

func (v *TimeBounds) XdrPointer() interface{}       { return v }
func (TimeBounds) XdrTypeName() string              { return "TimeBounds" }
func (v TimeBounds) XdrValue() interface{}          { return v }
func (v *TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TimeBounds) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sminTime", name), XDR_TimePoint(&v.MinTime))
	x.Marshal(x.Sprintf("%smaxTime", name), XDR_TimePoint(&v.MaxTime))
}
func XDR_TimeBounds(v *TimeBounds) *TimeBounds { return v }

type XdrType_LedgerBounds = *LedgerBounds

func (v *LedgerBounds) XdrPointer() interface{}       { return v }
func (LedgerBounds) XdrTypeName() string              { return "LedgerBounds" }
func (v LedgerBounds) XdrValue() interface{}          { return v }
func (v *LedgerBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LedgerBounds) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sminLedger", name), XDR_Uint32(&v.MinLedger))
	x.Marshal(x.Sprintf("%smaxLedger", name), XDR_Uint32(&v.MaxLedger))
}
func XDR_LedgerBounds(v *LedgerBounds) *LedgerBounds { return v }

type _XdrPtr_TimeBounds struct {
	p **TimeBounds
}
type _ptrflag_TimeBounds _XdrPtr_TimeBounds

func (v _ptrflag_TimeBounds) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_TimeBounds) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("TimeBounds flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_TimeBounds) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_TimeBounds) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(TimeBounds)
		}
	default:
		XdrPanic("*TimeBounds present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_TimeBounds) XdrTypeName() string             { return "TimeBounds?" }
func (v _ptrflag_TimeBounds) XdrPointer() interface{}       { return nil }
func (v _ptrflag_TimeBounds) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_TimeBounds) XdrBound() uint32              { return 1 }
func (v _XdrPtr_TimeBounds) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_TimeBounds) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(TimeBounds)
	}
}
func (v _XdrPtr_TimeBounds) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_TimeBounds(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_TimeBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_TimeBounds) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_TimeBounds(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_TimeBounds) XdrTypeName() string       { return "TimeBounds*" }
func (v _XdrPtr_TimeBounds) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_TimeBounds) XdrValue() interface{}   { return *v.p }

type _XdrPtr_LedgerBounds struct {
	p **LedgerBounds
}
type _ptrflag_LedgerBounds _XdrPtr_LedgerBounds

func (v _ptrflag_LedgerBounds) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_LedgerBounds) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("LedgerBounds flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_LedgerBounds) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_LedgerBounds) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(LedgerBounds)
		}
	default:
		XdrPanic("*LedgerBounds present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_LedgerBounds) XdrTypeName() string             { return "LedgerBounds?" }
func (v _ptrflag_LedgerBounds) XdrPointer() interface{}       { return nil }
func (v _ptrflag_LedgerBounds) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_LedgerBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_LedgerBounds) XdrBound() uint32              { return 1 }
func (v _XdrPtr_LedgerBounds) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_LedgerBounds) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(LedgerBounds)
	}
}
func (v _XdrPtr_LedgerBounds) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_LedgerBounds(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_LedgerBounds) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_LedgerBounds) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_LedgerBounds(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_LedgerBounds) XdrTypeName() string       { return "LedgerBounds*" }
func (v _XdrPtr_LedgerBounds) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_LedgerBounds) XdrValue() interface{}   { return *v.p }

type _XdrPtr_SequenceNumber struct {
	p **SequenceNumber
}
type _ptrflag_SequenceNumber _XdrPtr_SequenceNumber

func (v _ptrflag_SequenceNumber) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SequenceNumber) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SequenceNumber flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SequenceNumber) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SequenceNumber) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SequenceNumber)
		}
	default:
		XdrPanic("*SequenceNumber present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SequenceNumber) XdrTypeName() string             { return "SequenceNumber?" }
func (v _ptrflag_SequenceNumber) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SequenceNumber) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SequenceNumber) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SequenceNumber) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SequenceNumber) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SequenceNumber) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SequenceNumber)
	}
}
func (v _XdrPtr_SequenceNumber) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SequenceNumber(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SequenceNumber) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SequenceNumber) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SequenceNumber(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SequenceNumber) XdrTypeName() string       { return "SequenceNumber*" }
func (v _XdrPtr_SequenceNumber) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SequenceNumber) XdrValue() interface{}   { return *v.p }

type _XdrVec_2_SignerKey []SignerKey

func (_XdrVec_2_SignerKey) XdrBound() uint32 {
	const bound uint32 = 2 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_2_SignerKey) XdrCheckLen(length uint32) {
	if length > uint32(2) {
		XdrPanic("_XdrVec_2_SignerKey length %d exceeds bound 2", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_2_SignerKey length %d exceeds max int", length)
	}
}
func (v _XdrVec_2_SignerKey) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_2_SignerKey) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(2); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SignerKey, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_2_SignerKey) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SignerKey(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_2_SignerKey) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 2}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_2_SignerKey) XdrTypeName() string              { return "SignerKey<>" }
func (v *_XdrVec_2_SignerKey) XdrPointer() interface{}       { return (*[]SignerKey)(v) }
func (v _XdrVec_2_SignerKey) XdrValue() interface{}          { return ([]SignerKey)(v) }
func (v *_XdrVec_2_SignerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PreconditionsV2 = *PreconditionsV2

func (v *PreconditionsV2) XdrPointer() interface{}       { return v }
func (PreconditionsV2) XdrTypeName() string              { return "PreconditionsV2" }
func (v PreconditionsV2) XdrValue() interface{}          { return v }
func (v *PreconditionsV2) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PreconditionsV2) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stimeBounds", name), _XdrPtr_TimeBounds{&v.TimeBounds})
	x.Marshal(x.Sprintf("%sledgerBounds", name), _XdrPtr_LedgerBounds{&v.LedgerBounds})
	x.Marshal(x.Sprintf("%sminSeqNum", name), _XdrPtr_SequenceNumber{&v.MinSeqNum})
	x.Marshal(x.Sprintf("%sminSeqAge", name), XDR_Duration(&v.MinSeqAge))
	x.Marshal(x.Sprintf("%sminSeqLedgerGap", name), XDR_Uint32(&v.MinSeqLedgerGap))
	x.Marshal(x.Sprintf("%sextraSigners", name), (*_XdrVec_2_SignerKey)(&v.ExtraSigners))
}
func XDR_PreconditionsV2(v *PreconditionsV2) *PreconditionsV2 { return v }

var _XdrNames_PreconditionType = map[int32]string{
	int32(PRECOND_NONE): "PRECOND_NONE",
	int32(PRECOND_TIME): "PRECOND_TIME",
	int32(PRECOND_V2):   "PRECOND_V2",
}
var _XdrValues_PreconditionType = map[string]int32{
	"PRECOND_NONE": int32(PRECOND_NONE),
	"PRECOND_TIME": int32(PRECOND_TIME),
	"PRECOND_V2":   int32(PRECOND_V2),
}

func (PreconditionType) XdrEnumNames() map[int32]string {
	return _XdrNames_PreconditionType
}
func (v PreconditionType) String() string {
	if s, ok := _XdrNames_PreconditionType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PreconditionType#%d", v)
}
func (v *PreconditionType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PreconditionType[stok]; ok {
			*v = PreconditionType(val)
			return nil
		} else if stok == "PreconditionType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PreconditionType.", stok))
	}
}
func (v PreconditionType) GetU32() uint32                 { return uint32(v) }
func (v *PreconditionType) SetU32(n uint32)               { *v = PreconditionType(n) }
func (v *PreconditionType) XdrPointer() interface{}       { return v }
func (PreconditionType) XdrTypeName() string              { return "PreconditionType" }
func (v PreconditionType) XdrValue() interface{}          { return v }
func (v *PreconditionType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PreconditionType = *PreconditionType

func XDR_PreconditionType(v *PreconditionType) *PreconditionType { return v }

var _XdrTags_Preconditions = map[int32]bool{
	XdrToI32(PRECOND_NONE): true,
	XdrToI32(PRECOND_TIME): true,
	XdrToI32(PRECOND_V2):   true,
}

func (_ Preconditions) XdrValidTags() map[int32]bool {
	return _XdrTags_Preconditions
}
func (u *Preconditions) TimeBounds() *TimeBounds {
	switch u.Type {
	case PRECOND_TIME:
		if v, ok := u._u.(*TimeBounds); ok {
			return v
		} else {
			var zero TimeBounds
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Preconditions.TimeBounds accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Preconditions) V2() *PreconditionsV2 {
	switch u.Type {
	case PRECOND_V2:
		if v, ok := u._u.(*PreconditionsV2); ok {
			return v
		} else {
			var zero PreconditionsV2
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("Preconditions.V2 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Preconditions) XdrValid() bool {
	switch u.Type {
	case PRECOND_NONE, PRECOND_TIME, PRECOND_V2:
		return true
	}
	return false
}
func (u *Preconditions) XdrUnionTag() XdrNum32 {
	return XDR_PreconditionType(&u.Type)
}
func (u *Preconditions) XdrUnionTagName() string {
	return "Type"
}
func (u *Preconditions) XdrUnionBody() XdrType {
	switch u.Type {
	case PRECOND_NONE:
		return nil
	case PRECOND_TIME:
		return XDR_TimeBounds(u.TimeBounds())
	case PRECOND_V2:
		return XDR_PreconditionsV2(u.V2())
	}
	return nil
}
func (u *Preconditions) XdrUnionBodyName() string {
	switch u.Type {
	case PRECOND_NONE:
		return ""
	case PRECOND_TIME:
		return "TimeBounds"
	case PRECOND_V2:
		return "V2"
	}
	return ""
}

type XdrType_Preconditions = *Preconditions

func (v *Preconditions) XdrPointer() interface{}       { return v }
func (Preconditions) XdrTypeName() string              { return "Preconditions" }
func (v Preconditions) XdrValue() interface{}          { return v }
func (v *Preconditions) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Preconditions) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PreconditionType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case PRECOND_NONE:
		return
	case PRECOND_TIME:
		x.Marshal(x.Sprintf("%stimeBounds", name), XDR_TimeBounds(u.TimeBounds()))
		return
	case PRECOND_V2:
		x.Marshal(x.Sprintf("%sv2", name), XDR_PreconditionsV2(u.V2()))
		return
	}
	XdrPanic("invalid Type (%v) in Preconditions", u.Type)
}
func XDR_Preconditions(v *Preconditions) *Preconditions { return v }

var _XdrTags_XdrAnon_TransactionV0_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TransactionV0_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionV0_Ext
}
func (u XdrAnon_TransactionV0_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionV0_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionV0_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionV0_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionV0_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionV0_Ext = *XdrAnon_TransactionV0_Ext

func (v *XdrAnon_TransactionV0_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_TransactionV0_Ext) XdrTypeName() string              { return "XdrAnon_TransactionV0_Ext" }
func (v XdrAnon_TransactionV0_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TransactionV0_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionV0_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionV0_Ext", u.V)
}
func XDR_XdrAnon_TransactionV0_Ext(v *XdrAnon_TransactionV0_Ext) *XdrAnon_TransactionV0_Ext { return v }

type _XdrVec_100_Operation []Operation

func (_XdrVec_100_Operation) XdrBound() uint32 {
	const bound uint32 = 100 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_100_Operation) XdrCheckLen(length uint32) {
	if length > uint32(100) {
		XdrPanic("_XdrVec_100_Operation length %d exceeds bound 100", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_100_Operation length %d exceeds max int", length)
	}
}
func (v _XdrVec_100_Operation) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_100_Operation) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(100); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Operation, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_100_Operation) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_Operation(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_100_Operation) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 100}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_100_Operation) XdrTypeName() string              { return "Operation<>" }
func (v *_XdrVec_100_Operation) XdrPointer() interface{}       { return (*[]Operation)(v) }
func (v _XdrVec_100_Operation) XdrValue() interface{}          { return ([]Operation)(v) }
func (v *_XdrVec_100_Operation) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionV0 = *TransactionV0

func (v *TransactionV0) XdrPointer() interface{}       { return v }
func (TransactionV0) XdrTypeName() string              { return "TransactionV0" }
func (v TransactionV0) XdrValue() interface{}          { return v }
func (v *TransactionV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccountEd25519", name), XDR_Uint256(&v.SourceAccountEd25519))
	x.Marshal(x.Sprintf("%sfee", name), XDR_Uint32(&v.Fee))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%stimeBounds", name), _XdrPtr_TimeBounds{&v.TimeBounds})
	x.Marshal(x.Sprintf("%smemo", name), XDR_Memo(&v.Memo))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_100_Operation)(&v.Operations))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionV0_Ext(&v.Ext))
}
func XDR_TransactionV0(v *TransactionV0) *TransactionV0 { return v }

type _XdrVec_20_DecoratedSignature []DecoratedSignature

func (_XdrVec_20_DecoratedSignature) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_20_DecoratedSignature) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		XdrPanic("_XdrVec_20_DecoratedSignature length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_20_DecoratedSignature length %d exceeds max int", length)
	}
}
func (v _XdrVec_20_DecoratedSignature) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_20_DecoratedSignature) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]DecoratedSignature, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_20_DecoratedSignature) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_DecoratedSignature(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_20_DecoratedSignature) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 20}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_20_DecoratedSignature) XdrTypeName() string              { return "DecoratedSignature<>" }
func (v *_XdrVec_20_DecoratedSignature) XdrPointer() interface{}       { return (*[]DecoratedSignature)(v) }
func (v _XdrVec_20_DecoratedSignature) XdrValue() interface{}          { return ([]DecoratedSignature)(v) }
func (v *_XdrVec_20_DecoratedSignature) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionV0Envelope = *TransactionV0Envelope

func (v *TransactionV0Envelope) XdrPointer() interface{}       { return v }
func (TransactionV0Envelope) XdrTypeName() string              { return "TransactionV0Envelope" }
func (v TransactionV0Envelope) XdrValue() interface{}          { return v }
func (v *TransactionV0Envelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionV0Envelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stx", name), XDR_TransactionV0(&v.Tx))
	x.Marshal(x.Sprintf("%ssignatures", name), (*_XdrVec_20_DecoratedSignature)(&v.Signatures))
}
func XDR_TransactionV0Envelope(v *TransactionV0Envelope) *TransactionV0Envelope { return v }

var _XdrTags_XdrAnon_Transaction_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_Transaction_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_Transaction_Ext
}
func (u XdrAnon_Transaction_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_Transaction_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_Transaction_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_Transaction_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_Transaction_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_Transaction_Ext = *XdrAnon_Transaction_Ext

func (v *XdrAnon_Transaction_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_Transaction_Ext) XdrTypeName() string              { return "XdrAnon_Transaction_Ext" }
func (v XdrAnon_Transaction_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_Transaction_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_Transaction_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_Transaction_Ext", u.V)
}
func XDR_XdrAnon_Transaction_Ext(v *XdrAnon_Transaction_Ext) *XdrAnon_Transaction_Ext { return v }

type XdrType_Transaction = *Transaction

func (v *Transaction) XdrPointer() interface{}       { return v }
func (Transaction) XdrTypeName() string              { return "Transaction" }
func (v Transaction) XdrValue() interface{}          { return v }
func (v *Transaction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Transaction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), XDR_MuxedAccount(&v.SourceAccount))
	x.Marshal(x.Sprintf("%sfee", name), XDR_Uint32(&v.Fee))
	x.Marshal(x.Sprintf("%sseqNum", name), XDR_SequenceNumber(&v.SeqNum))
	x.Marshal(x.Sprintf("%scond", name), XDR_Preconditions(&v.Cond))
	x.Marshal(x.Sprintf("%smemo", name), XDR_Memo(&v.Memo))
	x.Marshal(x.Sprintf("%soperations", name), (*_XdrVec_100_Operation)(&v.Operations))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_Transaction_Ext(&v.Ext))
}
func XDR_Transaction(v *Transaction) *Transaction { return v }

type XdrType_TransactionV1Envelope = *TransactionV1Envelope

func (v *TransactionV1Envelope) XdrPointer() interface{}       { return v }
func (TransactionV1Envelope) XdrTypeName() string              { return "TransactionV1Envelope" }
func (v TransactionV1Envelope) XdrValue() interface{}          { return v }
func (v *TransactionV1Envelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionV1Envelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stx", name), XDR_Transaction(&v.Tx))
	x.Marshal(x.Sprintf("%ssignatures", name), (*_XdrVec_20_DecoratedSignature)(&v.Signatures))
}
func XDR_TransactionV1Envelope(v *TransactionV1Envelope) *TransactionV1Envelope { return v }

var _XdrTags_XdrAnon_FeeBumpTransaction_InnerTx = map[int32]bool{
	XdrToI32(ENVELOPE_TYPE_TX): true,
}

func (_ XdrAnon_FeeBumpTransaction_InnerTx) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_FeeBumpTransaction_InnerTx
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) V1() *TransactionV1Envelope {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		if v, ok := u._u.(*TransactionV1Envelope); ok {
			return v
		} else {
			var zero TransactionV1Envelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_FeeBumpTransaction_InnerTx.V1 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_FeeBumpTransaction_InnerTx) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return true
	}
	return false
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrUnionTag() XdrNum32 {
	return XDR_EnvelopeType(&u.Type)
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrUnionBody() XdrType {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return XDR_TransactionV1Envelope(u.V1())
	}
	return nil
}
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return "V1"
	}
	return ""
}

type XdrType_XdrAnon_FeeBumpTransaction_InnerTx = *XdrAnon_FeeBumpTransaction_InnerTx

func (v *XdrAnon_FeeBumpTransaction_InnerTx) XdrPointer() interface{} { return v }
func (XdrAnon_FeeBumpTransaction_InnerTx) XdrTypeName() string {
	return "XdrAnon_FeeBumpTransaction_InnerTx"
}
func (v XdrAnon_FeeBumpTransaction_InnerTx) XdrValue() interface{}          { return v }
func (v *XdrAnon_FeeBumpTransaction_InnerTx) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_FeeBumpTransaction_InnerTx) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		x.Marshal(x.Sprintf("%sv1", name), XDR_TransactionV1Envelope(u.V1()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_FeeBumpTransaction_InnerTx", u.Type)
}
func (v *XdrAnon_FeeBumpTransaction_InnerTx) XdrInitialize() {
	var zero EnvelopeType
	switch zero {
	case ENVELOPE_TYPE_TX:
	default:
		if v.Type == zero {
			v.Type = ENVELOPE_TYPE_TX
		}
	}
}
func XDR_XdrAnon_FeeBumpTransaction_InnerTx(v *XdrAnon_FeeBumpTransaction_InnerTx) *XdrAnon_FeeBumpTransaction_InnerTx {
	return v
}

var _XdrTags_XdrAnon_FeeBumpTransaction_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_FeeBumpTransaction_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_FeeBumpTransaction_Ext
}
func (u XdrAnon_FeeBumpTransaction_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_FeeBumpTransaction_Ext = *XdrAnon_FeeBumpTransaction_Ext

func (v *XdrAnon_FeeBumpTransaction_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_FeeBumpTransaction_Ext) XdrTypeName() string              { return "XdrAnon_FeeBumpTransaction_Ext" }
func (v XdrAnon_FeeBumpTransaction_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_FeeBumpTransaction_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_FeeBumpTransaction_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_FeeBumpTransaction_Ext", u.V)
}
func XDR_XdrAnon_FeeBumpTransaction_Ext(v *XdrAnon_FeeBumpTransaction_Ext) *XdrAnon_FeeBumpTransaction_Ext {
	return v
}

type XdrType_FeeBumpTransaction = *FeeBumpTransaction

func (v *FeeBumpTransaction) XdrPointer() interface{}       { return v }
func (FeeBumpTransaction) XdrTypeName() string              { return "FeeBumpTransaction" }
func (v FeeBumpTransaction) XdrValue() interface{}          { return v }
func (v *FeeBumpTransaction) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FeeBumpTransaction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfeeSource", name), XDR_MuxedAccount(&v.FeeSource))
	x.Marshal(x.Sprintf("%sfee", name), XDR_Int64(&v.Fee))
	x.Marshal(x.Sprintf("%sinnerTx", name), XDR_XdrAnon_FeeBumpTransaction_InnerTx(&v.InnerTx))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_FeeBumpTransaction_Ext(&v.Ext))
}
func XDR_FeeBumpTransaction(v *FeeBumpTransaction) *FeeBumpTransaction { return v }

type XdrType_FeeBumpTransactionEnvelope = *FeeBumpTransactionEnvelope

func (v *FeeBumpTransactionEnvelope) XdrPointer() interface{}       { return v }
func (FeeBumpTransactionEnvelope) XdrTypeName() string              { return "FeeBumpTransactionEnvelope" }
func (v FeeBumpTransactionEnvelope) XdrValue() interface{}          { return v }
func (v *FeeBumpTransactionEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FeeBumpTransactionEnvelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stx", name), XDR_FeeBumpTransaction(&v.Tx))
	x.Marshal(x.Sprintf("%ssignatures", name), (*_XdrVec_20_DecoratedSignature)(&v.Signatures))
}
func XDR_FeeBumpTransactionEnvelope(v *FeeBumpTransactionEnvelope) *FeeBumpTransactionEnvelope {
	return v
}

var _XdrTags_TransactionEnvelope = map[int32]bool{
	XdrToI32(ENVELOPE_TYPE_TX_V0):       true,
	XdrToI32(ENVELOPE_TYPE_TX):          true,
	XdrToI32(ENVELOPE_TYPE_TX_FEE_BUMP): true,
}

func (_ TransactionEnvelope) XdrValidTags() map[int32]bool {
	return _XdrTags_TransactionEnvelope
}
func (u *TransactionEnvelope) V0() *TransactionV0Envelope {
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0:
		if v, ok := u._u.(*TransactionV0Envelope); ok {
			return v
		} else {
			var zero TransactionV0Envelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionEnvelope.V0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *TransactionEnvelope) V1() *TransactionV1Envelope {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		if v, ok := u._u.(*TransactionV1Envelope); ok {
			return v
		} else {
			var zero TransactionV1Envelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionEnvelope.V1 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *TransactionEnvelope) FeeBump() *FeeBumpTransactionEnvelope {
	switch u.Type {
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		if v, ok := u._u.(*FeeBumpTransactionEnvelope); ok {
			return v
		} else {
			var zero FeeBumpTransactionEnvelope
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("TransactionEnvelope.FeeBump accessed when Type == %v", u.Type)
		return nil
	}
}
func (u TransactionEnvelope) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0, ENVELOPE_TYPE_TX, ENVELOPE_TYPE_TX_FEE_BUMP:
		return true
	}
	return false
}
func (u *TransactionEnvelope) XdrUnionTag() XdrNum32 {
	return XDR_EnvelopeType(&u.Type)
}
func (u *TransactionEnvelope) XdrUnionTagName() string {
	return "Type"
}
func (u *TransactionEnvelope) XdrUnionBody() XdrType {
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0:
		return XDR_TransactionV0Envelope(u.V0())
	case ENVELOPE_TYPE_TX:
		return XDR_TransactionV1Envelope(u.V1())
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		return XDR_FeeBumpTransactionEnvelope(u.FeeBump())
	}
	return nil
}
func (u *TransactionEnvelope) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0:
		return "V0"
	case ENVELOPE_TYPE_TX:
		return "V1"
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		return "FeeBump"
	}
	return ""
}

type XdrType_TransactionEnvelope = *TransactionEnvelope

func (v *TransactionEnvelope) XdrPointer() interface{}       { return v }
func (TransactionEnvelope) XdrTypeName() string              { return "TransactionEnvelope" }
func (v TransactionEnvelope) XdrValue() interface{}          { return v }
func (v *TransactionEnvelope) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TransactionEnvelope) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_TX_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_TransactionV0Envelope(u.V0()))
		return
	case ENVELOPE_TYPE_TX:
		x.Marshal(x.Sprintf("%sv1", name), XDR_TransactionV1Envelope(u.V1()))
		return
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		x.Marshal(x.Sprintf("%sfeeBump", name), XDR_FeeBumpTransactionEnvelope(u.FeeBump()))
		return
	}
	XdrPanic("invalid Type (%v) in TransactionEnvelope", u.Type)
}
func XDR_TransactionEnvelope(v *TransactionEnvelope) *TransactionEnvelope { return v }

var _XdrTags_XdrAnon_TransactionSignaturePayload_TaggedTransaction = map[int32]bool{
	XdrToI32(ENVELOPE_TYPE_TX):          true,
	XdrToI32(ENVELOPE_TYPE_TX_FEE_BUMP): true,
}

func (_ XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionSignaturePayload_TaggedTransaction
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) Tx() *Transaction {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		if v, ok := u._u.(*Transaction); ok {
			return v
		} else {
			var zero Transaction
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionSignaturePayload_TaggedTransaction.Tx accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) FeeBump() *FeeBumpTransaction {
	switch u.Type {
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		if v, ok := u._u.(*FeeBumpTransaction); ok {
			return v
		} else {
			var zero FeeBumpTransaction
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionSignaturePayload_TaggedTransaction.FeeBump accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_TX, ENVELOPE_TYPE_TX_FEE_BUMP:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionTag() XdrNum32 {
	return XDR_EnvelopeType(&u.Type)
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionBody() XdrType {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return XDR_Transaction(u.Tx())
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		return XDR_FeeBumpTransaction(u.FeeBump())
	}
	return nil
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return "Tx"
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		return "FeeBump"
	}
	return ""
}

type XdrType_XdrAnon_TransactionSignaturePayload_TaggedTransaction = *XdrAnon_TransactionSignaturePayload_TaggedTransaction

func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrTypeName() string {
	return "XdrAnon_TransactionSignaturePayload_TaggedTransaction"
}
func (v XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrValue() interface{} { return v }
func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (u *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		x.Marshal(x.Sprintf("%stx", name), XDR_Transaction(u.Tx()))
		return
	case ENVELOPE_TYPE_TX_FEE_BUMP:
		x.Marshal(x.Sprintf("%sfeeBump", name), XDR_FeeBumpTransaction(u.FeeBump()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_TransactionSignaturePayload_TaggedTransaction", u.Type)
}
func (v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) XdrInitialize() {
	var zero EnvelopeType
	switch zero {
	case ENVELOPE_TYPE_TX, ENVELOPE_TYPE_TX_FEE_BUMP:
	default:
		if v.Type == zero {
			v.Type = ENVELOPE_TYPE_TX
		}
	}
}
func XDR_XdrAnon_TransactionSignaturePayload_TaggedTransaction(v *XdrAnon_TransactionSignaturePayload_TaggedTransaction) *XdrAnon_TransactionSignaturePayload_TaggedTransaction {
	return v
}

type XdrType_TransactionSignaturePayload = *TransactionSignaturePayload

func (v *TransactionSignaturePayload) XdrPointer() interface{}       { return v }
func (TransactionSignaturePayload) XdrTypeName() string              { return "TransactionSignaturePayload" }
func (v TransactionSignaturePayload) XdrValue() interface{}          { return v }
func (v *TransactionSignaturePayload) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionSignaturePayload) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snetworkId", name), XDR_Hash(&v.NetworkId))
	x.Marshal(x.Sprintf("%staggedTransaction", name), XDR_XdrAnon_TransactionSignaturePayload_TaggedTransaction(&v.TaggedTransaction))
}
func XDR_TransactionSignaturePayload(v *TransactionSignaturePayload) *TransactionSignaturePayload {
	return v
}

var _XdrNames_ClaimAtomType = map[int32]string{
	int32(CLAIM_ATOM_TYPE_V0):             "CLAIM_ATOM_TYPE_V0",
	int32(CLAIM_ATOM_TYPE_ORDER_BOOK):     "CLAIM_ATOM_TYPE_ORDER_BOOK",
	int32(CLAIM_ATOM_TYPE_LIQUIDITY_POOL): "CLAIM_ATOM_TYPE_LIQUIDITY_POOL",
}
var _XdrValues_ClaimAtomType = map[string]int32{
	"CLAIM_ATOM_TYPE_V0":             int32(CLAIM_ATOM_TYPE_V0),
	"CLAIM_ATOM_TYPE_ORDER_BOOK":     int32(CLAIM_ATOM_TYPE_ORDER_BOOK),
	"CLAIM_ATOM_TYPE_LIQUIDITY_POOL": int32(CLAIM_ATOM_TYPE_LIQUIDITY_POOL),
}

func (ClaimAtomType) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimAtomType
}
func (v ClaimAtomType) String() string {
	if s, ok := _XdrNames_ClaimAtomType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimAtomType#%d", v)
}
func (v *ClaimAtomType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimAtomType[stok]; ok {
			*v = ClaimAtomType(val)
			return nil
		} else if stok == "ClaimAtomType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimAtomType.", stok))
	}
}
func (v ClaimAtomType) GetU32() uint32                 { return uint32(v) }
func (v *ClaimAtomType) SetU32(n uint32)               { *v = ClaimAtomType(n) }
func (v *ClaimAtomType) XdrPointer() interface{}       { return v }
func (ClaimAtomType) XdrTypeName() string              { return "ClaimAtomType" }
func (v ClaimAtomType) XdrValue() interface{}          { return v }
func (v *ClaimAtomType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimAtomType = *ClaimAtomType

func XDR_ClaimAtomType(v *ClaimAtomType) *ClaimAtomType { return v }

type XdrType_ClaimOfferAtomV0 = *ClaimOfferAtomV0

func (v *ClaimOfferAtomV0) XdrPointer() interface{}       { return v }
func (ClaimOfferAtomV0) XdrTypeName() string              { return "ClaimOfferAtomV0" }
func (v ClaimOfferAtomV0) XdrValue() interface{}          { return v }
func (v *ClaimOfferAtomV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimOfferAtomV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssellerEd25519", name), XDR_Uint256(&v.SellerEd25519))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
	x.Marshal(x.Sprintf("%sassetSold", name), XDR_Asset(&v.AssetSold))
	x.Marshal(x.Sprintf("%samountSold", name), XDR_Int64(&v.AmountSold))
	x.Marshal(x.Sprintf("%sassetBought", name), XDR_Asset(&v.AssetBought))
	x.Marshal(x.Sprintf("%samountBought", name), XDR_Int64(&v.AmountBought))
}
func XDR_ClaimOfferAtomV0(v *ClaimOfferAtomV0) *ClaimOfferAtomV0 { return v }

type XdrType_ClaimOfferAtom = *ClaimOfferAtom

func (v *ClaimOfferAtom) XdrPointer() interface{}       { return v }
func (ClaimOfferAtom) XdrTypeName() string              { return "ClaimOfferAtom" }
func (v ClaimOfferAtom) XdrValue() interface{}          { return v }
func (v *ClaimOfferAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimOfferAtom) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssellerID", name), XDR_AccountID(&v.SellerID))
	x.Marshal(x.Sprintf("%sofferID", name), XDR_Int64(&v.OfferID))
	x.Marshal(x.Sprintf("%sassetSold", name), XDR_Asset(&v.AssetSold))
	x.Marshal(x.Sprintf("%samountSold", name), XDR_Int64(&v.AmountSold))
	x.Marshal(x.Sprintf("%sassetBought", name), XDR_Asset(&v.AssetBought))
	x.Marshal(x.Sprintf("%samountBought", name), XDR_Int64(&v.AmountBought))
}
func XDR_ClaimOfferAtom(v *ClaimOfferAtom) *ClaimOfferAtom { return v }

type XdrType_ClaimLiquidityAtom = *ClaimLiquidityAtom

func (v *ClaimLiquidityAtom) XdrPointer() interface{}       { return v }
func (ClaimLiquidityAtom) XdrTypeName() string              { return "ClaimLiquidityAtom" }
func (v ClaimLiquidityAtom) XdrValue() interface{}          { return v }
func (v *ClaimLiquidityAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ClaimLiquidityAtom) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sliquidityPoolID", name), XDR_PoolID(&v.LiquidityPoolID))
	x.Marshal(x.Sprintf("%sassetSold", name), XDR_Asset(&v.AssetSold))
	x.Marshal(x.Sprintf("%samountSold", name), XDR_Int64(&v.AmountSold))
	x.Marshal(x.Sprintf("%sassetBought", name), XDR_Asset(&v.AssetBought))
	x.Marshal(x.Sprintf("%samountBought", name), XDR_Int64(&v.AmountBought))
}
func XDR_ClaimLiquidityAtom(v *ClaimLiquidityAtom) *ClaimLiquidityAtom { return v }

var _XdrTags_ClaimAtom = map[int32]bool{
	XdrToI32(CLAIM_ATOM_TYPE_V0):             true,
	XdrToI32(CLAIM_ATOM_TYPE_ORDER_BOOK):     true,
	XdrToI32(CLAIM_ATOM_TYPE_LIQUIDITY_POOL): true,
}

func (_ ClaimAtom) XdrValidTags() map[int32]bool {
	return _XdrTags_ClaimAtom
}
func (u *ClaimAtom) V0() *ClaimOfferAtomV0 {
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0:
		if v, ok := u._u.(*ClaimOfferAtomV0); ok {
			return v
		} else {
			var zero ClaimOfferAtomV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimAtom.V0 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ClaimAtom) OrderBook() *ClaimOfferAtom {
	switch u.Type {
	case CLAIM_ATOM_TYPE_ORDER_BOOK:
		if v, ok := u._u.(*ClaimOfferAtom); ok {
			return v
		} else {
			var zero ClaimOfferAtom
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimAtom.OrderBook accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *ClaimAtom) LiquidityPool() *ClaimLiquidityAtom {
	switch u.Type {
	case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		if v, ok := u._u.(*ClaimLiquidityAtom); ok {
			return v
		} else {
			var zero ClaimLiquidityAtom
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ClaimAtom.LiquidityPool accessed when Type == %v", u.Type)
		return nil
	}
}
func (u ClaimAtom) XdrValid() bool {
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0, CLAIM_ATOM_TYPE_ORDER_BOOK, CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		return true
	}
	return false
}
func (u *ClaimAtom) XdrUnionTag() XdrNum32 {
	return XDR_ClaimAtomType(&u.Type)
}
func (u *ClaimAtom) XdrUnionTagName() string {
	return "Type"
}
func (u *ClaimAtom) XdrUnionBody() XdrType {
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0:
		return XDR_ClaimOfferAtomV0(u.V0())
	case CLAIM_ATOM_TYPE_ORDER_BOOK:
		return XDR_ClaimOfferAtom(u.OrderBook())
	case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		return XDR_ClaimLiquidityAtom(u.LiquidityPool())
	}
	return nil
}
func (u *ClaimAtom) XdrUnionBodyName() string {
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0:
		return "V0"
	case CLAIM_ATOM_TYPE_ORDER_BOOK:
		return "OrderBook"
	case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		return "LiquidityPool"
	}
	return ""
}

type XdrType_ClaimAtom = *ClaimAtom

func (v *ClaimAtom) XdrPointer() interface{}       { return v }
func (ClaimAtom) XdrTypeName() string              { return "ClaimAtom" }
func (v ClaimAtom) XdrValue() interface{}          { return v }
func (v *ClaimAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClaimAtom) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimAtomType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CLAIM_ATOM_TYPE_V0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_ClaimOfferAtomV0(u.V0()))
		return
	case CLAIM_ATOM_TYPE_ORDER_BOOK:
		x.Marshal(x.Sprintf("%sorderBook", name), XDR_ClaimOfferAtom(u.OrderBook()))
		return
	case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
		x.Marshal(x.Sprintf("%sliquidityPool", name), XDR_ClaimLiquidityAtom(u.LiquidityPool()))
		return
	}
	XdrPanic("invalid Type (%v) in ClaimAtom", u.Type)
}
func XDR_ClaimAtom(v *ClaimAtom) *ClaimAtom { return v }

var _XdrNames_CreateAccountResultCode = map[int32]string{
	int32(CREATE_ACCOUNT_SUCCESS):       "CREATE_ACCOUNT_SUCCESS",
	int32(CREATE_ACCOUNT_MALFORMED):     "CREATE_ACCOUNT_MALFORMED",
	int32(CREATE_ACCOUNT_UNDERFUNDED):   "CREATE_ACCOUNT_UNDERFUNDED",
	int32(CREATE_ACCOUNT_LOW_RESERVE):   "CREATE_ACCOUNT_LOW_RESERVE",
	int32(CREATE_ACCOUNT_ALREADY_EXIST): "CREATE_ACCOUNT_ALREADY_EXIST",
}
var _XdrValues_CreateAccountResultCode = map[string]int32{
	"CREATE_ACCOUNT_SUCCESS":       int32(CREATE_ACCOUNT_SUCCESS),
	"CREATE_ACCOUNT_MALFORMED":     int32(CREATE_ACCOUNT_MALFORMED),
	"CREATE_ACCOUNT_UNDERFUNDED":   int32(CREATE_ACCOUNT_UNDERFUNDED),
	"CREATE_ACCOUNT_LOW_RESERVE":   int32(CREATE_ACCOUNT_LOW_RESERVE),
	"CREATE_ACCOUNT_ALREADY_EXIST": int32(CREATE_ACCOUNT_ALREADY_EXIST),
}

func (CreateAccountResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_CreateAccountResultCode
}
func (v CreateAccountResultCode) String() string {
	if s, ok := _XdrNames_CreateAccountResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("CreateAccountResultCode#%d", v)
}
func (v *CreateAccountResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CreateAccountResultCode[stok]; ok {
			*v = CreateAccountResultCode(val)
			return nil
		} else if stok == "CreateAccountResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid CreateAccountResultCode.", stok))
	}
}
func (v CreateAccountResultCode) GetU32() uint32                 { return uint32(v) }
func (v *CreateAccountResultCode) SetU32(n uint32)               { *v = CreateAccountResultCode(n) }
func (v *CreateAccountResultCode) XdrPointer() interface{}       { return v }
func (CreateAccountResultCode) XdrTypeName() string              { return "CreateAccountResultCode" }
func (v CreateAccountResultCode) XdrValue() interface{}          { return v }
func (v *CreateAccountResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_CreateAccountResultCode = *CreateAccountResultCode

func XDR_CreateAccountResultCode(v *CreateAccountResultCode) *CreateAccountResultCode { return v }

var _XdrComments_CreateAccountResultCode = map[int32]string{
	int32(CREATE_ACCOUNT_SUCCESS):       "account was created",
	int32(CREATE_ACCOUNT_MALFORMED):     "invalid destination",
	int32(CREATE_ACCOUNT_UNDERFUNDED):   "not enough funds in source account",
	int32(CREATE_ACCOUNT_LOW_RESERVE):   "would create an account below the min reserve",
	int32(CREATE_ACCOUNT_ALREADY_EXIST): "account already exists",
}

func (e CreateAccountResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_CreateAccountResultCode
}

var _XdrTags_CreateAccountResult = map[int32]bool{
	XdrToI32(CREATE_ACCOUNT_SUCCESS):       true,
	XdrToI32(CREATE_ACCOUNT_MALFORMED):     true,
	XdrToI32(CREATE_ACCOUNT_UNDERFUNDED):   true,
	XdrToI32(CREATE_ACCOUNT_LOW_RESERVE):   true,
	XdrToI32(CREATE_ACCOUNT_ALREADY_EXIST): true,
}

func (_ CreateAccountResult) XdrValidTags() map[int32]bool {
	return _XdrTags_CreateAccountResult
}
func (u CreateAccountResult) XdrValid() bool {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS, CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
		return true
	}
	return false
}
func (u *CreateAccountResult) XdrUnionTag() XdrNum32 {
	return XDR_CreateAccountResultCode(&u.Code)
}
func (u *CreateAccountResult) XdrUnionTagName() string {
	return "Code"
}
func (u *CreateAccountResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return nil
	case CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
		return nil
	}
	return nil
}
func (u *CreateAccountResult) XdrUnionBodyName() string {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return ""
	case CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
		return ""
	}
	return ""
}

type XdrType_CreateAccountResult = *CreateAccountResult

func (v *CreateAccountResult) XdrPointer() interface{}       { return v }
func (CreateAccountResult) XdrTypeName() string              { return "CreateAccountResult" }
func (v CreateAccountResult) XdrValue() interface{}          { return v }
func (v *CreateAccountResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CreateAccountResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_CreateAccountResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return
	case CREATE_ACCOUNT_MALFORMED, CREATE_ACCOUNT_UNDERFUNDED, CREATE_ACCOUNT_LOW_RESERVE, CREATE_ACCOUNT_ALREADY_EXIST:
		return
	}
	XdrPanic("invalid Code (%v) in CreateAccountResult", u.Code)
}
func XDR_CreateAccountResult(v *CreateAccountResult) *CreateAccountResult { return v }

var _XdrNames_PaymentResultCode = map[int32]string{
	int32(PAYMENT_SUCCESS):            "PAYMENT_SUCCESS",
	int32(PAYMENT_MALFORMED):          "PAYMENT_MALFORMED",
	int32(PAYMENT_UNDERFUNDED):        "PAYMENT_UNDERFUNDED",
	int32(PAYMENT_SRC_NO_TRUST):       "PAYMENT_SRC_NO_TRUST",
	int32(PAYMENT_SRC_NOT_AUTHORIZED): "PAYMENT_SRC_NOT_AUTHORIZED",
	int32(PAYMENT_NO_DESTINATION):     "PAYMENT_NO_DESTINATION",
	int32(PAYMENT_NO_TRUST):           "PAYMENT_NO_TRUST",
	int32(PAYMENT_NOT_AUTHORIZED):     "PAYMENT_NOT_AUTHORIZED",
	int32(PAYMENT_LINE_FULL):          "PAYMENT_LINE_FULL",
	int32(PAYMENT_NO_ISSUER):          "PAYMENT_NO_ISSUER",
}
var _XdrValues_PaymentResultCode = map[string]int32{
	"PAYMENT_SUCCESS":            int32(PAYMENT_SUCCESS),
	"PAYMENT_MALFORMED":          int32(PAYMENT_MALFORMED),
	"PAYMENT_UNDERFUNDED":        int32(PAYMENT_UNDERFUNDED),
	"PAYMENT_SRC_NO_TRUST":       int32(PAYMENT_SRC_NO_TRUST),
	"PAYMENT_SRC_NOT_AUTHORIZED": int32(PAYMENT_SRC_NOT_AUTHORIZED),
	"PAYMENT_NO_DESTINATION":     int32(PAYMENT_NO_DESTINATION),
	"PAYMENT_NO_TRUST":           int32(PAYMENT_NO_TRUST),
	"PAYMENT_NOT_AUTHORIZED":     int32(PAYMENT_NOT_AUTHORIZED),
	"PAYMENT_LINE_FULL":          int32(PAYMENT_LINE_FULL),
	"PAYMENT_NO_ISSUER":          int32(PAYMENT_NO_ISSUER),
}

func (PaymentResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PaymentResultCode
}
func (v PaymentResultCode) String() string {
	if s, ok := _XdrNames_PaymentResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PaymentResultCode#%d", v)
}
func (v *PaymentResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PaymentResultCode[stok]; ok {
			*v = PaymentResultCode(val)
			return nil
		} else if stok == "PaymentResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PaymentResultCode.", stok))
	}
}
func (v PaymentResultCode) GetU32() uint32                 { return uint32(v) }
func (v *PaymentResultCode) SetU32(n uint32)               { *v = PaymentResultCode(n) }
func (v *PaymentResultCode) XdrPointer() interface{}       { return v }
func (PaymentResultCode) XdrTypeName() string              { return "PaymentResultCode" }
func (v PaymentResultCode) XdrValue() interface{}          { return v }
func (v *PaymentResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PaymentResultCode = *PaymentResultCode

func XDR_PaymentResultCode(v *PaymentResultCode) *PaymentResultCode { return v }

var _XdrComments_PaymentResultCode = map[int32]string{
	int32(PAYMENT_SUCCESS):            "payment successfully completed",
	int32(PAYMENT_MALFORMED):          "bad input",
	int32(PAYMENT_UNDERFUNDED):        "not enough funds in source account",
	int32(PAYMENT_SRC_NO_TRUST):       "no trust line on source account",
	int32(PAYMENT_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PAYMENT_NO_DESTINATION):     "destination account does not exist",
	int32(PAYMENT_NO_TRUST):           "destination missing a trust line for asset",
	int32(PAYMENT_NOT_AUTHORIZED):     "destination not authorized to hold asset",
	int32(PAYMENT_LINE_FULL):          "destination would go above their limit",
	int32(PAYMENT_NO_ISSUER):          "missing issuer on asset",
}

func (e PaymentResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PaymentResultCode
}

var _XdrTags_PaymentResult = map[int32]bool{
	XdrToI32(PAYMENT_SUCCESS):            true,
	XdrToI32(PAYMENT_MALFORMED):          true,
	XdrToI32(PAYMENT_UNDERFUNDED):        true,
	XdrToI32(PAYMENT_SRC_NO_TRUST):       true,
	XdrToI32(PAYMENT_SRC_NOT_AUTHORIZED): true,
	XdrToI32(PAYMENT_NO_DESTINATION):     true,
	XdrToI32(PAYMENT_NO_TRUST):           true,
	XdrToI32(PAYMENT_NOT_AUTHORIZED):     true,
	XdrToI32(PAYMENT_LINE_FULL):          true,
	XdrToI32(PAYMENT_NO_ISSUER):          true,
}

func (_ PaymentResult) XdrValidTags() map[int32]bool {
	return _XdrTags_PaymentResult
}
func (u PaymentResult) XdrValid() bool {
	switch u.Code {
	case PAYMENT_SUCCESS, PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
		return true
	}
	return false
}
func (u *PaymentResult) XdrUnionTag() XdrNum32 {
	return XDR_PaymentResultCode(&u.Code)
}
func (u *PaymentResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PaymentResult) XdrUnionBody() XdrType {
	switch u.Code {
	case PAYMENT_SUCCESS:
		return nil
	case PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
		return nil
	}
	return nil
}
func (u *PaymentResult) XdrUnionBodyName() string {
	switch u.Code {
	case PAYMENT_SUCCESS:
		return ""
	case PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
		return ""
	}
	return ""
}

type XdrType_PaymentResult = *PaymentResult

func (v *PaymentResult) XdrPointer() interface{}       { return v }
func (PaymentResult) XdrTypeName() string              { return "PaymentResult" }
func (v PaymentResult) XdrValue() interface{}          { return v }
func (v *PaymentResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PaymentResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PaymentResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PAYMENT_SUCCESS:
		return
	case PAYMENT_MALFORMED, PAYMENT_UNDERFUNDED, PAYMENT_SRC_NO_TRUST, PAYMENT_SRC_NOT_AUTHORIZED, PAYMENT_NO_DESTINATION, PAYMENT_NO_TRUST, PAYMENT_NOT_AUTHORIZED, PAYMENT_LINE_FULL, PAYMENT_NO_ISSUER:
		return
	}
	XdrPanic("invalid Code (%v) in PaymentResult", u.Code)
}
func XDR_PaymentResult(v *PaymentResult) *PaymentResult { return v }

var _XdrNames_PathPaymentStrictReceiveResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS):            "PATH_PAYMENT_STRICT_RECEIVE_SUCCESS",
	int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED):          "PATH_PAYMENT_STRICT_RECEIVE_MALFORMED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED):        "PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST):       "PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED): "PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION):     "PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST):           "PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED):     "PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL):          "PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER):          "PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER",
	int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS):     "PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF):   "PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX):       "PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX",
}
var _XdrValues_PathPaymentStrictReceiveResultCode = map[string]int32{
	"PATH_PAYMENT_STRICT_RECEIVE_SUCCESS":            int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS),
	"PATH_PAYMENT_STRICT_RECEIVE_MALFORMED":          int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED),
	"PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED":        int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED),
	"PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST":       int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST),
	"PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED": int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION":     int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST":           int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST),
	"PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED":     int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL":          int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL),
	"PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER":          int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER),
	"PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS":     int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS),
	"PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF":   int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF),
	"PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX":       int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX),
}

func (PathPaymentStrictReceiveResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PathPaymentStrictReceiveResultCode
}
func (v PathPaymentStrictReceiveResultCode) String() string {
	if s, ok := _XdrNames_PathPaymentStrictReceiveResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PathPaymentStrictReceiveResultCode#%d", v)
}
func (v *PathPaymentStrictReceiveResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PathPaymentStrictReceiveResultCode[stok]; ok {
			*v = PathPaymentStrictReceiveResultCode(val)
			return nil
		} else if stok == "PathPaymentStrictReceiveResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PathPaymentStrictReceiveResultCode.", stok))
	}
}
func (v PathPaymentStrictReceiveResultCode) GetU32() uint32 { return uint32(v) }
func (v *PathPaymentStrictReceiveResultCode) SetU32(n uint32) {
	*v = PathPaymentStrictReceiveResultCode(n)
}
func (v *PathPaymentStrictReceiveResultCode) XdrPointer() interface{} { return v }
func (PathPaymentStrictReceiveResultCode) XdrTypeName() string {
	return "PathPaymentStrictReceiveResultCode"
}
func (v PathPaymentStrictReceiveResultCode) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictReceiveResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PathPaymentStrictReceiveResultCode = *PathPaymentStrictReceiveResultCode

func XDR_PathPaymentStrictReceiveResultCode(v *PathPaymentStrictReceiveResultCode) *PathPaymentStrictReceiveResultCode {
	return v
}

var _XdrComments_PathPaymentStrictReceiveResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS):            "success",
	int32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED):          "bad input",
	int32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED):        "not enough funds in source account",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST):       "no trust line on source account",
	int32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION):     "destination account does not exist",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST):           "dest missing a trust line for asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED):     "dest not authorized to hold asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL):          "dest would go above their limit",
	int32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER):          "missing issuer on one asset",
	int32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS):     "not enough offers to satisfy path",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF):   "would cross one of its own offers",
	int32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX):       "could not satisfy sendmax",
}

func (e PathPaymentStrictReceiveResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PathPaymentStrictReceiveResultCode
}

type XdrType_SimplePaymentResult = *SimplePaymentResult

func (v *SimplePaymentResult) XdrPointer() interface{}       { return v }
func (SimplePaymentResult) XdrTypeName() string              { return "SimplePaymentResult" }
func (v SimplePaymentResult) XdrValue() interface{}          { return v }
func (v *SimplePaymentResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SimplePaymentResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_AccountID(&v.Destination))
	x.Marshal(x.Sprintf("%sasset", name), XDR_Asset(&v.Asset))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
}
func XDR_SimplePaymentResult(v *SimplePaymentResult) *SimplePaymentResult { return v }

type _XdrVec_unbounded_ClaimAtom []ClaimAtom

func (_XdrVec_unbounded_ClaimAtom) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_ClaimAtom) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_ClaimAtom length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_ClaimAtom length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_ClaimAtom) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_ClaimAtom) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ClaimAtom, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_ClaimAtom) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_ClaimAtom(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_ClaimAtom) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_ClaimAtom) XdrTypeName() string              { return "ClaimAtom<>" }
func (v *_XdrVec_unbounded_ClaimAtom) XdrPointer() interface{}       { return (*[]ClaimAtom)(v) }
func (v _XdrVec_unbounded_ClaimAtom) XdrValue() interface{}          { return ([]ClaimAtom)(v) }
func (v *_XdrVec_unbounded_ClaimAtom) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_XdrAnon_PathPaymentStrictReceiveResult_Success = *XdrAnon_PathPaymentStrictReceiveResult_Success

func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrPointer() interface{} { return v }
func (XdrAnon_PathPaymentStrictReceiveResult_Success) XdrTypeName() string {
	return "XdrAnon_PathPaymentStrictReceiveResult_Success"
}
func (v XdrAnon_PathPaymentStrictReceiveResult_Success) XdrValue() interface{} { return v }
func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_PathPaymentStrictReceiveResult_Success) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffers", name), (*_XdrVec_unbounded_ClaimAtom)(&v.Offers))
	x.Marshal(x.Sprintf("%slast", name), XDR_SimplePaymentResult(&v.Last))
}
func XDR_XdrAnon_PathPaymentStrictReceiveResult_Success(v *XdrAnon_PathPaymentStrictReceiveResult_Success) *XdrAnon_PathPaymentStrictReceiveResult_Success {
	return v
}

var _XdrTags_PathPaymentStrictReceiveResult = map[int32]bool{
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_SUCCESS):            true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_MALFORMED):          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED):        true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST):       true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED): true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION):     true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST):           true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED):     true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL):          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER):          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS):     true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF):   true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX):       true,
}

func (_ PathPaymentStrictReceiveResult) XdrValidTags() map[int32]bool {
	return _XdrTags_PathPaymentStrictReceiveResult
}
func (u *PathPaymentStrictReceiveResult) Success() *XdrAnon_PathPaymentStrictReceiveResult_Success {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		if v, ok := u._u.(*XdrAnon_PathPaymentStrictReceiveResult_Success); ok {
			return v
		} else {
			var zero XdrAnon_PathPaymentStrictReceiveResult_Success
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictReceiveResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}

// the asset that caused the error
func (u *PathPaymentStrictReceiveResult) NoIssuer() *Asset {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictReceiveResult.NoIssuer accessed when Code == %v", u.Code)
		return nil
	}
}
func (u PathPaymentStrictReceiveResult) XdrValid() bool {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS, PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL, PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER, PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
		return true
	}
	return false
}
func (u *PathPaymentStrictReceiveResult) XdrUnionTag() XdrNum32 {
	return XDR_PathPaymentStrictReceiveResultCode(&u.Code)
}
func (u *PathPaymentStrictReceiveResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PathPaymentStrictReceiveResult) XdrUnionBody() XdrType {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		return XDR_XdrAnon_PathPaymentStrictReceiveResult_Success(u.Success())
	case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
		return nil
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		return XDR_Asset(u.NoIssuer())
	case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
		return nil
	}
	return nil
}
func (u *PathPaymentStrictReceiveResult) XdrUnionBodyName() string {
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		return "Success"
	case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
		return ""
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		return "NoIssuer"
	case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
		return ""
	}
	return ""
}

type XdrType_PathPaymentStrictReceiveResult = *PathPaymentStrictReceiveResult

func (v *PathPaymentStrictReceiveResult) XdrPointer() interface{}       { return v }
func (PathPaymentStrictReceiveResult) XdrTypeName() string              { return "PathPaymentStrictReceiveResult" }
func (v PathPaymentStrictReceiveResult) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictReceiveResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PathPaymentStrictReceiveResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PathPaymentStrictReceiveResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_XdrAnon_PathPaymentStrictReceiveResult_Success(u.Success()))
		return
	case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED, PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED, PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION, PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST, PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
		return
	case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
		x.Marshal(x.Sprintf("%snoIssuer", name), XDR_Asset(u.NoIssuer()))
		return
	case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
		return
	}
	XdrPanic("invalid Code (%v) in PathPaymentStrictReceiveResult", u.Code)
}
func XDR_PathPaymentStrictReceiveResult(v *PathPaymentStrictReceiveResult) *PathPaymentStrictReceiveResult {
	return v
}

var _XdrNames_PathPaymentStrictSendResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_SEND_SUCCESS):            "PATH_PAYMENT_STRICT_SEND_SUCCESS",
	int32(PATH_PAYMENT_STRICT_SEND_MALFORMED):          "PATH_PAYMENT_STRICT_SEND_MALFORMED",
	int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED):        "PATH_PAYMENT_STRICT_SEND_UNDERFUNDED",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST):       "PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED): "PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION):     "PATH_PAYMENT_STRICT_SEND_NO_DESTINATION",
	int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST):           "PATH_PAYMENT_STRICT_SEND_NO_TRUST",
	int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED):     "PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL):          "PATH_PAYMENT_STRICT_SEND_LINE_FULL",
	int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER):          "PATH_PAYMENT_STRICT_SEND_NO_ISSUER",
	int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS):     "PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS",
	int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF):   "PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF",
	int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN):      "PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN",
}
var _XdrValues_PathPaymentStrictSendResultCode = map[string]int32{
	"PATH_PAYMENT_STRICT_SEND_SUCCESS":            int32(PATH_PAYMENT_STRICT_SEND_SUCCESS),
	"PATH_PAYMENT_STRICT_SEND_MALFORMED":          int32(PATH_PAYMENT_STRICT_SEND_MALFORMED),
	"PATH_PAYMENT_STRICT_SEND_UNDERFUNDED":        int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED),
	"PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST":       int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST),
	"PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED": int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_SEND_NO_DESTINATION":     int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION),
	"PATH_PAYMENT_STRICT_SEND_NO_TRUST":           int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST),
	"PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED":     int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED),
	"PATH_PAYMENT_STRICT_SEND_LINE_FULL":          int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL),
	"PATH_PAYMENT_STRICT_SEND_NO_ISSUER":          int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER),
	"PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS":     int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS),
	"PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF":   int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF),
	"PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN":      int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN),
}

func (PathPaymentStrictSendResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PathPaymentStrictSendResultCode
}
func (v PathPaymentStrictSendResultCode) String() string {
	if s, ok := _XdrNames_PathPaymentStrictSendResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PathPaymentStrictSendResultCode#%d", v)
}
func (v *PathPaymentStrictSendResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PathPaymentStrictSendResultCode[stok]; ok {
			*v = PathPaymentStrictSendResultCode(val)
			return nil
		} else if stok == "PathPaymentStrictSendResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PathPaymentStrictSendResultCode.", stok))
	}
}
func (v PathPaymentStrictSendResultCode) GetU32() uint32                 { return uint32(v) }
func (v *PathPaymentStrictSendResultCode) SetU32(n uint32)               { *v = PathPaymentStrictSendResultCode(n) }
func (v *PathPaymentStrictSendResultCode) XdrPointer() interface{}       { return v }
func (PathPaymentStrictSendResultCode) XdrTypeName() string              { return "PathPaymentStrictSendResultCode" }
func (v PathPaymentStrictSendResultCode) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictSendResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PathPaymentStrictSendResultCode = *PathPaymentStrictSendResultCode

func XDR_PathPaymentStrictSendResultCode(v *PathPaymentStrictSendResultCode) *PathPaymentStrictSendResultCode {
	return v
}

var _XdrComments_PathPaymentStrictSendResultCode = map[int32]string{
	int32(PATH_PAYMENT_STRICT_SEND_SUCCESS):            "success",
	int32(PATH_PAYMENT_STRICT_SEND_MALFORMED):          "bad input",
	int32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED):        "not enough funds in source account",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST):       "no trust line on source account",
	int32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED): "source not authorized to transfer",
	int32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION):     "destination account does not exist",
	int32(PATH_PAYMENT_STRICT_SEND_NO_TRUST):           "dest missing a trust line for asset",
	int32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED):     "dest not authorized to hold asset",
	int32(PATH_PAYMENT_STRICT_SEND_LINE_FULL):          "dest would go above their limit",
	int32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER):          "missing issuer on one asset",
	int32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS):     "not enough offers to satisfy path",
	int32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF):   "would cross one of its own offers",
	int32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN):      "could not satisfy destMin",
}

func (e PathPaymentStrictSendResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_PathPaymentStrictSendResultCode
}

type XdrType_XdrAnon_PathPaymentStrictSendResult_Success = *XdrAnon_PathPaymentStrictSendResult_Success

func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrPointer() interface{} { return v }
func (XdrAnon_PathPaymentStrictSendResult_Success) XdrTypeName() string {
	return "XdrAnon_PathPaymentStrictSendResult_Success"
}
func (v XdrAnon_PathPaymentStrictSendResult_Success) XdrValue() interface{} { return v }
func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrMarshal(x XDR, name string) {
	x.Marshal(name, v)
}
func (v *XdrAnon_PathPaymentStrictSendResult_Success) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffers", name), (*_XdrVec_unbounded_ClaimAtom)(&v.Offers))
	x.Marshal(x.Sprintf("%slast", name), XDR_SimplePaymentResult(&v.Last))
}
func XDR_XdrAnon_PathPaymentStrictSendResult_Success(v *XdrAnon_PathPaymentStrictSendResult_Success) *XdrAnon_PathPaymentStrictSendResult_Success {
	return v
}

var _XdrTags_PathPaymentStrictSendResult = map[int32]bool{
	XdrToI32(PATH_PAYMENT_STRICT_SEND_SUCCESS):            true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_MALFORMED):          true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_UNDERFUNDED):        true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST):       true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED): true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_NO_DESTINATION):     true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_NO_TRUST):           true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED):     true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_LINE_FULL):          true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_NO_ISSUER):          true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS):     true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF):   true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN):      true,
}

func (_ PathPaymentStrictSendResult) XdrValidTags() map[int32]bool {
	return _XdrTags_PathPaymentStrictSendResult
}
func (u *PathPaymentStrictSendResult) Success() *XdrAnon_PathPaymentStrictSendResult_Success {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		if v, ok := u._u.(*XdrAnon_PathPaymentStrictSendResult_Success); ok {
			return v
		} else {
			var zero XdrAnon_PathPaymentStrictSendResult_Success
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictSendResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}

// the asset that caused the error
func (u *PathPaymentStrictSendResult) NoIssuer() *Asset {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PathPaymentStrictSendResult.NoIssuer accessed when Code == %v", u.Code)
		return nil
	}
}
func (u PathPaymentStrictSendResult) XdrValid() bool {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS, PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL, PATH_PAYMENT_STRICT_SEND_NO_ISSUER, PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
		return true
	}
	return false
}
func (u *PathPaymentStrictSendResult) XdrUnionTag() XdrNum32 {
	return XDR_PathPaymentStrictSendResultCode(&u.Code)
}
func (u *PathPaymentStrictSendResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PathPaymentStrictSendResult) XdrUnionBody() XdrType {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		return XDR_XdrAnon_PathPaymentStrictSendResult_Success(u.Success())
	case PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL:
		return nil
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		return XDR_Asset(u.NoIssuer())
	case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
		return nil
	}
	return nil
}
func (u *PathPaymentStrictSendResult) XdrUnionBodyName() string {
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		return "Success"
	case PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL:
		return ""
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		return "NoIssuer"
	case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
		return ""
	}
	return ""
}

type XdrType_PathPaymentStrictSendResult = *PathPaymentStrictSendResult

func (v *PathPaymentStrictSendResult) XdrPointer() interface{}       { return v }
func (PathPaymentStrictSendResult) XdrTypeName() string              { return "PathPaymentStrictSendResult" }
func (v PathPaymentStrictSendResult) XdrValue() interface{}          { return v }
func (v *PathPaymentStrictSendResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PathPaymentStrictSendResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PathPaymentStrictSendResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case PATH_PAYMENT_STRICT_SEND_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_XdrAnon_PathPaymentStrictSendResult_Success(u.Success()))
		return
	case PATH_PAYMENT_STRICT_SEND_MALFORMED, PATH_PAYMENT_STRICT_SEND_UNDERFUNDED, PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST, PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_NO_DESTINATION, PATH_PAYMENT_STRICT_SEND_NO_TRUST, PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED, PATH_PAYMENT_STRICT_SEND_LINE_FULL:
		return
	case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
		x.Marshal(x.Sprintf("%snoIssuer", name), XDR_Asset(u.NoIssuer()))
		return
	case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS, PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF, PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
		return
	}
	XdrPanic("invalid Code (%v) in PathPaymentStrictSendResult", u.Code)
}
func XDR_PathPaymentStrictSendResult(v *PathPaymentStrictSendResult) *PathPaymentStrictSendResult {
	return v
}

var _XdrNames_ManageSellOfferResultCode = map[int32]string{
	int32(MANAGE_SELL_OFFER_SUCCESS):             "MANAGE_SELL_OFFER_SUCCESS",
	int32(MANAGE_SELL_OFFER_MALFORMED):           "MANAGE_SELL_OFFER_MALFORMED",
	int32(MANAGE_SELL_OFFER_SELL_NO_TRUST):       "MANAGE_SELL_OFFER_SELL_NO_TRUST",
	int32(MANAGE_SELL_OFFER_BUY_NO_TRUST):        "MANAGE_SELL_OFFER_BUY_NO_TRUST",
	int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED): "MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED",
	int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED):  "MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED",
	int32(MANAGE_SELL_OFFER_LINE_FULL):           "MANAGE_SELL_OFFER_LINE_FULL",
	int32(MANAGE_SELL_OFFER_UNDERFUNDED):         "MANAGE_SELL_OFFER_UNDERFUNDED",
	int32(MANAGE_SELL_OFFER_CROSS_SELF):          "MANAGE_SELL_OFFER_CROSS_SELF",
	int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER):      "MANAGE_SELL_OFFER_SELL_NO_ISSUER",
	int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER):       "MANAGE_SELL_OFFER_BUY_NO_ISSUER",
	int32(MANAGE_SELL_OFFER_NOT_FOUND):           "MANAGE_SELL_OFFER_NOT_FOUND",
	int32(MANAGE_SELL_OFFER_LOW_RESERVE):         "MANAGE_SELL_OFFER_LOW_RESERVE",
}
var _XdrValues_ManageSellOfferResultCode = map[string]int32{
	"MANAGE_SELL_OFFER_SUCCESS":             int32(MANAGE_SELL_OFFER_SUCCESS),
	"MANAGE_SELL_OFFER_MALFORMED":           int32(MANAGE_SELL_OFFER_MALFORMED),
	"MANAGE_SELL_OFFER_SELL_NO_TRUST":       int32(MANAGE_SELL_OFFER_SELL_NO_TRUST),
	"MANAGE_SELL_OFFER_BUY_NO_TRUST":        int32(MANAGE_SELL_OFFER_BUY_NO_TRUST),
	"MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED": int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED),
	"MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED":  int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED),
	"MANAGE_SELL_OFFER_LINE_FULL":           int32(MANAGE_SELL_OFFER_LINE_FULL),
	"MANAGE_SELL_OFFER_UNDERFUNDED":         int32(MANAGE_SELL_OFFER_UNDERFUNDED),
	"MANAGE_SELL_OFFER_CROSS_SELF":          int32(MANAGE_SELL_OFFER_CROSS_SELF),
	"MANAGE_SELL_OFFER_SELL_NO_ISSUER":      int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER),
	"MANAGE_SELL_OFFER_BUY_NO_ISSUER":       int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER),
	"MANAGE_SELL_OFFER_NOT_FOUND":           int32(MANAGE_SELL_OFFER_NOT_FOUND),
	"MANAGE_SELL_OFFER_LOW_RESERVE":         int32(MANAGE_SELL_OFFER_LOW_RESERVE),
}

func (ManageSellOfferResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageSellOfferResultCode
}
func (v ManageSellOfferResultCode) String() string {
	if s, ok := _XdrNames_ManageSellOfferResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageSellOfferResultCode#%d", v)
}
func (v *ManageSellOfferResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageSellOfferResultCode[stok]; ok {
			*v = ManageSellOfferResultCode(val)
			return nil
		} else if stok == "ManageSellOfferResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageSellOfferResultCode.", stok))
	}
}
func (v ManageSellOfferResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ManageSellOfferResultCode) SetU32(n uint32)               { *v = ManageSellOfferResultCode(n) }
func (v *ManageSellOfferResultCode) XdrPointer() interface{}       { return v }
func (ManageSellOfferResultCode) XdrTypeName() string              { return "ManageSellOfferResultCode" }
func (v ManageSellOfferResultCode) XdrValue() interface{}          { return v }
func (v *ManageSellOfferResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ManageSellOfferResultCode = *ManageSellOfferResultCode

func XDR_ManageSellOfferResultCode(v *ManageSellOfferResultCode) *ManageSellOfferResultCode { return v }

var _XdrComments_ManageSellOfferResultCode = map[int32]string{
	int32(MANAGE_SELL_OFFER_SUCCESS):             "codes considered as \"success\" for the operation",
	int32(MANAGE_SELL_OFFER_MALFORMED):           "generated offer would be invalid",
	int32(MANAGE_SELL_OFFER_SELL_NO_TRUST):       "no trust line for what we're selling",
	int32(MANAGE_SELL_OFFER_BUY_NO_TRUST):        "no trust line for what we're buying",
	int32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED): "not authorized to sell",
	int32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED):  "not authorized to buy",
	int32(MANAGE_SELL_OFFER_LINE_FULL):           "can't receive more of what it's buying",
	int32(MANAGE_SELL_OFFER_UNDERFUNDED):         "doesn't hold what it's trying to sell",
	int32(MANAGE_SELL_OFFER_CROSS_SELF):          "would cross an offer from the same user",
	int32(MANAGE_SELL_OFFER_SELL_NO_ISSUER):      "no issuer for what we're selling",
	int32(MANAGE_SELL_OFFER_BUY_NO_ISSUER):       "no issuer for what we're buying",
	int32(MANAGE_SELL_OFFER_NOT_FOUND):           "offerID does not match an existing offer",
	int32(MANAGE_SELL_OFFER_LOW_RESERVE):         "not enough funds to create a new Offer",
}

func (e ManageSellOfferResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageSellOfferResultCode
}

var _XdrNames_ManageOfferEffect = map[int32]string{
	int32(MANAGE_OFFER_CREATED): "MANAGE_OFFER_CREATED",
	int32(MANAGE_OFFER_UPDATED): "MANAGE_OFFER_UPDATED",
	int32(MANAGE_OFFER_DELETED): "MANAGE_OFFER_DELETED",
}
var _XdrValues_ManageOfferEffect = map[string]int32{
	"MANAGE_OFFER_CREATED": int32(MANAGE_OFFER_CREATED),
	"MANAGE_OFFER_UPDATED": int32(MANAGE_OFFER_UPDATED),
	"MANAGE_OFFER_DELETED": int32(MANAGE_OFFER_DELETED),
}

func (ManageOfferEffect) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageOfferEffect
}
func (v ManageOfferEffect) String() string {
	if s, ok := _XdrNames_ManageOfferEffect[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageOfferEffect#%d", v)
}
func (v *ManageOfferEffect) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageOfferEffect[stok]; ok {
			*v = ManageOfferEffect(val)
			return nil
		} else if stok == "ManageOfferEffect" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageOfferEffect.", stok))
	}
}
func (v ManageOfferEffect) GetU32() uint32                 { return uint32(v) }
func (v *ManageOfferEffect) SetU32(n uint32)               { *v = ManageOfferEffect(n) }
func (v *ManageOfferEffect) XdrPointer() interface{}       { return v }
func (ManageOfferEffect) XdrTypeName() string              { return "ManageOfferEffect" }
func (v ManageOfferEffect) XdrValue() interface{}          { return v }
func (v *ManageOfferEffect) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ManageOfferEffect = *ManageOfferEffect

func XDR_ManageOfferEffect(v *ManageOfferEffect) *ManageOfferEffect { return v }

var _XdrTags_XdrAnon_ManageOfferSuccessResult_Offer = map[int32]bool{
	XdrToI32(MANAGE_OFFER_CREATED): true,
	XdrToI32(MANAGE_OFFER_UPDATED): true,
	XdrToI32(MANAGE_OFFER_DELETED): true,
}

func (_ XdrAnon_ManageOfferSuccessResult_Offer) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_ManageOfferSuccessResult_Offer
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) Offer() *OfferEntry {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		if v, ok := u._u.(*OfferEntry); ok {
			return v
		} else {
			var zero OfferEntry
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_ManageOfferSuccessResult_Offer.Offer accessed when Effect == %v", u.Effect)
		return nil
	}
}
func (u XdrAnon_ManageOfferSuccessResult_Offer) XdrValid() bool {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED, MANAGE_OFFER_DELETED:
		return true
	}
	return false
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionTag() XdrNum32 {
	return XDR_ManageOfferEffect(&u.Effect)
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionTagName() string {
	return "Effect"
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionBody() XdrType {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		return XDR_OfferEntry(u.Offer())
	case MANAGE_OFFER_DELETED:
		return nil
	}
	return nil
}
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrUnionBodyName() string {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		return "Offer"
	case MANAGE_OFFER_DELETED:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_ManageOfferSuccessResult_Offer = *XdrAnon_ManageOfferSuccessResult_Offer

func (v *XdrAnon_ManageOfferSuccessResult_Offer) XdrPointer() interface{} { return v }
func (XdrAnon_ManageOfferSuccessResult_Offer) XdrTypeName() string {
	return "XdrAnon_ManageOfferSuccessResult_Offer"
}
func (v XdrAnon_ManageOfferSuccessResult_Offer) XdrValue() interface{}          { return v }
func (v *XdrAnon_ManageOfferSuccessResult_Offer) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_ManageOfferSuccessResult_Offer) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageOfferEffect(&u.Effect).XdrMarshal(x, x.Sprintf("%seffect", name))
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		x.Marshal(x.Sprintf("%soffer", name), XDR_OfferEntry(u.Offer()))
		return
	case MANAGE_OFFER_DELETED:
		return
	}
	XdrPanic("invalid Effect (%v) in XdrAnon_ManageOfferSuccessResult_Offer", u.Effect)
}
func XDR_XdrAnon_ManageOfferSuccessResult_Offer(v *XdrAnon_ManageOfferSuccessResult_Offer) *XdrAnon_ManageOfferSuccessResult_Offer {
	return v
}

type XdrType_ManageOfferSuccessResult = *ManageOfferSuccessResult

func (v *ManageOfferSuccessResult) XdrPointer() interface{}       { return v }
func (ManageOfferSuccessResult) XdrTypeName() string              { return "ManageOfferSuccessResult" }
func (v ManageOfferSuccessResult) XdrValue() interface{}          { return v }
func (v *ManageOfferSuccessResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ManageOfferSuccessResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffersClaimed", name), (*_XdrVec_unbounded_ClaimAtom)(&v.OffersClaimed))
	x.Marshal(x.Sprintf("%soffer", name), XDR_XdrAnon_ManageOfferSuccessResult_Offer(&v.Offer))
}
func XDR_ManageOfferSuccessResult(v *ManageOfferSuccessResult) *ManageOfferSuccessResult { return v }

var _XdrTags_ManageSellOfferResult = map[int32]bool{
	XdrToI32(MANAGE_SELL_OFFER_SUCCESS):             true,
	XdrToI32(MANAGE_SELL_OFFER_MALFORMED):           true,
	XdrToI32(MANAGE_SELL_OFFER_SELL_NO_TRUST):       true,
	XdrToI32(MANAGE_SELL_OFFER_BUY_NO_TRUST):        true,
	XdrToI32(MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED): true,
	XdrToI32(MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED):  true,
	XdrToI32(MANAGE_SELL_OFFER_LINE_FULL):           true,
	XdrToI32(MANAGE_SELL_OFFER_UNDERFUNDED):         true,
	XdrToI32(MANAGE_SELL_OFFER_CROSS_SELF):          true,
	XdrToI32(MANAGE_SELL_OFFER_SELL_NO_ISSUER):      true,
	XdrToI32(MANAGE_SELL_OFFER_BUY_NO_ISSUER):       true,
	XdrToI32(MANAGE_SELL_OFFER_NOT_FOUND):           true,
	XdrToI32(MANAGE_SELL_OFFER_LOW_RESERVE):         true,
}

func (_ ManageSellOfferResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ManageSellOfferResult
}
func (u *ManageSellOfferResult) Success() *ManageOfferSuccessResult {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		if v, ok := u._u.(*ManageOfferSuccessResult); ok {
			return v
		} else {
			var zero ManageOfferSuccessResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ManageSellOfferResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u ManageSellOfferResult) XdrValid() bool {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS, MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
		return true
	}
	return false
}
func (u *ManageSellOfferResult) XdrUnionTag() XdrNum32 {
	return XDR_ManageSellOfferResultCode(&u.Code)
}
func (u *ManageSellOfferResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageSellOfferResult) XdrUnionBody() XdrType {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		return XDR_ManageOfferSuccessResult(u.Success())
	case MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
		return nil
	}
	return nil
}
func (u *ManageSellOfferResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		return "Success"
	case MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
		return ""
	}
	return ""
}

type XdrType_ManageSellOfferResult = *ManageSellOfferResult

func (v *ManageSellOfferResult) XdrPointer() interface{}       { return v }
func (ManageSellOfferResult) XdrTypeName() string              { return "ManageSellOfferResult" }
func (v ManageSellOfferResult) XdrValue() interface{}          { return v }
func (v *ManageSellOfferResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageSellOfferResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageSellOfferResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_SELL_OFFER_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_ManageOfferSuccessResult(u.Success()))
		return
	case MANAGE_SELL_OFFER_MALFORMED, MANAGE_SELL_OFFER_SELL_NO_TRUST, MANAGE_SELL_OFFER_BUY_NO_TRUST, MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED, MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED, MANAGE_SELL_OFFER_LINE_FULL, MANAGE_SELL_OFFER_UNDERFUNDED, MANAGE_SELL_OFFER_CROSS_SELF, MANAGE_SELL_OFFER_SELL_NO_ISSUER, MANAGE_SELL_OFFER_BUY_NO_ISSUER, MANAGE_SELL_OFFER_NOT_FOUND, MANAGE_SELL_OFFER_LOW_RESERVE:
		return
	}
	XdrPanic("invalid Code (%v) in ManageSellOfferResult", u.Code)
}
func XDR_ManageSellOfferResult(v *ManageSellOfferResult) *ManageSellOfferResult { return v }

var _XdrNames_ManageBuyOfferResultCode = map[int32]string{
	int32(MANAGE_BUY_OFFER_SUCCESS):             "MANAGE_BUY_OFFER_SUCCESS",
	int32(MANAGE_BUY_OFFER_MALFORMED):           "MANAGE_BUY_OFFER_MALFORMED",
	int32(MANAGE_BUY_OFFER_SELL_NO_TRUST):       "MANAGE_BUY_OFFER_SELL_NO_TRUST",
	int32(MANAGE_BUY_OFFER_BUY_NO_TRUST):        "MANAGE_BUY_OFFER_BUY_NO_TRUST",
	int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED): "MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED",
	int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED):  "MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED",
	int32(MANAGE_BUY_OFFER_LINE_FULL):           "MANAGE_BUY_OFFER_LINE_FULL",
	int32(MANAGE_BUY_OFFER_UNDERFUNDED):         "MANAGE_BUY_OFFER_UNDERFUNDED",
	int32(MANAGE_BUY_OFFER_CROSS_SELF):          "MANAGE_BUY_OFFER_CROSS_SELF",
	int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER):      "MANAGE_BUY_OFFER_SELL_NO_ISSUER",
	int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER):       "MANAGE_BUY_OFFER_BUY_NO_ISSUER",
	int32(MANAGE_BUY_OFFER_NOT_FOUND):           "MANAGE_BUY_OFFER_NOT_FOUND",
	int32(MANAGE_BUY_OFFER_LOW_RESERVE):         "MANAGE_BUY_OFFER_LOW_RESERVE",
}
var _XdrValues_ManageBuyOfferResultCode = map[string]int32{
	"MANAGE_BUY_OFFER_SUCCESS":             int32(MANAGE_BUY_OFFER_SUCCESS),
	"MANAGE_BUY_OFFER_MALFORMED":           int32(MANAGE_BUY_OFFER_MALFORMED),
	"MANAGE_BUY_OFFER_SELL_NO_TRUST":       int32(MANAGE_BUY_OFFER_SELL_NO_TRUST),
	"MANAGE_BUY_OFFER_BUY_NO_TRUST":        int32(MANAGE_BUY_OFFER_BUY_NO_TRUST),
	"MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED": int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED),
	"MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED":  int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED),
	"MANAGE_BUY_OFFER_LINE_FULL":           int32(MANAGE_BUY_OFFER_LINE_FULL),
	"MANAGE_BUY_OFFER_UNDERFUNDED":         int32(MANAGE_BUY_OFFER_UNDERFUNDED),
	"MANAGE_BUY_OFFER_CROSS_SELF":          int32(MANAGE_BUY_OFFER_CROSS_SELF),
	"MANAGE_BUY_OFFER_SELL_NO_ISSUER":      int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER),
	"MANAGE_BUY_OFFER_BUY_NO_ISSUER":       int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER),
	"MANAGE_BUY_OFFER_NOT_FOUND":           int32(MANAGE_BUY_OFFER_NOT_FOUND),
	"MANAGE_BUY_OFFER_LOW_RESERVE":         int32(MANAGE_BUY_OFFER_LOW_RESERVE),
}

func (ManageBuyOfferResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageBuyOfferResultCode
}
func (v ManageBuyOfferResultCode) String() string {
	if s, ok := _XdrNames_ManageBuyOfferResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageBuyOfferResultCode#%d", v)
}
func (v *ManageBuyOfferResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageBuyOfferResultCode[stok]; ok {
			*v = ManageBuyOfferResultCode(val)
			return nil
		} else if stok == "ManageBuyOfferResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageBuyOfferResultCode.", stok))
	}
}
func (v ManageBuyOfferResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ManageBuyOfferResultCode) SetU32(n uint32)               { *v = ManageBuyOfferResultCode(n) }
func (v *ManageBuyOfferResultCode) XdrPointer() interface{}       { return v }
func (ManageBuyOfferResultCode) XdrTypeName() string              { return "ManageBuyOfferResultCode" }
func (v ManageBuyOfferResultCode) XdrValue() interface{}          { return v }
func (v *ManageBuyOfferResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ManageBuyOfferResultCode = *ManageBuyOfferResultCode

func XDR_ManageBuyOfferResultCode(v *ManageBuyOfferResultCode) *ManageBuyOfferResultCode { return v }

var _XdrComments_ManageBuyOfferResultCode = map[int32]string{
	int32(MANAGE_BUY_OFFER_SUCCESS):             "codes considered as \"success\" for the operation",
	int32(MANAGE_BUY_OFFER_MALFORMED):           "generated offer would be invalid",
	int32(MANAGE_BUY_OFFER_SELL_NO_TRUST):       "no trust line for what we're selling",
	int32(MANAGE_BUY_OFFER_BUY_NO_TRUST):        "no trust line for what we're buying",
	int32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED): "not authorized to sell",
	int32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED):  "not authorized to buy",
	int32(MANAGE_BUY_OFFER_LINE_FULL):           "can't receive more of what it's buying",
	int32(MANAGE_BUY_OFFER_UNDERFUNDED):         "doesn't hold what it's trying to sell",
	int32(MANAGE_BUY_OFFER_CROSS_SELF):          "would cross an offer from the same user",
	int32(MANAGE_BUY_OFFER_SELL_NO_ISSUER):      "no issuer for what we're selling",
	int32(MANAGE_BUY_OFFER_BUY_NO_ISSUER):       "no issuer for what we're buying",
	int32(MANAGE_BUY_OFFER_NOT_FOUND):           "offerID does not match an existing offer",
	int32(MANAGE_BUY_OFFER_LOW_RESERVE):         "not enough funds to create a new Offer",
}

func (e ManageBuyOfferResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageBuyOfferResultCode
}

var _XdrTags_ManageBuyOfferResult = map[int32]bool{
	XdrToI32(MANAGE_BUY_OFFER_SUCCESS):             true,
	XdrToI32(MANAGE_BUY_OFFER_MALFORMED):           true,
	XdrToI32(MANAGE_BUY_OFFER_SELL_NO_TRUST):       true,
	XdrToI32(MANAGE_BUY_OFFER_BUY_NO_TRUST):        true,
	XdrToI32(MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED): true,
	XdrToI32(MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED):  true,
	XdrToI32(MANAGE_BUY_OFFER_LINE_FULL):           true,
	XdrToI32(MANAGE_BUY_OFFER_UNDERFUNDED):         true,
	XdrToI32(MANAGE_BUY_OFFER_CROSS_SELF):          true,
	XdrToI32(MANAGE_BUY_OFFER_SELL_NO_ISSUER):      true,
	XdrToI32(MANAGE_BUY_OFFER_BUY_NO_ISSUER):       true,
	XdrToI32(MANAGE_BUY_OFFER_NOT_FOUND):           true,
	XdrToI32(MANAGE_BUY_OFFER_LOW_RESERVE):         true,
}

func (_ ManageBuyOfferResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ManageBuyOfferResult
}
func (u *ManageBuyOfferResult) Success() *ManageOfferSuccessResult {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		if v, ok := u._u.(*ManageOfferSuccessResult); ok {
			return v
		} else {
			var zero ManageOfferSuccessResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("ManageBuyOfferResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u ManageBuyOfferResult) XdrValid() bool {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS, MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
		return true
	}
	return false
}
func (u *ManageBuyOfferResult) XdrUnionTag() XdrNum32 {
	return XDR_ManageBuyOfferResultCode(&u.Code)
}
func (u *ManageBuyOfferResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageBuyOfferResult) XdrUnionBody() XdrType {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		return XDR_ManageOfferSuccessResult(u.Success())
	case MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
		return nil
	}
	return nil
}
func (u *ManageBuyOfferResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		return "Success"
	case MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
		return ""
	}
	return ""
}

type XdrType_ManageBuyOfferResult = *ManageBuyOfferResult

func (v *ManageBuyOfferResult) XdrPointer() interface{}       { return v }
func (ManageBuyOfferResult) XdrTypeName() string              { return "ManageBuyOfferResult" }
func (v ManageBuyOfferResult) XdrValue() interface{}          { return v }
func (v *ManageBuyOfferResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageBuyOfferResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageBuyOfferResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_BUY_OFFER_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_ManageOfferSuccessResult(u.Success()))
		return
	case MANAGE_BUY_OFFER_MALFORMED, MANAGE_BUY_OFFER_SELL_NO_TRUST, MANAGE_BUY_OFFER_BUY_NO_TRUST, MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED, MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED, MANAGE_BUY_OFFER_LINE_FULL, MANAGE_BUY_OFFER_UNDERFUNDED, MANAGE_BUY_OFFER_CROSS_SELF, MANAGE_BUY_OFFER_SELL_NO_ISSUER, MANAGE_BUY_OFFER_BUY_NO_ISSUER, MANAGE_BUY_OFFER_NOT_FOUND, MANAGE_BUY_OFFER_LOW_RESERVE:
		return
	}
	XdrPanic("invalid Code (%v) in ManageBuyOfferResult", u.Code)
}
func XDR_ManageBuyOfferResult(v *ManageBuyOfferResult) *ManageBuyOfferResult { return v }

var _XdrNames_SetOptionsResultCode = map[int32]string{
	int32(SET_OPTIONS_SUCCESS):                 "SET_OPTIONS_SUCCESS",
	int32(SET_OPTIONS_LOW_RESERVE):             "SET_OPTIONS_LOW_RESERVE",
	int32(SET_OPTIONS_TOO_MANY_SIGNERS):        "SET_OPTIONS_TOO_MANY_SIGNERS",
	int32(SET_OPTIONS_BAD_FLAGS):               "SET_OPTIONS_BAD_FLAGS",
	int32(SET_OPTIONS_INVALID_INFLATION):       "SET_OPTIONS_INVALID_INFLATION",
	int32(SET_OPTIONS_CANT_CHANGE):             "SET_OPTIONS_CANT_CHANGE",
	int32(SET_OPTIONS_UNKNOWN_FLAG):            "SET_OPTIONS_UNKNOWN_FLAG",
	int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE):  "SET_OPTIONS_THRESHOLD_OUT_OF_RANGE",
	int32(SET_OPTIONS_BAD_SIGNER):              "SET_OPTIONS_BAD_SIGNER",
	int32(SET_OPTIONS_INVALID_HOME_DOMAIN):     "SET_OPTIONS_INVALID_HOME_DOMAIN",
	int32(SET_OPTIONS_AUTH_REVOCABLE_REQUIRED): "SET_OPTIONS_AUTH_REVOCABLE_REQUIRED",
}
var _XdrValues_SetOptionsResultCode = map[string]int32{
	"SET_OPTIONS_SUCCESS":                 int32(SET_OPTIONS_SUCCESS),
	"SET_OPTIONS_LOW_RESERVE":             int32(SET_OPTIONS_LOW_RESERVE),
	"SET_OPTIONS_TOO_MANY_SIGNERS":        int32(SET_OPTIONS_TOO_MANY_SIGNERS),
	"SET_OPTIONS_BAD_FLAGS":               int32(SET_OPTIONS_BAD_FLAGS),
	"SET_OPTIONS_INVALID_INFLATION":       int32(SET_OPTIONS_INVALID_INFLATION),
	"SET_OPTIONS_CANT_CHANGE":             int32(SET_OPTIONS_CANT_CHANGE),
	"SET_OPTIONS_UNKNOWN_FLAG":            int32(SET_OPTIONS_UNKNOWN_FLAG),
	"SET_OPTIONS_THRESHOLD_OUT_OF_RANGE":  int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE),
	"SET_OPTIONS_BAD_SIGNER":              int32(SET_OPTIONS_BAD_SIGNER),
	"SET_OPTIONS_INVALID_HOME_DOMAIN":     int32(SET_OPTIONS_INVALID_HOME_DOMAIN),
	"SET_OPTIONS_AUTH_REVOCABLE_REQUIRED": int32(SET_OPTIONS_AUTH_REVOCABLE_REQUIRED),
}

func (SetOptionsResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SetOptionsResultCode
}
func (v SetOptionsResultCode) String() string {
	if s, ok := _XdrNames_SetOptionsResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SetOptionsResultCode#%d", v)
}
func (v *SetOptionsResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SetOptionsResultCode[stok]; ok {
			*v = SetOptionsResultCode(val)
			return nil
		} else if stok == "SetOptionsResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SetOptionsResultCode.", stok))
	}
}
func (v SetOptionsResultCode) GetU32() uint32                 { return uint32(v) }
func (v *SetOptionsResultCode) SetU32(n uint32)               { *v = SetOptionsResultCode(n) }
func (v *SetOptionsResultCode) XdrPointer() interface{}       { return v }
func (SetOptionsResultCode) XdrTypeName() string              { return "SetOptionsResultCode" }
func (v SetOptionsResultCode) XdrValue() interface{}          { return v }
func (v *SetOptionsResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SetOptionsResultCode = *SetOptionsResultCode

func XDR_SetOptionsResultCode(v *SetOptionsResultCode) *SetOptionsResultCode { return v }

var _XdrComments_SetOptionsResultCode = map[int32]string{
	int32(SET_OPTIONS_SUCCESS):                 "codes considered as \"success\" for the operation",
	int32(SET_OPTIONS_LOW_RESERVE):             "not enough funds to add a signer",
	int32(SET_OPTIONS_TOO_MANY_SIGNERS):        "max number of signers already reached",
	int32(SET_OPTIONS_BAD_FLAGS):               "invalid combination of clear/set flags",
	int32(SET_OPTIONS_INVALID_INFLATION):       "inflation account does not exist",
	int32(SET_OPTIONS_CANT_CHANGE):             "can no longer change this option",
	int32(SET_OPTIONS_UNKNOWN_FLAG):            "can't set an unknown flag",
	int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE):  "bad value for weight/threshold",
	int32(SET_OPTIONS_BAD_SIGNER):              "signer cannot be masterkey",
	int32(SET_OPTIONS_INVALID_HOME_DOMAIN):     "malformed home domain",
	int32(SET_OPTIONS_AUTH_REVOCABLE_REQUIRED): "auth revocable is required for clawback",
}

func (e SetOptionsResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_SetOptionsResultCode
}

var _XdrTags_SetOptionsResult = map[int32]bool{
	XdrToI32(SET_OPTIONS_SUCCESS):                 true,
	XdrToI32(SET_OPTIONS_LOW_RESERVE):             true,
	XdrToI32(SET_OPTIONS_TOO_MANY_SIGNERS):        true,
	XdrToI32(SET_OPTIONS_BAD_FLAGS):               true,
	XdrToI32(SET_OPTIONS_INVALID_INFLATION):       true,
	XdrToI32(SET_OPTIONS_CANT_CHANGE):             true,
	XdrToI32(SET_OPTIONS_UNKNOWN_FLAG):            true,
	XdrToI32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE):  true,
	XdrToI32(SET_OPTIONS_BAD_SIGNER):              true,
	XdrToI32(SET_OPTIONS_INVALID_HOME_DOMAIN):     true,
	XdrToI32(SET_OPTIONS_AUTH_REVOCABLE_REQUIRED): true,
}

func (_ SetOptionsResult) XdrValidTags() map[int32]bool {
	return _XdrTags_SetOptionsResult
}
func (u SetOptionsResult) XdrValid() bool {
	switch u.Code {
	case SET_OPTIONS_SUCCESS, SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
		return true
	}
	return false
}
func (u *SetOptionsResult) XdrUnionTag() XdrNum32 {
	return XDR_SetOptionsResultCode(&u.Code)
}
func (u *SetOptionsResult) XdrUnionTagName() string {
	return "Code"
}
func (u *SetOptionsResult) XdrUnionBody() XdrType {
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return nil
	case SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
		return nil
	}
	return nil
}
func (u *SetOptionsResult) XdrUnionBodyName() string {
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return ""
	case SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
		return ""
	}
	return ""
}

type XdrType_SetOptionsResult = *SetOptionsResult

func (v *SetOptionsResult) XdrPointer() interface{}       { return v }
func (SetOptionsResult) XdrTypeName() string              { return "SetOptionsResult" }
func (v SetOptionsResult) XdrValue() interface{}          { return v }
func (v *SetOptionsResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SetOptionsResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SetOptionsResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return
	case SET_OPTIONS_LOW_RESERVE, SET_OPTIONS_TOO_MANY_SIGNERS, SET_OPTIONS_BAD_FLAGS, SET_OPTIONS_INVALID_INFLATION, SET_OPTIONS_CANT_CHANGE, SET_OPTIONS_UNKNOWN_FLAG, SET_OPTIONS_THRESHOLD_OUT_OF_RANGE, SET_OPTIONS_BAD_SIGNER, SET_OPTIONS_INVALID_HOME_DOMAIN, SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
		return
	}
	XdrPanic("invalid Code (%v) in SetOptionsResult", u.Code)
}
func XDR_SetOptionsResult(v *SetOptionsResult) *SetOptionsResult { return v }

var _XdrNames_ChangeTrustResultCode = map[int32]string{
	int32(CHANGE_TRUST_SUCCESS):                       "CHANGE_TRUST_SUCCESS",
	int32(CHANGE_TRUST_MALFORMED):                     "CHANGE_TRUST_MALFORMED",
	int32(CHANGE_TRUST_NO_ISSUER):                     "CHANGE_TRUST_NO_ISSUER",
	int32(CHANGE_TRUST_INVALID_LIMIT):                 "CHANGE_TRUST_INVALID_LIMIT",
	int32(CHANGE_TRUST_LOW_RESERVE):                   "CHANGE_TRUST_LOW_RESERVE",
	int32(CHANGE_TRUST_SELF_NOT_ALLOWED):              "CHANGE_TRUST_SELF_NOT_ALLOWED",
	int32(CHANGE_TRUST_TRUST_LINE_MISSING):            "CHANGE_TRUST_TRUST_LINE_MISSING",
	int32(CHANGE_TRUST_CANNOT_DELETE):                 "CHANGE_TRUST_CANNOT_DELETE",
	int32(CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES): "CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES",
}
var _XdrValues_ChangeTrustResultCode = map[string]int32{
	"CHANGE_TRUST_SUCCESS":                       int32(CHANGE_TRUST_SUCCESS),
	"CHANGE_TRUST_MALFORMED":                     int32(CHANGE_TRUST_MALFORMED),
	"CHANGE_TRUST_NO_ISSUER":                     int32(CHANGE_TRUST_NO_ISSUER),
	"CHANGE_TRUST_INVALID_LIMIT":                 int32(CHANGE_TRUST_INVALID_LIMIT),
	"CHANGE_TRUST_LOW_RESERVE":                   int32(CHANGE_TRUST_LOW_RESERVE),
	"CHANGE_TRUST_SELF_NOT_ALLOWED":              int32(CHANGE_TRUST_SELF_NOT_ALLOWED),
	"CHANGE_TRUST_TRUST_LINE_MISSING":            int32(CHANGE_TRUST_TRUST_LINE_MISSING),
	"CHANGE_TRUST_CANNOT_DELETE":                 int32(CHANGE_TRUST_CANNOT_DELETE),
	"CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES": int32(CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES),
}

func (ChangeTrustResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ChangeTrustResultCode
}
func (v ChangeTrustResultCode) String() string {
	if s, ok := _XdrNames_ChangeTrustResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ChangeTrustResultCode#%d", v)
}
func (v *ChangeTrustResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ChangeTrustResultCode[stok]; ok {
			*v = ChangeTrustResultCode(val)
			return nil
		} else if stok == "ChangeTrustResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ChangeTrustResultCode.", stok))
	}
}
func (v ChangeTrustResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ChangeTrustResultCode) SetU32(n uint32)               { *v = ChangeTrustResultCode(n) }
func (v *ChangeTrustResultCode) XdrPointer() interface{}       { return v }
func (ChangeTrustResultCode) XdrTypeName() string              { return "ChangeTrustResultCode" }
func (v ChangeTrustResultCode) XdrValue() interface{}          { return v }
func (v *ChangeTrustResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ChangeTrustResultCode = *ChangeTrustResultCode

func XDR_ChangeTrustResultCode(v *ChangeTrustResultCode) *ChangeTrustResultCode { return v }

var _XdrComments_ChangeTrustResultCode = map[int32]string{
	int32(CHANGE_TRUST_SUCCESS):                       "codes considered as \"success\" for the operation",
	int32(CHANGE_TRUST_MALFORMED):                     "bad input",
	int32(CHANGE_TRUST_NO_ISSUER):                     "could not find issuer",
	int32(CHANGE_TRUST_INVALID_LIMIT):                 "cannot drop limit below balance",
	int32(CHANGE_TRUST_LOW_RESERVE):                   "not enough funds to create a new trust line,",
	int32(CHANGE_TRUST_SELF_NOT_ALLOWED):              "trusting self is not allowed",
	int32(CHANGE_TRUST_TRUST_LINE_MISSING):            "Asset trustline is missing for pool",
	int32(CHANGE_TRUST_CANNOT_DELETE):                 "Asset trustline is still referenced in a pool",
	int32(CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES): "Asset trustline is deauthorized",
}

func (e ChangeTrustResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ChangeTrustResultCode
}

var _XdrTags_ChangeTrustResult = map[int32]bool{
	XdrToI32(CHANGE_TRUST_SUCCESS):                       true,
	XdrToI32(CHANGE_TRUST_MALFORMED):                     true,
	XdrToI32(CHANGE_TRUST_NO_ISSUER):                     true,
	XdrToI32(CHANGE_TRUST_INVALID_LIMIT):                 true,
	XdrToI32(CHANGE_TRUST_LOW_RESERVE):                   true,
	XdrToI32(CHANGE_TRUST_SELF_NOT_ALLOWED):              true,
	XdrToI32(CHANGE_TRUST_TRUST_LINE_MISSING):            true,
	XdrToI32(CHANGE_TRUST_CANNOT_DELETE):                 true,
	XdrToI32(CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES): true,
}

func (_ ChangeTrustResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ChangeTrustResult
}
func (u ChangeTrustResult) XdrValid() bool {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS, CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
		return true
	}
	return false
}
func (u *ChangeTrustResult) XdrUnionTag() XdrNum32 {
	return XDR_ChangeTrustResultCode(&u.Code)
}
func (u *ChangeTrustResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ChangeTrustResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return nil
	case CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
		return nil
	}
	return nil
}
func (u *ChangeTrustResult) XdrUnionBodyName() string {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return ""
	case CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
		return ""
	}
	return ""
}

type XdrType_ChangeTrustResult = *ChangeTrustResult

func (v *ChangeTrustResult) XdrPointer() interface{}       { return v }
func (ChangeTrustResult) XdrTypeName() string              { return "ChangeTrustResult" }
func (v ChangeTrustResult) XdrValue() interface{}          { return v }
func (v *ChangeTrustResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ChangeTrustResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ChangeTrustResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return
	case CHANGE_TRUST_MALFORMED, CHANGE_TRUST_NO_ISSUER, CHANGE_TRUST_INVALID_LIMIT, CHANGE_TRUST_LOW_RESERVE, CHANGE_TRUST_SELF_NOT_ALLOWED, CHANGE_TRUST_TRUST_LINE_MISSING, CHANGE_TRUST_CANNOT_DELETE, CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
		return
	}
	XdrPanic("invalid Code (%v) in ChangeTrustResult", u.Code)
}
func XDR_ChangeTrustResult(v *ChangeTrustResult) *ChangeTrustResult { return v }

var _XdrNames_AllowTrustResultCode = map[int32]string{
	int32(ALLOW_TRUST_SUCCESS):            "ALLOW_TRUST_SUCCESS",
	int32(ALLOW_TRUST_MALFORMED):          "ALLOW_TRUST_MALFORMED",
	int32(ALLOW_TRUST_NO_TRUST_LINE):      "ALLOW_TRUST_NO_TRUST_LINE",
	int32(ALLOW_TRUST_TRUST_NOT_REQUIRED): "ALLOW_TRUST_TRUST_NOT_REQUIRED",
	int32(ALLOW_TRUST_CANT_REVOKE):        "ALLOW_TRUST_CANT_REVOKE",
	int32(ALLOW_TRUST_SELF_NOT_ALLOWED):   "ALLOW_TRUST_SELF_NOT_ALLOWED",
	int32(ALLOW_TRUST_LOW_RESERVE):        "ALLOW_TRUST_LOW_RESERVE",
}
var _XdrValues_AllowTrustResultCode = map[string]int32{
	"ALLOW_TRUST_SUCCESS":            int32(ALLOW_TRUST_SUCCESS),
	"ALLOW_TRUST_MALFORMED":          int32(ALLOW_TRUST_MALFORMED),
	"ALLOW_TRUST_NO_TRUST_LINE":      int32(ALLOW_TRUST_NO_TRUST_LINE),
	"ALLOW_TRUST_TRUST_NOT_REQUIRED": int32(ALLOW_TRUST_TRUST_NOT_REQUIRED),
	"ALLOW_TRUST_CANT_REVOKE":        int32(ALLOW_TRUST_CANT_REVOKE),
	"ALLOW_TRUST_SELF_NOT_ALLOWED":   int32(ALLOW_TRUST_SELF_NOT_ALLOWED),
	"ALLOW_TRUST_LOW_RESERVE":        int32(ALLOW_TRUST_LOW_RESERVE),
}

func (AllowTrustResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_AllowTrustResultCode
}
func (v AllowTrustResultCode) String() string {
	if s, ok := _XdrNames_AllowTrustResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AllowTrustResultCode#%d", v)
}
func (v *AllowTrustResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AllowTrustResultCode[stok]; ok {
			*v = AllowTrustResultCode(val)
			return nil
		} else if stok == "AllowTrustResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AllowTrustResultCode.", stok))
	}
}
func (v AllowTrustResultCode) GetU32() uint32                 { return uint32(v) }
func (v *AllowTrustResultCode) SetU32(n uint32)               { *v = AllowTrustResultCode(n) }
func (v *AllowTrustResultCode) XdrPointer() interface{}       { return v }
func (AllowTrustResultCode) XdrTypeName() string              { return "AllowTrustResultCode" }
func (v AllowTrustResultCode) XdrValue() interface{}          { return v }
func (v *AllowTrustResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AllowTrustResultCode = *AllowTrustResultCode

func XDR_AllowTrustResultCode(v *AllowTrustResultCode) *AllowTrustResultCode { return v }

var _XdrComments_AllowTrustResultCode = map[int32]string{
	int32(ALLOW_TRUST_SUCCESS):            "codes considered as \"success\" for the operation",
	int32(ALLOW_TRUST_MALFORMED):          "asset is not ASSET_TYPE_ALPHANUM",
	int32(ALLOW_TRUST_NO_TRUST_LINE):      "trustor does not have a trustline",
	int32(ALLOW_TRUST_TRUST_NOT_REQUIRED): "source account does not require trust",
	int32(ALLOW_TRUST_CANT_REVOKE):        "source account can't revoke trust,",
	int32(ALLOW_TRUST_SELF_NOT_ALLOWED):   "trusting self is not allowed",
	int32(ALLOW_TRUST_LOW_RESERVE):        "claimable balances can't be created",
}

func (e AllowTrustResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_AllowTrustResultCode
}

var _XdrTags_AllowTrustResult = map[int32]bool{
	XdrToI32(ALLOW_TRUST_SUCCESS):            true,
	XdrToI32(ALLOW_TRUST_MALFORMED):          true,
	XdrToI32(ALLOW_TRUST_NO_TRUST_LINE):      true,
	XdrToI32(ALLOW_TRUST_TRUST_NOT_REQUIRED): true,
	XdrToI32(ALLOW_TRUST_CANT_REVOKE):        true,
	XdrToI32(ALLOW_TRUST_SELF_NOT_ALLOWED):   true,
	XdrToI32(ALLOW_TRUST_LOW_RESERVE):        true,
}

func (_ AllowTrustResult) XdrValidTags() map[int32]bool {
	return _XdrTags_AllowTrustResult
}
func (u AllowTrustResult) XdrValid() bool {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS, ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
		return true
	}
	return false
}
func (u *AllowTrustResult) XdrUnionTag() XdrNum32 {
	return XDR_AllowTrustResultCode(&u.Code)
}
func (u *AllowTrustResult) XdrUnionTagName() string {
	return "Code"
}
func (u *AllowTrustResult) XdrUnionBody() XdrType {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return nil
	case ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
		return nil
	}
	return nil
}
func (u *AllowTrustResult) XdrUnionBodyName() string {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return ""
	case ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
		return ""
	}
	return ""
}

type XdrType_AllowTrustResult = *AllowTrustResult

func (v *AllowTrustResult) XdrPointer() interface{}       { return v }
func (AllowTrustResult) XdrTypeName() string              { return "AllowTrustResult" }
func (v AllowTrustResult) XdrValue() interface{}          { return v }
func (v *AllowTrustResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AllowTrustResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AllowTrustResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return
	case ALLOW_TRUST_MALFORMED, ALLOW_TRUST_NO_TRUST_LINE, ALLOW_TRUST_TRUST_NOT_REQUIRED, ALLOW_TRUST_CANT_REVOKE, ALLOW_TRUST_SELF_NOT_ALLOWED, ALLOW_TRUST_LOW_RESERVE:
		return
	}
	XdrPanic("invalid Code (%v) in AllowTrustResult", u.Code)
}
func XDR_AllowTrustResult(v *AllowTrustResult) *AllowTrustResult { return v }

var _XdrNames_AccountMergeResultCode = map[int32]string{
	int32(ACCOUNT_MERGE_SUCCESS):         "ACCOUNT_MERGE_SUCCESS",
	int32(ACCOUNT_MERGE_MALFORMED):       "ACCOUNT_MERGE_MALFORMED",
	int32(ACCOUNT_MERGE_NO_ACCOUNT):      "ACCOUNT_MERGE_NO_ACCOUNT",
	int32(ACCOUNT_MERGE_IMMUTABLE_SET):   "ACCOUNT_MERGE_IMMUTABLE_SET",
	int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): "ACCOUNT_MERGE_HAS_SUB_ENTRIES",
	int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR):  "ACCOUNT_MERGE_SEQNUM_TOO_FAR",
	int32(ACCOUNT_MERGE_DEST_FULL):       "ACCOUNT_MERGE_DEST_FULL",
	int32(ACCOUNT_MERGE_IS_SPONSOR):      "ACCOUNT_MERGE_IS_SPONSOR",
}
var _XdrValues_AccountMergeResultCode = map[string]int32{
	"ACCOUNT_MERGE_SUCCESS":         int32(ACCOUNT_MERGE_SUCCESS),
	"ACCOUNT_MERGE_MALFORMED":       int32(ACCOUNT_MERGE_MALFORMED),
	"ACCOUNT_MERGE_NO_ACCOUNT":      int32(ACCOUNT_MERGE_NO_ACCOUNT),
	"ACCOUNT_MERGE_IMMUTABLE_SET":   int32(ACCOUNT_MERGE_IMMUTABLE_SET),
	"ACCOUNT_MERGE_HAS_SUB_ENTRIES": int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES),
	"ACCOUNT_MERGE_SEQNUM_TOO_FAR":  int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR),
	"ACCOUNT_MERGE_DEST_FULL":       int32(ACCOUNT_MERGE_DEST_FULL),
	"ACCOUNT_MERGE_IS_SPONSOR":      int32(ACCOUNT_MERGE_IS_SPONSOR),
}

func (AccountMergeResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_AccountMergeResultCode
}
func (v AccountMergeResultCode) String() string {
	if s, ok := _XdrNames_AccountMergeResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("AccountMergeResultCode#%d", v)
}
func (v *AccountMergeResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AccountMergeResultCode[stok]; ok {
			*v = AccountMergeResultCode(val)
			return nil
		} else if stok == "AccountMergeResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid AccountMergeResultCode.", stok))
	}
}
func (v AccountMergeResultCode) GetU32() uint32                 { return uint32(v) }
func (v *AccountMergeResultCode) SetU32(n uint32)               { *v = AccountMergeResultCode(n) }
func (v *AccountMergeResultCode) XdrPointer() interface{}       { return v }
func (AccountMergeResultCode) XdrTypeName() string              { return "AccountMergeResultCode" }
func (v AccountMergeResultCode) XdrValue() interface{}          { return v }
func (v *AccountMergeResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_AccountMergeResultCode = *AccountMergeResultCode

func XDR_AccountMergeResultCode(v *AccountMergeResultCode) *AccountMergeResultCode { return v }

var _XdrComments_AccountMergeResultCode = map[int32]string{
	int32(ACCOUNT_MERGE_SUCCESS):         "codes considered as \"success\" for the operation",
	int32(ACCOUNT_MERGE_MALFORMED):       "can't merge onto itself",
	int32(ACCOUNT_MERGE_NO_ACCOUNT):      "destination does not exist",
	int32(ACCOUNT_MERGE_IMMUTABLE_SET):   "source account has AUTH_IMMUTABLE set",
	int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): "account has trust lines/offers",
	int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR):  "sequence number is over max allowed",
	int32(ACCOUNT_MERGE_DEST_FULL):       "can't add source balance to",
	int32(ACCOUNT_MERGE_IS_SPONSOR):      "destination balance",
}

func (e AccountMergeResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_AccountMergeResultCode
}

var _XdrTags_AccountMergeResult = map[int32]bool{
	XdrToI32(ACCOUNT_MERGE_SUCCESS):         true,
	XdrToI32(ACCOUNT_MERGE_MALFORMED):       true,
	XdrToI32(ACCOUNT_MERGE_NO_ACCOUNT):      true,
	XdrToI32(ACCOUNT_MERGE_IMMUTABLE_SET):   true,
	XdrToI32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): true,
	XdrToI32(ACCOUNT_MERGE_SEQNUM_TOO_FAR):  true,
	XdrToI32(ACCOUNT_MERGE_DEST_FULL):       true,
	XdrToI32(ACCOUNT_MERGE_IS_SPONSOR):      true,
}

func (_ AccountMergeResult) XdrValidTags() map[int32]bool {
	return _XdrTags_AccountMergeResult
}

// how much got transferred from source account
func (u *AccountMergeResult) SourceAccountBalance() *Int64 {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("AccountMergeResult.SourceAccountBalance accessed when Code == %v", u.Code)
		return nil
	}
}
func (u AccountMergeResult) XdrValid() bool {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS, ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
		return true
	}
	return false
}
func (u *AccountMergeResult) XdrUnionTag() XdrNum32 {
	return XDR_AccountMergeResultCode(&u.Code)
}
func (u *AccountMergeResult) XdrUnionTagName() string {
	return "Code"
}
func (u *AccountMergeResult) XdrUnionBody() XdrType {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		return XDR_Int64(u.SourceAccountBalance())
	case ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
		return nil
	}
	return nil
}
func (u *AccountMergeResult) XdrUnionBodyName() string {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		return "SourceAccountBalance"
	case ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
		return ""
	}
	return ""
}

type XdrType_AccountMergeResult = *AccountMergeResult

func (v *AccountMergeResult) XdrPointer() interface{}       { return v }
func (AccountMergeResult) XdrTypeName() string              { return "AccountMergeResult" }
func (v AccountMergeResult) XdrValue() interface{}          { return v }
func (v *AccountMergeResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *AccountMergeResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountMergeResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		x.Marshal(x.Sprintf("%ssourceAccountBalance", name), XDR_Int64(u.SourceAccountBalance()))
		return
	case ACCOUNT_MERGE_MALFORMED, ACCOUNT_MERGE_NO_ACCOUNT, ACCOUNT_MERGE_IMMUTABLE_SET, ACCOUNT_MERGE_HAS_SUB_ENTRIES, ACCOUNT_MERGE_SEQNUM_TOO_FAR, ACCOUNT_MERGE_DEST_FULL, ACCOUNT_MERGE_IS_SPONSOR:
		return
	}
	XdrPanic("invalid Code (%v) in AccountMergeResult", u.Code)
}
func XDR_AccountMergeResult(v *AccountMergeResult) *AccountMergeResult { return v }

var _XdrNames_InflationResultCode = map[int32]string{
	int32(INFLATION_SUCCESS):  "INFLATION_SUCCESS",
	int32(INFLATION_NOT_TIME): "INFLATION_NOT_TIME",
}
var _XdrValues_InflationResultCode = map[string]int32{
	"INFLATION_SUCCESS":  int32(INFLATION_SUCCESS),
	"INFLATION_NOT_TIME": int32(INFLATION_NOT_TIME),
}

func (InflationResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_InflationResultCode
}
func (v InflationResultCode) String() string {
	if s, ok := _XdrNames_InflationResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("InflationResultCode#%d", v)
}
func (v *InflationResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_InflationResultCode[stok]; ok {
			*v = InflationResultCode(val)
			return nil
		} else if stok == "InflationResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid InflationResultCode.", stok))
	}
}
func (v InflationResultCode) GetU32() uint32                 { return uint32(v) }
func (v *InflationResultCode) SetU32(n uint32)               { *v = InflationResultCode(n) }
func (v *InflationResultCode) XdrPointer() interface{}       { return v }
func (InflationResultCode) XdrTypeName() string              { return "InflationResultCode" }
func (v InflationResultCode) XdrValue() interface{}          { return v }
func (v *InflationResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_InflationResultCode = *InflationResultCode

func XDR_InflationResultCode(v *InflationResultCode) *InflationResultCode { return v }

var _XdrComments_InflationResultCode = map[int32]string{
	int32(INFLATION_SUCCESS):  "codes considered as \"success\" for the operation",
	int32(INFLATION_NOT_TIME): "codes considered as \"failure\" for the operation",
}

func (e InflationResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_InflationResultCode
}

type XdrType_InflationPayout = *InflationPayout

func (v *InflationPayout) XdrPointer() interface{}       { return v }
func (InflationPayout) XdrTypeName() string              { return "InflationPayout" }
func (v InflationPayout) XdrValue() interface{}          { return v }
func (v *InflationPayout) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InflationPayout) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdestination", name), XDR_AccountID(&v.Destination))
	x.Marshal(x.Sprintf("%samount", name), XDR_Int64(&v.Amount))
}
func XDR_InflationPayout(v *InflationPayout) *InflationPayout { return v }

type _XdrVec_unbounded_InflationPayout []InflationPayout

func (_XdrVec_unbounded_InflationPayout) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_InflationPayout) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_InflationPayout length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_InflationPayout length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_InflationPayout) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_InflationPayout) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]InflationPayout, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_InflationPayout) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_InflationPayout(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_InflationPayout) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_InflationPayout) XdrTypeName() string              { return "InflationPayout<>" }
func (v *_XdrVec_unbounded_InflationPayout) XdrPointer() interface{}       { return (*[]InflationPayout)(v) }
func (v _XdrVec_unbounded_InflationPayout) XdrValue() interface{}          { return ([]InflationPayout)(v) }
func (v *_XdrVec_unbounded_InflationPayout) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_InflationResult = map[int32]bool{
	XdrToI32(INFLATION_SUCCESS):  true,
	XdrToI32(INFLATION_NOT_TIME): true,
}

func (_ InflationResult) XdrValidTags() map[int32]bool {
	return _XdrTags_InflationResult
}
func (u *InflationResult) Payouts() *[]InflationPayout {
	switch u.Code {
	case INFLATION_SUCCESS:
		if v, ok := u._u.(*[]InflationPayout); ok {
			return v
		} else {
			var zero []InflationPayout
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("InflationResult.Payouts accessed when Code == %v", u.Code)
		return nil
	}
}
func (u InflationResult) XdrValid() bool {
	switch u.Code {
	case INFLATION_SUCCESS, INFLATION_NOT_TIME:
		return true
	}
	return false
}
func (u *InflationResult) XdrUnionTag() XdrNum32 {
	return XDR_InflationResultCode(&u.Code)
}
func (u *InflationResult) XdrUnionTagName() string {
	return "Code"
}
func (u *InflationResult) XdrUnionBody() XdrType {
	switch u.Code {
	case INFLATION_SUCCESS:
		return (*_XdrVec_unbounded_InflationPayout)(u.Payouts())
	case INFLATION_NOT_TIME:
		return nil
	}
	return nil
}
func (u *InflationResult) XdrUnionBodyName() string {
	switch u.Code {
	case INFLATION_SUCCESS:
		return "Payouts"
	case INFLATION_NOT_TIME:
		return ""
	}
	return ""
}

type XdrType_InflationResult = *InflationResult

func (v *InflationResult) XdrPointer() interface{}       { return v }
func (InflationResult) XdrTypeName() string              { return "InflationResult" }
func (v InflationResult) XdrValue() interface{}          { return v }
func (v *InflationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *InflationResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_InflationResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case INFLATION_SUCCESS:
		x.Marshal(x.Sprintf("%spayouts", name), (*_XdrVec_unbounded_InflationPayout)(u.Payouts()))
		return
	case INFLATION_NOT_TIME:
		return
	}
	XdrPanic("invalid Code (%v) in InflationResult", u.Code)
}
func XDR_InflationResult(v *InflationResult) *InflationResult { return v }

var _XdrNames_ManageDataResultCode = map[int32]string{
	int32(MANAGE_DATA_SUCCESS):           "MANAGE_DATA_SUCCESS",
	int32(MANAGE_DATA_NOT_SUPPORTED_YET): "MANAGE_DATA_NOT_SUPPORTED_YET",
	int32(MANAGE_DATA_NAME_NOT_FOUND):    "MANAGE_DATA_NAME_NOT_FOUND",
	int32(MANAGE_DATA_LOW_RESERVE):       "MANAGE_DATA_LOW_RESERVE",
	int32(MANAGE_DATA_INVALID_NAME):      "MANAGE_DATA_INVALID_NAME",
}
var _XdrValues_ManageDataResultCode = map[string]int32{
	"MANAGE_DATA_SUCCESS":           int32(MANAGE_DATA_SUCCESS),
	"MANAGE_DATA_NOT_SUPPORTED_YET": int32(MANAGE_DATA_NOT_SUPPORTED_YET),
	"MANAGE_DATA_NAME_NOT_FOUND":    int32(MANAGE_DATA_NAME_NOT_FOUND),
	"MANAGE_DATA_LOW_RESERVE":       int32(MANAGE_DATA_LOW_RESERVE),
	"MANAGE_DATA_INVALID_NAME":      int32(MANAGE_DATA_INVALID_NAME),
}

func (ManageDataResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageDataResultCode
}
func (v ManageDataResultCode) String() string {
	if s, ok := _XdrNames_ManageDataResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageDataResultCode#%d", v)
}
func (v *ManageDataResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageDataResultCode[stok]; ok {
			*v = ManageDataResultCode(val)
			return nil
		} else if stok == "ManageDataResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageDataResultCode.", stok))
	}
}
func (v ManageDataResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ManageDataResultCode) SetU32(n uint32)               { *v = ManageDataResultCode(n) }
func (v *ManageDataResultCode) XdrPointer() interface{}       { return v }
func (ManageDataResultCode) XdrTypeName() string              { return "ManageDataResultCode" }
func (v ManageDataResultCode) XdrValue() interface{}          { return v }
func (v *ManageDataResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ManageDataResultCode = *ManageDataResultCode

func XDR_ManageDataResultCode(v *ManageDataResultCode) *ManageDataResultCode { return v }

var _XdrComments_ManageDataResultCode = map[int32]string{
	int32(MANAGE_DATA_SUCCESS):           "codes considered as \"success\" for the operation",
	int32(MANAGE_DATA_NOT_SUPPORTED_YET): "The network hasn't moved to this protocol change yet",
	int32(MANAGE_DATA_NAME_NOT_FOUND):    "Trying to remove a Data Entry that isn't there",
	int32(MANAGE_DATA_LOW_RESERVE):       "not enough funds to create a new Data Entry",
	int32(MANAGE_DATA_INVALID_NAME):      "Name not a valid string",
}

func (e ManageDataResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ManageDataResultCode
}

var _XdrTags_ManageDataResult = map[int32]bool{
	XdrToI32(MANAGE_DATA_SUCCESS):           true,
	XdrToI32(MANAGE_DATA_NOT_SUPPORTED_YET): true,
	XdrToI32(MANAGE_DATA_NAME_NOT_FOUND):    true,
	XdrToI32(MANAGE_DATA_LOW_RESERVE):       true,
	XdrToI32(MANAGE_DATA_INVALID_NAME):      true,
}

func (_ ManageDataResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ManageDataResult
}
func (u ManageDataResult) XdrValid() bool {
	switch u.Code {
	case MANAGE_DATA_SUCCESS, MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
		return true
	}
	return false
}
func (u *ManageDataResult) XdrUnionTag() XdrNum32 {
	return XDR_ManageDataResultCode(&u.Code)
}
func (u *ManageDataResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageDataResult) XdrUnionBody() XdrType {
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return nil
	case MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
		return nil
	}
	return nil
}
func (u *ManageDataResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return ""
	case MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
		return ""
	}
	return ""
}

type XdrType_ManageDataResult = *ManageDataResult

func (v *ManageDataResult) XdrPointer() interface{}       { return v }
func (ManageDataResult) XdrTypeName() string              { return "ManageDataResult" }
func (v ManageDataResult) XdrValue() interface{}          { return v }
func (v *ManageDataResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ManageDataResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageDataResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return
	case MANAGE_DATA_NOT_SUPPORTED_YET, MANAGE_DATA_NAME_NOT_FOUND, MANAGE_DATA_LOW_RESERVE, MANAGE_DATA_INVALID_NAME:
		return
	}
	XdrPanic("invalid Code (%v) in ManageDataResult", u.Code)
}
func XDR_ManageDataResult(v *ManageDataResult) *ManageDataResult { return v }

var _XdrNames_BumpSequenceResultCode = map[int32]string{
	int32(BUMP_SEQUENCE_SUCCESS): "BUMP_SEQUENCE_SUCCESS",
	int32(BUMP_SEQUENCE_BAD_SEQ): "BUMP_SEQUENCE_BAD_SEQ",
}
var _XdrValues_BumpSequenceResultCode = map[string]int32{
	"BUMP_SEQUENCE_SUCCESS": int32(BUMP_SEQUENCE_SUCCESS),
	"BUMP_SEQUENCE_BAD_SEQ": int32(BUMP_SEQUENCE_BAD_SEQ),
}

func (BumpSequenceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_BumpSequenceResultCode
}
func (v BumpSequenceResultCode) String() string {
	if s, ok := _XdrNames_BumpSequenceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("BumpSequenceResultCode#%d", v)
}
func (v *BumpSequenceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BumpSequenceResultCode[stok]; ok {
			*v = BumpSequenceResultCode(val)
			return nil
		} else if stok == "BumpSequenceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid BumpSequenceResultCode.", stok))
	}
}
func (v BumpSequenceResultCode) GetU32() uint32                 { return uint32(v) }
func (v *BumpSequenceResultCode) SetU32(n uint32)               { *v = BumpSequenceResultCode(n) }
func (v *BumpSequenceResultCode) XdrPointer() interface{}       { return v }
func (BumpSequenceResultCode) XdrTypeName() string              { return "BumpSequenceResultCode" }
func (v BumpSequenceResultCode) XdrValue() interface{}          { return v }
func (v *BumpSequenceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_BumpSequenceResultCode = *BumpSequenceResultCode

func XDR_BumpSequenceResultCode(v *BumpSequenceResultCode) *BumpSequenceResultCode { return v }

var _XdrComments_BumpSequenceResultCode = map[int32]string{
	int32(BUMP_SEQUENCE_SUCCESS): "codes considered as \"success\" for the operation",
	int32(BUMP_SEQUENCE_BAD_SEQ): "codes considered as \"failure\" for the operation",
}

func (e BumpSequenceResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_BumpSequenceResultCode
}

var _XdrTags_BumpSequenceResult = map[int32]bool{
	XdrToI32(BUMP_SEQUENCE_SUCCESS): true,
	XdrToI32(BUMP_SEQUENCE_BAD_SEQ): true,
}

func (_ BumpSequenceResult) XdrValidTags() map[int32]bool {
	return _XdrTags_BumpSequenceResult
}
func (u BumpSequenceResult) XdrValid() bool {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS, BUMP_SEQUENCE_BAD_SEQ:
		return true
	}
	return false
}
func (u *BumpSequenceResult) XdrUnionTag() XdrNum32 {
	return XDR_BumpSequenceResultCode(&u.Code)
}
func (u *BumpSequenceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *BumpSequenceResult) XdrUnionBody() XdrType {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return nil
	case BUMP_SEQUENCE_BAD_SEQ:
		return nil
	}
	return nil
}
func (u *BumpSequenceResult) XdrUnionBodyName() string {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return ""
	case BUMP_SEQUENCE_BAD_SEQ:
		return ""
	}
	return ""
}

type XdrType_BumpSequenceResult = *BumpSequenceResult

func (v *BumpSequenceResult) XdrPointer() interface{}       { return v }
func (BumpSequenceResult) XdrTypeName() string              { return "BumpSequenceResult" }
func (v BumpSequenceResult) XdrValue() interface{}          { return v }
func (v *BumpSequenceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *BumpSequenceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BumpSequenceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return
	case BUMP_SEQUENCE_BAD_SEQ:
		return
	}
	XdrPanic("invalid Code (%v) in BumpSequenceResult", u.Code)
}
func XDR_BumpSequenceResult(v *BumpSequenceResult) *BumpSequenceResult { return v }

var _XdrNames_CreateClaimableBalanceResultCode = map[int32]string{
	int32(CREATE_CLAIMABLE_BALANCE_SUCCESS):        "CREATE_CLAIMABLE_BALANCE_SUCCESS",
	int32(CREATE_CLAIMABLE_BALANCE_MALFORMED):      "CREATE_CLAIMABLE_BALANCE_MALFORMED",
	int32(CREATE_CLAIMABLE_BALANCE_LOW_RESERVE):    "CREATE_CLAIMABLE_BALANCE_LOW_RESERVE",
	int32(CREATE_CLAIMABLE_BALANCE_NO_TRUST):       "CREATE_CLAIMABLE_BALANCE_NO_TRUST",
	int32(CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED): "CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED",
	int32(CREATE_CLAIMABLE_BALANCE_UNDERFUNDED):    "CREATE_CLAIMABLE_BALANCE_UNDERFUNDED",
}
var _XdrValues_CreateClaimableBalanceResultCode = map[string]int32{
	"CREATE_CLAIMABLE_BALANCE_SUCCESS":        int32(CREATE_CLAIMABLE_BALANCE_SUCCESS),
	"CREATE_CLAIMABLE_BALANCE_MALFORMED":      int32(CREATE_CLAIMABLE_BALANCE_MALFORMED),
	"CREATE_CLAIMABLE_BALANCE_LOW_RESERVE":    int32(CREATE_CLAIMABLE_BALANCE_LOW_RESERVE),
	"CREATE_CLAIMABLE_BALANCE_NO_TRUST":       int32(CREATE_CLAIMABLE_BALANCE_NO_TRUST),
	"CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED": int32(CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED),
	"CREATE_CLAIMABLE_BALANCE_UNDERFUNDED":    int32(CREATE_CLAIMABLE_BALANCE_UNDERFUNDED),
}

func (CreateClaimableBalanceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_CreateClaimableBalanceResultCode
}
func (v CreateClaimableBalanceResultCode) String() string {
	if s, ok := _XdrNames_CreateClaimableBalanceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("CreateClaimableBalanceResultCode#%d", v)
}
func (v *CreateClaimableBalanceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CreateClaimableBalanceResultCode[stok]; ok {
			*v = CreateClaimableBalanceResultCode(val)
			return nil
		} else if stok == "CreateClaimableBalanceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid CreateClaimableBalanceResultCode.", stok))
	}
}
func (v CreateClaimableBalanceResultCode) GetU32() uint32           { return uint32(v) }
func (v *CreateClaimableBalanceResultCode) SetU32(n uint32)         { *v = CreateClaimableBalanceResultCode(n) }
func (v *CreateClaimableBalanceResultCode) XdrPointer() interface{} { return v }
func (CreateClaimableBalanceResultCode) XdrTypeName() string {
	return "CreateClaimableBalanceResultCode"
}
func (v CreateClaimableBalanceResultCode) XdrValue() interface{}          { return v }
func (v *CreateClaimableBalanceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_CreateClaimableBalanceResultCode = *CreateClaimableBalanceResultCode

func XDR_CreateClaimableBalanceResultCode(v *CreateClaimableBalanceResultCode) *CreateClaimableBalanceResultCode {
	return v
}

var _XdrTags_CreateClaimableBalanceResult = map[int32]bool{
	XdrToI32(CREATE_CLAIMABLE_BALANCE_SUCCESS):        true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_MALFORMED):      true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_LOW_RESERVE):    true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_NO_TRUST):       true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED): true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE_UNDERFUNDED):    true,
}

func (_ CreateClaimableBalanceResult) XdrValidTags() map[int32]bool {
	return _XdrTags_CreateClaimableBalanceResult
}
func (u *CreateClaimableBalanceResult) BalanceID() *ClaimableBalanceID {
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS:
		if v, ok := u._u.(*ClaimableBalanceID); ok {
			return v
		} else {
			var zero ClaimableBalanceID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("CreateClaimableBalanceResult.BalanceID accessed when Code == %v", u.Code)
		return nil
	}
}
func (u CreateClaimableBalanceResult) XdrValid() bool {
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS, CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
		return true
	}
	return false
}
func (u *CreateClaimableBalanceResult) XdrUnionTag() XdrNum32 {
	return XDR_CreateClaimableBalanceResultCode(&u.Code)
}
func (u *CreateClaimableBalanceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *CreateClaimableBalanceResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS:
		return XDR_ClaimableBalanceID(u.BalanceID())
	case CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
		return nil
	}
	return nil
}
func (u *CreateClaimableBalanceResult) XdrUnionBodyName() string {
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS:
		return "BalanceID"
	case CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
		return ""
	}
	return ""
}

type XdrType_CreateClaimableBalanceResult = *CreateClaimableBalanceResult

func (v *CreateClaimableBalanceResult) XdrPointer() interface{}       { return v }
func (CreateClaimableBalanceResult) XdrTypeName() string              { return "CreateClaimableBalanceResult" }
func (v CreateClaimableBalanceResult) XdrValue() interface{}          { return v }
func (v *CreateClaimableBalanceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CreateClaimableBalanceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_CreateClaimableBalanceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CREATE_CLAIMABLE_BALANCE_SUCCESS:
		x.Marshal(x.Sprintf("%sbalanceID", name), XDR_ClaimableBalanceID(u.BalanceID()))
		return
	case CREATE_CLAIMABLE_BALANCE_MALFORMED, CREATE_CLAIMABLE_BALANCE_LOW_RESERVE, CREATE_CLAIMABLE_BALANCE_NO_TRUST, CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED, CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
		return
	}
	XdrPanic("invalid Code (%v) in CreateClaimableBalanceResult", u.Code)
}
func XDR_CreateClaimableBalanceResult(v *CreateClaimableBalanceResult) *CreateClaimableBalanceResult {
	return v
}

var _XdrNames_ClaimClaimableBalanceResultCode = map[int32]string{
	int32(CLAIM_CLAIMABLE_BALANCE_SUCCESS):        "CLAIM_CLAIMABLE_BALANCE_SUCCESS",
	int32(CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST): "CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST",
	int32(CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM):   "CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM",
	int32(CLAIM_CLAIMABLE_BALANCE_LINE_FULL):      "CLAIM_CLAIMABLE_BALANCE_LINE_FULL",
	int32(CLAIM_CLAIMABLE_BALANCE_NO_TRUST):       "CLAIM_CLAIMABLE_BALANCE_NO_TRUST",
	int32(CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED): "CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED",
}
var _XdrValues_ClaimClaimableBalanceResultCode = map[string]int32{
	"CLAIM_CLAIMABLE_BALANCE_SUCCESS":        int32(CLAIM_CLAIMABLE_BALANCE_SUCCESS),
	"CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST": int32(CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST),
	"CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM":   int32(CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM),
	"CLAIM_CLAIMABLE_BALANCE_LINE_FULL":      int32(CLAIM_CLAIMABLE_BALANCE_LINE_FULL),
	"CLAIM_CLAIMABLE_BALANCE_NO_TRUST":       int32(CLAIM_CLAIMABLE_BALANCE_NO_TRUST),
	"CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED": int32(CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED),
}

func (ClaimClaimableBalanceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ClaimClaimableBalanceResultCode
}
func (v ClaimClaimableBalanceResultCode) String() string {
	if s, ok := _XdrNames_ClaimClaimableBalanceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClaimClaimableBalanceResultCode#%d", v)
}
func (v *ClaimClaimableBalanceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClaimClaimableBalanceResultCode[stok]; ok {
			*v = ClaimClaimableBalanceResultCode(val)
			return nil
		} else if stok == "ClaimClaimableBalanceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClaimClaimableBalanceResultCode.", stok))
	}
}
func (v ClaimClaimableBalanceResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ClaimClaimableBalanceResultCode) SetU32(n uint32)               { *v = ClaimClaimableBalanceResultCode(n) }
func (v *ClaimClaimableBalanceResultCode) XdrPointer() interface{}       { return v }
func (ClaimClaimableBalanceResultCode) XdrTypeName() string              { return "ClaimClaimableBalanceResultCode" }
func (v ClaimClaimableBalanceResultCode) XdrValue() interface{}          { return v }
func (v *ClaimClaimableBalanceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClaimClaimableBalanceResultCode = *ClaimClaimableBalanceResultCode

func XDR_ClaimClaimableBalanceResultCode(v *ClaimClaimableBalanceResultCode) *ClaimClaimableBalanceResultCode {
	return v
}

var _XdrTags_ClaimClaimableBalanceResult = map[int32]bool{
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_SUCCESS):        true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST): true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM):   true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_LINE_FULL):      true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_NO_TRUST):       true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED): true,
}

func (_ ClaimClaimableBalanceResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ClaimClaimableBalanceResult
}
func (u ClaimClaimableBalanceResult) XdrValid() bool {
	switch u.Code {
	case CLAIM_CLAIMABLE_BALANCE_SUCCESS, CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
		return true
	}
	return false
}
func (u *ClaimClaimableBalanceResult) XdrUnionTag() XdrNum32 {
	return XDR_ClaimClaimableBalanceResultCode(&u.Code)
}
func (u *ClaimClaimableBalanceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ClaimClaimableBalanceResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CLAIM_CLAIMABLE_BALANCE_SUCCESS:
		return nil
	case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
		return nil
	}
	return nil
}
func (u *ClaimClaimableBalanceResult) XdrUnionBodyName() string {
	switch u.Code {
	case CLAIM_CLAIMABLE_BALANCE_SUCCESS:
		return ""
	case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
		return ""
	}
	return ""
}

type XdrType_ClaimClaimableBalanceResult = *ClaimClaimableBalanceResult

func (v *ClaimClaimableBalanceResult) XdrPointer() interface{}       { return v }
func (ClaimClaimableBalanceResult) XdrTypeName() string              { return "ClaimClaimableBalanceResult" }
func (v ClaimClaimableBalanceResult) XdrValue() interface{}          { return v }
func (v *ClaimClaimableBalanceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClaimClaimableBalanceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClaimClaimableBalanceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CLAIM_CLAIMABLE_BALANCE_SUCCESS:
		return
	case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM, CLAIM_CLAIMABLE_BALANCE_LINE_FULL, CLAIM_CLAIMABLE_BALANCE_NO_TRUST, CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
		return
	}
	XdrPanic("invalid Code (%v) in ClaimClaimableBalanceResult", u.Code)
}
func XDR_ClaimClaimableBalanceResult(v *ClaimClaimableBalanceResult) *ClaimClaimableBalanceResult {
	return v
}

var _XdrNames_BeginSponsoringFutureReservesResultCode = map[int32]string{
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS):           "BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED):         "BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED): "BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE):         "BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE",
}
var _XdrValues_BeginSponsoringFutureReservesResultCode = map[string]int32{
	"BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS":           int32(BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS),
	"BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED":         int32(BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED),
	"BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED": int32(BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED),
	"BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE":         int32(BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE),
}

func (BeginSponsoringFutureReservesResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_BeginSponsoringFutureReservesResultCode
}
func (v BeginSponsoringFutureReservesResultCode) String() string {
	if s, ok := _XdrNames_BeginSponsoringFutureReservesResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("BeginSponsoringFutureReservesResultCode#%d", v)
}
func (v *BeginSponsoringFutureReservesResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BeginSponsoringFutureReservesResultCode[stok]; ok {
			*v = BeginSponsoringFutureReservesResultCode(val)
			return nil
		} else if stok == "BeginSponsoringFutureReservesResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid BeginSponsoringFutureReservesResultCode.", stok))
	}
}
func (v BeginSponsoringFutureReservesResultCode) GetU32() uint32 { return uint32(v) }
func (v *BeginSponsoringFutureReservesResultCode) SetU32(n uint32) {
	*v = BeginSponsoringFutureReservesResultCode(n)
}
func (v *BeginSponsoringFutureReservesResultCode) XdrPointer() interface{} { return v }
func (BeginSponsoringFutureReservesResultCode) XdrTypeName() string {
	return "BeginSponsoringFutureReservesResultCode"
}
func (v BeginSponsoringFutureReservesResultCode) XdrValue() interface{}          { return v }
func (v *BeginSponsoringFutureReservesResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_BeginSponsoringFutureReservesResultCode = *BeginSponsoringFutureReservesResultCode

func XDR_BeginSponsoringFutureReservesResultCode(v *BeginSponsoringFutureReservesResultCode) *BeginSponsoringFutureReservesResultCode {
	return v
}

var _XdrComments_BeginSponsoringFutureReservesResultCode = map[int32]string{
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS):   "codes considered as \"success\" for the operation",
	int32(BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED): "codes considered as \"failure\" for the operation",
}

func (e BeginSponsoringFutureReservesResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_BeginSponsoringFutureReservesResultCode
}

var _XdrTags_BeginSponsoringFutureReservesResult = map[int32]bool{
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS):           true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED):         true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED): true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE):         true,
}

func (_ BeginSponsoringFutureReservesResult) XdrValidTags() map[int32]bool {
	return _XdrTags_BeginSponsoringFutureReservesResult
}
func (u BeginSponsoringFutureReservesResult) XdrValid() bool {
	switch u.Code {
	case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS, BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
		return true
	}
	return false
}
func (u *BeginSponsoringFutureReservesResult) XdrUnionTag() XdrNum32 {
	return XDR_BeginSponsoringFutureReservesResultCode(&u.Code)
}
func (u *BeginSponsoringFutureReservesResult) XdrUnionTagName() string {
	return "Code"
}
func (u *BeginSponsoringFutureReservesResult) XdrUnionBody() XdrType {
	switch u.Code {
	case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return nil
	case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
		return nil
	}
	return nil
}
func (u *BeginSponsoringFutureReservesResult) XdrUnionBodyName() string {
	switch u.Code {
	case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return ""
	case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
		return ""
	}
	return ""
}

type XdrType_BeginSponsoringFutureReservesResult = *BeginSponsoringFutureReservesResult

func (v *BeginSponsoringFutureReservesResult) XdrPointer() interface{} { return v }
func (BeginSponsoringFutureReservesResult) XdrTypeName() string {
	return "BeginSponsoringFutureReservesResult"
}
func (v BeginSponsoringFutureReservesResult) XdrValue() interface{}          { return v }
func (v *BeginSponsoringFutureReservesResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *BeginSponsoringFutureReservesResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BeginSponsoringFutureReservesResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return
	case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED, BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED, BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
		return
	}
	XdrPanic("invalid Code (%v) in BeginSponsoringFutureReservesResult", u.Code)
}
func XDR_BeginSponsoringFutureReservesResult(v *BeginSponsoringFutureReservesResult) *BeginSponsoringFutureReservesResult {
	return v
}

var _XdrNames_EndSponsoringFutureReservesResultCode = map[int32]string{
	int32(END_SPONSORING_FUTURE_RESERVES_SUCCESS):       "END_SPONSORING_FUTURE_RESERVES_SUCCESS",
	int32(END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED): "END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED",
}
var _XdrValues_EndSponsoringFutureReservesResultCode = map[string]int32{
	"END_SPONSORING_FUTURE_RESERVES_SUCCESS":       int32(END_SPONSORING_FUTURE_RESERVES_SUCCESS),
	"END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED": int32(END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED),
}

func (EndSponsoringFutureReservesResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_EndSponsoringFutureReservesResultCode
}
func (v EndSponsoringFutureReservesResultCode) String() string {
	if s, ok := _XdrNames_EndSponsoringFutureReservesResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("EndSponsoringFutureReservesResultCode#%d", v)
}
func (v *EndSponsoringFutureReservesResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_EndSponsoringFutureReservesResultCode[stok]; ok {
			*v = EndSponsoringFutureReservesResultCode(val)
			return nil
		} else if stok == "EndSponsoringFutureReservesResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid EndSponsoringFutureReservesResultCode.", stok))
	}
}
func (v EndSponsoringFutureReservesResultCode) GetU32() uint32 { return uint32(v) }
func (v *EndSponsoringFutureReservesResultCode) SetU32(n uint32) {
	*v = EndSponsoringFutureReservesResultCode(n)
}
func (v *EndSponsoringFutureReservesResultCode) XdrPointer() interface{} { return v }
func (EndSponsoringFutureReservesResultCode) XdrTypeName() string {
	return "EndSponsoringFutureReservesResultCode"
}
func (v EndSponsoringFutureReservesResultCode) XdrValue() interface{}          { return v }
func (v *EndSponsoringFutureReservesResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_EndSponsoringFutureReservesResultCode = *EndSponsoringFutureReservesResultCode

func XDR_EndSponsoringFutureReservesResultCode(v *EndSponsoringFutureReservesResultCode) *EndSponsoringFutureReservesResultCode {
	return v
}

var _XdrComments_EndSponsoringFutureReservesResultCode = map[int32]string{
	int32(END_SPONSORING_FUTURE_RESERVES_SUCCESS):       "codes considered as \"success\" for the operation",
	int32(END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED): "codes considered as \"failure\" for the operation",
}

func (e EndSponsoringFutureReservesResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_EndSponsoringFutureReservesResultCode
}

var _XdrTags_EndSponsoringFutureReservesResult = map[int32]bool{
	XdrToI32(END_SPONSORING_FUTURE_RESERVES_SUCCESS):       true,
	XdrToI32(END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED): true,
}

func (_ EndSponsoringFutureReservesResult) XdrValidTags() map[int32]bool {
	return _XdrTags_EndSponsoringFutureReservesResult
}
func (u EndSponsoringFutureReservesResult) XdrValid() bool {
	switch u.Code {
	case END_SPONSORING_FUTURE_RESERVES_SUCCESS, END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
		return true
	}
	return false
}
func (u *EndSponsoringFutureReservesResult) XdrUnionTag() XdrNum32 {
	return XDR_EndSponsoringFutureReservesResultCode(&u.Code)
}
func (u *EndSponsoringFutureReservesResult) XdrUnionTagName() string {
	return "Code"
}
func (u *EndSponsoringFutureReservesResult) XdrUnionBody() XdrType {
	switch u.Code {
	case END_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return nil
	case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
		return nil
	}
	return nil
}
func (u *EndSponsoringFutureReservesResult) XdrUnionBodyName() string {
	switch u.Code {
	case END_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return ""
	case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
		return ""
	}
	return ""
}

type XdrType_EndSponsoringFutureReservesResult = *EndSponsoringFutureReservesResult

func (v *EndSponsoringFutureReservesResult) XdrPointer() interface{} { return v }
func (EndSponsoringFutureReservesResult) XdrTypeName() string {
	return "EndSponsoringFutureReservesResult"
}
func (v EndSponsoringFutureReservesResult) XdrValue() interface{}          { return v }
func (v *EndSponsoringFutureReservesResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *EndSponsoringFutureReservesResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EndSponsoringFutureReservesResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case END_SPONSORING_FUTURE_RESERVES_SUCCESS:
		return
	case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
		return
	}
	XdrPanic("invalid Code (%v) in EndSponsoringFutureReservesResult", u.Code)
}
func XDR_EndSponsoringFutureReservesResult(v *EndSponsoringFutureReservesResult) *EndSponsoringFutureReservesResult {
	return v
}

var _XdrNames_RevokeSponsorshipResultCode = map[int32]string{
	int32(REVOKE_SPONSORSHIP_SUCCESS):           "REVOKE_SPONSORSHIP_SUCCESS",
	int32(REVOKE_SPONSORSHIP_DOES_NOT_EXIST):    "REVOKE_SPONSORSHIP_DOES_NOT_EXIST",
	int32(REVOKE_SPONSORSHIP_NOT_SPONSOR):       "REVOKE_SPONSORSHIP_NOT_SPONSOR",
	int32(REVOKE_SPONSORSHIP_LOW_RESERVE):       "REVOKE_SPONSORSHIP_LOW_RESERVE",
	int32(REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE): "REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE",
	int32(REVOKE_SPONSORSHIP_MALFORMED):         "REVOKE_SPONSORSHIP_MALFORMED",
}
var _XdrValues_RevokeSponsorshipResultCode = map[string]int32{
	"REVOKE_SPONSORSHIP_SUCCESS":           int32(REVOKE_SPONSORSHIP_SUCCESS),
	"REVOKE_SPONSORSHIP_DOES_NOT_EXIST":    int32(REVOKE_SPONSORSHIP_DOES_NOT_EXIST),
	"REVOKE_SPONSORSHIP_NOT_SPONSOR":       int32(REVOKE_SPONSORSHIP_NOT_SPONSOR),
	"REVOKE_SPONSORSHIP_LOW_RESERVE":       int32(REVOKE_SPONSORSHIP_LOW_RESERVE),
	"REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE": int32(REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE),
	"REVOKE_SPONSORSHIP_MALFORMED":         int32(REVOKE_SPONSORSHIP_MALFORMED),
}

func (RevokeSponsorshipResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_RevokeSponsorshipResultCode
}
func (v RevokeSponsorshipResultCode) String() string {
	if s, ok := _XdrNames_RevokeSponsorshipResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("RevokeSponsorshipResultCode#%d", v)
}
func (v *RevokeSponsorshipResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_RevokeSponsorshipResultCode[stok]; ok {
			*v = RevokeSponsorshipResultCode(val)
			return nil
		} else if stok == "RevokeSponsorshipResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid RevokeSponsorshipResultCode.", stok))
	}
}
func (v RevokeSponsorshipResultCode) GetU32() uint32                 { return uint32(v) }
func (v *RevokeSponsorshipResultCode) SetU32(n uint32)               { *v = RevokeSponsorshipResultCode(n) }
func (v *RevokeSponsorshipResultCode) XdrPointer() interface{}       { return v }
func (RevokeSponsorshipResultCode) XdrTypeName() string              { return "RevokeSponsorshipResultCode" }
func (v RevokeSponsorshipResultCode) XdrValue() interface{}          { return v }
func (v *RevokeSponsorshipResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_RevokeSponsorshipResultCode = *RevokeSponsorshipResultCode

func XDR_RevokeSponsorshipResultCode(v *RevokeSponsorshipResultCode) *RevokeSponsorshipResultCode {
	return v
}

var _XdrComments_RevokeSponsorshipResultCode = map[int32]string{
	int32(REVOKE_SPONSORSHIP_SUCCESS):        "codes considered as \"success\" for the operation",
	int32(REVOKE_SPONSORSHIP_DOES_NOT_EXIST): "codes considered as \"failure\" for the operation",
}

func (e RevokeSponsorshipResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_RevokeSponsorshipResultCode
}

var _XdrTags_RevokeSponsorshipResult = map[int32]bool{
	XdrToI32(REVOKE_SPONSORSHIP_SUCCESS):           true,
	XdrToI32(REVOKE_SPONSORSHIP_DOES_NOT_EXIST):    true,
	XdrToI32(REVOKE_SPONSORSHIP_NOT_SPONSOR):       true,
	XdrToI32(REVOKE_SPONSORSHIP_LOW_RESERVE):       true,
	XdrToI32(REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE): true,
	XdrToI32(REVOKE_SPONSORSHIP_MALFORMED):         true,
}

func (_ RevokeSponsorshipResult) XdrValidTags() map[int32]bool {
	return _XdrTags_RevokeSponsorshipResult
}
func (u RevokeSponsorshipResult) XdrValid() bool {
	switch u.Code {
	case REVOKE_SPONSORSHIP_SUCCESS, REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
		return true
	}
	return false
}
func (u *RevokeSponsorshipResult) XdrUnionTag() XdrNum32 {
	return XDR_RevokeSponsorshipResultCode(&u.Code)
}
func (u *RevokeSponsorshipResult) XdrUnionTagName() string {
	return "Code"
}
func (u *RevokeSponsorshipResult) XdrUnionBody() XdrType {
	switch u.Code {
	case REVOKE_SPONSORSHIP_SUCCESS:
		return nil
	case REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
		return nil
	}
	return nil
}
func (u *RevokeSponsorshipResult) XdrUnionBodyName() string {
	switch u.Code {
	case REVOKE_SPONSORSHIP_SUCCESS:
		return ""
	case REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
		return ""
	}
	return ""
}

type XdrType_RevokeSponsorshipResult = *RevokeSponsorshipResult

func (v *RevokeSponsorshipResult) XdrPointer() interface{}       { return v }
func (RevokeSponsorshipResult) XdrTypeName() string              { return "RevokeSponsorshipResult" }
func (v RevokeSponsorshipResult) XdrValue() interface{}          { return v }
func (v *RevokeSponsorshipResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *RevokeSponsorshipResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_RevokeSponsorshipResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case REVOKE_SPONSORSHIP_SUCCESS:
		return
	case REVOKE_SPONSORSHIP_DOES_NOT_EXIST, REVOKE_SPONSORSHIP_NOT_SPONSOR, REVOKE_SPONSORSHIP_LOW_RESERVE, REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE, REVOKE_SPONSORSHIP_MALFORMED:
		return
	}
	XdrPanic("invalid Code (%v) in RevokeSponsorshipResult", u.Code)
}
func XDR_RevokeSponsorshipResult(v *RevokeSponsorshipResult) *RevokeSponsorshipResult { return v }

var _XdrNames_ClawbackResultCode = map[int32]string{
	int32(CLAWBACK_SUCCESS):              "CLAWBACK_SUCCESS",
	int32(CLAWBACK_MALFORMED):            "CLAWBACK_MALFORMED",
	int32(CLAWBACK_NOT_CLAWBACK_ENABLED): "CLAWBACK_NOT_CLAWBACK_ENABLED",
	int32(CLAWBACK_NO_TRUST):             "CLAWBACK_NO_TRUST",
	int32(CLAWBACK_UNDERFUNDED):          "CLAWBACK_UNDERFUNDED",
}
var _XdrValues_ClawbackResultCode = map[string]int32{
	"CLAWBACK_SUCCESS":              int32(CLAWBACK_SUCCESS),
	"CLAWBACK_MALFORMED":            int32(CLAWBACK_MALFORMED),
	"CLAWBACK_NOT_CLAWBACK_ENABLED": int32(CLAWBACK_NOT_CLAWBACK_ENABLED),
	"CLAWBACK_NO_TRUST":             int32(CLAWBACK_NO_TRUST),
	"CLAWBACK_UNDERFUNDED":          int32(CLAWBACK_UNDERFUNDED),
}

func (ClawbackResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ClawbackResultCode
}
func (v ClawbackResultCode) String() string {
	if s, ok := _XdrNames_ClawbackResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClawbackResultCode#%d", v)
}
func (v *ClawbackResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClawbackResultCode[stok]; ok {
			*v = ClawbackResultCode(val)
			return nil
		} else if stok == "ClawbackResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClawbackResultCode.", stok))
	}
}
func (v ClawbackResultCode) GetU32() uint32                 { return uint32(v) }
func (v *ClawbackResultCode) SetU32(n uint32)               { *v = ClawbackResultCode(n) }
func (v *ClawbackResultCode) XdrPointer() interface{}       { return v }
func (ClawbackResultCode) XdrTypeName() string              { return "ClawbackResultCode" }
func (v ClawbackResultCode) XdrValue() interface{}          { return v }
func (v *ClawbackResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClawbackResultCode = *ClawbackResultCode

func XDR_ClawbackResultCode(v *ClawbackResultCode) *ClawbackResultCode { return v }

var _XdrComments_ClawbackResultCode = map[int32]string{
	int32(CLAWBACK_SUCCESS):   "codes considered as \"success\" for the operation",
	int32(CLAWBACK_MALFORMED): "codes considered as \"failure\" for the operation",
}

func (e ClawbackResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ClawbackResultCode
}

var _XdrTags_ClawbackResult = map[int32]bool{
	XdrToI32(CLAWBACK_SUCCESS):              true,
	XdrToI32(CLAWBACK_MALFORMED):            true,
	XdrToI32(CLAWBACK_NOT_CLAWBACK_ENABLED): true,
	XdrToI32(CLAWBACK_NO_TRUST):             true,
	XdrToI32(CLAWBACK_UNDERFUNDED):          true,
}

func (_ ClawbackResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ClawbackResult
}
func (u ClawbackResult) XdrValid() bool {
	switch u.Code {
	case CLAWBACK_SUCCESS, CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
		return true
	}
	return false
}
func (u *ClawbackResult) XdrUnionTag() XdrNum32 {
	return XDR_ClawbackResultCode(&u.Code)
}
func (u *ClawbackResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ClawbackResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CLAWBACK_SUCCESS:
		return nil
	case CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
		return nil
	}
	return nil
}
func (u *ClawbackResult) XdrUnionBodyName() string {
	switch u.Code {
	case CLAWBACK_SUCCESS:
		return ""
	case CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
		return ""
	}
	return ""
}

type XdrType_ClawbackResult = *ClawbackResult

func (v *ClawbackResult) XdrPointer() interface{}       { return v }
func (ClawbackResult) XdrTypeName() string              { return "ClawbackResult" }
func (v ClawbackResult) XdrValue() interface{}          { return v }
func (v *ClawbackResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClawbackResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClawbackResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CLAWBACK_SUCCESS:
		return
	case CLAWBACK_MALFORMED, CLAWBACK_NOT_CLAWBACK_ENABLED, CLAWBACK_NO_TRUST, CLAWBACK_UNDERFUNDED:
		return
	}
	XdrPanic("invalid Code (%v) in ClawbackResult", u.Code)
}
func XDR_ClawbackResult(v *ClawbackResult) *ClawbackResult { return v }

var _XdrNames_ClawbackClaimableBalanceResultCode = map[int32]string{
	int32(CLAWBACK_CLAIMABLE_BALANCE_SUCCESS):              "CLAWBACK_CLAIMABLE_BALANCE_SUCCESS",
	int32(CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST):       "CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST",
	int32(CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER):           "CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER",
	int32(CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED): "CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED",
}
var _XdrValues_ClawbackClaimableBalanceResultCode = map[string]int32{
	"CLAWBACK_CLAIMABLE_BALANCE_SUCCESS":              int32(CLAWBACK_CLAIMABLE_BALANCE_SUCCESS),
	"CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST":       int32(CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST),
	"CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER":           int32(CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER),
	"CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED": int32(CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED),
}

func (ClawbackClaimableBalanceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ClawbackClaimableBalanceResultCode
}
func (v ClawbackClaimableBalanceResultCode) String() string {
	if s, ok := _XdrNames_ClawbackClaimableBalanceResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("ClawbackClaimableBalanceResultCode#%d", v)
}
func (v *ClawbackClaimableBalanceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ClawbackClaimableBalanceResultCode[stok]; ok {
			*v = ClawbackClaimableBalanceResultCode(val)
			return nil
		} else if stok == "ClawbackClaimableBalanceResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid ClawbackClaimableBalanceResultCode.", stok))
	}
}
func (v ClawbackClaimableBalanceResultCode) GetU32() uint32 { return uint32(v) }
func (v *ClawbackClaimableBalanceResultCode) SetU32(n uint32) {
	*v = ClawbackClaimableBalanceResultCode(n)
}
func (v *ClawbackClaimableBalanceResultCode) XdrPointer() interface{} { return v }
func (ClawbackClaimableBalanceResultCode) XdrTypeName() string {
	return "ClawbackClaimableBalanceResultCode"
}
func (v ClawbackClaimableBalanceResultCode) XdrValue() interface{}          { return v }
func (v *ClawbackClaimableBalanceResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_ClawbackClaimableBalanceResultCode = *ClawbackClaimableBalanceResultCode

func XDR_ClawbackClaimableBalanceResultCode(v *ClawbackClaimableBalanceResultCode) *ClawbackClaimableBalanceResultCode {
	return v
}

var _XdrComments_ClawbackClaimableBalanceResultCode = map[int32]string{
	int32(CLAWBACK_CLAIMABLE_BALANCE_SUCCESS):        "codes considered as \"success\" for the operation",
	int32(CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST): "codes considered as \"failure\" for the operation",
}

func (e ClawbackClaimableBalanceResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_ClawbackClaimableBalanceResultCode
}

var _XdrTags_ClawbackClaimableBalanceResult = map[int32]bool{
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE_SUCCESS):              true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST):       true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER):           true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED): true,
}

func (_ ClawbackClaimableBalanceResult) XdrValidTags() map[int32]bool {
	return _XdrTags_ClawbackClaimableBalanceResult
}
func (u ClawbackClaimableBalanceResult) XdrValid() bool {
	switch u.Code {
	case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS, CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
		return true
	}
	return false
}
func (u *ClawbackClaimableBalanceResult) XdrUnionTag() XdrNum32 {
	return XDR_ClawbackClaimableBalanceResultCode(&u.Code)
}
func (u *ClawbackClaimableBalanceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ClawbackClaimableBalanceResult) XdrUnionBody() XdrType {
	switch u.Code {
	case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
		return nil
	case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
		return nil
	}
	return nil
}
func (u *ClawbackClaimableBalanceResult) XdrUnionBodyName() string {
	switch u.Code {
	case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
		return ""
	case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
		return ""
	}
	return ""
}

type XdrType_ClawbackClaimableBalanceResult = *ClawbackClaimableBalanceResult

func (v *ClawbackClaimableBalanceResult) XdrPointer() interface{}       { return v }
func (ClawbackClaimableBalanceResult) XdrTypeName() string              { return "ClawbackClaimableBalanceResult" }
func (v ClawbackClaimableBalanceResult) XdrValue() interface{}          { return v }
func (v *ClawbackClaimableBalanceResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ClawbackClaimableBalanceResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ClawbackClaimableBalanceResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
		return
	case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST, CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER, CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
		return
	}
	XdrPanic("invalid Code (%v) in ClawbackClaimableBalanceResult", u.Code)
}
func XDR_ClawbackClaimableBalanceResult(v *ClawbackClaimableBalanceResult) *ClawbackClaimableBalanceResult {
	return v
}

var _XdrNames_SetTrustLineFlagsResultCode = map[int32]string{
	int32(SET_TRUST_LINE_FLAGS_SUCCESS):       "SET_TRUST_LINE_FLAGS_SUCCESS",
	int32(SET_TRUST_LINE_FLAGS_MALFORMED):     "SET_TRUST_LINE_FLAGS_MALFORMED",
	int32(SET_TRUST_LINE_FLAGS_NO_TRUST_LINE): "SET_TRUST_LINE_FLAGS_NO_TRUST_LINE",
	int32(SET_TRUST_LINE_FLAGS_CANT_REVOKE):   "SET_TRUST_LINE_FLAGS_CANT_REVOKE",
	int32(SET_TRUST_LINE_FLAGS_INVALID_STATE): "SET_TRUST_LINE_FLAGS_INVALID_STATE",
	int32(SET_TRUST_LINE_FLAGS_LOW_RESERVE):   "SET_TRUST_LINE_FLAGS_LOW_RESERVE",
}
var _XdrValues_SetTrustLineFlagsResultCode = map[string]int32{
	"SET_TRUST_LINE_FLAGS_SUCCESS":       int32(SET_TRUST_LINE_FLAGS_SUCCESS),
	"SET_TRUST_LINE_FLAGS_MALFORMED":     int32(SET_TRUST_LINE_FLAGS_MALFORMED),
	"SET_TRUST_LINE_FLAGS_NO_TRUST_LINE": int32(SET_TRUST_LINE_FLAGS_NO_TRUST_LINE),
	"SET_TRUST_LINE_FLAGS_CANT_REVOKE":   int32(SET_TRUST_LINE_FLAGS_CANT_REVOKE),
	"SET_TRUST_LINE_FLAGS_INVALID_STATE": int32(SET_TRUST_LINE_FLAGS_INVALID_STATE),
	"SET_TRUST_LINE_FLAGS_LOW_RESERVE":   int32(SET_TRUST_LINE_FLAGS_LOW_RESERVE),
}

func (SetTrustLineFlagsResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SetTrustLineFlagsResultCode
}
func (v SetTrustLineFlagsResultCode) String() string {
	if s, ok := _XdrNames_SetTrustLineFlagsResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SetTrustLineFlagsResultCode#%d", v)
}
func (v *SetTrustLineFlagsResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SetTrustLineFlagsResultCode[stok]; ok {
			*v = SetTrustLineFlagsResultCode(val)
			return nil
		} else if stok == "SetTrustLineFlagsResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SetTrustLineFlagsResultCode.", stok))
	}
}
func (v SetTrustLineFlagsResultCode) GetU32() uint32                 { return uint32(v) }
func (v *SetTrustLineFlagsResultCode) SetU32(n uint32)               { *v = SetTrustLineFlagsResultCode(n) }
func (v *SetTrustLineFlagsResultCode) XdrPointer() interface{}       { return v }
func (SetTrustLineFlagsResultCode) XdrTypeName() string              { return "SetTrustLineFlagsResultCode" }
func (v SetTrustLineFlagsResultCode) XdrValue() interface{}          { return v }
func (v *SetTrustLineFlagsResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SetTrustLineFlagsResultCode = *SetTrustLineFlagsResultCode

func XDR_SetTrustLineFlagsResultCode(v *SetTrustLineFlagsResultCode) *SetTrustLineFlagsResultCode {
	return v
}

var _XdrComments_SetTrustLineFlagsResultCode = map[int32]string{
	int32(SET_TRUST_LINE_FLAGS_SUCCESS):     "codes considered as \"success\" for the operation",
	int32(SET_TRUST_LINE_FLAGS_MALFORMED):   "codes considered as \"failure\" for the operation",
	int32(SET_TRUST_LINE_FLAGS_LOW_RESERVE): "claimable balances can't be created",
}

func (e SetTrustLineFlagsResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_SetTrustLineFlagsResultCode
}

var _XdrTags_SetTrustLineFlagsResult = map[int32]bool{
	XdrToI32(SET_TRUST_LINE_FLAGS_SUCCESS):       true,
	XdrToI32(SET_TRUST_LINE_FLAGS_MALFORMED):     true,
	XdrToI32(SET_TRUST_LINE_FLAGS_NO_TRUST_LINE): true,
	XdrToI32(SET_TRUST_LINE_FLAGS_CANT_REVOKE):   true,
	XdrToI32(SET_TRUST_LINE_FLAGS_INVALID_STATE): true,
	XdrToI32(SET_TRUST_LINE_FLAGS_LOW_RESERVE):   true,
}

func (_ SetTrustLineFlagsResult) XdrValidTags() map[int32]bool {
	return _XdrTags_SetTrustLineFlagsResult
}
func (u SetTrustLineFlagsResult) XdrValid() bool {
	switch u.Code {
	case SET_TRUST_LINE_FLAGS_SUCCESS, SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
		return true
	}
	return false
}
func (u *SetTrustLineFlagsResult) XdrUnionTag() XdrNum32 {
	return XDR_SetTrustLineFlagsResultCode(&u.Code)
}
func (u *SetTrustLineFlagsResult) XdrUnionTagName() string {
	return "Code"
}
func (u *SetTrustLineFlagsResult) XdrUnionBody() XdrType {
	switch u.Code {
	case SET_TRUST_LINE_FLAGS_SUCCESS:
		return nil
	case SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
		return nil
	}
	return nil
}
func (u *SetTrustLineFlagsResult) XdrUnionBodyName() string {
	switch u.Code {
	case SET_TRUST_LINE_FLAGS_SUCCESS:
		return ""
	case SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
		return ""
	}
	return ""
}

type XdrType_SetTrustLineFlagsResult = *SetTrustLineFlagsResult

func (v *SetTrustLineFlagsResult) XdrPointer() interface{}       { return v }
func (SetTrustLineFlagsResult) XdrTypeName() string              { return "SetTrustLineFlagsResult" }
func (v SetTrustLineFlagsResult) XdrValue() interface{}          { return v }
func (v *SetTrustLineFlagsResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SetTrustLineFlagsResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SetTrustLineFlagsResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case SET_TRUST_LINE_FLAGS_SUCCESS:
		return
	case SET_TRUST_LINE_FLAGS_MALFORMED, SET_TRUST_LINE_FLAGS_NO_TRUST_LINE, SET_TRUST_LINE_FLAGS_CANT_REVOKE, SET_TRUST_LINE_FLAGS_INVALID_STATE, SET_TRUST_LINE_FLAGS_LOW_RESERVE:
		return
	}
	XdrPanic("invalid Code (%v) in SetTrustLineFlagsResult", u.Code)
}
func XDR_SetTrustLineFlagsResult(v *SetTrustLineFlagsResult) *SetTrustLineFlagsResult { return v }

var _XdrNames_LiquidityPoolDepositResultCode = map[int32]string{
	int32(LIQUIDITY_POOL_DEPOSIT_SUCCESS):        "LIQUIDITY_POOL_DEPOSIT_SUCCESS",
	int32(LIQUIDITY_POOL_DEPOSIT_MALFORMED):      "LIQUIDITY_POOL_DEPOSIT_MALFORMED",
	int32(LIQUIDITY_POOL_DEPOSIT_NO_TRUST):       "LIQUIDITY_POOL_DEPOSIT_NO_TRUST",
	int32(LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED): "LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED",
	int32(LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED):    "LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED",
	int32(LIQUIDITY_POOL_DEPOSIT_LINE_FULL):      "LIQUIDITY_POOL_DEPOSIT_LINE_FULL",
	int32(LIQUIDITY_POOL_DEPOSIT_BAD_PRICE):      "LIQUIDITY_POOL_DEPOSIT_BAD_PRICE",
	int32(LIQUIDITY_POOL_DEPOSIT_POOL_FULL):      "LIQUIDITY_POOL_DEPOSIT_POOL_FULL",
}
var _XdrValues_LiquidityPoolDepositResultCode = map[string]int32{
	"LIQUIDITY_POOL_DEPOSIT_SUCCESS":        int32(LIQUIDITY_POOL_DEPOSIT_SUCCESS),
	"LIQUIDITY_POOL_DEPOSIT_MALFORMED":      int32(LIQUIDITY_POOL_DEPOSIT_MALFORMED),
	"LIQUIDITY_POOL_DEPOSIT_NO_TRUST":       int32(LIQUIDITY_POOL_DEPOSIT_NO_TRUST),
	"LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED": int32(LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED),
	"LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED":    int32(LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED),
	"LIQUIDITY_POOL_DEPOSIT_LINE_FULL":      int32(LIQUIDITY_POOL_DEPOSIT_LINE_FULL),
	"LIQUIDITY_POOL_DEPOSIT_BAD_PRICE":      int32(LIQUIDITY_POOL_DEPOSIT_BAD_PRICE),
	"LIQUIDITY_POOL_DEPOSIT_POOL_FULL":      int32(LIQUIDITY_POOL_DEPOSIT_POOL_FULL),
}

func (LiquidityPoolDepositResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_LiquidityPoolDepositResultCode
}
func (v LiquidityPoolDepositResultCode) String() string {
	if s, ok := _XdrNames_LiquidityPoolDepositResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LiquidityPoolDepositResultCode#%d", v)
}
func (v *LiquidityPoolDepositResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LiquidityPoolDepositResultCode[stok]; ok {
			*v = LiquidityPoolDepositResultCode(val)
			return nil
		} else if stok == "LiquidityPoolDepositResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LiquidityPoolDepositResultCode.", stok))
	}
}
func (v LiquidityPoolDepositResultCode) GetU32() uint32                 { return uint32(v) }
func (v *LiquidityPoolDepositResultCode) SetU32(n uint32)               { *v = LiquidityPoolDepositResultCode(n) }
func (v *LiquidityPoolDepositResultCode) XdrPointer() interface{}       { return v }
func (LiquidityPoolDepositResultCode) XdrTypeName() string              { return "LiquidityPoolDepositResultCode" }
func (v LiquidityPoolDepositResultCode) XdrValue() interface{}          { return v }
func (v *LiquidityPoolDepositResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LiquidityPoolDepositResultCode = *LiquidityPoolDepositResultCode

func XDR_LiquidityPoolDepositResultCode(v *LiquidityPoolDepositResultCode) *LiquidityPoolDepositResultCode {
	return v
}

var _XdrComments_LiquidityPoolDepositResultCode = map[int32]string{
	int32(LIQUIDITY_POOL_DEPOSIT_SUCCESS):        "codes considered as \"success\" for the operation",
	int32(LIQUIDITY_POOL_DEPOSIT_MALFORMED):      "bad input",
	int32(LIQUIDITY_POOL_DEPOSIT_NO_TRUST):       "no trust line for one of the",
	int32(LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED): "not authorized for one of the",
	int32(LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED):    "not enough balance for one of",
	int32(LIQUIDITY_POOL_DEPOSIT_LINE_FULL):      "pool share trust line doesn't",
	int32(LIQUIDITY_POOL_DEPOSIT_BAD_PRICE):      "deposit price outside bounds",
	int32(LIQUIDITY_POOL_DEPOSIT_POOL_FULL):      "pool reserves are full",
}

func (e LiquidityPoolDepositResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_LiquidityPoolDepositResultCode
}

var _XdrTags_LiquidityPoolDepositResult = map[int32]bool{
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_SUCCESS):        true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_MALFORMED):      true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_NO_TRUST):       true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED): true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED):    true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_LINE_FULL):      true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_BAD_PRICE):      true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT_POOL_FULL):      true,
}

func (_ LiquidityPoolDepositResult) XdrValidTags() map[int32]bool {
	return _XdrTags_LiquidityPoolDepositResult
}
func (u LiquidityPoolDepositResult) XdrValid() bool {
	switch u.Code {
	case LIQUIDITY_POOL_DEPOSIT_SUCCESS, LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
		return true
	}
	return false
}
func (u *LiquidityPoolDepositResult) XdrUnionTag() XdrNum32 {
	return XDR_LiquidityPoolDepositResultCode(&u.Code)
}
func (u *LiquidityPoolDepositResult) XdrUnionTagName() string {
	return "Code"
}
func (u *LiquidityPoolDepositResult) XdrUnionBody() XdrType {
	switch u.Code {
	case LIQUIDITY_POOL_DEPOSIT_SUCCESS:
		return nil
	case LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
		return nil
	}
	return nil
}
func (u *LiquidityPoolDepositResult) XdrUnionBodyName() string {
	switch u.Code {
	case LIQUIDITY_POOL_DEPOSIT_SUCCESS:
		return ""
	case LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
		return ""
	}
	return ""
}

type XdrType_LiquidityPoolDepositResult = *LiquidityPoolDepositResult

func (v *LiquidityPoolDepositResult) XdrPointer() interface{}       { return v }
func (LiquidityPoolDepositResult) XdrTypeName() string              { return "LiquidityPoolDepositResult" }
func (v LiquidityPoolDepositResult) XdrValue() interface{}          { return v }
func (v *LiquidityPoolDepositResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LiquidityPoolDepositResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LiquidityPoolDepositResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case LIQUIDITY_POOL_DEPOSIT_SUCCESS:
		return
	case LIQUIDITY_POOL_DEPOSIT_MALFORMED, LIQUIDITY_POOL_DEPOSIT_NO_TRUST, LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED, LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED, LIQUIDITY_POOL_DEPOSIT_LINE_FULL, LIQUIDITY_POOL_DEPOSIT_BAD_PRICE, LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
		return
	}
	XdrPanic("invalid Code (%v) in LiquidityPoolDepositResult", u.Code)
}
func XDR_LiquidityPoolDepositResult(v *LiquidityPoolDepositResult) *LiquidityPoolDepositResult {
	return v
}

var _XdrNames_LiquidityPoolWithdrawResultCode = map[int32]string{
	int32(LIQUIDITY_POOL_WITHDRAW_SUCCESS):       "LIQUIDITY_POOL_WITHDRAW_SUCCESS",
	int32(LIQUIDITY_POOL_WITHDRAW_MALFORMED):     "LIQUIDITY_POOL_WITHDRAW_MALFORMED",
	int32(LIQUIDITY_POOL_WITHDRAW_NO_TRUST):      "LIQUIDITY_POOL_WITHDRAW_NO_TRUST",
	int32(LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED):   "LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED",
	int32(LIQUIDITY_POOL_WITHDRAW_LINE_FULL):     "LIQUIDITY_POOL_WITHDRAW_LINE_FULL",
	int32(LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM): "LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM",
}
var _XdrValues_LiquidityPoolWithdrawResultCode = map[string]int32{
	"LIQUIDITY_POOL_WITHDRAW_SUCCESS":       int32(LIQUIDITY_POOL_WITHDRAW_SUCCESS),
	"LIQUIDITY_POOL_WITHDRAW_MALFORMED":     int32(LIQUIDITY_POOL_WITHDRAW_MALFORMED),
	"LIQUIDITY_POOL_WITHDRAW_NO_TRUST":      int32(LIQUIDITY_POOL_WITHDRAW_NO_TRUST),
	"LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED":   int32(LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED),
	"LIQUIDITY_POOL_WITHDRAW_LINE_FULL":     int32(LIQUIDITY_POOL_WITHDRAW_LINE_FULL),
	"LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM": int32(LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM),
}

func (LiquidityPoolWithdrawResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_LiquidityPoolWithdrawResultCode
}
func (v LiquidityPoolWithdrawResultCode) String() string {
	if s, ok := _XdrNames_LiquidityPoolWithdrawResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("LiquidityPoolWithdrawResultCode#%d", v)
}
func (v *LiquidityPoolWithdrawResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LiquidityPoolWithdrawResultCode[stok]; ok {
			*v = LiquidityPoolWithdrawResultCode(val)
			return nil
		} else if stok == "LiquidityPoolWithdrawResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid LiquidityPoolWithdrawResultCode.", stok))
	}
}
func (v LiquidityPoolWithdrawResultCode) GetU32() uint32                 { return uint32(v) }
func (v *LiquidityPoolWithdrawResultCode) SetU32(n uint32)               { *v = LiquidityPoolWithdrawResultCode(n) }
func (v *LiquidityPoolWithdrawResultCode) XdrPointer() interface{}       { return v }
func (LiquidityPoolWithdrawResultCode) XdrTypeName() string              { return "LiquidityPoolWithdrawResultCode" }
func (v LiquidityPoolWithdrawResultCode) XdrValue() interface{}          { return v }
func (v *LiquidityPoolWithdrawResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_LiquidityPoolWithdrawResultCode = *LiquidityPoolWithdrawResultCode

func XDR_LiquidityPoolWithdrawResultCode(v *LiquidityPoolWithdrawResultCode) *LiquidityPoolWithdrawResultCode {
	return v
}

var _XdrComments_LiquidityPoolWithdrawResultCode = map[int32]string{
	int32(LIQUIDITY_POOL_WITHDRAW_SUCCESS):       "codes considered as \"success\" for the operation",
	int32(LIQUIDITY_POOL_WITHDRAW_MALFORMED):     "bad input",
	int32(LIQUIDITY_POOL_WITHDRAW_NO_TRUST):      "no trust line for one of the",
	int32(LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED):   "not enough balance of the",
	int32(LIQUIDITY_POOL_WITHDRAW_LINE_FULL):     "would go above limit for one",
	int32(LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM): "of the assets",
}

func (e LiquidityPoolWithdrawResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_LiquidityPoolWithdrawResultCode
}

var _XdrTags_LiquidityPoolWithdrawResult = map[int32]bool{
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_SUCCESS):       true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_MALFORMED):     true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_NO_TRUST):      true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED):   true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_LINE_FULL):     true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM): true,
}

func (_ LiquidityPoolWithdrawResult) XdrValidTags() map[int32]bool {
	return _XdrTags_LiquidityPoolWithdrawResult
}
func (u LiquidityPoolWithdrawResult) XdrValid() bool {
	switch u.Code {
	case LIQUIDITY_POOL_WITHDRAW_SUCCESS, LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
		return true
	}
	return false
}
func (u *LiquidityPoolWithdrawResult) XdrUnionTag() XdrNum32 {
	return XDR_LiquidityPoolWithdrawResultCode(&u.Code)
}
func (u *LiquidityPoolWithdrawResult) XdrUnionTagName() string {
	return "Code"
}
func (u *LiquidityPoolWithdrawResult) XdrUnionBody() XdrType {
	switch u.Code {
	case LIQUIDITY_POOL_WITHDRAW_SUCCESS:
		return nil
	case LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
		return nil
	}
	return nil
}
func (u *LiquidityPoolWithdrawResult) XdrUnionBodyName() string {
	switch u.Code {
	case LIQUIDITY_POOL_WITHDRAW_SUCCESS:
		return ""
	case LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
		return ""
	}
	return ""
}

type XdrType_LiquidityPoolWithdrawResult = *LiquidityPoolWithdrawResult

func (v *LiquidityPoolWithdrawResult) XdrPointer() interface{}       { return v }
func (LiquidityPoolWithdrawResult) XdrTypeName() string              { return "LiquidityPoolWithdrawResult" }
func (v LiquidityPoolWithdrawResult) XdrValue() interface{}          { return v }
func (v *LiquidityPoolWithdrawResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LiquidityPoolWithdrawResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LiquidityPoolWithdrawResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case LIQUIDITY_POOL_WITHDRAW_SUCCESS:
		return
	case LIQUIDITY_POOL_WITHDRAW_MALFORMED, LIQUIDITY_POOL_WITHDRAW_NO_TRUST, LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED, LIQUIDITY_POOL_WITHDRAW_LINE_FULL, LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
		return
	}
	XdrPanic("invalid Code (%v) in LiquidityPoolWithdrawResult", u.Code)
}
func XDR_LiquidityPoolWithdrawResult(v *LiquidityPoolWithdrawResult) *LiquidityPoolWithdrawResult {
	return v
}

var _XdrNames_InvokeHostFunctionResultCode = map[int32]string{
	int32(INVOKE_HOST_FUNCTION_SUCCESS):   "INVOKE_HOST_FUNCTION_SUCCESS",
	int32(INVOKE_HOST_FUNCTION_MALFORMED): "INVOKE_HOST_FUNCTION_MALFORMED",
	int32(INVOKE_HOST_FUNCTION_TRAPPED):   "INVOKE_HOST_FUNCTION_TRAPPED",
}
var _XdrValues_InvokeHostFunctionResultCode = map[string]int32{
	"INVOKE_HOST_FUNCTION_SUCCESS":   int32(INVOKE_HOST_FUNCTION_SUCCESS),
	"INVOKE_HOST_FUNCTION_MALFORMED": int32(INVOKE_HOST_FUNCTION_MALFORMED),
	"INVOKE_HOST_FUNCTION_TRAPPED":   int32(INVOKE_HOST_FUNCTION_TRAPPED),
}

func (InvokeHostFunctionResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_InvokeHostFunctionResultCode
}
func (v InvokeHostFunctionResultCode) String() string {
	if s, ok := _XdrNames_InvokeHostFunctionResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("InvokeHostFunctionResultCode#%d", v)
}
func (v *InvokeHostFunctionResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_InvokeHostFunctionResultCode[stok]; ok {
			*v = InvokeHostFunctionResultCode(val)
			return nil
		} else if stok == "InvokeHostFunctionResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid InvokeHostFunctionResultCode.", stok))
	}
}
func (v InvokeHostFunctionResultCode) GetU32() uint32                 { return uint32(v) }
func (v *InvokeHostFunctionResultCode) SetU32(n uint32)               { *v = InvokeHostFunctionResultCode(n) }
func (v *InvokeHostFunctionResultCode) XdrPointer() interface{}       { return v }
func (InvokeHostFunctionResultCode) XdrTypeName() string              { return "InvokeHostFunctionResultCode" }
func (v InvokeHostFunctionResultCode) XdrValue() interface{}          { return v }
func (v *InvokeHostFunctionResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_InvokeHostFunctionResultCode = *InvokeHostFunctionResultCode

func XDR_InvokeHostFunctionResultCode(v *InvokeHostFunctionResultCode) *InvokeHostFunctionResultCode {
	return v
}

var _XdrComments_InvokeHostFunctionResultCode = map[int32]string{
	int32(INVOKE_HOST_FUNCTION_SUCCESS):   "codes considered as \"success\" for the operation",
	int32(INVOKE_HOST_FUNCTION_MALFORMED): "codes considered as \"failure\" for the operation",
}

func (e InvokeHostFunctionResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_InvokeHostFunctionResultCode
}

var _XdrTags_InvokeHostFunctionResult = map[int32]bool{
	XdrToI32(INVOKE_HOST_FUNCTION_SUCCESS):   true,
	XdrToI32(INVOKE_HOST_FUNCTION_MALFORMED): true,
	XdrToI32(INVOKE_HOST_FUNCTION_TRAPPED):   true,
}

func (_ InvokeHostFunctionResult) XdrValidTags() map[int32]bool {
	return _XdrTags_InvokeHostFunctionResult
}
func (u *InvokeHostFunctionResult) Success() *SCVal {
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS:
		if v, ok := u._u.(*SCVal); ok {
			return v
		} else {
			var zero SCVal
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("InvokeHostFunctionResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u InvokeHostFunctionResult) XdrValid() bool {
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS, INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED:
		return true
	}
	return false
}
func (u *InvokeHostFunctionResult) XdrUnionTag() XdrNum32 {
	return XDR_InvokeHostFunctionResultCode(&u.Code)
}
func (u *InvokeHostFunctionResult) XdrUnionTagName() string {
	return "Code"
}
func (u *InvokeHostFunctionResult) XdrUnionBody() XdrType {
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS:
		return XDR_SCVal(u.Success())
	case INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED:
		return nil
	}
	return nil
}
func (u *InvokeHostFunctionResult) XdrUnionBodyName() string {
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS:
		return "Success"
	case INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED:
		return ""
	}
	return ""
}

type XdrType_InvokeHostFunctionResult = *InvokeHostFunctionResult

func (v *InvokeHostFunctionResult) XdrPointer() interface{}       { return v }
func (InvokeHostFunctionResult) XdrTypeName() string              { return "InvokeHostFunctionResult" }
func (v InvokeHostFunctionResult) XdrValue() interface{}          { return v }
func (v *InvokeHostFunctionResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *InvokeHostFunctionResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_InvokeHostFunctionResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case INVOKE_HOST_FUNCTION_SUCCESS:
		x.Marshal(x.Sprintf("%ssuccess", name), XDR_SCVal(u.Success()))
		return
	case INVOKE_HOST_FUNCTION_MALFORMED, INVOKE_HOST_FUNCTION_TRAPPED:
		return
	}
	XdrPanic("invalid Code (%v) in InvokeHostFunctionResult", u.Code)
}
func XDR_InvokeHostFunctionResult(v *InvokeHostFunctionResult) *InvokeHostFunctionResult { return v }

var _XdrNames_OperationResultCode = map[int32]string{
	int32(OpINNER):               "opINNER",
	int32(OpBAD_AUTH):            "opBAD_AUTH",
	int32(OpNO_ACCOUNT):          "opNO_ACCOUNT",
	int32(OpNOT_SUPPORTED):       "opNOT_SUPPORTED",
	int32(OpTOO_MANY_SUBENTRIES): "opTOO_MANY_SUBENTRIES",
	int32(OpEXCEEDED_WORK_LIMIT): "opEXCEEDED_WORK_LIMIT",
	int32(OpTOO_MANY_SPONSORING): "opTOO_MANY_SPONSORING",
}
var _XdrValues_OperationResultCode = map[string]int32{
	"opINNER":               int32(OpINNER),
	"opBAD_AUTH":            int32(OpBAD_AUTH),
	"opNO_ACCOUNT":          int32(OpNO_ACCOUNT),
	"opNOT_SUPPORTED":       int32(OpNOT_SUPPORTED),
	"opTOO_MANY_SUBENTRIES": int32(OpTOO_MANY_SUBENTRIES),
	"opEXCEEDED_WORK_LIMIT": int32(OpEXCEEDED_WORK_LIMIT),
	"opTOO_MANY_SPONSORING": int32(OpTOO_MANY_SPONSORING),
}

func (OperationResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_OperationResultCode
}
func (v OperationResultCode) String() string {
	if s, ok := _XdrNames_OperationResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("OperationResultCode#%d", v)
}
func (v *OperationResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OperationResultCode[stok]; ok {
			*v = OperationResultCode(val)
			return nil
		} else if stok == "OperationResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid OperationResultCode.", stok))
	}
}
func (v OperationResultCode) GetU32() uint32                 { return uint32(v) }
func (v *OperationResultCode) SetU32(n uint32)               { *v = OperationResultCode(n) }
func (v *OperationResultCode) XdrPointer() interface{}       { return v }
func (OperationResultCode) XdrTypeName() string              { return "OperationResultCode" }
func (v OperationResultCode) XdrValue() interface{}          { return v }
func (v *OperationResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_OperationResultCode = *OperationResultCode

func XDR_OperationResultCode(v *OperationResultCode) *OperationResultCode { return v }

var _XdrComments_OperationResultCode = map[int32]string{
	int32(OpINNER):               "inner object result is valid",
	int32(OpBAD_AUTH):            "too few valid signatures / wrong network",
	int32(OpNO_ACCOUNT):          "source account was not found",
	int32(OpNOT_SUPPORTED):       "operation not supported at this time",
	int32(OpTOO_MANY_SUBENTRIES): "max number of subentries already reached",
	int32(OpEXCEEDED_WORK_LIMIT): "operation did too much work",
	int32(OpTOO_MANY_SPONSORING): "account is sponsoring too many entries",
}

func (e OperationResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_OperationResultCode
}

var _XdrTags_XdrAnon_OperationResult_Tr = map[int32]bool{
	XdrToI32(CREATE_ACCOUNT):                   true,
	XdrToI32(PAYMENT):                          true,
	XdrToI32(PATH_PAYMENT_STRICT_RECEIVE):      true,
	XdrToI32(MANAGE_SELL_OFFER):                true,
	XdrToI32(CREATE_PASSIVE_SELL_OFFER):        true,
	XdrToI32(SET_OPTIONS):                      true,
	XdrToI32(CHANGE_TRUST):                     true,
	XdrToI32(ALLOW_TRUST):                      true,
	XdrToI32(ACCOUNT_MERGE):                    true,
	XdrToI32(INFLATION):                        true,
	XdrToI32(MANAGE_DATA):                      true,
	XdrToI32(BUMP_SEQUENCE):                    true,
	XdrToI32(MANAGE_BUY_OFFER):                 true,
	XdrToI32(PATH_PAYMENT_STRICT_SEND):         true,
	XdrToI32(CREATE_CLAIMABLE_BALANCE):         true,
	XdrToI32(CLAIM_CLAIMABLE_BALANCE):          true,
	XdrToI32(BEGIN_SPONSORING_FUTURE_RESERVES): true,
	XdrToI32(END_SPONSORING_FUTURE_RESERVES):   true,
	XdrToI32(REVOKE_SPONSORSHIP):               true,
	XdrToI32(CLAWBACK):                         true,
	XdrToI32(CLAWBACK_CLAIMABLE_BALANCE):       true,
	XdrToI32(SET_TRUST_LINE_FLAGS):             true,
	XdrToI32(LIQUIDITY_POOL_DEPOSIT):           true,
	XdrToI32(LIQUIDITY_POOL_WITHDRAW):          true,
	XdrToI32(INVOKE_HOST_FUNCTION):             true,
}

func (_ XdrAnon_OperationResult_Tr) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_OperationResult_Tr
}
func (u *XdrAnon_OperationResult_Tr) CreateAccountResult() *CreateAccountResult {
	switch u.Type {
	case CREATE_ACCOUNT:
		if v, ok := u._u.(*CreateAccountResult); ok {
			return v
		} else {
			var zero CreateAccountResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.CreateAccountResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PaymentResult() *PaymentResult {
	switch u.Type {
	case PAYMENT:
		if v, ok := u._u.(*PaymentResult); ok {
			return v
		} else {
			var zero PaymentResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PaymentResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PathPaymentStrictReceiveResult() *PathPaymentStrictReceiveResult {
	switch u.Type {
	case PATH_PAYMENT_STRICT_RECEIVE:
		if v, ok := u._u.(*PathPaymentStrictReceiveResult); ok {
			return v
		} else {
			var zero PathPaymentStrictReceiveResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PathPaymentStrictReceiveResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageSellOfferResult() *ManageSellOfferResult {
	switch u.Type {
	case MANAGE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferResult); ok {
			return v
		} else {
			var zero ManageSellOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageSellOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) CreatePassiveSellOfferResult() *ManageSellOfferResult {
	switch u.Type {
	case CREATE_PASSIVE_SELL_OFFER:
		if v, ok := u._u.(*ManageSellOfferResult); ok {
			return v
		} else {
			var zero ManageSellOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.CreatePassiveSellOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) SetOptionsResult() *SetOptionsResult {
	switch u.Type {
	case SET_OPTIONS:
		if v, ok := u._u.(*SetOptionsResult); ok {
			return v
		} else {
			var zero SetOptionsResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.SetOptionsResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ChangeTrustResult() *ChangeTrustResult {
	switch u.Type {
	case CHANGE_TRUST:
		if v, ok := u._u.(*ChangeTrustResult); ok {
			return v
		} else {
			var zero ChangeTrustResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ChangeTrustResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) AllowTrustResult() *AllowTrustResult {
	switch u.Type {
	case ALLOW_TRUST:
		if v, ok := u._u.(*AllowTrustResult); ok {
			return v
		} else {
			var zero AllowTrustResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.AllowTrustResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) AccountMergeResult() *AccountMergeResult {
	switch u.Type {
	case ACCOUNT_MERGE:
		if v, ok := u._u.(*AccountMergeResult); ok {
			return v
		} else {
			var zero AccountMergeResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.AccountMergeResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) InflationResult() *InflationResult {
	switch u.Type {
	case INFLATION:
		if v, ok := u._u.(*InflationResult); ok {
			return v
		} else {
			var zero InflationResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.InflationResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageDataResult() *ManageDataResult {
	switch u.Type {
	case MANAGE_DATA:
		if v, ok := u._u.(*ManageDataResult); ok {
			return v
		} else {
			var zero ManageDataResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageDataResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) BumpSeqResult() *BumpSequenceResult {
	switch u.Type {
	case BUMP_SEQUENCE:
		if v, ok := u._u.(*BumpSequenceResult); ok {
			return v
		} else {
			var zero BumpSequenceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.BumpSeqResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ManageBuyOfferResult() *ManageBuyOfferResult {
	switch u.Type {
	case MANAGE_BUY_OFFER:
		if v, ok := u._u.(*ManageBuyOfferResult); ok {
			return v
		} else {
			var zero ManageBuyOfferResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ManageBuyOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) PathPaymentStrictSendResult() *PathPaymentStrictSendResult {
	switch u.Type {
	case PATH_PAYMENT_STRICT_SEND:
		if v, ok := u._u.(*PathPaymentStrictSendResult); ok {
			return v
		} else {
			var zero PathPaymentStrictSendResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.PathPaymentStrictSendResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) CreateClaimableBalanceResult() *CreateClaimableBalanceResult {
	switch u.Type {
	case CREATE_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*CreateClaimableBalanceResult); ok {
			return v
		} else {
			var zero CreateClaimableBalanceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.CreateClaimableBalanceResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ClaimClaimableBalanceResult() *ClaimClaimableBalanceResult {
	switch u.Type {
	case CLAIM_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClaimClaimableBalanceResult); ok {
			return v
		} else {
			var zero ClaimClaimableBalanceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ClaimClaimableBalanceResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) BeginSponsoringFutureReservesResult() *BeginSponsoringFutureReservesResult {
	switch u.Type {
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		if v, ok := u._u.(*BeginSponsoringFutureReservesResult); ok {
			return v
		} else {
			var zero BeginSponsoringFutureReservesResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.BeginSponsoringFutureReservesResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) EndSponsoringFutureReservesResult() *EndSponsoringFutureReservesResult {
	switch u.Type {
	case END_SPONSORING_FUTURE_RESERVES:
		if v, ok := u._u.(*EndSponsoringFutureReservesResult); ok {
			return v
		} else {
			var zero EndSponsoringFutureReservesResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.EndSponsoringFutureReservesResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) RevokeSponsorshipResult() *RevokeSponsorshipResult {
	switch u.Type {
	case REVOKE_SPONSORSHIP:
		if v, ok := u._u.(*RevokeSponsorshipResult); ok {
			return v
		} else {
			var zero RevokeSponsorshipResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.RevokeSponsorshipResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ClawbackResult() *ClawbackResult {
	switch u.Type {
	case CLAWBACK:
		if v, ok := u._u.(*ClawbackResult); ok {
			return v
		} else {
			var zero ClawbackResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ClawbackResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) ClawbackClaimableBalanceResult() *ClawbackClaimableBalanceResult {
	switch u.Type {
	case CLAWBACK_CLAIMABLE_BALANCE:
		if v, ok := u._u.(*ClawbackClaimableBalanceResult); ok {
			return v
		} else {
			var zero ClawbackClaimableBalanceResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.ClawbackClaimableBalanceResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) SetTrustLineFlagsResult() *SetTrustLineFlagsResult {
	switch u.Type {
	case SET_TRUST_LINE_FLAGS:
		if v, ok := u._u.(*SetTrustLineFlagsResult); ok {
			return v
		} else {
			var zero SetTrustLineFlagsResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.SetTrustLineFlagsResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) LiquidityPoolDepositResult() *LiquidityPoolDepositResult {
	switch u.Type {
	case LIQUIDITY_POOL_DEPOSIT:
		if v, ok := u._u.(*LiquidityPoolDepositResult); ok {
			return v
		} else {
			var zero LiquidityPoolDepositResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.LiquidityPoolDepositResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) LiquidityPoolWithdrawResult() *LiquidityPoolWithdrawResult {
	switch u.Type {
	case LIQUIDITY_POOL_WITHDRAW:
		if v, ok := u._u.(*LiquidityPoolWithdrawResult); ok {
			return v
		} else {
			var zero LiquidityPoolWithdrawResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.LiquidityPoolWithdrawResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *XdrAnon_OperationResult_Tr) InvokeHostFunctionResult() *InvokeHostFunctionResult {
	switch u.Type {
	case INVOKE_HOST_FUNCTION:
		if v, ok := u._u.(*InvokeHostFunctionResult); ok {
			return v
		} else {
			var zero InvokeHostFunctionResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_OperationResult_Tr.InvokeHostFunctionResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u XdrAnon_OperationResult_Tr) XdrValid() bool {
	switch u.Type {
	case CREATE_ACCOUNT, PAYMENT, PATH_PAYMENT_STRICT_RECEIVE, MANAGE_SELL_OFFER, CREATE_PASSIVE_SELL_OFFER, SET_OPTIONS, CHANGE_TRUST, ALLOW_TRUST, ACCOUNT_MERGE, INFLATION, MANAGE_DATA, BUMP_SEQUENCE, MANAGE_BUY_OFFER, PATH_PAYMENT_STRICT_SEND, CREATE_CLAIMABLE_BALANCE, CLAIM_CLAIMABLE_BALANCE, BEGIN_SPONSORING_FUTURE_RESERVES, END_SPONSORING_FUTURE_RESERVES, REVOKE_SPONSORSHIP, CLAWBACK, CLAWBACK_CLAIMABLE_BALANCE, SET_TRUST_LINE_FLAGS, LIQUIDITY_POOL_DEPOSIT, LIQUIDITY_POOL_WITHDRAW, INVOKE_HOST_FUNCTION:
		return true
	}
	return false
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionTag() XdrNum32 {
	return XDR_OperationType(&u.Type)
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionTagName() string {
	return "Type"
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionBody() XdrType {
	switch u.Type {
	case CREATE_ACCOUNT:
		return XDR_CreateAccountResult(u.CreateAccountResult())
	case PAYMENT:
		return XDR_PaymentResult(u.PaymentResult())
	case PATH_PAYMENT_STRICT_RECEIVE:
		return XDR_PathPaymentStrictReceiveResult(u.PathPaymentStrictReceiveResult())
	case MANAGE_SELL_OFFER:
		return XDR_ManageSellOfferResult(u.ManageSellOfferResult())
	case CREATE_PASSIVE_SELL_OFFER:
		return XDR_ManageSellOfferResult(u.CreatePassiveSellOfferResult())
	case SET_OPTIONS:
		return XDR_SetOptionsResult(u.SetOptionsResult())
	case CHANGE_TRUST:
		return XDR_ChangeTrustResult(u.ChangeTrustResult())
	case ALLOW_TRUST:
		return XDR_AllowTrustResult(u.AllowTrustResult())
	case ACCOUNT_MERGE:
		return XDR_AccountMergeResult(u.AccountMergeResult())
	case INFLATION:
		return XDR_InflationResult(u.InflationResult())
	case MANAGE_DATA:
		return XDR_ManageDataResult(u.ManageDataResult())
	case BUMP_SEQUENCE:
		return XDR_BumpSequenceResult(u.BumpSeqResult())
	case MANAGE_BUY_OFFER:
		return XDR_ManageBuyOfferResult(u.ManageBuyOfferResult())
	case PATH_PAYMENT_STRICT_SEND:
		return XDR_PathPaymentStrictSendResult(u.PathPaymentStrictSendResult())
	case CREATE_CLAIMABLE_BALANCE:
		return XDR_CreateClaimableBalanceResult(u.CreateClaimableBalanceResult())
	case CLAIM_CLAIMABLE_BALANCE:
		return XDR_ClaimClaimableBalanceResult(u.ClaimClaimableBalanceResult())
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		return XDR_BeginSponsoringFutureReservesResult(u.BeginSponsoringFutureReservesResult())
	case END_SPONSORING_FUTURE_RESERVES:
		return XDR_EndSponsoringFutureReservesResult(u.EndSponsoringFutureReservesResult())
	case REVOKE_SPONSORSHIP:
		return XDR_RevokeSponsorshipResult(u.RevokeSponsorshipResult())
	case CLAWBACK:
		return XDR_ClawbackResult(u.ClawbackResult())
	case CLAWBACK_CLAIMABLE_BALANCE:
		return XDR_ClawbackClaimableBalanceResult(u.ClawbackClaimableBalanceResult())
	case SET_TRUST_LINE_FLAGS:
		return XDR_SetTrustLineFlagsResult(u.SetTrustLineFlagsResult())
	case LIQUIDITY_POOL_DEPOSIT:
		return XDR_LiquidityPoolDepositResult(u.LiquidityPoolDepositResult())
	case LIQUIDITY_POOL_WITHDRAW:
		return XDR_LiquidityPoolWithdrawResult(u.LiquidityPoolWithdrawResult())
	case INVOKE_HOST_FUNCTION:
		return XDR_InvokeHostFunctionResult(u.InvokeHostFunctionResult())
	}
	return nil
}
func (u *XdrAnon_OperationResult_Tr) XdrUnionBodyName() string {
	switch u.Type {
	case CREATE_ACCOUNT:
		return "CreateAccountResult"
	case PAYMENT:
		return "PaymentResult"
	case PATH_PAYMENT_STRICT_RECEIVE:
		return "PathPaymentStrictReceiveResult"
	case MANAGE_SELL_OFFER:
		return "ManageSellOfferResult"
	case CREATE_PASSIVE_SELL_OFFER:
		return "CreatePassiveSellOfferResult"
	case SET_OPTIONS:
		return "SetOptionsResult"
	case CHANGE_TRUST:
		return "ChangeTrustResult"
	case ALLOW_TRUST:
		return "AllowTrustResult"
	case ACCOUNT_MERGE:
		return "AccountMergeResult"
	case INFLATION:
		return "InflationResult"
	case MANAGE_DATA:
		return "ManageDataResult"
	case BUMP_SEQUENCE:
		return "BumpSeqResult"
	case MANAGE_BUY_OFFER:
		return "ManageBuyOfferResult"
	case PATH_PAYMENT_STRICT_SEND:
		return "PathPaymentStrictSendResult"
	case CREATE_CLAIMABLE_BALANCE:
		return "CreateClaimableBalanceResult"
	case CLAIM_CLAIMABLE_BALANCE:
		return "ClaimClaimableBalanceResult"
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		return "BeginSponsoringFutureReservesResult"
	case END_SPONSORING_FUTURE_RESERVES:
		return "EndSponsoringFutureReservesResult"
	case REVOKE_SPONSORSHIP:
		return "RevokeSponsorshipResult"
	case CLAWBACK:
		return "ClawbackResult"
	case CLAWBACK_CLAIMABLE_BALANCE:
		return "ClawbackClaimableBalanceResult"
	case SET_TRUST_LINE_FLAGS:
		return "SetTrustLineFlagsResult"
	case LIQUIDITY_POOL_DEPOSIT:
		return "LiquidityPoolDepositResult"
	case LIQUIDITY_POOL_WITHDRAW:
		return "LiquidityPoolWithdrawResult"
	case INVOKE_HOST_FUNCTION:
		return "InvokeHostFunctionResult"
	}
	return ""
}

type XdrType_XdrAnon_OperationResult_Tr = *XdrAnon_OperationResult_Tr

func (v *XdrAnon_OperationResult_Tr) XdrPointer() interface{}       { return v }
func (XdrAnon_OperationResult_Tr) XdrTypeName() string              { return "XdrAnon_OperationResult_Tr" }
func (v XdrAnon_OperationResult_Tr) XdrValue() interface{}          { return v }
func (v *XdrAnon_OperationResult_Tr) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_OperationResult_Tr) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case CREATE_ACCOUNT:
		x.Marshal(x.Sprintf("%screateAccountResult", name), XDR_CreateAccountResult(u.CreateAccountResult()))
		return
	case PAYMENT:
		x.Marshal(x.Sprintf("%spaymentResult", name), XDR_PaymentResult(u.PaymentResult()))
		return
	case PATH_PAYMENT_STRICT_RECEIVE:
		x.Marshal(x.Sprintf("%spathPaymentStrictReceiveResult", name), XDR_PathPaymentStrictReceiveResult(u.PathPaymentStrictReceiveResult()))
		return
	case MANAGE_SELL_OFFER:
		x.Marshal(x.Sprintf("%smanageSellOfferResult", name), XDR_ManageSellOfferResult(u.ManageSellOfferResult()))
		return
	case CREATE_PASSIVE_SELL_OFFER:
		x.Marshal(x.Sprintf("%screatePassiveSellOfferResult", name), XDR_ManageSellOfferResult(u.CreatePassiveSellOfferResult()))
		return
	case SET_OPTIONS:
		x.Marshal(x.Sprintf("%ssetOptionsResult", name), XDR_SetOptionsResult(u.SetOptionsResult()))
		return
	case CHANGE_TRUST:
		x.Marshal(x.Sprintf("%schangeTrustResult", name), XDR_ChangeTrustResult(u.ChangeTrustResult()))
		return
	case ALLOW_TRUST:
		x.Marshal(x.Sprintf("%sallowTrustResult", name), XDR_AllowTrustResult(u.AllowTrustResult()))
		return
	case ACCOUNT_MERGE:
		x.Marshal(x.Sprintf("%saccountMergeResult", name), XDR_AccountMergeResult(u.AccountMergeResult()))
		return
	case INFLATION:
		x.Marshal(x.Sprintf("%sinflationResult", name), XDR_InflationResult(u.InflationResult()))
		return
	case MANAGE_DATA:
		x.Marshal(x.Sprintf("%smanageDataResult", name), XDR_ManageDataResult(u.ManageDataResult()))
		return
	case BUMP_SEQUENCE:
		x.Marshal(x.Sprintf("%sbumpSeqResult", name), XDR_BumpSequenceResult(u.BumpSeqResult()))
		return
	case MANAGE_BUY_OFFER:
		x.Marshal(x.Sprintf("%smanageBuyOfferResult", name), XDR_ManageBuyOfferResult(u.ManageBuyOfferResult()))
		return
	case PATH_PAYMENT_STRICT_SEND:
		x.Marshal(x.Sprintf("%spathPaymentStrictSendResult", name), XDR_PathPaymentStrictSendResult(u.PathPaymentStrictSendResult()))
		return
	case CREATE_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%screateClaimableBalanceResult", name), XDR_CreateClaimableBalanceResult(u.CreateClaimableBalanceResult()))
		return
	case CLAIM_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclaimClaimableBalanceResult", name), XDR_ClaimClaimableBalanceResult(u.ClaimClaimableBalanceResult()))
		return
	case BEGIN_SPONSORING_FUTURE_RESERVES:
		x.Marshal(x.Sprintf("%sbeginSponsoringFutureReservesResult", name), XDR_BeginSponsoringFutureReservesResult(u.BeginSponsoringFutureReservesResult()))
		return
	case END_SPONSORING_FUTURE_RESERVES:
		x.Marshal(x.Sprintf("%sendSponsoringFutureReservesResult", name), XDR_EndSponsoringFutureReservesResult(u.EndSponsoringFutureReservesResult()))
		return
	case REVOKE_SPONSORSHIP:
		x.Marshal(x.Sprintf("%srevokeSponsorshipResult", name), XDR_RevokeSponsorshipResult(u.RevokeSponsorshipResult()))
		return
	case CLAWBACK:
		x.Marshal(x.Sprintf("%sclawbackResult", name), XDR_ClawbackResult(u.ClawbackResult()))
		return
	case CLAWBACK_CLAIMABLE_BALANCE:
		x.Marshal(x.Sprintf("%sclawbackClaimableBalanceResult", name), XDR_ClawbackClaimableBalanceResult(u.ClawbackClaimableBalanceResult()))
		return
	case SET_TRUST_LINE_FLAGS:
		x.Marshal(x.Sprintf("%ssetTrustLineFlagsResult", name), XDR_SetTrustLineFlagsResult(u.SetTrustLineFlagsResult()))
		return
	case LIQUIDITY_POOL_DEPOSIT:
		x.Marshal(x.Sprintf("%sliquidityPoolDepositResult", name), XDR_LiquidityPoolDepositResult(u.LiquidityPoolDepositResult()))
		return
	case LIQUIDITY_POOL_WITHDRAW:
		x.Marshal(x.Sprintf("%sliquidityPoolWithdrawResult", name), XDR_LiquidityPoolWithdrawResult(u.LiquidityPoolWithdrawResult()))
		return
	case INVOKE_HOST_FUNCTION:
		x.Marshal(x.Sprintf("%sinvokeHostFunctionResult", name), XDR_InvokeHostFunctionResult(u.InvokeHostFunctionResult()))
		return
	}
	XdrPanic("invalid Type (%v) in XdrAnon_OperationResult_Tr", u.Type)
}
func XDR_XdrAnon_OperationResult_Tr(v *XdrAnon_OperationResult_Tr) *XdrAnon_OperationResult_Tr {
	return v
}

var _XdrTags_OperationResult = map[int32]bool{
	XdrToI32(OpINNER):               true,
	XdrToI32(OpBAD_AUTH):            true,
	XdrToI32(OpNO_ACCOUNT):          true,
	XdrToI32(OpNOT_SUPPORTED):       true,
	XdrToI32(OpTOO_MANY_SUBENTRIES): true,
	XdrToI32(OpEXCEEDED_WORK_LIMIT): true,
	XdrToI32(OpTOO_MANY_SPONSORING): true,
}

func (_ OperationResult) XdrValidTags() map[int32]bool {
	return _XdrTags_OperationResult
}
func (u *OperationResult) Tr() *XdrAnon_OperationResult_Tr {
	switch u.Code {
	case OpINNER:
		if v, ok := u._u.(*XdrAnon_OperationResult_Tr); ok {
			return v
		} else {
			var zero XdrAnon_OperationResult_Tr
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("OperationResult.Tr accessed when Code == %v", u.Code)
		return nil
	}
}
func (u OperationResult) XdrValid() bool {
	switch u.Code {
	case OpINNER, OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
		return true
	}
	return false
}
func (u *OperationResult) XdrUnionTag() XdrNum32 {
	return XDR_OperationResultCode(&u.Code)
}
func (u *OperationResult) XdrUnionTagName() string {
	return "Code"
}
func (u *OperationResult) XdrUnionBody() XdrType {
	switch u.Code {
	case OpINNER:
		return XDR_XdrAnon_OperationResult_Tr(u.Tr())
	case OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
		return nil
	}
	return nil
}
func (u *OperationResult) XdrUnionBodyName() string {
	switch u.Code {
	case OpINNER:
		return "Tr"
	case OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
		return ""
	}
	return ""
}

type XdrType_OperationResult = *OperationResult

func (v *OperationResult) XdrPointer() interface{}       { return v }
func (OperationResult) XdrTypeName() string              { return "OperationResult" }
func (v OperationResult) XdrValue() interface{}          { return v }
func (v *OperationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *OperationResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case OpINNER:
		x.Marshal(x.Sprintf("%str", name), XDR_XdrAnon_OperationResult_Tr(u.Tr()))
		return
	case OpBAD_AUTH, OpNO_ACCOUNT, OpNOT_SUPPORTED, OpTOO_MANY_SUBENTRIES, OpEXCEEDED_WORK_LIMIT, OpTOO_MANY_SPONSORING:
		return
	}
	XdrPanic("invalid Code (%v) in OperationResult", u.Code)
}
func XDR_OperationResult(v *OperationResult) *OperationResult { return v }

var _XdrNames_TransactionResultCode = map[int32]string{
	int32(TxFEE_BUMP_INNER_SUCCESS): "txFEE_BUMP_INNER_SUCCESS",
	int32(TxSUCCESS):                "txSUCCESS",
	int32(TxFAILED):                 "txFAILED",
	int32(TxTOO_EARLY):              "txTOO_EARLY",
	int32(TxTOO_LATE):               "txTOO_LATE",
	int32(TxMISSING_OPERATION):      "txMISSING_OPERATION",
	int32(TxBAD_SEQ):                "txBAD_SEQ",
	int32(TxBAD_AUTH):               "txBAD_AUTH",
	int32(TxINSUFFICIENT_BALANCE):   "txINSUFFICIENT_BALANCE",
	int32(TxNO_ACCOUNT):             "txNO_ACCOUNT",
	int32(TxINSUFFICIENT_FEE):       "txINSUFFICIENT_FEE",
	int32(TxBAD_AUTH_EXTRA):         "txBAD_AUTH_EXTRA",
	int32(TxINTERNAL_ERROR):         "txINTERNAL_ERROR",
	int32(TxNOT_SUPPORTED):          "txNOT_SUPPORTED",
	int32(TxFEE_BUMP_INNER_FAILED):  "txFEE_BUMP_INNER_FAILED",
	int32(TxBAD_SPONSORSHIP):        "txBAD_SPONSORSHIP",
	int32(TxBAD_MIN_SEQ_AGE_OR_GAP): "txBAD_MIN_SEQ_AGE_OR_GAP",
	int32(TxMALFORMED):              "txMALFORMED",
}
var _XdrValues_TransactionResultCode = map[string]int32{
	"txFEE_BUMP_INNER_SUCCESS": int32(TxFEE_BUMP_INNER_SUCCESS),
	"txSUCCESS":                int32(TxSUCCESS),
	"txFAILED":                 int32(TxFAILED),
	"txTOO_EARLY":              int32(TxTOO_EARLY),
	"txTOO_LATE":               int32(TxTOO_LATE),
	"txMISSING_OPERATION":      int32(TxMISSING_OPERATION),
	"txBAD_SEQ":                int32(TxBAD_SEQ),
	"txBAD_AUTH":               int32(TxBAD_AUTH),
	"txINSUFFICIENT_BALANCE":   int32(TxINSUFFICIENT_BALANCE),
	"txNO_ACCOUNT":             int32(TxNO_ACCOUNT),
	"txINSUFFICIENT_FEE":       int32(TxINSUFFICIENT_FEE),
	"txBAD_AUTH_EXTRA":         int32(TxBAD_AUTH_EXTRA),
	"txINTERNAL_ERROR":         int32(TxINTERNAL_ERROR),
	"txNOT_SUPPORTED":          int32(TxNOT_SUPPORTED),
	"txFEE_BUMP_INNER_FAILED":  int32(TxFEE_BUMP_INNER_FAILED),
	"txBAD_SPONSORSHIP":        int32(TxBAD_SPONSORSHIP),
	"txBAD_MIN_SEQ_AGE_OR_GAP": int32(TxBAD_MIN_SEQ_AGE_OR_GAP),
	"txMALFORMED":              int32(TxMALFORMED),
}

func (TransactionResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_TransactionResultCode
}
func (v TransactionResultCode) String() string {
	if s, ok := _XdrNames_TransactionResultCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("TransactionResultCode#%d", v)
}
func (v *TransactionResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TransactionResultCode[stok]; ok {
			*v = TransactionResultCode(val)
			return nil
		} else if stok == "TransactionResultCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid TransactionResultCode.", stok))
	}
}
func (v TransactionResultCode) GetU32() uint32                 { return uint32(v) }
func (v *TransactionResultCode) SetU32(n uint32)               { *v = TransactionResultCode(n) }
func (v *TransactionResultCode) XdrPointer() interface{}       { return v }
func (TransactionResultCode) XdrTypeName() string              { return "TransactionResultCode" }
func (v TransactionResultCode) XdrValue() interface{}          { return v }
func (v *TransactionResultCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_TransactionResultCode = *TransactionResultCode

func XDR_TransactionResultCode(v *TransactionResultCode) *TransactionResultCode { return v }

var _XdrComments_TransactionResultCode = map[int32]string{
	int32(TxFEE_BUMP_INNER_SUCCESS): "fee bump inner transaction succeeded",
	int32(TxSUCCESS):                "all operations succeeded",
	int32(TxFAILED):                 "one of the operations failed (none were applied)",
	int32(TxTOO_EARLY):              "ledger closeTime before minTime",
	int32(TxTOO_LATE):               "ledger closeTime after maxTime",
	int32(TxMISSING_OPERATION):      "no operation was specified",
	int32(TxBAD_SEQ):                "sequence number does not match source account",
	int32(TxBAD_AUTH):               "too few valid signatures / wrong network",
	int32(TxINSUFFICIENT_BALANCE):   "fee would bring account below reserve",
	int32(TxNO_ACCOUNT):             "source account not found",
	int32(TxINSUFFICIENT_FEE):       "fee is too small",
	int32(TxBAD_AUTH_EXTRA):         "unused signatures attached to transaction",
	int32(TxINTERNAL_ERROR):         "an unknown error occurred",
	int32(TxNOT_SUPPORTED):          "transaction type not supported",
	int32(TxFEE_BUMP_INNER_FAILED):  "fee bump inner transaction failed",
	int32(TxBAD_SPONSORSHIP):        "sponsorship not confirmed",
	int32(TxBAD_MIN_SEQ_AGE_OR_GAP): "minSeqAge or minSeqLedgerGap conditions not met",
	int32(TxMALFORMED):              "precondition is invalid",
}

func (e TransactionResultCode) XdrEnumComments() map[int32]string {
	return _XdrComments_TransactionResultCode
}

type _XdrVec_unbounded_OperationResult []OperationResult

func (_XdrVec_unbounded_OperationResult) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_OperationResult) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_OperationResult length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_OperationResult length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_OperationResult) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_OperationResult) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]OperationResult, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_OperationResult) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_OperationResult(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_OperationResult) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_OperationResult) XdrTypeName() string              { return "OperationResult<>" }
func (v *_XdrVec_unbounded_OperationResult) XdrPointer() interface{}       { return (*[]OperationResult)(v) }
func (v _XdrVec_unbounded_OperationResult) XdrValue() interface{}          { return ([]OperationResult)(v) }
func (v *_XdrVec_unbounded_OperationResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

var _XdrTags_XdrAnon_InnerTransactionResult_Result = map[int32]bool{
	XdrToI32(TxSUCCESS):                true,
	XdrToI32(TxFAILED):                 true,
	XdrToI32(TxTOO_EARLY):              true,
	XdrToI32(TxTOO_LATE):               true,
	XdrToI32(TxMISSING_OPERATION):      true,
	XdrToI32(TxBAD_SEQ):                true,
	XdrToI32(TxBAD_AUTH):               true,
	XdrToI32(TxINSUFFICIENT_BALANCE):   true,
	XdrToI32(TxNO_ACCOUNT):             true,
	XdrToI32(TxINSUFFICIENT_FEE):       true,
	XdrToI32(TxBAD_AUTH_EXTRA):         true,
	XdrToI32(TxINTERNAL_ERROR):         true,
	XdrToI32(TxNOT_SUPPORTED):          true,
	XdrToI32(TxBAD_SPONSORSHIP):        true,
	XdrToI32(TxBAD_MIN_SEQ_AGE_OR_GAP): true,
	XdrToI32(TxMALFORMED):              true,
}

func (_ XdrAnon_InnerTransactionResult_Result) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_InnerTransactionResult_Result
}
func (u *XdrAnon_InnerTransactionResult_Result) Results() *[]OperationResult {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		if v, ok := u._u.(*[]OperationResult); ok {
			return v
		} else {
			var zero []OperationResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_InnerTransactionResult_Result.Results accessed when Code == %v", u.Code)
		return nil
	}
}
func (u XdrAnon_InnerTransactionResult_Result) XdrValid() bool {
	switch u.Code {
	case TxSUCCESS, TxFAILED, TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
		return true
	}
	return false
}
func (u *XdrAnon_InnerTransactionResult_Result) XdrUnionTag() XdrNum32 {
	return XDR_TransactionResultCode(&u.Code)
}
func (u *XdrAnon_InnerTransactionResult_Result) XdrUnionTagName() string {
	return "Code"
}
func (u *XdrAnon_InnerTransactionResult_Result) XdrUnionBody() XdrType {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		return (*_XdrVec_unbounded_OperationResult)(u.Results())
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
		return nil
	}
	return nil
}
func (u *XdrAnon_InnerTransactionResult_Result) XdrUnionBodyName() string {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		return "Results"
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_InnerTransactionResult_Result = *XdrAnon_InnerTransactionResult_Result

func (v *XdrAnon_InnerTransactionResult_Result) XdrPointer() interface{} { return v }
func (XdrAnon_InnerTransactionResult_Result) XdrTypeName() string {
	return "XdrAnon_InnerTransactionResult_Result"
}
func (v XdrAnon_InnerTransactionResult_Result) XdrValue() interface{}          { return v }
func (v *XdrAnon_InnerTransactionResult_Result) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_InnerTransactionResult_Result) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TransactionResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_OperationResult)(u.Results()))
		return
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
		return
	}
	XdrPanic("invalid Code (%v) in XdrAnon_InnerTransactionResult_Result", u.Code)
}
func XDR_XdrAnon_InnerTransactionResult_Result(v *XdrAnon_InnerTransactionResult_Result) *XdrAnon_InnerTransactionResult_Result {
	return v
}

var _XdrTags_XdrAnon_InnerTransactionResult_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_InnerTransactionResult_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_InnerTransactionResult_Ext
}
func (u XdrAnon_InnerTransactionResult_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_InnerTransactionResult_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_InnerTransactionResult_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_InnerTransactionResult_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_InnerTransactionResult_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_InnerTransactionResult_Ext = *XdrAnon_InnerTransactionResult_Ext

func (v *XdrAnon_InnerTransactionResult_Ext) XdrPointer() interface{} { return v }
func (XdrAnon_InnerTransactionResult_Ext) XdrTypeName() string {
	return "XdrAnon_InnerTransactionResult_Ext"
}
func (v XdrAnon_InnerTransactionResult_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_InnerTransactionResult_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_InnerTransactionResult_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_InnerTransactionResult_Ext", u.V)
}
func XDR_XdrAnon_InnerTransactionResult_Ext(v *XdrAnon_InnerTransactionResult_Ext) *XdrAnon_InnerTransactionResult_Ext {
	return v
}

type XdrType_InnerTransactionResult = *InnerTransactionResult

func (v *InnerTransactionResult) XdrPointer() interface{}       { return v }
func (InnerTransactionResult) XdrTypeName() string              { return "InnerTransactionResult" }
func (v InnerTransactionResult) XdrValue() interface{}          { return v }
func (v *InnerTransactionResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InnerTransactionResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfeeCharged", name), XDR_Int64(&v.FeeCharged))
	x.Marshal(x.Sprintf("%sresult", name), XDR_XdrAnon_InnerTransactionResult_Result(&v.Result))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_InnerTransactionResult_Ext(&v.Ext))
}
func XDR_InnerTransactionResult(v *InnerTransactionResult) *InnerTransactionResult { return v }

type XdrType_InnerTransactionResultPair = *InnerTransactionResultPair

func (v *InnerTransactionResultPair) XdrPointer() interface{}       { return v }
func (InnerTransactionResultPair) XdrTypeName() string              { return "InnerTransactionResultPair" }
func (v InnerTransactionResultPair) XdrValue() interface{}          { return v }
func (v *InnerTransactionResultPair) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *InnerTransactionResultPair) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stransactionHash", name), XDR_Hash(&v.TransactionHash))
	x.Marshal(x.Sprintf("%sresult", name), XDR_InnerTransactionResult(&v.Result))
}
func XDR_InnerTransactionResultPair(v *InnerTransactionResultPair) *InnerTransactionResultPair {
	return v
}

var _XdrTags_XdrAnon_TransactionResult_Result = map[int32]bool{
	XdrToI32(TxFEE_BUMP_INNER_SUCCESS): true,
	XdrToI32(TxFEE_BUMP_INNER_FAILED):  true,
	XdrToI32(TxSUCCESS):                true,
	XdrToI32(TxFAILED):                 true,
	XdrToI32(TxTOO_EARLY):              true,
	XdrToI32(TxTOO_LATE):               true,
	XdrToI32(TxMISSING_OPERATION):      true,
	XdrToI32(TxBAD_SEQ):                true,
	XdrToI32(TxBAD_AUTH):               true,
	XdrToI32(TxINSUFFICIENT_BALANCE):   true,
	XdrToI32(TxNO_ACCOUNT):             true,
	XdrToI32(TxINSUFFICIENT_FEE):       true,
	XdrToI32(TxBAD_AUTH_EXTRA):         true,
	XdrToI32(TxINTERNAL_ERROR):         true,
	XdrToI32(TxNOT_SUPPORTED):          true,
	XdrToI32(TxBAD_SPONSORSHIP):        true,
	XdrToI32(TxBAD_MIN_SEQ_AGE_OR_GAP): true,
	XdrToI32(TxMALFORMED):              true,
}

func (_ XdrAnon_TransactionResult_Result) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionResult_Result
}
func (u *XdrAnon_TransactionResult_Result) InnerResultPair() *InnerTransactionResultPair {
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
		if v, ok := u._u.(*InnerTransactionResultPair); ok {
			return v
		} else {
			var zero InnerTransactionResultPair
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionResult_Result.InnerResultPair accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *XdrAnon_TransactionResult_Result) Results() *[]OperationResult {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		if v, ok := u._u.(*[]OperationResult); ok {
			return v
		} else {
			var zero []OperationResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_TransactionResult_Result.Results accessed when Code == %v", u.Code)
		return nil
	}
}
func (u XdrAnon_TransactionResult_Result) XdrValid() bool {
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED, TxSUCCESS, TxFAILED, TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionTag() XdrNum32 {
	return XDR_TransactionResultCode(&u.Code)
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionTagName() string {
	return "Code"
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionBody() XdrType {
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
		return XDR_InnerTransactionResultPair(u.InnerResultPair())
	case TxSUCCESS, TxFAILED:
		return (*_XdrVec_unbounded_OperationResult)(u.Results())
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionResult_Result) XdrUnionBodyName() string {
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
		return "InnerResultPair"
	case TxSUCCESS, TxFAILED:
		return "Results"
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionResult_Result = *XdrAnon_TransactionResult_Result

func (v *XdrAnon_TransactionResult_Result) XdrPointer() interface{} { return v }
func (XdrAnon_TransactionResult_Result) XdrTypeName() string {
	return "XdrAnon_TransactionResult_Result"
}
func (v XdrAnon_TransactionResult_Result) XdrValue() interface{}          { return v }
func (v *XdrAnon_TransactionResult_Result) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionResult_Result) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TransactionResultCode(&u.Code).XdrMarshal(x, x.Sprintf("%scode", name))
	switch u.Code {
	case TxFEE_BUMP_INNER_SUCCESS, TxFEE_BUMP_INNER_FAILED:
		x.Marshal(x.Sprintf("%sinnerResultPair", name), XDR_InnerTransactionResultPair(u.InnerResultPair()))
		return
	case TxSUCCESS, TxFAILED:
		x.Marshal(x.Sprintf("%sresults", name), (*_XdrVec_unbounded_OperationResult)(u.Results()))
		return
	case TxTOO_EARLY, TxTOO_LATE, TxMISSING_OPERATION, TxBAD_SEQ, TxBAD_AUTH, TxINSUFFICIENT_BALANCE, TxNO_ACCOUNT, TxINSUFFICIENT_FEE, TxBAD_AUTH_EXTRA, TxINTERNAL_ERROR, TxNOT_SUPPORTED, TxBAD_SPONSORSHIP, TxBAD_MIN_SEQ_AGE_OR_GAP, TxMALFORMED:
		return
	}
	XdrPanic("invalid Code (%v) in XdrAnon_TransactionResult_Result", u.Code)
}
func XDR_XdrAnon_TransactionResult_Result(v *XdrAnon_TransactionResult_Result) *XdrAnon_TransactionResult_Result {
	return v
}

var _XdrTags_XdrAnon_TransactionResult_Ext = map[int32]bool{
	XdrToI32(0): true,
}

func (_ XdrAnon_TransactionResult_Ext) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_TransactionResult_Ext
}
func (u XdrAnon_TransactionResult_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *XdrAnon_TransactionResult_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_XdrAnon_TransactionResult_Ext = *XdrAnon_TransactionResult_Ext

func (v *XdrAnon_TransactionResult_Ext) XdrPointer() interface{}       { return v }
func (XdrAnon_TransactionResult_Ext) XdrTypeName() string              { return "XdrAnon_TransactionResult_Ext" }
func (v XdrAnon_TransactionResult_Ext) XdrValue() interface{}          { return v }
func (v *XdrAnon_TransactionResult_Ext) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_TransactionResult_Ext) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in XdrAnon_TransactionResult_Ext", u.V)
}
func XDR_XdrAnon_TransactionResult_Ext(v *XdrAnon_TransactionResult_Ext) *XdrAnon_TransactionResult_Ext {
	return v
}

type XdrType_TransactionResult = *TransactionResult

func (v *TransactionResult) XdrPointer() interface{}       { return v }
func (TransactionResult) XdrTypeName() string              { return "TransactionResult" }
func (v TransactionResult) XdrValue() interface{}          { return v }
func (v *TransactionResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TransactionResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfeeCharged", name), XDR_Int64(&v.FeeCharged))
	x.Marshal(x.Sprintf("%sresult", name), XDR_XdrAnon_TransactionResult_Result(&v.Result))
	x.Marshal(x.Sprintf("%sext", name), XDR_XdrAnon_TransactionResult_Ext(&v.Ext))
}
func XDR_TransactionResult(v *TransactionResult) *TransactionResult { return v }

type _XdrArray_32_opaque [32]byte

func (v *_XdrArray_32_opaque) GetByteSlice() []byte          { return v[:] }
func (v *_XdrArray_32_opaque) XdrTypeName() string           { return "opaque[]" }
func (v *_XdrArray_32_opaque) XdrValue() interface{}         { return v[:] }
func (v *_XdrArray_32_opaque) XdrPointer() interface{}       { return (*[32]byte)(v) }
func (v *_XdrArray_32_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_32_opaque) String() string                { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_32_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_32_opaque) XdrArraySize() uint32 {
	const bound uint32 = 32 // Force error if not const or doesn't fit
	return bound
}

type XdrType_Hash struct {
	*_XdrArray_32_opaque
}

func XDR_Hash(v *Hash) XdrType_Hash {
	return XdrType_Hash{(*_XdrArray_32_opaque)(v)}
}
func (XdrType_Hash) XdrTypeName() string  { return "Hash" }
func (v XdrType_Hash) XdrUnwrap() XdrType { return v._XdrArray_32_opaque }

type XdrType_Uint256 struct {
	*_XdrArray_32_opaque
}

func XDR_Uint256(v *Uint256) XdrType_Uint256 {
	return XdrType_Uint256{(*_XdrArray_32_opaque)(v)}
}
func (XdrType_Uint256) XdrTypeName() string  { return "Uint256" }
func (v XdrType_Uint256) XdrUnwrap() XdrType { return v._XdrArray_32_opaque }

type XdrType_Uint32 struct {
	XdrType_uint32
}

func XDR_Uint32(v *Uint32) XdrType_Uint32 {
	return XdrType_Uint32{XDR_uint32(v)}
}
func (XdrType_Uint32) XdrTypeName() string  { return "Uint32" }
func (v XdrType_Uint32) XdrUnwrap() XdrType { return v.XdrType_uint32 }

type XdrType_Int32 struct {
	XdrType_int32
}

func XDR_Int32(v *Int32) XdrType_Int32 {
	return XdrType_Int32{XDR_int32(v)}
}
func (XdrType_Int32) XdrTypeName() string  { return "Int32" }
func (v XdrType_Int32) XdrUnwrap() XdrType { return v.XdrType_int32 }

type XdrType_Uint64 struct {
	XdrType_uint64
}

func XDR_Uint64(v *Uint64) XdrType_Uint64 {
	return XdrType_Uint64{XDR_uint64(v)}
}
func (XdrType_Uint64) XdrTypeName() string  { return "Uint64" }
func (v XdrType_Uint64) XdrUnwrap() XdrType { return v.XdrType_uint64 }

type XdrType_Int64 struct {
	XdrType_int64
}

func XDR_Int64(v *Int64) XdrType_Int64 {
	return XdrType_Int64{XDR_int64(v)}
}
func (XdrType_Int64) XdrTypeName() string  { return "Int64" }
func (v XdrType_Int64) XdrUnwrap() XdrType { return v.XdrType_int64 }

var _XdrTags_ExtensionPoint = map[int32]bool{
	XdrToI32(0): true,
}

func (_ ExtensionPoint) XdrValidTags() map[int32]bool {
	return _XdrTags_ExtensionPoint
}
func (u ExtensionPoint) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *ExtensionPoint) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *ExtensionPoint) XdrUnionTagName() string {
	return "V"
}
func (u *ExtensionPoint) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *ExtensionPoint) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}

type XdrType_ExtensionPoint = *ExtensionPoint

func (v *ExtensionPoint) XdrPointer() interface{}       { return v }
func (ExtensionPoint) XdrTypeName() string              { return "ExtensionPoint" }
func (v ExtensionPoint) XdrValue() interface{}          { return v }
func (v *ExtensionPoint) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ExtensionPoint) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		return
	}
	XdrPanic("invalid V (%v) in ExtensionPoint", u.V)
}
func XDR_ExtensionPoint(v *ExtensionPoint) *ExtensionPoint { return v }

var _XdrNames_CryptoKeyType = map[int32]string{
	int32(KEY_TYPE_ED25519):                "KEY_TYPE_ED25519",
	int32(KEY_TYPE_PRE_AUTH_TX):            "KEY_TYPE_PRE_AUTH_TX",
	int32(KEY_TYPE_HASH_X):                 "KEY_TYPE_HASH_X",
	int32(KEY_TYPE_ED25519_SIGNED_PAYLOAD): "KEY_TYPE_ED25519_SIGNED_PAYLOAD",
	int32(KEY_TYPE_MUXED_ED25519):          "KEY_TYPE_MUXED_ED25519",
}
var _XdrValues_CryptoKeyType = map[string]int32{
	"KEY_TYPE_ED25519":                int32(KEY_TYPE_ED25519),
	"KEY_TYPE_PRE_AUTH_TX":            int32(KEY_TYPE_PRE_AUTH_TX),
	"KEY_TYPE_HASH_X":                 int32(KEY_TYPE_HASH_X),
	"KEY_TYPE_ED25519_SIGNED_PAYLOAD": int32(KEY_TYPE_ED25519_SIGNED_PAYLOAD),
	"KEY_TYPE_MUXED_ED25519":          int32(KEY_TYPE_MUXED_ED25519),
}

func (CryptoKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_CryptoKeyType
}
func (v CryptoKeyType) String() string {
	if s, ok := _XdrNames_CryptoKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("CryptoKeyType#%d", v)
}
func (v *CryptoKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CryptoKeyType[stok]; ok {
			*v = CryptoKeyType(val)
			return nil
		} else if stok == "CryptoKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid CryptoKeyType.", stok))
	}
}
func (v CryptoKeyType) GetU32() uint32                 { return uint32(v) }
func (v *CryptoKeyType) SetU32(n uint32)               { *v = CryptoKeyType(n) }
func (v *CryptoKeyType) XdrPointer() interface{}       { return v }
func (CryptoKeyType) XdrTypeName() string              { return "CryptoKeyType" }
func (v CryptoKeyType) XdrValue() interface{}          { return v }
func (v *CryptoKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_CryptoKeyType = *CryptoKeyType

func XDR_CryptoKeyType(v *CryptoKeyType) *CryptoKeyType { return v }

var _XdrComments_CryptoKeyType = map[int32]string{
	int32(KEY_TYPE_MUXED_ED25519): "MUXED enum values for supported type are derived from the enum values above by ORing them with 0x100",
}

func (e CryptoKeyType) XdrEnumComments() map[int32]string {
	return _XdrComments_CryptoKeyType
}

var _XdrNames_PublicKeyType = map[int32]string{
	int32(PUBLIC_KEY_TYPE_ED25519): "PUBLIC_KEY_TYPE_ED25519",
}
var _XdrValues_PublicKeyType = map[string]int32{
	"PUBLIC_KEY_TYPE_ED25519": int32(PUBLIC_KEY_TYPE_ED25519),
}

func (PublicKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_PublicKeyType
}
func (v PublicKeyType) String() string {
	if s, ok := _XdrNames_PublicKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("PublicKeyType#%d", v)
}
func (v *PublicKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PublicKeyType[stok]; ok {
			*v = PublicKeyType(val)
			return nil
		} else if stok == "PublicKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid PublicKeyType.", stok))
	}
}
func (v PublicKeyType) GetU32() uint32                 { return uint32(v) }
func (v *PublicKeyType) SetU32(n uint32)               { *v = PublicKeyType(n) }
func (v *PublicKeyType) XdrPointer() interface{}       { return v }
func (PublicKeyType) XdrTypeName() string              { return "PublicKeyType" }
func (v PublicKeyType) XdrValue() interface{}          { return v }
func (v *PublicKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PublicKeyType = *PublicKeyType

func XDR_PublicKeyType(v *PublicKeyType) *PublicKeyType { return v }

var _XdrNames_SignerKeyType = map[int32]string{
	int32(SIGNER_KEY_TYPE_ED25519):                "SIGNER_KEY_TYPE_ED25519",
	int32(SIGNER_KEY_TYPE_PRE_AUTH_TX):            "SIGNER_KEY_TYPE_PRE_AUTH_TX",
	int32(SIGNER_KEY_TYPE_HASH_X):                 "SIGNER_KEY_TYPE_HASH_X",
	int32(SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD): "SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD",
}
var _XdrValues_SignerKeyType = map[string]int32{
	"SIGNER_KEY_TYPE_ED25519":                int32(SIGNER_KEY_TYPE_ED25519),
	"SIGNER_KEY_TYPE_PRE_AUTH_TX":            int32(SIGNER_KEY_TYPE_PRE_AUTH_TX),
	"SIGNER_KEY_TYPE_HASH_X":                 int32(SIGNER_KEY_TYPE_HASH_X),
	"SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD": int32(SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD),
}

func (SignerKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_SignerKeyType
}
func (v SignerKeyType) String() string {
	if s, ok := _XdrNames_SignerKeyType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SignerKeyType#%d", v)
}
func (v *SignerKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SignerKeyType[stok]; ok {
			*v = SignerKeyType(val)
			return nil
		} else if stok == "SignerKeyType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SignerKeyType.", stok))
	}
}
func (v SignerKeyType) GetU32() uint32                 { return uint32(v) }
func (v *SignerKeyType) SetU32(n uint32)               { *v = SignerKeyType(n) }
func (v *SignerKeyType) XdrPointer() interface{}       { return v }
func (SignerKeyType) XdrTypeName() string              { return "SignerKeyType" }
func (v SignerKeyType) XdrValue() interface{}          { return v }
func (v *SignerKeyType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SignerKeyType = *SignerKeyType

func XDR_SignerKeyType(v *SignerKeyType) *SignerKeyType { return v }

var _XdrTags_PublicKey = map[int32]bool{
	XdrToI32(PUBLIC_KEY_TYPE_ED25519): true,
}

func (_ PublicKey) XdrValidTags() map[int32]bool {
	return _XdrTags_PublicKey
}
func (u *PublicKey) Ed25519() *Uint256 {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PublicKey.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u PublicKey) XdrValid() bool {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return true
	}
	return false
}
func (u *PublicKey) XdrUnionTag() XdrNum32 {
	return XDR_PublicKeyType(&u.Type)
}
func (u *PublicKey) XdrUnionTagName() string {
	return "Type"
}
func (u *PublicKey) XdrUnionBody() XdrType {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return XDR_Uint256(u.Ed25519())
	}
	return nil
}
func (u *PublicKey) XdrUnionBodyName() string {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return "Ed25519"
	}
	return ""
}

type XdrType_PublicKey = *PublicKey

func (v *PublicKey) XdrPointer() interface{}       { return v }
func (PublicKey) XdrTypeName() string              { return "PublicKey" }
func (v PublicKey) XdrValue() interface{}          { return v }
func (v *PublicKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PublicKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PublicKeyType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(u.Ed25519()))
		return
	}
	XdrPanic("invalid Type (%v) in PublicKey", u.Type)
}
func XDR_PublicKey(v *PublicKey) *PublicKey { return v }

type XdrType_XdrAnon_SignerKey_Ed25519SignedPayload = *XdrAnon_SignerKey_Ed25519SignedPayload

func (v *XdrAnon_SignerKey_Ed25519SignedPayload) XdrPointer() interface{} { return v }
func (XdrAnon_SignerKey_Ed25519SignedPayload) XdrTypeName() string {
	return "XdrAnon_SignerKey_Ed25519SignedPayload"
}
func (v XdrAnon_SignerKey_Ed25519SignedPayload) XdrValue() interface{}          { return v }
func (v *XdrAnon_SignerKey_Ed25519SignedPayload) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_SignerKey_Ed25519SignedPayload) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(&v.Ed25519))
	x.Marshal(x.Sprintf("%spayload", name), XdrVecOpaque{&v.Payload, 64})
}
func XDR_XdrAnon_SignerKey_Ed25519SignedPayload(v *XdrAnon_SignerKey_Ed25519SignedPayload) *XdrAnon_SignerKey_Ed25519SignedPayload {
	return v
}

var _XdrTags_SignerKey = map[int32]bool{
	XdrToI32(SIGNER_KEY_TYPE_ED25519):                true,
	XdrToI32(SIGNER_KEY_TYPE_PRE_AUTH_TX):            true,
	XdrToI32(SIGNER_KEY_TYPE_HASH_X):                 true,
	XdrToI32(SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD): true,
}

func (_ SignerKey) XdrValidTags() map[int32]bool {
	return _XdrTags_SignerKey
}
func (u *SignerKey) Ed25519() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}

/* SHA-256 Hash of TransactionSignaturePayload structure */
func (u *SignerKey) PreAuthTx() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.PreAuthTx accessed when Type == %v", u.Type)
		return nil
	}
}

/* Hash of random 256 bit preimage X */
func (u *SignerKey) HashX() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_HASH_X:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.HashX accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SignerKey) Ed25519SignedPayload() *XdrAnon_SignerKey_Ed25519SignedPayload {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		if v, ok := u._u.(*XdrAnon_SignerKey_Ed25519SignedPayload); ok {
			return v
		} else {
			var zero XdrAnon_SignerKey_Ed25519SignedPayload
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SignerKey.Ed25519SignedPayload accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SignerKey) XdrValid() bool {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519, SIGNER_KEY_TYPE_PRE_AUTH_TX, SIGNER_KEY_TYPE_HASH_X, SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		return true
	}
	return false
}
func (u *SignerKey) XdrUnionTag() XdrNum32 {
	return XDR_SignerKeyType(&u.Type)
}
func (u *SignerKey) XdrUnionTagName() string {
	return "Type"
}
func (u *SignerKey) XdrUnionBody() XdrType {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		return XDR_Uint256(u.Ed25519())
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		return XDR_Uint256(u.PreAuthTx())
	case SIGNER_KEY_TYPE_HASH_X:
		return XDR_Uint256(u.HashX())
	case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		return XDR_XdrAnon_SignerKey_Ed25519SignedPayload(u.Ed25519SignedPayload())
	}
	return nil
}
func (u *SignerKey) XdrUnionBodyName() string {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		return "Ed25519"
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		return "PreAuthTx"
	case SIGNER_KEY_TYPE_HASH_X:
		return "HashX"
	case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		return "Ed25519SignedPayload"
	}
	return ""
}

type XdrType_SignerKey = *SignerKey

func (v *SignerKey) XdrPointer() interface{}       { return v }
func (SignerKey) XdrTypeName() string              { return "SignerKey" }
func (v SignerKey) XdrValue() interface{}          { return v }
func (v *SignerKey) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SignerKey) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SignerKeyType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		x.Marshal(x.Sprintf("%sed25519", name), XDR_Uint256(u.Ed25519()))
		return
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		x.Marshal(x.Sprintf("%spreAuthTx", name), XDR_Uint256(u.PreAuthTx()))
		return
	case SIGNER_KEY_TYPE_HASH_X:
		x.Marshal(x.Sprintf("%shashX", name), XDR_Uint256(u.HashX()))
		return
	case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
		x.Marshal(x.Sprintf("%sed25519SignedPayload", name), XDR_XdrAnon_SignerKey_Ed25519SignedPayload(u.Ed25519SignedPayload()))
		return
	}
	XdrPanic("invalid Type (%v) in SignerKey", u.Type)
}
func XDR_SignerKey(v *SignerKey) *SignerKey { return v }

type XdrType_Signature struct {
	XdrVecOpaque
}

func XDR_Signature(v *Signature) XdrType_Signature {
	return XdrType_Signature{XdrVecOpaque{v, 64}}
}
func (XdrType_Signature) XdrTypeName() string  { return "Signature" }
func (v XdrType_Signature) XdrUnwrap() XdrType { return v.XdrVecOpaque }

type XdrType_SignatureHint struct {
	*_XdrArray_4_opaque
}

func XDR_SignatureHint(v *SignatureHint) XdrType_SignatureHint {
	return XdrType_SignatureHint{(*_XdrArray_4_opaque)(v)}
}
func (XdrType_SignatureHint) XdrTypeName() string  { return "SignatureHint" }
func (v XdrType_SignatureHint) XdrUnwrap() XdrType { return v._XdrArray_4_opaque }

type XdrType_NodeID struct {
	XdrType_PublicKey
}

func XDR_NodeID(v *NodeID) XdrType_NodeID {
	return XdrType_NodeID{XDR_PublicKey(v)}
}
func (XdrType_NodeID) XdrTypeName() string  { return "NodeID" }
func (v XdrType_NodeID) XdrUnwrap() XdrType { return v.XdrType_PublicKey }

type XdrType_AccountID struct {
	XdrType_PublicKey
}

func XDR_AccountID(v *AccountID) XdrType_AccountID {
	return XdrType_AccountID{XDR_PublicKey(v)}
}
func (XdrType_AccountID) XdrTypeName() string  { return "AccountID" }
func (v XdrType_AccountID) XdrUnwrap() XdrType { return v.XdrType_PublicKey }

type XdrType_Curve25519Secret = *Curve25519Secret

func (v *Curve25519Secret) XdrPointer() interface{}       { return v }
func (Curve25519Secret) XdrTypeName() string              { return "Curve25519Secret" }
func (v Curve25519Secret) XdrValue() interface{}          { return v }
func (v *Curve25519Secret) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Curve25519Secret) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), (*_XdrArray_32_opaque)(&v.Key))
}
func XDR_Curve25519Secret(v *Curve25519Secret) *Curve25519Secret { return v }

type XdrType_Curve25519Public = *Curve25519Public

func (v *Curve25519Public) XdrPointer() interface{}       { return v }
func (Curve25519Public) XdrTypeName() string              { return "Curve25519Public" }
func (v Curve25519Public) XdrValue() interface{}          { return v }
func (v *Curve25519Public) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Curve25519Public) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), (*_XdrArray_32_opaque)(&v.Key))
}
func XDR_Curve25519Public(v *Curve25519Public) *Curve25519Public { return v }

type XdrType_HmacSha256Key = *HmacSha256Key

func (v *HmacSha256Key) XdrPointer() interface{}       { return v }
func (HmacSha256Key) XdrTypeName() string              { return "HmacSha256Key" }
func (v HmacSha256Key) XdrValue() interface{}          { return v }
func (v *HmacSha256Key) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *HmacSha256Key) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), (*_XdrArray_32_opaque)(&v.Key))
}
func XDR_HmacSha256Key(v *HmacSha256Key) *HmacSha256Key { return v }

type XdrType_HmacSha256Mac = *HmacSha256Mac

func (v *HmacSha256Mac) XdrPointer() interface{}       { return v }
func (HmacSha256Mac) XdrTypeName() string              { return "HmacSha256Mac" }
func (v HmacSha256Mac) XdrValue() interface{}          { return v }
func (v *HmacSha256Mac) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *HmacSha256Mac) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%smac", name), (*_XdrArray_32_opaque)(&v.Mac))
}
func XDR_HmacSha256Mac(v *HmacSha256Mac) *HmacSha256Mac { return v }

var _XdrNames_SCEnvMetaKind = map[int32]string{
	int32(SC_ENV_META_KIND_INTERFACE_VERSION): "SC_ENV_META_KIND_INTERFACE_VERSION",
}
var _XdrValues_SCEnvMetaKind = map[string]int32{
	"SC_ENV_META_KIND_INTERFACE_VERSION": int32(SC_ENV_META_KIND_INTERFACE_VERSION),
}

func (SCEnvMetaKind) XdrEnumNames() map[int32]string {
	return _XdrNames_SCEnvMetaKind
}
func (v SCEnvMetaKind) String() string {
	if s, ok := _XdrNames_SCEnvMetaKind[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCEnvMetaKind#%d", v)
}
func (v *SCEnvMetaKind) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCEnvMetaKind[stok]; ok {
			*v = SCEnvMetaKind(val)
			return nil
		} else if stok == "SCEnvMetaKind" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCEnvMetaKind.", stok))
	}
}
func (v SCEnvMetaKind) GetU32() uint32                 { return uint32(v) }
func (v *SCEnvMetaKind) SetU32(n uint32)               { *v = SCEnvMetaKind(n) }
func (v *SCEnvMetaKind) XdrPointer() interface{}       { return v }
func (SCEnvMetaKind) XdrTypeName() string              { return "SCEnvMetaKind" }
func (v SCEnvMetaKind) XdrValue() interface{}          { return v }
func (v *SCEnvMetaKind) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCEnvMetaKind = *SCEnvMetaKind

func XDR_SCEnvMetaKind(v *SCEnvMetaKind) *SCEnvMetaKind { return v }

var _XdrTags_SCEnvMetaEntry = map[int32]bool{
	XdrToI32(SC_ENV_META_KIND_INTERFACE_VERSION): true,
}

func (_ SCEnvMetaEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_SCEnvMetaEntry
}
func (u *SCEnvMetaEntry) InterfaceVersion() *Uint64 {
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCEnvMetaEntry.InterfaceVersion accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u SCEnvMetaEntry) XdrValid() bool {
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		return true
	}
	return false
}
func (u *SCEnvMetaEntry) XdrUnionTag() XdrNum32 {
	return XDR_SCEnvMetaKind(&u.Kind)
}
func (u *SCEnvMetaEntry) XdrUnionTagName() string {
	return "Kind"
}
func (u *SCEnvMetaEntry) XdrUnionBody() XdrType {
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		return XDR_Uint64(u.InterfaceVersion())
	}
	return nil
}
func (u *SCEnvMetaEntry) XdrUnionBodyName() string {
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		return "InterfaceVersion"
	}
	return ""
}

type XdrType_SCEnvMetaEntry = *SCEnvMetaEntry

func (v *SCEnvMetaEntry) XdrPointer() interface{}       { return v }
func (SCEnvMetaEntry) XdrTypeName() string              { return "SCEnvMetaEntry" }
func (v SCEnvMetaEntry) XdrValue() interface{}          { return v }
func (v *SCEnvMetaEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCEnvMetaEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCEnvMetaKind(&u.Kind).XdrMarshal(x, x.Sprintf("%skind", name))
	switch u.Kind {
	case SC_ENV_META_KIND_INTERFACE_VERSION:
		x.Marshal(x.Sprintf("%sinterfaceVersion", name), XDR_Uint64(u.InterfaceVersion()))
		return
	}
	XdrPanic("invalid Kind (%v) in SCEnvMetaEntry", u.Kind)
}
func XDR_SCEnvMetaEntry(v *SCEnvMetaEntry) *SCEnvMetaEntry { return v }

var _XdrNames_SCSpecType = map[int32]string{
	int32(SC_SPEC_TYPE_VAL):        "SC_SPEC_TYPE_VAL",
	int32(SC_SPEC_TYPE_U32):        "SC_SPEC_TYPE_U32",
	int32(SC_SPEC_TYPE_I32):        "SC_SPEC_TYPE_I32",
	int32(SC_SPEC_TYPE_U64):        "SC_SPEC_TYPE_U64",
	int32(SC_SPEC_TYPE_I64):        "SC_SPEC_TYPE_I64",
	int32(SC_SPEC_TYPE_BOOL):       "SC_SPEC_TYPE_BOOL",
	int32(SC_SPEC_TYPE_SYMBOL):     "SC_SPEC_TYPE_SYMBOL",
	int32(SC_SPEC_TYPE_BITSET):     "SC_SPEC_TYPE_BITSET",
	int32(SC_SPEC_TYPE_STATUS):     "SC_SPEC_TYPE_STATUS",
	int32(SC_SPEC_TYPE_BYTES):      "SC_SPEC_TYPE_BYTES",
	int32(SC_SPEC_TYPE_BIG_INT):    "SC_SPEC_TYPE_BIG_INT",
	int32(SC_SPEC_TYPE_INVOKER):    "SC_SPEC_TYPE_INVOKER",
	int32(SC_SPEC_TYPE_ACCOUNT_ID): "SC_SPEC_TYPE_ACCOUNT_ID",
	int32(SC_SPEC_TYPE_OPTION):     "SC_SPEC_TYPE_OPTION",
	int32(SC_SPEC_TYPE_RESULT):     "SC_SPEC_TYPE_RESULT",
	int32(SC_SPEC_TYPE_VEC):        "SC_SPEC_TYPE_VEC",
	int32(SC_SPEC_TYPE_SET):        "SC_SPEC_TYPE_SET",
	int32(SC_SPEC_TYPE_MAP):        "SC_SPEC_TYPE_MAP",
	int32(SC_SPEC_TYPE_TUPLE):      "SC_SPEC_TYPE_TUPLE",
	int32(SC_SPEC_TYPE_BYTES_N):    "SC_SPEC_TYPE_BYTES_N",
	int32(SC_SPEC_TYPE_UDT):        "SC_SPEC_TYPE_UDT",
}
var _XdrValues_SCSpecType = map[string]int32{
	"SC_SPEC_TYPE_VAL":        int32(SC_SPEC_TYPE_VAL),
	"SC_SPEC_TYPE_U32":        int32(SC_SPEC_TYPE_U32),
	"SC_SPEC_TYPE_I32":        int32(SC_SPEC_TYPE_I32),
	"SC_SPEC_TYPE_U64":        int32(SC_SPEC_TYPE_U64),
	"SC_SPEC_TYPE_I64":        int32(SC_SPEC_TYPE_I64),
	"SC_SPEC_TYPE_BOOL":       int32(SC_SPEC_TYPE_BOOL),
	"SC_SPEC_TYPE_SYMBOL":     int32(SC_SPEC_TYPE_SYMBOL),
	"SC_SPEC_TYPE_BITSET":     int32(SC_SPEC_TYPE_BITSET),
	"SC_SPEC_TYPE_STATUS":     int32(SC_SPEC_TYPE_STATUS),
	"SC_SPEC_TYPE_BYTES":      int32(SC_SPEC_TYPE_BYTES),
	"SC_SPEC_TYPE_BIG_INT":    int32(SC_SPEC_TYPE_BIG_INT),
	"SC_SPEC_TYPE_INVOKER":    int32(SC_SPEC_TYPE_INVOKER),
	"SC_SPEC_TYPE_ACCOUNT_ID": int32(SC_SPEC_TYPE_ACCOUNT_ID),
	"SC_SPEC_TYPE_OPTION":     int32(SC_SPEC_TYPE_OPTION),
	"SC_SPEC_TYPE_RESULT":     int32(SC_SPEC_TYPE_RESULT),
	"SC_SPEC_TYPE_VEC":        int32(SC_SPEC_TYPE_VEC),
	"SC_SPEC_TYPE_SET":        int32(SC_SPEC_TYPE_SET),
	"SC_SPEC_TYPE_MAP":        int32(SC_SPEC_TYPE_MAP),
	"SC_SPEC_TYPE_TUPLE":      int32(SC_SPEC_TYPE_TUPLE),
	"SC_SPEC_TYPE_BYTES_N":    int32(SC_SPEC_TYPE_BYTES_N),
	"SC_SPEC_TYPE_UDT":        int32(SC_SPEC_TYPE_UDT),
}

func (SCSpecType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCSpecType
}
func (v SCSpecType) String() string {
	if s, ok := _XdrNames_SCSpecType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCSpecType#%d", v)
}
func (v *SCSpecType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCSpecType[stok]; ok {
			*v = SCSpecType(val)
			return nil
		} else if stok == "SCSpecType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCSpecType.", stok))
	}
}
func (v SCSpecType) GetU32() uint32                 { return uint32(v) }
func (v *SCSpecType) SetU32(n uint32)               { *v = SCSpecType(n) }
func (v *SCSpecType) XdrPointer() interface{}       { return v }
func (SCSpecType) XdrTypeName() string              { return "SCSpecType" }
func (v SCSpecType) XdrValue() interface{}          { return v }
func (v *SCSpecType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecType = *SCSpecType

func XDR_SCSpecType(v *SCSpecType) *SCSpecType { return v }

var _XdrComments_SCSpecType = map[int32]string{
	int32(SC_SPEC_TYPE_U32):    "Types with no parameters.",
	int32(SC_SPEC_TYPE_OPTION): "Types with parameters.",
	int32(SC_SPEC_TYPE_UDT):    "User defined types.",
}

func (e SCSpecType) XdrEnumComments() map[int32]string {
	return _XdrComments_SCSpecType
}

type XdrType_SCSpecTypeOption = *SCSpecTypeOption

func (v *SCSpecTypeOption) XdrPointer() interface{}       { return v }
func (SCSpecTypeOption) XdrTypeName() string              { return "SCSpecTypeOption" }
func (v SCSpecTypeOption) XdrValue() interface{}          { return v }
func (v *SCSpecTypeOption) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeOption) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%svalueType", name), XDR_SCSpecTypeDef(&v.ValueType))
}
func XDR_SCSpecTypeOption(v *SCSpecTypeOption) *SCSpecTypeOption { return v }

type XdrType_SCSpecTypeResult = *SCSpecTypeResult

func (v *SCSpecTypeResult) XdrPointer() interface{}       { return v }
func (SCSpecTypeResult) XdrTypeName() string              { return "SCSpecTypeResult" }
func (v SCSpecTypeResult) XdrValue() interface{}          { return v }
func (v *SCSpecTypeResult) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeResult) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sokType", name), XDR_SCSpecTypeDef(&v.OkType))
	x.Marshal(x.Sprintf("%serrorType", name), XDR_SCSpecTypeDef(&v.ErrorType))
}
func XDR_SCSpecTypeResult(v *SCSpecTypeResult) *SCSpecTypeResult { return v }

type XdrType_SCSpecTypeVec = *SCSpecTypeVec

func (v *SCSpecTypeVec) XdrPointer() interface{}       { return v }
func (SCSpecTypeVec) XdrTypeName() string              { return "SCSpecTypeVec" }
func (v SCSpecTypeVec) XdrValue() interface{}          { return v }
func (v *SCSpecTypeVec) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeVec) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%selementType", name), XDR_SCSpecTypeDef(&v.ElementType))
}
func XDR_SCSpecTypeVec(v *SCSpecTypeVec) *SCSpecTypeVec { return v }

type XdrType_SCSpecTypeMap = *SCSpecTypeMap

func (v *SCSpecTypeMap) XdrPointer() interface{}       { return v }
func (SCSpecTypeMap) XdrTypeName() string              { return "SCSpecTypeMap" }
func (v SCSpecTypeMap) XdrValue() interface{}          { return v }
func (v *SCSpecTypeMap) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeMap) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skeyType", name), XDR_SCSpecTypeDef(&v.KeyType))
	x.Marshal(x.Sprintf("%svalueType", name), XDR_SCSpecTypeDef(&v.ValueType))
}
func XDR_SCSpecTypeMap(v *SCSpecTypeMap) *SCSpecTypeMap { return v }

type XdrType_SCSpecTypeSet = *SCSpecTypeSet

func (v *SCSpecTypeSet) XdrPointer() interface{}       { return v }
func (SCSpecTypeSet) XdrTypeName() string              { return "SCSpecTypeSet" }
func (v SCSpecTypeSet) XdrValue() interface{}          { return v }
func (v *SCSpecTypeSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%selementType", name), XDR_SCSpecTypeDef(&v.ElementType))
}
func XDR_SCSpecTypeSet(v *SCSpecTypeSet) *SCSpecTypeSet { return v }

type _XdrVec_12_SCSpecTypeDef []SCSpecTypeDef

func (_XdrVec_12_SCSpecTypeDef) XdrBound() uint32 {
	const bound uint32 = 12 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_12_SCSpecTypeDef) XdrCheckLen(length uint32) {
	if length > uint32(12) {
		XdrPanic("_XdrVec_12_SCSpecTypeDef length %d exceeds bound 12", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_12_SCSpecTypeDef length %d exceeds max int", length)
	}
}
func (v _XdrVec_12_SCSpecTypeDef) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_12_SCSpecTypeDef) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(12); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecTypeDef, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_12_SCSpecTypeDef) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecTypeDef(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_12_SCSpecTypeDef) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 12}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_12_SCSpecTypeDef) XdrTypeName() string              { return "SCSpecTypeDef<>" }
func (v *_XdrVec_12_SCSpecTypeDef) XdrPointer() interface{}       { return (*[]SCSpecTypeDef)(v) }
func (v _XdrVec_12_SCSpecTypeDef) XdrValue() interface{}          { return ([]SCSpecTypeDef)(v) }
func (v *_XdrVec_12_SCSpecTypeDef) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecTypeTuple = *SCSpecTypeTuple

func (v *SCSpecTypeTuple) XdrPointer() interface{}       { return v }
func (SCSpecTypeTuple) XdrTypeName() string              { return "SCSpecTypeTuple" }
func (v SCSpecTypeTuple) XdrValue() interface{}          { return v }
func (v *SCSpecTypeTuple) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeTuple) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%svalueTypes", name), (*_XdrVec_12_SCSpecTypeDef)(&v.ValueTypes))
}
func XDR_SCSpecTypeTuple(v *SCSpecTypeTuple) *SCSpecTypeTuple { return v }

type XdrType_SCSpecTypeBytesN = *SCSpecTypeBytesN

func (v *SCSpecTypeBytesN) XdrPointer() interface{}       { return v }
func (SCSpecTypeBytesN) XdrTypeName() string              { return "SCSpecTypeBytesN" }
func (v SCSpecTypeBytesN) XdrValue() interface{}          { return v }
func (v *SCSpecTypeBytesN) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeBytesN) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sn", name), XDR_Uint32(&v.N))
}
func XDR_SCSpecTypeBytesN(v *SCSpecTypeBytesN) *SCSpecTypeBytesN { return v }

type XdrType_SCSpecTypeUDT = *SCSpecTypeUDT

func (v *SCSpecTypeUDT) XdrPointer() interface{}       { return v }
func (SCSpecTypeUDT) XdrTypeName() string              { return "SCSpecTypeUDT" }
func (v SCSpecTypeUDT) XdrValue() interface{}          { return v }
func (v *SCSpecTypeUDT) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecTypeUDT) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
}
func XDR_SCSpecTypeUDT(v *SCSpecTypeUDT) *SCSpecTypeUDT { return v }

var _XdrTags_SCSpecTypeDef = map[int32]bool{
	XdrToI32(SC_SPEC_TYPE_VAL):        true,
	XdrToI32(SC_SPEC_TYPE_U64):        true,
	XdrToI32(SC_SPEC_TYPE_I64):        true,
	XdrToI32(SC_SPEC_TYPE_U32):        true,
	XdrToI32(SC_SPEC_TYPE_I32):        true,
	XdrToI32(SC_SPEC_TYPE_BOOL):       true,
	XdrToI32(SC_SPEC_TYPE_SYMBOL):     true,
	XdrToI32(SC_SPEC_TYPE_BITSET):     true,
	XdrToI32(SC_SPEC_TYPE_STATUS):     true,
	XdrToI32(SC_SPEC_TYPE_BYTES):      true,
	XdrToI32(SC_SPEC_TYPE_BIG_INT):    true,
	XdrToI32(SC_SPEC_TYPE_INVOKER):    true,
	XdrToI32(SC_SPEC_TYPE_ACCOUNT_ID): true,
	XdrToI32(SC_SPEC_TYPE_OPTION):     true,
	XdrToI32(SC_SPEC_TYPE_RESULT):     true,
	XdrToI32(SC_SPEC_TYPE_VEC):        true,
	XdrToI32(SC_SPEC_TYPE_MAP):        true,
	XdrToI32(SC_SPEC_TYPE_SET):        true,
	XdrToI32(SC_SPEC_TYPE_TUPLE):      true,
	XdrToI32(SC_SPEC_TYPE_BYTES_N):    true,
	XdrToI32(SC_SPEC_TYPE_UDT):        true,
}

func (_ SCSpecTypeDef) XdrValidTags() map[int32]bool {
	return _XdrTags_SCSpecTypeDef
}
func (u *SCSpecTypeDef) Option() *SCSpecTypeOption {
	switch u.Type {
	case SC_SPEC_TYPE_OPTION:
		if v, ok := u._u.(*SCSpecTypeOption); ok {
			return v
		} else {
			var zero SCSpecTypeOption
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Option accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Result() *SCSpecTypeResult {
	switch u.Type {
	case SC_SPEC_TYPE_RESULT:
		if v, ok := u._u.(*SCSpecTypeResult); ok {
			return v
		} else {
			var zero SCSpecTypeResult
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Result accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Vec() *SCSpecTypeVec {
	switch u.Type {
	case SC_SPEC_TYPE_VEC:
		if v, ok := u._u.(*SCSpecTypeVec); ok {
			return v
		} else {
			var zero SCSpecTypeVec
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Vec accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Map() *SCSpecTypeMap {
	switch u.Type {
	case SC_SPEC_TYPE_MAP:
		if v, ok := u._u.(*SCSpecTypeMap); ok {
			return v
		} else {
			var zero SCSpecTypeMap
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Map accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Set() *SCSpecTypeSet {
	switch u.Type {
	case SC_SPEC_TYPE_SET:
		if v, ok := u._u.(*SCSpecTypeSet); ok {
			return v
		} else {
			var zero SCSpecTypeSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Set accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Tuple() *SCSpecTypeTuple {
	switch u.Type {
	case SC_SPEC_TYPE_TUPLE:
		if v, ok := u._u.(*SCSpecTypeTuple); ok {
			return v
		} else {
			var zero SCSpecTypeTuple
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Tuple accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) BytesN() *SCSpecTypeBytesN {
	switch u.Type {
	case SC_SPEC_TYPE_BYTES_N:
		if v, ok := u._u.(*SCSpecTypeBytesN); ok {
			return v
		} else {
			var zero SCSpecTypeBytesN
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.BytesN accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCSpecTypeDef) Udt() *SCSpecTypeUDT {
	switch u.Type {
	case SC_SPEC_TYPE_UDT:
		if v, ok := u._u.(*SCSpecTypeUDT); ok {
			return v
		} else {
			var zero SCSpecTypeUDT
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecTypeDef.Udt accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCSpecTypeDef) XdrValid() bool {
	switch u.Type {
	case SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_BITSET, SC_SPEC_TYPE_STATUS, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_BIG_INT, SC_SPEC_TYPE_INVOKER, SC_SPEC_TYPE_ACCOUNT_ID, SC_SPEC_TYPE_OPTION, SC_SPEC_TYPE_RESULT, SC_SPEC_TYPE_VEC, SC_SPEC_TYPE_MAP, SC_SPEC_TYPE_SET, SC_SPEC_TYPE_TUPLE, SC_SPEC_TYPE_BYTES_N, SC_SPEC_TYPE_UDT:
		return true
	}
	return false
}
func (u *SCSpecTypeDef) XdrUnionTag() XdrNum32 {
	return XDR_SCSpecType(&u.Type)
}
func (u *SCSpecTypeDef) XdrUnionTagName() string {
	return "Type"
}
func (u *SCSpecTypeDef) XdrUnionBody() XdrType {
	switch u.Type {
	case SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_BITSET, SC_SPEC_TYPE_STATUS, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_BIG_INT, SC_SPEC_TYPE_INVOKER, SC_SPEC_TYPE_ACCOUNT_ID:
		return nil
	case SC_SPEC_TYPE_OPTION:
		return XDR_SCSpecTypeOption(u.Option())
	case SC_SPEC_TYPE_RESULT:
		return XDR_SCSpecTypeResult(u.Result())
	case SC_SPEC_TYPE_VEC:
		return XDR_SCSpecTypeVec(u.Vec())
	case SC_SPEC_TYPE_MAP:
		return XDR_SCSpecTypeMap(u.Map())
	case SC_SPEC_TYPE_SET:
		return XDR_SCSpecTypeSet(u.Set())
	case SC_SPEC_TYPE_TUPLE:
		return XDR_SCSpecTypeTuple(u.Tuple())
	case SC_SPEC_TYPE_BYTES_N:
		return XDR_SCSpecTypeBytesN(u.BytesN())
	case SC_SPEC_TYPE_UDT:
		return XDR_SCSpecTypeUDT(u.Udt())
	}
	return nil
}
func (u *SCSpecTypeDef) XdrUnionBodyName() string {
	switch u.Type {
	case SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_BITSET, SC_SPEC_TYPE_STATUS, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_BIG_INT, SC_SPEC_TYPE_INVOKER, SC_SPEC_TYPE_ACCOUNT_ID:
		return ""
	case SC_SPEC_TYPE_OPTION:
		return "Option"
	case SC_SPEC_TYPE_RESULT:
		return "Result"
	case SC_SPEC_TYPE_VEC:
		return "Vec"
	case SC_SPEC_TYPE_MAP:
		return "Map"
	case SC_SPEC_TYPE_SET:
		return "Set"
	case SC_SPEC_TYPE_TUPLE:
		return "Tuple"
	case SC_SPEC_TYPE_BYTES_N:
		return "BytesN"
	case SC_SPEC_TYPE_UDT:
		return "Udt"
	}
	return ""
}

type XdrType_SCSpecTypeDef = *SCSpecTypeDef

func (v *SCSpecTypeDef) XdrPointer() interface{}       { return v }
func (SCSpecTypeDef) XdrTypeName() string              { return "SCSpecTypeDef" }
func (v SCSpecTypeDef) XdrValue() interface{}          { return v }
func (v *SCSpecTypeDef) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCSpecTypeDef) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCSpecType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SC_SPEC_TYPE_VAL, SC_SPEC_TYPE_U64, SC_SPEC_TYPE_I64, SC_SPEC_TYPE_U32, SC_SPEC_TYPE_I32, SC_SPEC_TYPE_BOOL, SC_SPEC_TYPE_SYMBOL, SC_SPEC_TYPE_BITSET, SC_SPEC_TYPE_STATUS, SC_SPEC_TYPE_BYTES, SC_SPEC_TYPE_BIG_INT, SC_SPEC_TYPE_INVOKER, SC_SPEC_TYPE_ACCOUNT_ID:
		return
	case SC_SPEC_TYPE_OPTION:
		x.Marshal(x.Sprintf("%soption", name), XDR_SCSpecTypeOption(u.Option()))
		return
	case SC_SPEC_TYPE_RESULT:
		x.Marshal(x.Sprintf("%sresult", name), XDR_SCSpecTypeResult(u.Result()))
		return
	case SC_SPEC_TYPE_VEC:
		x.Marshal(x.Sprintf("%svec", name), XDR_SCSpecTypeVec(u.Vec()))
		return
	case SC_SPEC_TYPE_MAP:
		x.Marshal(x.Sprintf("%smap", name), XDR_SCSpecTypeMap(u.Map()))
		return
	case SC_SPEC_TYPE_SET:
		x.Marshal(x.Sprintf("%sset", name), XDR_SCSpecTypeSet(u.Set()))
		return
	case SC_SPEC_TYPE_TUPLE:
		x.Marshal(x.Sprintf("%stuple", name), XDR_SCSpecTypeTuple(u.Tuple()))
		return
	case SC_SPEC_TYPE_BYTES_N:
		x.Marshal(x.Sprintf("%sbytesN", name), XDR_SCSpecTypeBytesN(u.BytesN()))
		return
	case SC_SPEC_TYPE_UDT:
		x.Marshal(x.Sprintf("%sudt", name), XDR_SCSpecTypeUDT(u.Udt()))
		return
	}
	XdrPanic("invalid Type (%v) in SCSpecTypeDef", u.Type)
}
func XDR_SCSpecTypeDef(v *SCSpecTypeDef) *SCSpecTypeDef { return v }

type XdrType_SCSpecUDTStructFieldV0 = *SCSpecUDTStructFieldV0

func (v *SCSpecUDTStructFieldV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTStructFieldV0) XdrTypeName() string              { return "SCSpecUDTStructFieldV0" }
func (v SCSpecUDTStructFieldV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTStructFieldV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTStructFieldV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 30})
	x.Marshal(x.Sprintf("%stype", name), XDR_SCSpecTypeDef(&v.Type))
}
func XDR_SCSpecUDTStructFieldV0(v *SCSpecUDTStructFieldV0) *SCSpecUDTStructFieldV0 { return v }

type _XdrVec_40_SCSpecUDTStructFieldV0 []SCSpecUDTStructFieldV0

func (_XdrVec_40_SCSpecUDTStructFieldV0) XdrBound() uint32 {
	const bound uint32 = 40 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_40_SCSpecUDTStructFieldV0) XdrCheckLen(length uint32) {
	if length > uint32(40) {
		XdrPanic("_XdrVec_40_SCSpecUDTStructFieldV0 length %d exceeds bound 40", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_40_SCSpecUDTStructFieldV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_40_SCSpecUDTStructFieldV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(40); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecUDTStructFieldV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecUDTStructFieldV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 40}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_40_SCSpecUDTStructFieldV0) XdrTypeName() string { return "SCSpecUDTStructFieldV0<>" }
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) XdrPointer() interface{} {
	return (*[]SCSpecUDTStructFieldV0)(v)
}
func (v _XdrVec_40_SCSpecUDTStructFieldV0) XdrValue() interface{} {
	return ([]SCSpecUDTStructFieldV0)(v)
}
func (v *_XdrVec_40_SCSpecUDTStructFieldV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTStructV0 = *SCSpecUDTStructV0

func (v *SCSpecUDTStructV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTStructV0) XdrTypeName() string              { return "SCSpecUDTStructV0" }
func (v SCSpecUDTStructV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTStructV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTStructV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slib", name), XdrString{&v.Lib, 80})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%sfields", name), (*_XdrVec_40_SCSpecUDTStructFieldV0)(&v.Fields))
}
func XDR_SCSpecUDTStructV0(v *SCSpecUDTStructV0) *SCSpecUDTStructV0 { return v }

type _XdrPtr_SCSpecTypeDef struct {
	p **SCSpecTypeDef
}
type _ptrflag_SCSpecTypeDef _XdrPtr_SCSpecTypeDef

func (v _ptrflag_SCSpecTypeDef) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SCSpecTypeDef) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SCSpecTypeDef flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SCSpecTypeDef) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SCSpecTypeDef) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SCSpecTypeDef)
		}
	default:
		XdrPanic("*SCSpecTypeDef present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SCSpecTypeDef) XdrTypeName() string             { return "SCSpecTypeDef?" }
func (v _ptrflag_SCSpecTypeDef) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SCSpecTypeDef) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SCSpecTypeDef) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SCSpecTypeDef) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SCSpecTypeDef) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SCSpecTypeDef) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SCSpecTypeDef)
	}
}
func (v _XdrPtr_SCSpecTypeDef) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SCSpecTypeDef(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SCSpecTypeDef) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SCSpecTypeDef) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SCSpecTypeDef(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SCSpecTypeDef) XdrTypeName() string       { return "SCSpecTypeDef*" }
func (v _XdrPtr_SCSpecTypeDef) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SCSpecTypeDef) XdrValue() interface{}   { return *v.p }

type XdrType_SCSpecUDTUnionCaseV0 = *SCSpecUDTUnionCaseV0

func (v *SCSpecUDTUnionCaseV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTUnionCaseV0) XdrTypeName() string              { return "SCSpecUDTUnionCaseV0" }
func (v SCSpecUDTUnionCaseV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTUnionCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTUnionCaseV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%stype", name), _XdrPtr_SCSpecTypeDef{&v.Type})
}
func XDR_SCSpecUDTUnionCaseV0(v *SCSpecUDTUnionCaseV0) *SCSpecUDTUnionCaseV0 { return v }

type _XdrVec_50_SCSpecUDTUnionCaseV0 []SCSpecUDTUnionCaseV0

func (_XdrVec_50_SCSpecUDTUnionCaseV0) XdrBound() uint32 {
	const bound uint32 = 50 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_50_SCSpecUDTUnionCaseV0) XdrCheckLen(length uint32) {
	if length > uint32(50) {
		XdrPanic("_XdrVec_50_SCSpecUDTUnionCaseV0 length %d exceeds bound 50", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_50_SCSpecUDTUnionCaseV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_50_SCSpecUDTUnionCaseV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(50); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecUDTUnionCaseV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecUDTUnionCaseV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 50}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_50_SCSpecUDTUnionCaseV0) XdrTypeName() string { return "SCSpecUDTUnionCaseV0<>" }
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) XdrPointer() interface{} {
	return (*[]SCSpecUDTUnionCaseV0)(v)
}
func (v _XdrVec_50_SCSpecUDTUnionCaseV0) XdrValue() interface{}          { return ([]SCSpecUDTUnionCaseV0)(v) }
func (v *_XdrVec_50_SCSpecUDTUnionCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTUnionV0 = *SCSpecUDTUnionV0

func (v *SCSpecUDTUnionV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTUnionV0) XdrTypeName() string              { return "SCSpecUDTUnionV0" }
func (v SCSpecUDTUnionV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTUnionV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTUnionV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slib", name), XdrString{&v.Lib, 80})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%scases", name), (*_XdrVec_50_SCSpecUDTUnionCaseV0)(&v.Cases))
}
func XDR_SCSpecUDTUnionV0(v *SCSpecUDTUnionV0) *SCSpecUDTUnionV0 { return v }

type XdrType_SCSpecUDTEnumCaseV0 = *SCSpecUDTEnumCaseV0

func (v *SCSpecUDTEnumCaseV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTEnumCaseV0) XdrTypeName() string              { return "SCSpecUDTEnumCaseV0" }
func (v SCSpecUDTEnumCaseV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTEnumCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTEnumCaseV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%svalue", name), XDR_Uint32(&v.Value))
}
func XDR_SCSpecUDTEnumCaseV0(v *SCSpecUDTEnumCaseV0) *SCSpecUDTEnumCaseV0 { return v }

type _XdrVec_50_SCSpecUDTEnumCaseV0 []SCSpecUDTEnumCaseV0

func (_XdrVec_50_SCSpecUDTEnumCaseV0) XdrBound() uint32 {
	const bound uint32 = 50 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_50_SCSpecUDTEnumCaseV0) XdrCheckLen(length uint32) {
	if length > uint32(50) {
		XdrPanic("_XdrVec_50_SCSpecUDTEnumCaseV0 length %d exceeds bound 50", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_50_SCSpecUDTEnumCaseV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_50_SCSpecUDTEnumCaseV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(50); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecUDTEnumCaseV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecUDTEnumCaseV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 50}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_50_SCSpecUDTEnumCaseV0) XdrTypeName() string              { return "SCSpecUDTEnumCaseV0<>" }
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) XdrPointer() interface{}       { return (*[]SCSpecUDTEnumCaseV0)(v) }
func (v _XdrVec_50_SCSpecUDTEnumCaseV0) XdrValue() interface{}          { return ([]SCSpecUDTEnumCaseV0)(v) }
func (v *_XdrVec_50_SCSpecUDTEnumCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTEnumV0 = *SCSpecUDTEnumV0

func (v *SCSpecUDTEnumV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTEnumV0) XdrTypeName() string              { return "SCSpecUDTEnumV0" }
func (v SCSpecUDTEnumV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTEnumV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTEnumV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slib", name), XdrString{&v.Lib, 80})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%scases", name), (*_XdrVec_50_SCSpecUDTEnumCaseV0)(&v.Cases))
}
func XDR_SCSpecUDTEnumV0(v *SCSpecUDTEnumV0) *SCSpecUDTEnumV0 { return v }

type XdrType_SCSpecUDTErrorEnumCaseV0 = *SCSpecUDTErrorEnumCaseV0

func (v *SCSpecUDTErrorEnumCaseV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTErrorEnumCaseV0) XdrTypeName() string              { return "SCSpecUDTErrorEnumCaseV0" }
func (v SCSpecUDTErrorEnumCaseV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTErrorEnumCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTErrorEnumCaseV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%svalue", name), XDR_Uint32(&v.Value))
}
func XDR_SCSpecUDTErrorEnumCaseV0(v *SCSpecUDTErrorEnumCaseV0) *SCSpecUDTErrorEnumCaseV0 { return v }

type _XdrVec_50_SCSpecUDTErrorEnumCaseV0 []SCSpecUDTErrorEnumCaseV0

func (_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrBound() uint32 {
	const bound uint32 = 50 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrCheckLen(length uint32) {
	if length > uint32(50) {
		XdrPanic("_XdrVec_50_SCSpecUDTErrorEnumCaseV0 length %d exceeds bound 50", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_50_SCSpecUDTErrorEnumCaseV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_50_SCSpecUDTErrorEnumCaseV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(50); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecUDTErrorEnumCaseV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecUDTErrorEnumCaseV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 50}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrTypeName() string { return "SCSpecUDTErrorEnumCaseV0<>" }
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrPointer() interface{} {
	return (*[]SCSpecUDTErrorEnumCaseV0)(v)
}
func (v _XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrValue() interface{} {
	return ([]SCSpecUDTErrorEnumCaseV0)(v)
}
func (v *_XdrVec_50_SCSpecUDTErrorEnumCaseV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecUDTErrorEnumV0 = *SCSpecUDTErrorEnumV0

func (v *SCSpecUDTErrorEnumV0) XdrPointer() interface{}       { return v }
func (SCSpecUDTErrorEnumV0) XdrTypeName() string              { return "SCSpecUDTErrorEnumV0" }
func (v SCSpecUDTErrorEnumV0) XdrValue() interface{}          { return v }
func (v *SCSpecUDTErrorEnumV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecUDTErrorEnumV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slib", name), XdrString{&v.Lib, 80})
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 60})
	x.Marshal(x.Sprintf("%scases", name), (*_XdrVec_50_SCSpecUDTErrorEnumCaseV0)(&v.Cases))
}
func XDR_SCSpecUDTErrorEnumV0(v *SCSpecUDTErrorEnumV0) *SCSpecUDTErrorEnumV0 { return v }

type XdrType_SCSpecFunctionInputV0 = *SCSpecFunctionInputV0

func (v *SCSpecFunctionInputV0) XdrPointer() interface{}       { return v }
func (SCSpecFunctionInputV0) XdrTypeName() string              { return "SCSpecFunctionInputV0" }
func (v SCSpecFunctionInputV0) XdrValue() interface{}          { return v }
func (v *SCSpecFunctionInputV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecFunctionInputV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XdrString{&v.Name, 30})
	x.Marshal(x.Sprintf("%stype", name), XDR_SCSpecTypeDef(&v.Type))
}
func XDR_SCSpecFunctionInputV0(v *SCSpecFunctionInputV0) *SCSpecFunctionInputV0 { return v }

type _XdrVec_10_SCSpecFunctionInputV0 []SCSpecFunctionInputV0

func (_XdrVec_10_SCSpecFunctionInputV0) XdrBound() uint32 {
	const bound uint32 = 10 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_10_SCSpecFunctionInputV0) XdrCheckLen(length uint32) {
	if length > uint32(10) {
		XdrPanic("_XdrVec_10_SCSpecFunctionInputV0 length %d exceeds bound 10", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_10_SCSpecFunctionInputV0 length %d exceeds max int", length)
	}
}
func (v _XdrVec_10_SCSpecFunctionInputV0) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_10_SCSpecFunctionInputV0) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(10); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecFunctionInputV0, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_10_SCSpecFunctionInputV0) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecFunctionInputV0(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_10_SCSpecFunctionInputV0) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 10}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_10_SCSpecFunctionInputV0) XdrTypeName() string { return "SCSpecFunctionInputV0<>" }
func (v *_XdrVec_10_SCSpecFunctionInputV0) XdrPointer() interface{} {
	return (*[]SCSpecFunctionInputV0)(v)
}
func (v _XdrVec_10_SCSpecFunctionInputV0) XdrValue() interface{}          { return ([]SCSpecFunctionInputV0)(v) }
func (v *_XdrVec_10_SCSpecFunctionInputV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type _XdrVec_1_SCSpecTypeDef []SCSpecTypeDef

func (_XdrVec_1_SCSpecTypeDef) XdrBound() uint32 {
	const bound uint32 = 1 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_1_SCSpecTypeDef) XdrCheckLen(length uint32) {
	if length > uint32(1) {
		XdrPanic("_XdrVec_1_SCSpecTypeDef length %d exceeds bound 1", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_1_SCSpecTypeDef length %d exceeds max int", length)
	}
}
func (v _XdrVec_1_SCSpecTypeDef) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_1_SCSpecTypeDef) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(1); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCSpecTypeDef, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_1_SCSpecTypeDef) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCSpecTypeDef(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_1_SCSpecTypeDef) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 1}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_1_SCSpecTypeDef) XdrTypeName() string              { return "SCSpecTypeDef<>" }
func (v *_XdrVec_1_SCSpecTypeDef) XdrPointer() interface{}       { return (*[]SCSpecTypeDef)(v) }
func (v _XdrVec_1_SCSpecTypeDef) XdrValue() interface{}          { return ([]SCSpecTypeDef)(v) }
func (v *_XdrVec_1_SCSpecTypeDef) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecFunctionV0 = *SCSpecFunctionV0

func (v *SCSpecFunctionV0) XdrPointer() interface{}       { return v }
func (SCSpecFunctionV0) XdrTypeName() string              { return "SCSpecFunctionV0" }
func (v SCSpecFunctionV0) XdrValue() interface{}          { return v }
func (v *SCSpecFunctionV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCSpecFunctionV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XDR_SCSymbol(&v.Name))
	x.Marshal(x.Sprintf("%sinputs", name), (*_XdrVec_10_SCSpecFunctionInputV0)(&v.Inputs))
	x.Marshal(x.Sprintf("%soutputs", name), (*_XdrVec_1_SCSpecTypeDef)(&v.Outputs))
}
func XDR_SCSpecFunctionV0(v *SCSpecFunctionV0) *SCSpecFunctionV0 { return v }

var _XdrNames_SCSpecEntryKind = map[int32]string{
	int32(SC_SPEC_ENTRY_FUNCTION_V0):       "SC_SPEC_ENTRY_FUNCTION_V0",
	int32(SC_SPEC_ENTRY_UDT_STRUCT_V0):     "SC_SPEC_ENTRY_UDT_STRUCT_V0",
	int32(SC_SPEC_ENTRY_UDT_UNION_V0):      "SC_SPEC_ENTRY_UDT_UNION_V0",
	int32(SC_SPEC_ENTRY_UDT_ENUM_V0):       "SC_SPEC_ENTRY_UDT_ENUM_V0",
	int32(SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0): "SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0",
}
var _XdrValues_SCSpecEntryKind = map[string]int32{
	"SC_SPEC_ENTRY_FUNCTION_V0":       int32(SC_SPEC_ENTRY_FUNCTION_V0),
	"SC_SPEC_ENTRY_UDT_STRUCT_V0":     int32(SC_SPEC_ENTRY_UDT_STRUCT_V0),
	"SC_SPEC_ENTRY_UDT_UNION_V0":      int32(SC_SPEC_ENTRY_UDT_UNION_V0),
	"SC_SPEC_ENTRY_UDT_ENUM_V0":       int32(SC_SPEC_ENTRY_UDT_ENUM_V0),
	"SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0": int32(SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0),
}

func (SCSpecEntryKind) XdrEnumNames() map[int32]string {
	return _XdrNames_SCSpecEntryKind
}
func (v SCSpecEntryKind) String() string {
	if s, ok := _XdrNames_SCSpecEntryKind[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCSpecEntryKind#%d", v)
}
func (v *SCSpecEntryKind) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCSpecEntryKind[stok]; ok {
			*v = SCSpecEntryKind(val)
			return nil
		} else if stok == "SCSpecEntryKind" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCSpecEntryKind.", stok))
	}
}
func (v SCSpecEntryKind) GetU32() uint32                 { return uint32(v) }
func (v *SCSpecEntryKind) SetU32(n uint32)               { *v = SCSpecEntryKind(n) }
func (v *SCSpecEntryKind) XdrPointer() interface{}       { return v }
func (SCSpecEntryKind) XdrTypeName() string              { return "SCSpecEntryKind" }
func (v SCSpecEntryKind) XdrValue() interface{}          { return v }
func (v *SCSpecEntryKind) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCSpecEntryKind = *SCSpecEntryKind

func XDR_SCSpecEntryKind(v *SCSpecEntryKind) *SCSpecEntryKind { return v }

var _XdrTags_SCSpecEntry = map[int32]bool{
	XdrToI32(SC_SPEC_ENTRY_FUNCTION_V0):       true,
	XdrToI32(SC_SPEC_ENTRY_UDT_STRUCT_V0):     true,
	XdrToI32(SC_SPEC_ENTRY_UDT_UNION_V0):      true,
	XdrToI32(SC_SPEC_ENTRY_UDT_ENUM_V0):       true,
	XdrToI32(SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0): true,
}

func (_ SCSpecEntry) XdrValidTags() map[int32]bool {
	return _XdrTags_SCSpecEntry
}
func (u *SCSpecEntry) FunctionV0() *SCSpecFunctionV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0:
		if v, ok := u._u.(*SCSpecFunctionV0); ok {
			return v
		} else {
			var zero SCSpecFunctionV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.FunctionV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecEntry) UdtStructV0() *SCSpecUDTStructV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_UDT_STRUCT_V0:
		if v, ok := u._u.(*SCSpecUDTStructV0); ok {
			return v
		} else {
			var zero SCSpecUDTStructV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.UdtStructV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecEntry) UdtUnionV0() *SCSpecUDTUnionV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_UDT_UNION_V0:
		if v, ok := u._u.(*SCSpecUDTUnionV0); ok {
			return v
		} else {
			var zero SCSpecUDTUnionV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.UdtUnionV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecEntry) UdtEnumV0() *SCSpecUDTEnumV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_UDT_ENUM_V0:
		if v, ok := u._u.(*SCSpecUDTEnumV0); ok {
			return v
		} else {
			var zero SCSpecUDTEnumV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.UdtEnumV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u *SCSpecEntry) UdtErrorEnumV0() *SCSpecUDTErrorEnumV0 {
	switch u.Kind {
	case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		if v, ok := u._u.(*SCSpecUDTErrorEnumV0); ok {
			return v
		} else {
			var zero SCSpecUDTErrorEnumV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCSpecEntry.UdtErrorEnumV0 accessed when Kind == %v", u.Kind)
		return nil
	}
}
func (u SCSpecEntry) XdrValid() bool {
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0, SC_SPEC_ENTRY_UDT_STRUCT_V0, SC_SPEC_ENTRY_UDT_UNION_V0, SC_SPEC_ENTRY_UDT_ENUM_V0, SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		return true
	}
	return false
}
func (u *SCSpecEntry) XdrUnionTag() XdrNum32 {
	return XDR_SCSpecEntryKind(&u.Kind)
}
func (u *SCSpecEntry) XdrUnionTagName() string {
	return "Kind"
}
func (u *SCSpecEntry) XdrUnionBody() XdrType {
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0:
		return XDR_SCSpecFunctionV0(u.FunctionV0())
	case SC_SPEC_ENTRY_UDT_STRUCT_V0:
		return XDR_SCSpecUDTStructV0(u.UdtStructV0())
	case SC_SPEC_ENTRY_UDT_UNION_V0:
		return XDR_SCSpecUDTUnionV0(u.UdtUnionV0())
	case SC_SPEC_ENTRY_UDT_ENUM_V0:
		return XDR_SCSpecUDTEnumV0(u.UdtEnumV0())
	case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		return XDR_SCSpecUDTErrorEnumV0(u.UdtErrorEnumV0())
	}
	return nil
}
func (u *SCSpecEntry) XdrUnionBodyName() string {
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0:
		return "FunctionV0"
	case SC_SPEC_ENTRY_UDT_STRUCT_V0:
		return "UdtStructV0"
	case SC_SPEC_ENTRY_UDT_UNION_V0:
		return "UdtUnionV0"
	case SC_SPEC_ENTRY_UDT_ENUM_V0:
		return "UdtEnumV0"
	case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		return "UdtErrorEnumV0"
	}
	return ""
}

type XdrType_SCSpecEntry = *SCSpecEntry

func (v *SCSpecEntry) XdrPointer() interface{}       { return v }
func (SCSpecEntry) XdrTypeName() string              { return "SCSpecEntry" }
func (v SCSpecEntry) XdrValue() interface{}          { return v }
func (v *SCSpecEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCSpecEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCSpecEntryKind(&u.Kind).XdrMarshal(x, x.Sprintf("%skind", name))
	switch u.Kind {
	case SC_SPEC_ENTRY_FUNCTION_V0:
		x.Marshal(x.Sprintf("%sfunctionV0", name), XDR_SCSpecFunctionV0(u.FunctionV0()))
		return
	case SC_SPEC_ENTRY_UDT_STRUCT_V0:
		x.Marshal(x.Sprintf("%sudtStructV0", name), XDR_SCSpecUDTStructV0(u.UdtStructV0()))
		return
	case SC_SPEC_ENTRY_UDT_UNION_V0:
		x.Marshal(x.Sprintf("%sudtUnionV0", name), XDR_SCSpecUDTUnionV0(u.UdtUnionV0()))
		return
	case SC_SPEC_ENTRY_UDT_ENUM_V0:
		x.Marshal(x.Sprintf("%sudtEnumV0", name), XDR_SCSpecUDTEnumV0(u.UdtEnumV0()))
		return
	case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
		x.Marshal(x.Sprintf("%sudtErrorEnumV0", name), XDR_SCSpecUDTErrorEnumV0(u.UdtErrorEnumV0()))
		return
	}
	XdrPanic("invalid Kind (%v) in SCSpecEntry", u.Kind)
}
func XDR_SCSpecEntry(v *SCSpecEntry) *SCSpecEntry { return v }

type XdrType_SCSymbol struct {
	XdrString
}

func XDR_SCSymbol(v *SCSymbol) XdrType_SCSymbol {
	return XdrType_SCSymbol{XdrString{v, 10}}
}
func (XdrType_SCSymbol) XdrTypeName() string  { return "SCSymbol" }
func (v XdrType_SCSymbol) XdrUnwrap() XdrType { return v.XdrString }

var _XdrNames_SCValType = map[int32]string{
	int32(SCV_U63):    "SCV_U63",
	int32(SCV_U32):    "SCV_U32",
	int32(SCV_I32):    "SCV_I32",
	int32(SCV_STATIC): "SCV_STATIC",
	int32(SCV_OBJECT): "SCV_OBJECT",
	int32(SCV_SYMBOL): "SCV_SYMBOL",
	int32(SCV_BITSET): "SCV_BITSET",
	int32(SCV_STATUS): "SCV_STATUS",
}
var _XdrValues_SCValType = map[string]int32{
	"SCV_U63":    int32(SCV_U63),
	"SCV_U32":    int32(SCV_U32),
	"SCV_I32":    int32(SCV_I32),
	"SCV_STATIC": int32(SCV_STATIC),
	"SCV_OBJECT": int32(SCV_OBJECT),
	"SCV_SYMBOL": int32(SCV_SYMBOL),
	"SCV_BITSET": int32(SCV_BITSET),
	"SCV_STATUS": int32(SCV_STATUS),
}

func (SCValType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCValType
}
func (v SCValType) String() string {
	if s, ok := _XdrNames_SCValType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCValType#%d", v)
}
func (v *SCValType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCValType[stok]; ok {
			*v = SCValType(val)
			return nil
		} else if stok == "SCValType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCValType.", stok))
	}
}
func (v SCValType) GetU32() uint32                 { return uint32(v) }
func (v *SCValType) SetU32(n uint32)               { *v = SCValType(n) }
func (v *SCValType) XdrPointer() interface{}       { return v }
func (SCValType) XdrTypeName() string              { return "SCValType" }
func (v SCValType) XdrValue() interface{}          { return v }
func (v *SCValType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCValType = *SCValType

func XDR_SCValType(v *SCValType) *SCValType { return v }

var _XdrNames_SCStatic = map[int32]string{
	int32(SCS_VOID):                     "SCS_VOID",
	int32(SCS_TRUE):                     "SCS_TRUE",
	int32(SCS_FALSE):                    "SCS_FALSE",
	int32(SCS_LEDGER_KEY_CONTRACT_CODE): "SCS_LEDGER_KEY_CONTRACT_CODE",
}
var _XdrValues_SCStatic = map[string]int32{
	"SCS_VOID":                     int32(SCS_VOID),
	"SCS_TRUE":                     int32(SCS_TRUE),
	"SCS_FALSE":                    int32(SCS_FALSE),
	"SCS_LEDGER_KEY_CONTRACT_CODE": int32(SCS_LEDGER_KEY_CONTRACT_CODE),
}

func (SCStatic) XdrEnumNames() map[int32]string {
	return _XdrNames_SCStatic
}
func (v SCStatic) String() string {
	if s, ok := _XdrNames_SCStatic[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCStatic#%d", v)
}
func (v *SCStatic) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCStatic[stok]; ok {
			*v = SCStatic(val)
			return nil
		} else if stok == "SCStatic" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCStatic.", stok))
	}
}
func (v SCStatic) GetU32() uint32                 { return uint32(v) }
func (v *SCStatic) SetU32(n uint32)               { *v = SCStatic(n) }
func (v *SCStatic) XdrPointer() interface{}       { return v }
func (SCStatic) XdrTypeName() string              { return "SCStatic" }
func (v SCStatic) XdrValue() interface{}          { return v }
func (v *SCStatic) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCStatic = *SCStatic

func XDR_SCStatic(v *SCStatic) *SCStatic { return v }

var _XdrNames_SCStatusType = map[int32]string{
	int32(SST_OK):                  "SST_OK",
	int32(SST_UNKNOWN_ERROR):       "SST_UNKNOWN_ERROR",
	int32(SST_HOST_VALUE_ERROR):    "SST_HOST_VALUE_ERROR",
	int32(SST_HOST_OBJECT_ERROR):   "SST_HOST_OBJECT_ERROR",
	int32(SST_HOST_FUNCTION_ERROR): "SST_HOST_FUNCTION_ERROR",
	int32(SST_HOST_STORAGE_ERROR):  "SST_HOST_STORAGE_ERROR",
	int32(SST_HOST_CONTEXT_ERROR):  "SST_HOST_CONTEXT_ERROR",
	int32(SST_VM_ERROR):            "SST_VM_ERROR",
	int32(SST_CONTRACT_ERROR):      "SST_CONTRACT_ERROR",
}
var _XdrValues_SCStatusType = map[string]int32{
	"SST_OK":                  int32(SST_OK),
	"SST_UNKNOWN_ERROR":       int32(SST_UNKNOWN_ERROR),
	"SST_HOST_VALUE_ERROR":    int32(SST_HOST_VALUE_ERROR),
	"SST_HOST_OBJECT_ERROR":   int32(SST_HOST_OBJECT_ERROR),
	"SST_HOST_FUNCTION_ERROR": int32(SST_HOST_FUNCTION_ERROR),
	"SST_HOST_STORAGE_ERROR":  int32(SST_HOST_STORAGE_ERROR),
	"SST_HOST_CONTEXT_ERROR":  int32(SST_HOST_CONTEXT_ERROR),
	"SST_VM_ERROR":            int32(SST_VM_ERROR),
	"SST_CONTRACT_ERROR":      int32(SST_CONTRACT_ERROR),
}

func (SCStatusType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCStatusType
}
func (v SCStatusType) String() string {
	if s, ok := _XdrNames_SCStatusType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCStatusType#%d", v)
}
func (v *SCStatusType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCStatusType[stok]; ok {
			*v = SCStatusType(val)
			return nil
		} else if stok == "SCStatusType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCStatusType.", stok))
	}
}
func (v SCStatusType) GetU32() uint32                 { return uint32(v) }
func (v *SCStatusType) SetU32(n uint32)               { *v = SCStatusType(n) }
func (v *SCStatusType) XdrPointer() interface{}       { return v }
func (SCStatusType) XdrTypeName() string              { return "SCStatusType" }
func (v SCStatusType) XdrValue() interface{}          { return v }
func (v *SCStatusType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCStatusType = *SCStatusType

func XDR_SCStatusType(v *SCStatusType) *SCStatusType { return v }

var _XdrNames_SCHostValErrorCode = map[int32]string{
	int32(HOST_VALUE_UNKNOWN_ERROR):            "HOST_VALUE_UNKNOWN_ERROR",
	int32(HOST_VALUE_RESERVED_TAG_VALUE):       "HOST_VALUE_RESERVED_TAG_VALUE",
	int32(HOST_VALUE_UNEXPECTED_VAL_TYPE):      "HOST_VALUE_UNEXPECTED_VAL_TYPE",
	int32(HOST_VALUE_U63_OUT_OF_RANGE):         "HOST_VALUE_U63_OUT_OF_RANGE",
	int32(HOST_VALUE_U32_OUT_OF_RANGE):         "HOST_VALUE_U32_OUT_OF_RANGE",
	int32(HOST_VALUE_STATIC_UNKNOWN):           "HOST_VALUE_STATIC_UNKNOWN",
	int32(HOST_VALUE_MISSING_OBJECT):           "HOST_VALUE_MISSING_OBJECT",
	int32(HOST_VALUE_SYMBOL_TOO_LONG):          "HOST_VALUE_SYMBOL_TOO_LONG",
	int32(HOST_VALUE_SYMBOL_BAD_CHAR):          "HOST_VALUE_SYMBOL_BAD_CHAR",
	int32(HOST_VALUE_SYMBOL_CONTAINS_NON_UTF8): "HOST_VALUE_SYMBOL_CONTAINS_NON_UTF8",
	int32(HOST_VALUE_BITSET_TOO_MANY_BITS):     "HOST_VALUE_BITSET_TOO_MANY_BITS",
	int32(HOST_VALUE_STATUS_UNKNOWN):           "HOST_VALUE_STATUS_UNKNOWN",
}
var _XdrValues_SCHostValErrorCode = map[string]int32{
	"HOST_VALUE_UNKNOWN_ERROR":            int32(HOST_VALUE_UNKNOWN_ERROR),
	"HOST_VALUE_RESERVED_TAG_VALUE":       int32(HOST_VALUE_RESERVED_TAG_VALUE),
	"HOST_VALUE_UNEXPECTED_VAL_TYPE":      int32(HOST_VALUE_UNEXPECTED_VAL_TYPE),
	"HOST_VALUE_U63_OUT_OF_RANGE":         int32(HOST_VALUE_U63_OUT_OF_RANGE),
	"HOST_VALUE_U32_OUT_OF_RANGE":         int32(HOST_VALUE_U32_OUT_OF_RANGE),
	"HOST_VALUE_STATIC_UNKNOWN":           int32(HOST_VALUE_STATIC_UNKNOWN),
	"HOST_VALUE_MISSING_OBJECT":           int32(HOST_VALUE_MISSING_OBJECT),
	"HOST_VALUE_SYMBOL_TOO_LONG":          int32(HOST_VALUE_SYMBOL_TOO_LONG),
	"HOST_VALUE_SYMBOL_BAD_CHAR":          int32(HOST_VALUE_SYMBOL_BAD_CHAR),
	"HOST_VALUE_SYMBOL_CONTAINS_NON_UTF8": int32(HOST_VALUE_SYMBOL_CONTAINS_NON_UTF8),
	"HOST_VALUE_BITSET_TOO_MANY_BITS":     int32(HOST_VALUE_BITSET_TOO_MANY_BITS),
	"HOST_VALUE_STATUS_UNKNOWN":           int32(HOST_VALUE_STATUS_UNKNOWN),
}

func (SCHostValErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SCHostValErrorCode
}
func (v SCHostValErrorCode) String() string {
	if s, ok := _XdrNames_SCHostValErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCHostValErrorCode#%d", v)
}
func (v *SCHostValErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCHostValErrorCode[stok]; ok {
			*v = SCHostValErrorCode(val)
			return nil
		} else if stok == "SCHostValErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCHostValErrorCode.", stok))
	}
}
func (v SCHostValErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *SCHostValErrorCode) SetU32(n uint32)               { *v = SCHostValErrorCode(n) }
func (v *SCHostValErrorCode) XdrPointer() interface{}       { return v }
func (SCHostValErrorCode) XdrTypeName() string              { return "SCHostValErrorCode" }
func (v SCHostValErrorCode) XdrValue() interface{}          { return v }
func (v *SCHostValErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCHostValErrorCode = *SCHostValErrorCode

func XDR_SCHostValErrorCode(v *SCHostValErrorCode) *SCHostValErrorCode { return v }

var _XdrNames_SCHostObjErrorCode = map[int32]string{
	int32(HOST_OBJECT_UNKNOWN_ERROR):                "HOST_OBJECT_UNKNOWN_ERROR",
	int32(HOST_OBJECT_UNKNOWN_REFERENCE):            "HOST_OBJECT_UNKNOWN_REFERENCE",
	int32(HOST_OBJECT_UNEXPECTED_TYPE):              "HOST_OBJECT_UNEXPECTED_TYPE",
	int32(HOST_OBJECT_OBJECT_COUNT_EXCEEDS_U32_MAX): "HOST_OBJECT_OBJECT_COUNT_EXCEEDS_U32_MAX",
	int32(HOST_OBJECT_OBJECT_NOT_EXIST):             "HOST_OBJECT_OBJECT_NOT_EXIST",
	int32(HOST_OBJECT_VEC_INDEX_OUT_OF_BOUND):       "HOST_OBJECT_VEC_INDEX_OUT_OF_BOUND",
	int32(HOST_OBJECT_CONTRACT_HASH_WRONG_LENGTH):   "HOST_OBJECT_CONTRACT_HASH_WRONG_LENGTH",
}
var _XdrValues_SCHostObjErrorCode = map[string]int32{
	"HOST_OBJECT_UNKNOWN_ERROR":                int32(HOST_OBJECT_UNKNOWN_ERROR),
	"HOST_OBJECT_UNKNOWN_REFERENCE":            int32(HOST_OBJECT_UNKNOWN_REFERENCE),
	"HOST_OBJECT_UNEXPECTED_TYPE":              int32(HOST_OBJECT_UNEXPECTED_TYPE),
	"HOST_OBJECT_OBJECT_COUNT_EXCEEDS_U32_MAX": int32(HOST_OBJECT_OBJECT_COUNT_EXCEEDS_U32_MAX),
	"HOST_OBJECT_OBJECT_NOT_EXIST":             int32(HOST_OBJECT_OBJECT_NOT_EXIST),
	"HOST_OBJECT_VEC_INDEX_OUT_OF_BOUND":       int32(HOST_OBJECT_VEC_INDEX_OUT_OF_BOUND),
	"HOST_OBJECT_CONTRACT_HASH_WRONG_LENGTH":   int32(HOST_OBJECT_CONTRACT_HASH_WRONG_LENGTH),
}

func (SCHostObjErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SCHostObjErrorCode
}
func (v SCHostObjErrorCode) String() string {
	if s, ok := _XdrNames_SCHostObjErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCHostObjErrorCode#%d", v)
}
func (v *SCHostObjErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCHostObjErrorCode[stok]; ok {
			*v = SCHostObjErrorCode(val)
			return nil
		} else if stok == "SCHostObjErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCHostObjErrorCode.", stok))
	}
}
func (v SCHostObjErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *SCHostObjErrorCode) SetU32(n uint32)               { *v = SCHostObjErrorCode(n) }
func (v *SCHostObjErrorCode) XdrPointer() interface{}       { return v }
func (SCHostObjErrorCode) XdrTypeName() string              { return "SCHostObjErrorCode" }
func (v SCHostObjErrorCode) XdrValue() interface{}          { return v }
func (v *SCHostObjErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCHostObjErrorCode = *SCHostObjErrorCode

func XDR_SCHostObjErrorCode(v *SCHostObjErrorCode) *SCHostObjErrorCode { return v }

var _XdrNames_SCHostFnErrorCode = map[int32]string{
	int32(HOST_FN_UNKNOWN_ERROR):                   "HOST_FN_UNKNOWN_ERROR",
	int32(HOST_FN_UNEXPECTED_HOST_FUNCTION_ACTION): "HOST_FN_UNEXPECTED_HOST_FUNCTION_ACTION",
	int32(HOST_FN_INPUT_ARGS_WRONG_LENGTH):         "HOST_FN_INPUT_ARGS_WRONG_LENGTH",
	int32(HOST_FN_INPUT_ARGS_WRONG_TYPE):           "HOST_FN_INPUT_ARGS_WRONG_TYPE",
	int32(HOST_FN_INPUT_ARGS_INVALID):              "HOST_FN_INPUT_ARGS_INVALID",
}
var _XdrValues_SCHostFnErrorCode = map[string]int32{
	"HOST_FN_UNKNOWN_ERROR":                   int32(HOST_FN_UNKNOWN_ERROR),
	"HOST_FN_UNEXPECTED_HOST_FUNCTION_ACTION": int32(HOST_FN_UNEXPECTED_HOST_FUNCTION_ACTION),
	"HOST_FN_INPUT_ARGS_WRONG_LENGTH":         int32(HOST_FN_INPUT_ARGS_WRONG_LENGTH),
	"HOST_FN_INPUT_ARGS_WRONG_TYPE":           int32(HOST_FN_INPUT_ARGS_WRONG_TYPE),
	"HOST_FN_INPUT_ARGS_INVALID":              int32(HOST_FN_INPUT_ARGS_INVALID),
}

func (SCHostFnErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SCHostFnErrorCode
}
func (v SCHostFnErrorCode) String() string {
	if s, ok := _XdrNames_SCHostFnErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCHostFnErrorCode#%d", v)
}
func (v *SCHostFnErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCHostFnErrorCode[stok]; ok {
			*v = SCHostFnErrorCode(val)
			return nil
		} else if stok == "SCHostFnErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCHostFnErrorCode.", stok))
	}
}
func (v SCHostFnErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *SCHostFnErrorCode) SetU32(n uint32)               { *v = SCHostFnErrorCode(n) }
func (v *SCHostFnErrorCode) XdrPointer() interface{}       { return v }
func (SCHostFnErrorCode) XdrTypeName() string              { return "SCHostFnErrorCode" }
func (v SCHostFnErrorCode) XdrValue() interface{}          { return v }
func (v *SCHostFnErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCHostFnErrorCode = *SCHostFnErrorCode

func XDR_SCHostFnErrorCode(v *SCHostFnErrorCode) *SCHostFnErrorCode { return v }

var _XdrNames_SCHostStorageErrorCode = map[int32]string{
	int32(HOST_STORAGE_UNKNOWN_ERROR):                      "HOST_STORAGE_UNKNOWN_ERROR",
	int32(HOST_STORAGE_EXPECT_CONTRACT_DATA):               "HOST_STORAGE_EXPECT_CONTRACT_DATA",
	int32(HOST_STORAGE_READWRITE_ACCESS_TO_READONLY_ENTRY): "HOST_STORAGE_READWRITE_ACCESS_TO_READONLY_ENTRY",
	int32(HOST_STORAGE_ACCESS_TO_UNKNOWN_ENTRY):            "HOST_STORAGE_ACCESS_TO_UNKNOWN_ENTRY",
	int32(HOST_STORAGE_MISSING_KEY_IN_GET):                 "HOST_STORAGE_MISSING_KEY_IN_GET",
	int32(HOST_STORAGE_GET_ON_DELETED_KEY):                 "HOST_STORAGE_GET_ON_DELETED_KEY",
}
var _XdrValues_SCHostStorageErrorCode = map[string]int32{
	"HOST_STORAGE_UNKNOWN_ERROR":                      int32(HOST_STORAGE_UNKNOWN_ERROR),
	"HOST_STORAGE_EXPECT_CONTRACT_DATA":               int32(HOST_STORAGE_EXPECT_CONTRACT_DATA),
	"HOST_STORAGE_READWRITE_ACCESS_TO_READONLY_ENTRY": int32(HOST_STORAGE_READWRITE_ACCESS_TO_READONLY_ENTRY),
	"HOST_STORAGE_ACCESS_TO_UNKNOWN_ENTRY":            int32(HOST_STORAGE_ACCESS_TO_UNKNOWN_ENTRY),
	"HOST_STORAGE_MISSING_KEY_IN_GET":                 int32(HOST_STORAGE_MISSING_KEY_IN_GET),
	"HOST_STORAGE_GET_ON_DELETED_KEY":                 int32(HOST_STORAGE_GET_ON_DELETED_KEY),
}

func (SCHostStorageErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SCHostStorageErrorCode
}
func (v SCHostStorageErrorCode) String() string {
	if s, ok := _XdrNames_SCHostStorageErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCHostStorageErrorCode#%d", v)
}
func (v *SCHostStorageErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCHostStorageErrorCode[stok]; ok {
			*v = SCHostStorageErrorCode(val)
			return nil
		} else if stok == "SCHostStorageErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCHostStorageErrorCode.", stok))
	}
}
func (v SCHostStorageErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *SCHostStorageErrorCode) SetU32(n uint32)               { *v = SCHostStorageErrorCode(n) }
func (v *SCHostStorageErrorCode) XdrPointer() interface{}       { return v }
func (SCHostStorageErrorCode) XdrTypeName() string              { return "SCHostStorageErrorCode" }
func (v SCHostStorageErrorCode) XdrValue() interface{}          { return v }
func (v *SCHostStorageErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCHostStorageErrorCode = *SCHostStorageErrorCode

func XDR_SCHostStorageErrorCode(v *SCHostStorageErrorCode) *SCHostStorageErrorCode { return v }

var _XdrNames_SCHostContextErrorCode = map[int32]string{
	int32(HOST_CONTEXT_UNKNOWN_ERROR):       "HOST_CONTEXT_UNKNOWN_ERROR",
	int32(HOST_CONTEXT_NO_CONTRACT_RUNNING): "HOST_CONTEXT_NO_CONTRACT_RUNNING",
}
var _XdrValues_SCHostContextErrorCode = map[string]int32{
	"HOST_CONTEXT_UNKNOWN_ERROR":       int32(HOST_CONTEXT_UNKNOWN_ERROR),
	"HOST_CONTEXT_NO_CONTRACT_RUNNING": int32(HOST_CONTEXT_NO_CONTRACT_RUNNING),
}

func (SCHostContextErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SCHostContextErrorCode
}
func (v SCHostContextErrorCode) String() string {
	if s, ok := _XdrNames_SCHostContextErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCHostContextErrorCode#%d", v)
}
func (v *SCHostContextErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCHostContextErrorCode[stok]; ok {
			*v = SCHostContextErrorCode(val)
			return nil
		} else if stok == "SCHostContextErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCHostContextErrorCode.", stok))
	}
}
func (v SCHostContextErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *SCHostContextErrorCode) SetU32(n uint32)               { *v = SCHostContextErrorCode(n) }
func (v *SCHostContextErrorCode) XdrPointer() interface{}       { return v }
func (SCHostContextErrorCode) XdrTypeName() string              { return "SCHostContextErrorCode" }
func (v SCHostContextErrorCode) XdrValue() interface{}          { return v }
func (v *SCHostContextErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCHostContextErrorCode = *SCHostContextErrorCode

func XDR_SCHostContextErrorCode(v *SCHostContextErrorCode) *SCHostContextErrorCode { return v }

var _XdrNames_SCVmErrorCode = map[int32]string{
	int32(VM_UNKNOWN):                          "VM_UNKNOWN",
	int32(VM_VALIDATION):                       "VM_VALIDATION",
	int32(VM_INSTANTIATION):                    "VM_INSTANTIATION",
	int32(VM_FUNCTION):                         "VM_FUNCTION",
	int32(VM_TABLE):                            "VM_TABLE",
	int32(VM_MEMORY):                           "VM_MEMORY",
	int32(VM_GLOBAL):                           "VM_GLOBAL",
	int32(VM_VALUE):                            "VM_VALUE",
	int32(VM_TRAP_UNREACHABLE):                 "VM_TRAP_UNREACHABLE",
	int32(VM_TRAP_MEMORY_ACCESS_OUT_OF_BOUNDS): "VM_TRAP_MEMORY_ACCESS_OUT_OF_BOUNDS",
	int32(VM_TRAP_TABLE_ACCESS_OUT_OF_BOUNDS):  "VM_TRAP_TABLE_ACCESS_OUT_OF_BOUNDS",
	int32(VM_TRAP_ELEM_UNINITIALIZED):          "VM_TRAP_ELEM_UNINITIALIZED",
	int32(VM_TRAP_DIVISION_BY_ZERO):            "VM_TRAP_DIVISION_BY_ZERO",
	int32(VM_TRAP_INTEGER_OVERFLOW):            "VM_TRAP_INTEGER_OVERFLOW",
	int32(VM_TRAP_INVALID_CONVERSION_TO_INT):   "VM_TRAP_INVALID_CONVERSION_TO_INT",
	int32(VM_TRAP_STACK_OVERFLOW):              "VM_TRAP_STACK_OVERFLOW",
	int32(VM_TRAP_UNEXPECTED_SIGNATURE):        "VM_TRAP_UNEXPECTED_SIGNATURE",
	int32(VM_TRAP_MEM_LIMIT_EXCEEDED):          "VM_TRAP_MEM_LIMIT_EXCEEDED",
	int32(VM_TRAP_CPU_LIMIT_EXCEEDED):          "VM_TRAP_CPU_LIMIT_EXCEEDED",
}
var _XdrValues_SCVmErrorCode = map[string]int32{
	"VM_UNKNOWN":                          int32(VM_UNKNOWN),
	"VM_VALIDATION":                       int32(VM_VALIDATION),
	"VM_INSTANTIATION":                    int32(VM_INSTANTIATION),
	"VM_FUNCTION":                         int32(VM_FUNCTION),
	"VM_TABLE":                            int32(VM_TABLE),
	"VM_MEMORY":                           int32(VM_MEMORY),
	"VM_GLOBAL":                           int32(VM_GLOBAL),
	"VM_VALUE":                            int32(VM_VALUE),
	"VM_TRAP_UNREACHABLE":                 int32(VM_TRAP_UNREACHABLE),
	"VM_TRAP_MEMORY_ACCESS_OUT_OF_BOUNDS": int32(VM_TRAP_MEMORY_ACCESS_OUT_OF_BOUNDS),
	"VM_TRAP_TABLE_ACCESS_OUT_OF_BOUNDS":  int32(VM_TRAP_TABLE_ACCESS_OUT_OF_BOUNDS),
	"VM_TRAP_ELEM_UNINITIALIZED":          int32(VM_TRAP_ELEM_UNINITIALIZED),
	"VM_TRAP_DIVISION_BY_ZERO":            int32(VM_TRAP_DIVISION_BY_ZERO),
	"VM_TRAP_INTEGER_OVERFLOW":            int32(VM_TRAP_INTEGER_OVERFLOW),
	"VM_TRAP_INVALID_CONVERSION_TO_INT":   int32(VM_TRAP_INVALID_CONVERSION_TO_INT),
	"VM_TRAP_STACK_OVERFLOW":              int32(VM_TRAP_STACK_OVERFLOW),
	"VM_TRAP_UNEXPECTED_SIGNATURE":        int32(VM_TRAP_UNEXPECTED_SIGNATURE),
	"VM_TRAP_MEM_LIMIT_EXCEEDED":          int32(VM_TRAP_MEM_LIMIT_EXCEEDED),
	"VM_TRAP_CPU_LIMIT_EXCEEDED":          int32(VM_TRAP_CPU_LIMIT_EXCEEDED),
}

func (SCVmErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SCVmErrorCode
}
func (v SCVmErrorCode) String() string {
	if s, ok := _XdrNames_SCVmErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCVmErrorCode#%d", v)
}
func (v *SCVmErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCVmErrorCode[stok]; ok {
			*v = SCVmErrorCode(val)
			return nil
		} else if stok == "SCVmErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCVmErrorCode.", stok))
	}
}
func (v SCVmErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *SCVmErrorCode) SetU32(n uint32)               { *v = SCVmErrorCode(n) }
func (v *SCVmErrorCode) XdrPointer() interface{}       { return v }
func (SCVmErrorCode) XdrTypeName() string              { return "SCVmErrorCode" }
func (v SCVmErrorCode) XdrValue() interface{}          { return v }
func (v *SCVmErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCVmErrorCode = *SCVmErrorCode

func XDR_SCVmErrorCode(v *SCVmErrorCode) *SCVmErrorCode { return v }

var _XdrNames_SCUnknownErrorCode = map[int32]string{
	int32(UNKNOWN_ERROR_GENERAL): "UNKNOWN_ERROR_GENERAL",
	int32(UNKNOWN_ERROR_XDR):     "UNKNOWN_ERROR_XDR",
}
var _XdrValues_SCUnknownErrorCode = map[string]int32{
	"UNKNOWN_ERROR_GENERAL": int32(UNKNOWN_ERROR_GENERAL),
	"UNKNOWN_ERROR_XDR":     int32(UNKNOWN_ERROR_XDR),
}

func (SCUnknownErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SCUnknownErrorCode
}
func (v SCUnknownErrorCode) String() string {
	if s, ok := _XdrNames_SCUnknownErrorCode[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCUnknownErrorCode#%d", v)
}
func (v *SCUnknownErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCUnknownErrorCode[stok]; ok {
			*v = SCUnknownErrorCode(val)
			return nil
		} else if stok == "SCUnknownErrorCode" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCUnknownErrorCode.", stok))
	}
}
func (v SCUnknownErrorCode) GetU32() uint32                 { return uint32(v) }
func (v *SCUnknownErrorCode) SetU32(n uint32)               { *v = SCUnknownErrorCode(n) }
func (v *SCUnknownErrorCode) XdrPointer() interface{}       { return v }
func (SCUnknownErrorCode) XdrTypeName() string              { return "SCUnknownErrorCode" }
func (v SCUnknownErrorCode) XdrValue() interface{}          { return v }
func (v *SCUnknownErrorCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCUnknownErrorCode = *SCUnknownErrorCode

func XDR_SCUnknownErrorCode(v *SCUnknownErrorCode) *SCUnknownErrorCode { return v }

var _XdrTags_SCStatus = map[int32]bool{
	XdrToI32(SST_OK):                  true,
	XdrToI32(SST_UNKNOWN_ERROR):       true,
	XdrToI32(SST_HOST_VALUE_ERROR):    true,
	XdrToI32(SST_HOST_OBJECT_ERROR):   true,
	XdrToI32(SST_HOST_FUNCTION_ERROR): true,
	XdrToI32(SST_HOST_STORAGE_ERROR):  true,
	XdrToI32(SST_HOST_CONTEXT_ERROR):  true,
	XdrToI32(SST_VM_ERROR):            true,
	XdrToI32(SST_CONTRACT_ERROR):      true,
}

func (_ SCStatus) XdrValidTags() map[int32]bool {
	return _XdrTags_SCStatus
}
func (u *SCStatus) UnknownCode() *SCUnknownErrorCode {
	switch u.Type {
	case SST_UNKNOWN_ERROR:
		if v, ok := u._u.(*SCUnknownErrorCode); ok {
			return v
		} else {
			var zero SCUnknownErrorCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCStatus.UnknownCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCStatus) ValCode() *SCHostValErrorCode {
	switch u.Type {
	case SST_HOST_VALUE_ERROR:
		if v, ok := u._u.(*SCHostValErrorCode); ok {
			return v
		} else {
			var zero SCHostValErrorCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCStatus.ValCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCStatus) ObjCode() *SCHostObjErrorCode {
	switch u.Type {
	case SST_HOST_OBJECT_ERROR:
		if v, ok := u._u.(*SCHostObjErrorCode); ok {
			return v
		} else {
			var zero SCHostObjErrorCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCStatus.ObjCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCStatus) FnCode() *SCHostFnErrorCode {
	switch u.Type {
	case SST_HOST_FUNCTION_ERROR:
		if v, ok := u._u.(*SCHostFnErrorCode); ok {
			return v
		} else {
			var zero SCHostFnErrorCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCStatus.FnCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCStatus) StorageCode() *SCHostStorageErrorCode {
	switch u.Type {
	case SST_HOST_STORAGE_ERROR:
		if v, ok := u._u.(*SCHostStorageErrorCode); ok {
			return v
		} else {
			var zero SCHostStorageErrorCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCStatus.StorageCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCStatus) ContextCode() *SCHostContextErrorCode {
	switch u.Type {
	case SST_HOST_CONTEXT_ERROR:
		if v, ok := u._u.(*SCHostContextErrorCode); ok {
			return v
		} else {
			var zero SCHostContextErrorCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCStatus.ContextCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCStatus) VmCode() *SCVmErrorCode {
	switch u.Type {
	case SST_VM_ERROR:
		if v, ok := u._u.(*SCVmErrorCode); ok {
			return v
		} else {
			var zero SCVmErrorCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCStatus.VmCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCStatus) ContractCode() *Uint32 {
	switch u.Type {
	case SST_CONTRACT_ERROR:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCStatus.ContractCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCStatus) XdrValid() bool {
	switch u.Type {
	case SST_OK, SST_UNKNOWN_ERROR, SST_HOST_VALUE_ERROR, SST_HOST_OBJECT_ERROR, SST_HOST_FUNCTION_ERROR, SST_HOST_STORAGE_ERROR, SST_HOST_CONTEXT_ERROR, SST_VM_ERROR, SST_CONTRACT_ERROR:
		return true
	}
	return false
}
func (u *SCStatus) XdrUnionTag() XdrNum32 {
	return XDR_SCStatusType(&u.Type)
}
func (u *SCStatus) XdrUnionTagName() string {
	return "Type"
}
func (u *SCStatus) XdrUnionBody() XdrType {
	switch u.Type {
	case SST_OK:
		return nil
	case SST_UNKNOWN_ERROR:
		return XDR_SCUnknownErrorCode(u.UnknownCode())
	case SST_HOST_VALUE_ERROR:
		return XDR_SCHostValErrorCode(u.ValCode())
	case SST_HOST_OBJECT_ERROR:
		return XDR_SCHostObjErrorCode(u.ObjCode())
	case SST_HOST_FUNCTION_ERROR:
		return XDR_SCHostFnErrorCode(u.FnCode())
	case SST_HOST_STORAGE_ERROR:
		return XDR_SCHostStorageErrorCode(u.StorageCode())
	case SST_HOST_CONTEXT_ERROR:
		return XDR_SCHostContextErrorCode(u.ContextCode())
	case SST_VM_ERROR:
		return XDR_SCVmErrorCode(u.VmCode())
	case SST_CONTRACT_ERROR:
		return XDR_Uint32(u.ContractCode())
	}
	return nil
}
func (u *SCStatus) XdrUnionBodyName() string {
	switch u.Type {
	case SST_OK:
		return ""
	case SST_UNKNOWN_ERROR:
		return "UnknownCode"
	case SST_HOST_VALUE_ERROR:
		return "ValCode"
	case SST_HOST_OBJECT_ERROR:
		return "ObjCode"
	case SST_HOST_FUNCTION_ERROR:
		return "FnCode"
	case SST_HOST_STORAGE_ERROR:
		return "StorageCode"
	case SST_HOST_CONTEXT_ERROR:
		return "ContextCode"
	case SST_VM_ERROR:
		return "VmCode"
	case SST_CONTRACT_ERROR:
		return "ContractCode"
	}
	return ""
}

type XdrType_SCStatus = *SCStatus

func (v *SCStatus) XdrPointer() interface{}       { return v }
func (SCStatus) XdrTypeName() string              { return "SCStatus" }
func (v SCStatus) XdrValue() interface{}          { return v }
func (v *SCStatus) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCStatus) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCStatusType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SST_OK:
		return
	case SST_UNKNOWN_ERROR:
		x.Marshal(x.Sprintf("%sunknownCode", name), XDR_SCUnknownErrorCode(u.UnknownCode()))
		return
	case SST_HOST_VALUE_ERROR:
		x.Marshal(x.Sprintf("%svalCode", name), XDR_SCHostValErrorCode(u.ValCode()))
		return
	case SST_HOST_OBJECT_ERROR:
		x.Marshal(x.Sprintf("%sobjCode", name), XDR_SCHostObjErrorCode(u.ObjCode()))
		return
	case SST_HOST_FUNCTION_ERROR:
		x.Marshal(x.Sprintf("%sfnCode", name), XDR_SCHostFnErrorCode(u.FnCode()))
		return
	case SST_HOST_STORAGE_ERROR:
		x.Marshal(x.Sprintf("%sstorageCode", name), XDR_SCHostStorageErrorCode(u.StorageCode()))
		return
	case SST_HOST_CONTEXT_ERROR:
		x.Marshal(x.Sprintf("%scontextCode", name), XDR_SCHostContextErrorCode(u.ContextCode()))
		return
	case SST_VM_ERROR:
		x.Marshal(x.Sprintf("%svmCode", name), XDR_SCVmErrorCode(u.VmCode()))
		return
	case SST_CONTRACT_ERROR:
		x.Marshal(x.Sprintf("%scontractCode", name), XDR_Uint32(u.ContractCode()))
		return
	}
	XdrPanic("invalid Type (%v) in SCStatus", u.Type)
}
func XDR_SCStatus(v *SCStatus) *SCStatus { return v }

type _XdrPtr_SCObject struct {
	p **SCObject
}
type _ptrflag_SCObject _XdrPtr_SCObject

func (v _ptrflag_SCObject) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SCObject) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("SCObject flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_SCObject) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SCObject) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SCObject)
		}
	default:
		XdrPanic("*SCObject present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_SCObject) XdrTypeName() string             { return "SCObject?" }
func (v _ptrflag_SCObject) XdrPointer() interface{}       { return nil }
func (v _ptrflag_SCObject) XdrValue() interface{}         { return v.GetU32() != 0 }
func (v _ptrflag_SCObject) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_SCObject) XdrBound() uint32              { return 1 }
func (v _XdrPtr_SCObject) GetPresent() bool               { return *v.p != nil }
func (v _XdrPtr_SCObject) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SCObject)
	}
}
func (v _XdrPtr_SCObject) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SCObject(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_SCObject) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_SCObject) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_SCObject(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_SCObject) XdrTypeName() string       { return "SCObject*" }
func (v _XdrPtr_SCObject) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_SCObject) XdrValue() interface{}   { return *v.p }

var _XdrTags_SCVal = map[int32]bool{
	XdrToI32(SCV_U63):    true,
	XdrToI32(SCV_U32):    true,
	XdrToI32(SCV_I32):    true,
	XdrToI32(SCV_STATIC): true,
	XdrToI32(SCV_OBJECT): true,
	XdrToI32(SCV_SYMBOL): true,
	XdrToI32(SCV_BITSET): true,
	XdrToI32(SCV_STATUS): true,
}

func (_ SCVal) XdrValidTags() map[int32]bool {
	return _XdrTags_SCVal
}
func (u *SCVal) U63() *Int64 {
	switch u.Type {
	case SCV_U63:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.U63 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) U32() *Uint32 {
	switch u.Type {
	case SCV_U32:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.U32 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) I32() *Int32 {
	switch u.Type {
	case SCV_I32:
		if v, ok := u._u.(*Int32); ok {
			return v
		} else {
			var zero Int32
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.I32 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Ic() *SCStatic {
	switch u.Type {
	case SCV_STATIC:
		if v, ok := u._u.(*SCStatic); ok {
			return v
		} else {
			var zero SCStatic
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Ic accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Obj() **SCObject {
	switch u.Type {
	case SCV_OBJECT:
		if v, ok := u._u.(**SCObject); ok {
			return v
		} else {
			var zero *SCObject
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Obj accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Sym() *SCSymbol {
	switch u.Type {
	case SCV_SYMBOL:
		if v, ok := u._u.(*SCSymbol); ok {
			return v
		} else {
			var zero SCSymbol
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Sym accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Bits() *Uint64 {
	switch u.Type {
	case SCV_BITSET:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Bits accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCVal) Status() *SCStatus {
	switch u.Type {
	case SCV_STATUS:
		if v, ok := u._u.(*SCStatus); ok {
			return v
		} else {
			var zero SCStatus
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCVal.Status accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCVal) XdrValid() bool {
	switch u.Type {
	case SCV_U63, SCV_U32, SCV_I32, SCV_STATIC, SCV_OBJECT, SCV_SYMBOL, SCV_BITSET, SCV_STATUS:
		return true
	}
	return false
}
func (u *SCVal) XdrUnionTag() XdrNum32 {
	return XDR_SCValType(&u.Type)
}
func (u *SCVal) XdrUnionTagName() string {
	return "Type"
}
func (u *SCVal) XdrUnionBody() XdrType {
	switch u.Type {
	case SCV_U63:
		return XDR_Int64(u.U63())
	case SCV_U32:
		return XDR_Uint32(u.U32())
	case SCV_I32:
		return XDR_Int32(u.I32())
	case SCV_STATIC:
		return XDR_SCStatic(u.Ic())
	case SCV_OBJECT:
		return _XdrPtr_SCObject{u.Obj()}
	case SCV_SYMBOL:
		return XDR_SCSymbol(u.Sym())
	case SCV_BITSET:
		return XDR_Uint64(u.Bits())
	case SCV_STATUS:
		return XDR_SCStatus(u.Status())
	}
	return nil
}
func (u *SCVal) XdrUnionBodyName() string {
	switch u.Type {
	case SCV_U63:
		return "U63"
	case SCV_U32:
		return "U32"
	case SCV_I32:
		return "I32"
	case SCV_STATIC:
		return "Ic"
	case SCV_OBJECT:
		return "Obj"
	case SCV_SYMBOL:
		return "Sym"
	case SCV_BITSET:
		return "Bits"
	case SCV_STATUS:
		return "Status"
	}
	return ""
}

type XdrType_SCVal = *SCVal

func (v *SCVal) XdrPointer() interface{}       { return v }
func (SCVal) XdrTypeName() string              { return "SCVal" }
func (v SCVal) XdrValue() interface{}          { return v }
func (v *SCVal) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCVal) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCValType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SCV_U63:
		x.Marshal(x.Sprintf("%su63", name), XDR_Int64(u.U63()))
		return
	case SCV_U32:
		x.Marshal(x.Sprintf("%su32", name), XDR_Uint32(u.U32()))
		return
	case SCV_I32:
		x.Marshal(x.Sprintf("%si32", name), XDR_Int32(u.I32()))
		return
	case SCV_STATIC:
		x.Marshal(x.Sprintf("%sic", name), XDR_SCStatic(u.Ic()))
		return
	case SCV_OBJECT:
		x.Marshal(x.Sprintf("%sobj", name), _XdrPtr_SCObject{u.Obj()})
		return
	case SCV_SYMBOL:
		x.Marshal(x.Sprintf("%ssym", name), XDR_SCSymbol(u.Sym()))
		return
	case SCV_BITSET:
		x.Marshal(x.Sprintf("%sbits", name), XDR_Uint64(u.Bits()))
		return
	case SCV_STATUS:
		x.Marshal(x.Sprintf("%sstatus", name), XDR_SCStatus(u.Status()))
		return
	}
	XdrPanic("invalid Type (%v) in SCVal", u.Type)
}
func XDR_SCVal(v *SCVal) *SCVal { return v }

var _XdrNames_SCObjectType = map[int32]string{
	int32(SCO_VEC):           "SCO_VEC",
	int32(SCO_MAP):           "SCO_MAP",
	int32(SCO_U64):           "SCO_U64",
	int32(SCO_I64):           "SCO_I64",
	int32(SCO_BYTES):         "SCO_BYTES",
	int32(SCO_BIG_INT):       "SCO_BIG_INT",
	int32(SCO_CONTRACT_CODE): "SCO_CONTRACT_CODE",
	int32(SCO_ACCOUNT_ID):    "SCO_ACCOUNT_ID",
}
var _XdrValues_SCObjectType = map[string]int32{
	"SCO_VEC":           int32(SCO_VEC),
	"SCO_MAP":           int32(SCO_MAP),
	"SCO_U64":           int32(SCO_U64),
	"SCO_I64":           int32(SCO_I64),
	"SCO_BYTES":         int32(SCO_BYTES),
	"SCO_BIG_INT":       int32(SCO_BIG_INT),
	"SCO_CONTRACT_CODE": int32(SCO_CONTRACT_CODE),
	"SCO_ACCOUNT_ID":    int32(SCO_ACCOUNT_ID),
}

func (SCObjectType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCObjectType
}
func (v SCObjectType) String() string {
	if s, ok := _XdrNames_SCObjectType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCObjectType#%d", v)
}
func (v *SCObjectType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCObjectType[stok]; ok {
			*v = SCObjectType(val)
			return nil
		} else if stok == "SCObjectType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCObjectType.", stok))
	}
}
func (v SCObjectType) GetU32() uint32                 { return uint32(v) }
func (v *SCObjectType) SetU32(n uint32)               { *v = SCObjectType(n) }
func (v *SCObjectType) XdrPointer() interface{}       { return v }
func (SCObjectType) XdrTypeName() string              { return "SCObjectType" }
func (v SCObjectType) XdrValue() interface{}          { return v }
func (v *SCObjectType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCObjectType = *SCObjectType

func XDR_SCObjectType(v *SCObjectType) *SCObjectType { return v }

type XdrType_SCMapEntry = *SCMapEntry

func (v *SCMapEntry) XdrPointer() interface{}       { return v }
func (SCMapEntry) XdrTypeName() string              { return "SCMapEntry" }
func (v SCMapEntry) XdrValue() interface{}          { return v }
func (v *SCMapEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SCMapEntry) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XDR_SCVal(&v.Key))
	x.Marshal(x.Sprintf("%sval", name), XDR_SCVal(&v.Val))
}
func XDR_SCMapEntry(v *SCMapEntry) *SCMapEntry { return v }

type _XdrVec_256000_SCVal []SCVal

func (_XdrVec_256000_SCVal) XdrBound() uint32 {
	const bound uint32 = 256000 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_256000_SCVal) XdrCheckLen(length uint32) {
	if length > uint32(256000) {
		XdrPanic("_XdrVec_256000_SCVal length %d exceeds bound 256000", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_256000_SCVal length %d exceeds max int", length)
	}
}
func (v _XdrVec_256000_SCVal) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_256000_SCVal) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(256000); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCVal, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_256000_SCVal) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCVal(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_256000_SCVal) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 256000}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_256000_SCVal) XdrTypeName() string              { return "SCVal<>" }
func (v *_XdrVec_256000_SCVal) XdrPointer() interface{}       { return (*[]SCVal)(v) }
func (v _XdrVec_256000_SCVal) XdrValue() interface{}          { return ([]SCVal)(v) }
func (v *_XdrVec_256000_SCVal) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCVec struct {
	*_XdrVec_256000_SCVal
}

func XDR_SCVec(v *SCVec) XdrType_SCVec {
	return XdrType_SCVec{(*_XdrVec_256000_SCVal)(v)}
}
func (XdrType_SCVec) XdrTypeName() string  { return "SCVec" }
func (v XdrType_SCVec) XdrUnwrap() XdrType { return v._XdrVec_256000_SCVal }

type _XdrVec_256000_SCMapEntry []SCMapEntry

func (_XdrVec_256000_SCMapEntry) XdrBound() uint32 {
	const bound uint32 = 256000 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_256000_SCMapEntry) XdrCheckLen(length uint32) {
	if length > uint32(256000) {
		XdrPanic("_XdrVec_256000_SCMapEntry length %d exceeds bound 256000", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_256000_SCMapEntry length %d exceeds max int", length)
	}
}
func (v _XdrVec_256000_SCMapEntry) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_256000_SCMapEntry) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(256000); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCMapEntry, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_256000_SCMapEntry) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_SCMapEntry(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_256000_SCMapEntry) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 256000}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_256000_SCMapEntry) XdrTypeName() string              { return "SCMapEntry<>" }
func (v *_XdrVec_256000_SCMapEntry) XdrPointer() interface{}       { return (*[]SCMapEntry)(v) }
func (v _XdrVec_256000_SCMapEntry) XdrValue() interface{}          { return ([]SCMapEntry)(v) }
func (v *_XdrVec_256000_SCMapEntry) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCMap struct {
	*_XdrVec_256000_SCMapEntry
}

func XDR_SCMap(v *SCMap) XdrType_SCMap {
	return XdrType_SCMap{(*_XdrVec_256000_SCMapEntry)(v)}
}
func (XdrType_SCMap) XdrTypeName() string  { return "SCMap" }
func (v XdrType_SCMap) XdrUnwrap() XdrType { return v._XdrVec_256000_SCMapEntry }

var _XdrNames_SCNumSign = map[int32]string{
	int32(NEGATIVE): "NEGATIVE",
	int32(ZERO):     "ZERO",
	int32(POSITIVE): "POSITIVE",
}
var _XdrValues_SCNumSign = map[string]int32{
	"NEGATIVE": int32(NEGATIVE),
	"ZERO":     int32(ZERO),
	"POSITIVE": int32(POSITIVE),
}

func (SCNumSign) XdrEnumNames() map[int32]string {
	return _XdrNames_SCNumSign
}
func (v SCNumSign) String() string {
	if s, ok := _XdrNames_SCNumSign[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCNumSign#%d", v)
}
func (v *SCNumSign) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCNumSign[stok]; ok {
			*v = SCNumSign(val)
			return nil
		} else if stok == "SCNumSign" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCNumSign.", stok))
	}
}
func (v SCNumSign) GetU32() uint32                 { return uint32(v) }
func (v *SCNumSign) SetU32(n uint32)               { *v = SCNumSign(n) }
func (v *SCNumSign) XdrPointer() interface{}       { return v }
func (SCNumSign) XdrTypeName() string              { return "SCNumSign" }
func (v SCNumSign) XdrValue() interface{}          { return v }
func (v *SCNumSign) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCNumSign = *SCNumSign

func XDR_SCNumSign(v *SCNumSign) *SCNumSign { return v }

var _XdrTags_SCBigInt = map[int32]bool{
	XdrToI32(ZERO):     true,
	XdrToI32(POSITIVE): true,
	XdrToI32(NEGATIVE): true,
}

func (_ SCBigInt) XdrValidTags() map[int32]bool {
	return _XdrTags_SCBigInt
}
func (u *SCBigInt) Magnitude() *[]byte {
	switch u.Sign {
	case POSITIVE, NEGATIVE:
		if v, ok := u._u.(*[]byte); ok {
			return v
		} else {
			var zero []byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCBigInt.Magnitude accessed when Sign == %v", u.Sign)
		return nil
	}
}
func (u SCBigInt) XdrValid() bool {
	switch u.Sign {
	case ZERO, POSITIVE, NEGATIVE:
		return true
	}
	return false
}
func (u *SCBigInt) XdrUnionTag() XdrNum32 {
	return XDR_SCNumSign(&u.Sign)
}
func (u *SCBigInt) XdrUnionTagName() string {
	return "Sign"
}
func (u *SCBigInt) XdrUnionBody() XdrType {
	switch u.Sign {
	case ZERO:
		return nil
	case POSITIVE, NEGATIVE:
		return XdrVecOpaque{u.Magnitude(), 256000}
	}
	return nil
}
func (u *SCBigInt) XdrUnionBodyName() string {
	switch u.Sign {
	case ZERO:
		return ""
	case POSITIVE, NEGATIVE:
		return "Magnitude"
	}
	return ""
}

type XdrType_SCBigInt = *SCBigInt

func (v *SCBigInt) XdrPointer() interface{}       { return v }
func (SCBigInt) XdrTypeName() string              { return "SCBigInt" }
func (v SCBigInt) XdrValue() interface{}          { return v }
func (v *SCBigInt) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCBigInt) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCNumSign(&u.Sign).XdrMarshal(x, x.Sprintf("%ssign", name))
	switch u.Sign {
	case ZERO:
		return
	case POSITIVE, NEGATIVE:
		x.Marshal(x.Sprintf("%smagnitude", name), XdrVecOpaque{u.Magnitude(), 256000})
		return
	}
	XdrPanic("invalid Sign (%v) in SCBigInt", u.Sign)
}
func XDR_SCBigInt(v *SCBigInt) *SCBigInt { return v }

var _XdrNames_SCContractCodeType = map[int32]string{
	int32(SCCONTRACT_CODE_WASM):  "SCCONTRACT_CODE_WASM",
	int32(SCCONTRACT_CODE_TOKEN): "SCCONTRACT_CODE_TOKEN",
}
var _XdrValues_SCContractCodeType = map[string]int32{
	"SCCONTRACT_CODE_WASM":  int32(SCCONTRACT_CODE_WASM),
	"SCCONTRACT_CODE_TOKEN": int32(SCCONTRACT_CODE_TOKEN),
}

func (SCContractCodeType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCContractCodeType
}
func (v SCContractCodeType) String() string {
	if s, ok := _XdrNames_SCContractCodeType[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("SCContractCodeType#%d", v)
}
func (v *SCContractCodeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCContractCodeType[stok]; ok {
			*v = SCContractCodeType(val)
			return nil
		} else if stok == "SCContractCodeType" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v)); n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCContractCodeType.", stok))
	}
}
func (v SCContractCodeType) GetU32() uint32                 { return uint32(v) }
func (v *SCContractCodeType) SetU32(n uint32)               { *v = SCContractCodeType(n) }
func (v *SCContractCodeType) XdrPointer() interface{}       { return v }
func (SCContractCodeType) XdrTypeName() string              { return "SCContractCodeType" }
func (v SCContractCodeType) XdrValue() interface{}          { return v }
func (v *SCContractCodeType) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_SCContractCodeType = *SCContractCodeType

func XDR_SCContractCodeType(v *SCContractCodeType) *SCContractCodeType { return v }

var _XdrTags_SCContractCode = map[int32]bool{
	XdrToI32(SCCONTRACT_CODE_WASM):  true,
	XdrToI32(SCCONTRACT_CODE_TOKEN): true,
}

func (_ SCContractCode) XdrValidTags() map[int32]bool {
	return _XdrTags_SCContractCode
}
func (u *SCContractCode) Wasm() *[]byte {
	switch u.Type {
	case SCCONTRACT_CODE_WASM:
		if v, ok := u._u.(*[]byte); ok {
			return v
		} else {
			var zero []byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCContractCode.Wasm accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCContractCode) XdrValid() bool {
	switch u.Type {
	case SCCONTRACT_CODE_WASM, SCCONTRACT_CODE_TOKEN:
		return true
	}
	return false
}
func (u *SCContractCode) XdrUnionTag() XdrNum32 {
	return XDR_SCContractCodeType(&u.Type)
}
func (u *SCContractCode) XdrUnionTagName() string {
	return "Type"
}
func (u *SCContractCode) XdrUnionBody() XdrType {
	switch u.Type {
	case SCCONTRACT_CODE_WASM:
		return XdrVecOpaque{u.Wasm(), SCVAL_LIMIT}
	case SCCONTRACT_CODE_TOKEN:
		return nil
	}
	return nil
}
func (u *SCContractCode) XdrUnionBodyName() string {
	switch u.Type {
	case SCCONTRACT_CODE_WASM:
		return "Wasm"
	case SCCONTRACT_CODE_TOKEN:
		return ""
	}
	return ""
}

type XdrType_SCContractCode = *SCContractCode

func (v *SCContractCode) XdrPointer() interface{}       { return v }
func (SCContractCode) XdrTypeName() string              { return "SCContractCode" }
func (v SCContractCode) XdrValue() interface{}          { return v }
func (v *SCContractCode) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCContractCode) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCContractCodeType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SCCONTRACT_CODE_WASM:
		x.Marshal(x.Sprintf("%swasm", name), XdrVecOpaque{u.Wasm(), SCVAL_LIMIT})
		return
	case SCCONTRACT_CODE_TOKEN:
		return
	}
	XdrPanic("invalid Type (%v) in SCContractCode", u.Type)
}
func XDR_SCContractCode(v *SCContractCode) *SCContractCode { return v }

var _XdrTags_SCObject = map[int32]bool{
	XdrToI32(SCO_VEC):           true,
	XdrToI32(SCO_MAP):           true,
	XdrToI32(SCO_U64):           true,
	XdrToI32(SCO_I64):           true,
	XdrToI32(SCO_BYTES):         true,
	XdrToI32(SCO_BIG_INT):       true,
	XdrToI32(SCO_CONTRACT_CODE): true,
	XdrToI32(SCO_ACCOUNT_ID):    true,
}

func (_ SCObject) XdrValidTags() map[int32]bool {
	return _XdrTags_SCObject
}
func (u *SCObject) Vec() *SCVec {
	switch u.Type {
	case SCO_VEC:
		if v, ok := u._u.(*SCVec); ok {
			return v
		} else {
			var zero SCVec
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCObject.Vec accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCObject) Map() *SCMap {
	switch u.Type {
	case SCO_MAP:
		if v, ok := u._u.(*SCMap); ok {
			return v
		} else {
			var zero SCMap
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCObject.Map accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCObject) U64() *Uint64 {
	switch u.Type {
	case SCO_U64:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCObject.U64 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCObject) I64() *Int64 {
	switch u.Type {
	case SCO_I64:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCObject.I64 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCObject) Bin() *[]byte {
	switch u.Type {
	case SCO_BYTES:
		if v, ok := u._u.(*[]byte); ok {
			return v
		} else {
			var zero []byte
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCObject.Bin accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCObject) BigInt() *SCBigInt {
	switch u.Type {
	case SCO_BIG_INT:
		if v, ok := u._u.(*SCBigInt); ok {
			return v
		} else {
			var zero SCBigInt
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCObject.BigInt accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCObject) ContractCode() *SCContractCode {
	switch u.Type {
	case SCO_CONTRACT_CODE:
		if v, ok := u._u.(*SCContractCode); ok {
			return v
		} else {
			var zero SCContractCode
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCObject.ContractCode accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SCObject) AccountID() *AccountID {
	switch u.Type {
	case SCO_ACCOUNT_ID:
		if v, ok := u._u.(*AccountID); ok {
			return v
		} else {
			var zero AccountID
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("SCObject.AccountID accessed when Type == %v", u.Type)
		return nil
	}
}
func (u SCObject) XdrValid() bool {
	switch u.Type {
	case SCO_VEC, SCO_MAP, SCO_U64, SCO_I64, SCO_BYTES, SCO_BIG_INT, SCO_CONTRACT_CODE, SCO_ACCOUNT_ID:
		return true
	}
	return false
}
func (u *SCObject) XdrUnionTag() XdrNum32 {
	return XDR_SCObjectType(&u.Type)
}
func (u *SCObject) XdrUnionTagName() string {
	return "Type"
}
func (u *SCObject) XdrUnionBody() XdrType {
	switch u.Type {
	case SCO_VEC:
		return XDR_SCVec(u.Vec())
	case SCO_MAP:
		return XDR_SCMap(u.Map())
	case SCO_U64:
		return XDR_Uint64(u.U64())
	case SCO_I64:
		return XDR_Int64(u.I64())
	case SCO_BYTES:
		return XdrVecOpaque{u.Bin(), SCVAL_LIMIT}
	case SCO_BIG_INT:
		return XDR_SCBigInt(u.BigInt())
	case SCO_CONTRACT_CODE:
		return XDR_SCContractCode(u.ContractCode())
	case SCO_ACCOUNT_ID:
		return XDR_AccountID(u.AccountID())
	}
	return nil
}
func (u *SCObject) XdrUnionBodyName() string {
	switch u.Type {
	case SCO_VEC:
		return "Vec"
	case SCO_MAP:
		return "Map"
	case SCO_U64:
		return "U64"
	case SCO_I64:
		return "I64"
	case SCO_BYTES:
		return "Bin"
	case SCO_BIG_INT:
		return "BigInt"
	case SCO_CONTRACT_CODE:
		return "ContractCode"
	case SCO_ACCOUNT_ID:
		return "AccountID"
	}
	return ""
}

type XdrType_SCObject = *SCObject

func (v *SCObject) XdrPointer() interface{}       { return v }
func (SCObject) XdrTypeName() string              { return "SCObject" }
func (v SCObject) XdrValue() interface{}          { return v }
func (v *SCObject) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SCObject) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCObjectType(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case SCO_VEC:
		x.Marshal(x.Sprintf("%svec", name), XDR_SCVec(u.Vec()))
		return
	case SCO_MAP:
		x.Marshal(x.Sprintf("%smap", name), XDR_SCMap(u.Map()))
		return
	case SCO_U64:
		x.Marshal(x.Sprintf("%su64", name), XDR_Uint64(u.U64()))
		return
	case SCO_I64:
		x.Marshal(x.Sprintf("%si64", name), XDR_Int64(u.I64()))
		return
	case SCO_BYTES:
		x.Marshal(x.Sprintf("%sbin", name), XdrVecOpaque{u.Bin(), SCVAL_LIMIT})
		return
	case SCO_BIG_INT:
		x.Marshal(x.Sprintf("%sbigInt", name), XDR_SCBigInt(u.BigInt()))
		return
	case SCO_CONTRACT_CODE:
		x.Marshal(x.Sprintf("%scontractCode", name), XDR_SCContractCode(u.ContractCode()))
		return
	case SCO_ACCOUNT_ID:
		x.Marshal(x.Sprintf("%saccountID", name), XDR_AccountID(u.AccountID()))
		return
	}
	XdrPanic("invalid Type (%v) in SCObject", u.Type)
}
func XDR_SCObject(v *SCObject) *SCObject { return v }

var _XdrTags_StoredTransactionSet = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ StoredTransactionSet) XdrValidTags() map[int32]bool {
	return _XdrTags_StoredTransactionSet
}
func (u *StoredTransactionSet) TxSet() *TransactionSet {
	switch u.V {
	case 0:
		if v, ok := u._u.(*TransactionSet); ok {
			return v
		} else {
			var zero TransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StoredTransactionSet.TxSet accessed when V == %v", u.V)
		return nil
	}
}
func (u *StoredTransactionSet) GeneralizedTxSet() *GeneralizedTransactionSet {
	switch u.V {
	case 1:
		if v, ok := u._u.(*GeneralizedTransactionSet); ok {
			return v
		} else {
			var zero GeneralizedTransactionSet
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("StoredTransactionSet.GeneralizedTxSet accessed when V == %v", u.V)
		return nil
	}
}
func (u StoredTransactionSet) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *StoredTransactionSet) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *StoredTransactionSet) XdrUnionTagName() string {
	return "V"
}
func (u *StoredTransactionSet) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_TransactionSet(u.TxSet())
	case 1:
		return XDR_GeneralizedTransactionSet(u.GeneralizedTxSet())
	}
	return nil
}
func (u *StoredTransactionSet) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "TxSet"
	case 1:
		return "GeneralizedTxSet"
	}
	return ""
}

type XdrType_StoredTransactionSet = *StoredTransactionSet

func (v *StoredTransactionSet) XdrPointer() interface{}       { return v }
func (StoredTransactionSet) XdrTypeName() string              { return "StoredTransactionSet" }
func (v StoredTransactionSet) XdrValue() interface{}          { return v }
func (v *StoredTransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *StoredTransactionSet) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%stxSet", name), XDR_TransactionSet(u.TxSet()))
		return
	case 1:
		x.Marshal(x.Sprintf("%sgeneralizedTxSet", name), XDR_GeneralizedTransactionSet(u.GeneralizedTxSet()))
		return
	}
	XdrPanic("invalid V (%v) in StoredTransactionSet", u.V)
}
func XDR_StoredTransactionSet(v *StoredTransactionSet) *StoredTransactionSet { return v }

type _XdrVec_unbounded_StoredTransactionSet []StoredTransactionSet

func (_XdrVec_unbounded_StoredTransactionSet) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_StoredTransactionSet) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_StoredTransactionSet length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_StoredTransactionSet length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_StoredTransactionSet) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_StoredTransactionSet) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2 * cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]StoredTransactionSet, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_StoredTransactionSet) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if i >= len(*v) {
			v.SetVecLen(uint32(i + 1))
		}
		XDR_StoredTransactionSet(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_StoredTransactionSet) XdrRecurse(x XDR, name string) {
	size := XdrSize{Size: uint32(len(*v)), Bound: 4294967295}
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_StoredTransactionSet) XdrTypeName() string { return "StoredTransactionSet<>" }
func (v *_XdrVec_unbounded_StoredTransactionSet) XdrPointer() interface{} {
	return (*[]StoredTransactionSet)(v)
}
func (v _XdrVec_unbounded_StoredTransactionSet) XdrValue() interface{} {
	return ([]StoredTransactionSet)(v)
}
func (v *_XdrVec_unbounded_StoredTransactionSet) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

type XdrType_PersistedSCPStateV0 = *PersistedSCPStateV0

func (v *PersistedSCPStateV0) XdrPointer() interface{}       { return v }
func (PersistedSCPStateV0) XdrTypeName() string              { return "PersistedSCPStateV0" }
func (v PersistedSCPStateV0) XdrValue() interface{}          { return v }
func (v *PersistedSCPStateV0) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PersistedSCPStateV0) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sscpEnvelopes", name), (*_XdrVec_unbounded_SCPEnvelope)(&v.ScpEnvelopes))
	x.Marshal(x.Sprintf("%squorumSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.QuorumSets))
	x.Marshal(x.Sprintf("%stxSets", name), (*_XdrVec_unbounded_StoredTransactionSet)(&v.TxSets))
}
func XDR_PersistedSCPStateV0(v *PersistedSCPStateV0) *PersistedSCPStateV0 { return v }

type XdrType_PersistedSCPStateV1 = *PersistedSCPStateV1

func (v *PersistedSCPStateV1) XdrPointer() interface{}       { return v }
func (PersistedSCPStateV1) XdrTypeName() string              { return "PersistedSCPStateV1" }
func (v PersistedSCPStateV1) XdrValue() interface{}          { return v }
func (v *PersistedSCPStateV1) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PersistedSCPStateV1) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sscpEnvelopes", name), (*_XdrVec_unbounded_SCPEnvelope)(&v.ScpEnvelopes))
	x.Marshal(x.Sprintf("%squorumSets", name), (*_XdrVec_unbounded_SCPQuorumSet)(&v.QuorumSets))
}
func XDR_PersistedSCPStateV1(v *PersistedSCPStateV1) *PersistedSCPStateV1 { return v }

var _XdrTags_PersistedSCPState = map[int32]bool{
	XdrToI32(0): true,
	XdrToI32(1): true,
}

func (_ PersistedSCPState) XdrValidTags() map[int32]bool {
	return _XdrTags_PersistedSCPState
}
func (u *PersistedSCPState) V0() *PersistedSCPStateV0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*PersistedSCPStateV0); ok {
			return v
		} else {
			var zero PersistedSCPStateV0
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PersistedSCPState.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u *PersistedSCPState) V1() *PersistedSCPStateV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*PersistedSCPStateV1); ok {
			return v
		} else {
			var zero PersistedSCPStateV1
			u._u = &zero
			return &zero
		}
	default:
		XdrPanic("PersistedSCPState.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u PersistedSCPState) XdrValid() bool {
	switch u.V {
	case 0, 1:
		return true
	}
	return false
}
func (u *PersistedSCPState) XdrUnionTag() XdrNum32 {
	return XDR_int32(&u.V)
}
func (u *PersistedSCPState) XdrUnionTagName() string {
	return "V"
}
func (u *PersistedSCPState) XdrUnionBody() XdrType {
	switch u.V {
	case 0:
		return XDR_PersistedSCPStateV0(u.V0())
	case 1:
		return XDR_PersistedSCPStateV1(u.V1())
	}
	return nil
}
func (u *PersistedSCPState) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	case 1:
		return "V1"
	}
	return ""
}

type XdrType_PersistedSCPState = *PersistedSCPState

func (v *PersistedSCPState) XdrPointer() interface{}       { return v }
func (PersistedSCPState) XdrTypeName() string              { return "PersistedSCPState" }
func (v PersistedSCPState) XdrValue() interface{}          { return v }
func (v *PersistedSCPState) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *PersistedSCPState) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(&u.V).XdrMarshal(x, x.Sprintf("%sv", name))
	switch u.V {
	case 0:
		x.Marshal(x.Sprintf("%sv0", name), XDR_PersistedSCPStateV0(u.V0()))
		return
	case 1:
		x.Marshal(x.Sprintf("%sv1", name), XDR_PersistedSCPStateV1(u.V1()))
		return
	}
	XdrPanic("invalid V (%v) in PersistedSCPState", u.V)
}
func XDR_PersistedSCPState(v *PersistedSCPState) *PersistedSCPState { return v }
