//lint:file-ignore U1001 Ignore all unused code, staticcheck doesn't understand testify/suite

package ingest

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/stellar/go/ingest"
	"github.com/stellar/go/ingest/ledgerbackend"
	"github.com/stellar/go/services/horizon/internal/test"
	"github.com/stellar/go/xdr"
)

type memoryChangeReader struct {
	changes        xdr.LedgerEntryChanges
	bucketListHash xdr.Hash
	verified       bool
}

func loadChanges(bucketListHash xdr.Hash, path string) (*memoryChangeReader, error) {
	contents, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	entryChanges := xdr.LedgerEntryChanges{}
	if err := entryChanges.UnmarshalBinary(contents); err != nil {
		return nil, err
	}

	return &memoryChangeReader{
		changes:        entryChanges,
		bucketListHash: bucketListHash,
	}, nil
}

func (r *memoryChangeReader) Read() (ingest.Change, error) {
	if len(r.changes) == 0 {
		return ingest.Change{}, io.EOF
	}

	change := r.changes[0]
	r.changes = r.changes[1:]
	return ingest.Change{
		Type: change.State.Data.Type,
		Post: change.State,
		Pre:  nil,
	}, nil
}

func (r *memoryChangeReader) VerifyBucketList(expectedHash xdr.Hash) error {
	if !bytes.Equal(r.bucketListHash[:], expectedHash[:]) {
		return fmt.Errorf(
			"bucket list hash of history archive does not match expected hash: %#x %#x",
			r.bucketListHash,
			expectedHash,
		)
	}
	r.verified = true
	return nil
}

func (r *memoryChangeReader) Close() error {
	return nil
}

func TestDBTestSuite(t *testing.T) {
	suite.Run(t, new(DBTestSuite))
}

type DBTestSuite struct {
	suite.Suite
	ctx            context.Context
	sampleFile     string
	sequence       uint32
	checkpointHash xdr.Hash
	ledgerBackend  *ledgerbackend.MockDatabaseBackend
	historyAdapter *mockHistoryArchiveAdapter
	system         *system
	tt             *test.T
}

func (s *DBTestSuite) SetupTest() {
	s.tt = test.Start(s.T())
	test.ResetHorizonDB(s.T(), s.tt.HorizonDB)

	// sample-changes.xdr is generated by sample_changes_test.go and is checked into
	// the testdata directory. To regenerate the file run:
	// go test -v -timeout 5m --tags=update  github.com/stellar/go/services/horizon/internal/ingest -run "^(TestUpdateSampleChanges)$"
	// and commit the new file to the git repo.
	s.sampleFile = filepath.Join("testdata", "sample-changes.xdr")
	s.checkpointHash = xdr.Hash{1, 2, 3}
	s.ledgerBackend = &ledgerbackend.MockDatabaseBackend{}
	s.historyAdapter = &mockHistoryArchiveAdapter{}

	var err error
	sIface, err := NewSystem(Config{
		HistorySession:           s.tt.HorizonSession(),
		HistoryArchiveURLs:       []string{"http://ignore.test"},
		DisableStateVerification: false,
		CheckpointFrequency:      64,
		CoreProtocolVersionFn:    func(string) (uint, error) { return 21, nil },
	})
	s.Assert().NoError(err)
	s.system = sIface.(*system)
	s.ctx = s.system.ctx

	s.sequence = uint32(28660351)
	s.setupMocksForBuildState()

	s.system.historyAdapter = s.historyAdapter
	s.system.ledgerBackend = s.ledgerBackend
	s.system.runner.SetHistoryAdapter(s.historyAdapter)
}

func (s *DBTestSuite) mockChangeReader() {
	changeReader, err := loadChanges(s.checkpointHash, s.sampleFile)
	s.Assert().NoError(err)
	s.T().Cleanup(func() {
		s.tt.Assert.True(changeReader.verified)
	})
	s.historyAdapter.On("GetState", s.ctx, s.sequence).
		Return(ingest.ChangeReader(changeReader), nil).Once()
}
func (s *DBTestSuite) setupMocksForBuildState() {
	s.historyAdapter.On("GetLatestLedgerSequence").
		Return(s.sequence, nil).Once()
	s.mockChangeReader()

	s.ledgerBackend.On("IsPrepared", s.ctx, ledgerbackend.UnboundedRange(s.sequence)).Return(true, nil).Once()
	s.ledgerBackend.On("GetLedger", s.ctx, s.sequence).
		Return(
			xdr.LedgerCloseMeta{
				V0: &xdr.LedgerCloseMetaV0{
					LedgerHeader: xdr.LedgerHeaderHistoryEntry{
						Header: xdr.LedgerHeader{
							LedgerSeq:      xdr.Uint32(s.sequence),
							BucketListHash: s.checkpointHash,
						},
					},
				},
			},
			nil,
		).Once()
}

func (s *DBTestSuite) TearDownTest() {
	t := s.T()
	s.historyAdapter.AssertExpectations(t)
	s.ledgerBackend.AssertExpectations(t)
	s.tt.Finish()
}

func (s *DBTestSuite) TestBuildState() {
	next, err := startState{}.run(s.system)
	s.Assert().NoError(err)
	build := next.node.(buildState)
	s.Assert().Equal(s.sequence, build.checkpointLedger)

	next, err = build.run(s.system)
	s.Assert().NoError(err)
	resume := next.node.(resumeState)
	s.Assert().Equal(s.sequence, resume.latestSuccessfullyProcessedLedger)

	s.mockChangeReader()
	s.Assert().NoError(s.system.verifyState(false, s.sequence, s.checkpointHash))
}

func (s *DBTestSuite) TestVersionMismatchTriggersRebuild() {
	s.TestBuildState()

	s.Assert().NoError(
		s.system.historyQ.UpdateIngestVersion(context.Background(), CurrentVersion-1),
	)

	s.setupMocksForBuildState()
	s.TestBuildState()
}
