package integration

import (
	"context"
	"encoding"
	"io"
	"math"
	"math/rand"
	"os"
	"sync"
	"testing"
	"time"

	"github.com/spf13/viper"

	"github.com/klauspost/compress/zstd"
	"github.com/stretchr/testify/require"

	"github.com/stellar/go/amount"
	"github.com/stellar/go/clients/horizonclient"
	"github.com/stellar/go/clients/stellarcore"
	"github.com/stellar/go/ingest"
	"github.com/stellar/go/ingest/ledgerbackend"
	"github.com/stellar/go/ingest/loadtest"
	"github.com/stellar/go/keypair"
	proto "github.com/stellar/go/protocols/stellarcore"
	internalingest "github.com/stellar/go/services/horizon/internal/ingest"
	"github.com/stellar/go/services/horizon/internal/test/integration"
	supportlog "github.com/stellar/go/support/log"
	"github.com/stellar/go/txnbuild"
	"github.com/stellar/go/xdr"
)

const loadTestNetworkPassphrase = "load test network"

type sorobanTransaction struct {
	op             *txnbuild.InvokeHostFunction
	signer         *keypair.Full
	sequenceNumber int64
}

// TestGenerateLedgers generates a sequence of ledgers for load testing and can optionally
// write the produced ledgers to a compressed XDR file. The ledgers will be generated by default
// at horizon's maximum supported protocol version as defined in 'MaxSupportedProtocolVersion'.
//
// Required env vars:
//   - HORIZON_INTEGRATION_TESTS_ENABLED=true
//     These should be all resolve to same stellar-core version
//   - HORIZON_INTEGRATION_TESTS_CAPTIVE_CORE_BIN=/usr/local/bin/stellar-core
//   - HORIZON_INTEGRATION_TESTS_DOCKER_IMG=stellar/unsafe-stellar-core:23.0.0-2634.d5cbc0793.focal
//   - HORIZON_INTEGRATION_TESTS_STELLAR_RPC_DOCKER_IMG=stellar/stellar-rpc:23.0.1-132
//
// Optional env vars:
//   - LOADTEST_TRANSACTIONS_PER_LEDGER (default 100)
//   - LOADTEST_TRANSFERS_PER_TX (default 10)
//   - LOADTEST_LEDGERS (default 2)
//   - LOADTEST_NETWORK_PASSPHRASE (default "load test network")
//   - LOADTEST_OUTPUT_PATH (default empty) - set to the destination path on local o/s (will be created/overwritten).
//     default is empty string, which means no output file will be written.
//   - HORIZON_INTEGRATION_TESTS_CORE_MAX_SUPPORTED_PROTOCOL - explicitly set protocol version for generated ledgers
//
// Example command to run the test and write output file (adjust values as needed):
// LOADTEST_OUTPUT_PATH=/full/path/my-load-test-ledgers-xdr.zstd \
// LOADTEST_NETWORK_PASSPHRASE="Standalone Network ; February 2017" \
// HORIZON_INTEGRATION_TESTS_ENABLED=true \
// HORIZON_INTEGRATION_TESTS_CAPTIVE_CORE_BIN=/usr/local/bin/stellar-core \
// HORIZON_INTEGRATION_TESTS_DOCKER_IMG=stellar/unsafe-stellar-core:23.0.0-2634.d5cbc0793.focal \
// HORIZON_INTEGRATION_TESTS_STELLAR_RPC_DOCKER_IMG=stellar/stellar-rpc:23.0.1-132 \
// go test -v ./services/horizon/internal/integration -run TestGenerateLedgers -count=1 -timeout=30m
func TestGenerateLedgers(t *testing.T) {
	envMaxSupportedProtocol := integration.GetCoreMaxSupportedProtocol()
	// if HORIZON_INTEGRATION_TESTS_CORE_MAX_SUPPORTED_PROTOCOL not set for a specific protocol
	// means this is zero and test will assume the protocol version based on horizon ingestion 'MaxSupportedProtocolVersion'
	if envMaxSupportedProtocol > 0 && envMaxSupportedProtocol < internalingest.MaxSupportedProtocolVersion {
		t.Skipf("This test run does not support less than Protocol %d", internalingest.MaxSupportedProtocolVersion)
	}

	var transactionsPerLedger, ledgers, transfersPerTx int
	var networkPassphrase, outputPath string

	// Read testing parameters from environment variables with defaults using viper
	viper.BindEnv("transactions_per_ledger", "LOADTEST_TRANSACTIONS_PER_LEDGER")
	viper.SetDefault("transactions_per_ledger", 100)
	transactionsPerLedger = viper.GetInt("transactions_per_ledger")

	viper.BindEnv("transfers_per_tx", "LOADTEST_TRANSFERS_PER_TX")
	viper.SetDefault("transfers_per_tx", 10)
	transfersPerTx = viper.GetInt("transfers_per_tx")

	viper.BindEnv("ledgers", "LOADTEST_LEDGERS")
	viper.SetDefault("ledgers", 2)
	ledgers = viper.GetInt("ledgers")

	viper.BindEnv("network_passphrase", "LOADTEST_NETWORK_PASSPHRASE")
	viper.SetDefault("network_passphrase", loadTestNetworkPassphrase)
	networkPassphrase = viper.GetString("network_passphrase")

	viper.BindEnv("output_path", "LOADTEST_OUTPUT_PATH")
	viper.SetDefault("output_path", "")

	outputPath = viper.GetString("output_path")

	itest := integration.NewTest(t, integration.Config{
		EnableStellarRPC:  true,
		NetworkPassphrase: networkPassphrase,
		HorizonEnvironment: map[string]string{
			"LOG_LEVEL": "error",
		},
	})
	supportlog.SetLevel(supportlog.ErrorLevel)

	if outputPath != "" {
		t.Log("ledger file will be written to ", outputPath)
	}

	maxAccountsPerTransaction := 100
	// transactionsPerLedger should be a multiple of maxAccountsPerTransaction
	require.Zero(t, transactionsPerLedger%maxAccountsPerTransaction)

	xlm := xdr.MustNewNativeAsset()
	createSAC(itest, xlm)

	bulkContractID, _ := mustCreateAndInstallContract(
		itest,
		itest.Master(),
		"a1",
		"soroban_bulk.wasm",
	)

	var signers []*keypair.Full
	var accounts []txnbuild.Account
	var accountLedgers []uint32
	for i := 0; i < 2*transactionsPerLedger; i += maxAccountsPerTransaction {
		keys, curAccounts := itest.CreateAccounts(maxAccountsPerTransaction, "10000000")
		account, err := itest.Client().AccountDetail(horizonclient.AccountRequest{AccountID: curAccounts[0].GetAccountID()})
		require.NoError(t, err)
		accountLedgers = append(accountLedgers, account.LastModifiedLedger)

		signers = append(signers, keys...)
		accounts = append(accounts, curAccounts...)
	}
	recipients := signers[transactionsPerLedger:]
	signers = signers[:transactionsPerLedger]
	accounts = accounts[:transactionsPerLedger]
	var transactions []sorobanTransaction
	var bulkAmounts xdr.ScVec
	for i := 0; i < transfersPerTx; i++ {
		bulkAmounts = append(bulkAmounts, i128Param(0, uint64(amount.MustParse("1"))))
	}

	for i := range signers {
		var op *txnbuild.InvokeHostFunction
		sender := accounts[i].GetAccountID()

		var bulkRecipients xdr.ScVec
		if i%2 == 0 {
			for j := i; j < i+transfersPerTx; j++ {
				recipient := accountAddressParam(recipients[j%len(recipients)].Address())
				bulkRecipients = append(bulkRecipients, recipient)
			}
		} else if i%2 == 1 {
			for j := 0; j < transfersPerTx; j++ {
				var contractID xdr.ContractId
				_, err := rand.Read(contractID[:])
				require.NoError(t, err)
				bulkRecipients = append(bulkRecipients, contractAddressParam(contractID))
			}
		}

		op = bulkTransfer(itest, bulkContractID, sender, xlm, &bulkRecipients, &bulkAmounts)
		preFlightOp := itest.PreflightHostFunctions(accounts[i], *op)
		preFlightOp.Ext.SorobanData.Resources.DiskReadBytes *= 10
		preFlightOp.Ext.SorobanData.Resources.WriteBytes *= 10
		preFlightOp.Ext.SorobanData.Resources.Instructions *= 10
		preFlightOp.Ext.SorobanData.ResourceFee *= 10
		sequenceNumber, err := accounts[i].GetSequenceNumber()
		require.NoError(t, err)
		transactions = append(transactions, sorobanTransaction{
			op:             &preFlightOp,
			signer:         signers[i],
			sequenceNumber: sequenceNumber,
		})
	}

	// wait until we have one empty ledger before we start generating load
	require.Eventually(t, func() bool {
		root, err := itest.Client().Root()
		if err != nil {
			return false
		}
		return uint32(root.HorizonSequence) > accountLedgers[len(accountLedgers)-1]+1
	}, time.Second*20, time.Second)

	lock := &sync.Mutex{}
	ledgerMap := map[int32]int{}
	wg := &sync.WaitGroup{}
	transactionsPerWorker := 100
	// transactions should be a multiple of transactionsPerWorker
	require.Zero(t, len(transactions)%transactionsPerWorker)
	for repetitions := 0; repetitions < ledgers; repetitions++ {
		for i := 0; i < len(transactions); i += transactionsPerWorker {
			subset := transactions[i : i+transactionsPerWorker]
			wg.Add(1)
			go func() {
				defer wg.Done()
				txSubWorker(
					itest,
					subset,
					itest.Client(),
					itest.CoreClient(),
					lock,
					ledgerMap,
					int64(repetitions),
				)
			}()
		}
		wg.Wait()
	}
	itest.StopHorizon()

	start, end := int32(-1), int32(-1)
	for ledgerSeq := range ledgerMap {
		if start < 0 || start > ledgerSeq {
			start = ledgerSeq
		}
		if end < 0 || ledgerSeq > end {
			end = ledgerSeq
		}
	}
	if start <= 2 {
		t.Fatalf("expected there to be an empty ledger preceding the load generated ledgers: %v", start)
	}
	start--
	t.Logf("waiting for ledgers [%v, %v] to be in history archive", start, end)
	itest.WaitForLedgerInArchive(6*time.Minute, uint32(end))

	ledgersForAccounts := getLedgers(itest, accountLedgers[0], accountLedgers[len(accountLedgers)-1])
	var accountLedgerEntries []xdr.LedgerEntry
	for _, seq := range accountLedgers {
		for _, change := range extractChanges(
			t, itest.Config().NetworkPassphrase, []xdr.LedgerCloseMeta{ledgersForAccounts[seq]},
		) {
			if change.Type == xdr.LedgerEntryTypeAccount && change.Post != nil && change.Pre == nil {
				accountLedgerEntries = append(accountLedgerEntries, *change.Post)
			}
		}
	}
	require.Len(t, accountLedgerEntries, 2*transactionsPerLedger)
	merge(itest, accountLedgerEntries, outputPath, uint32(start), uint32(end), transactionsPerLedger)
}

func readFile[T xdr.DecoderFrom](t *testing.T, path string, constructor func() T, consume func(T)) {
	file, err := os.Open(path)
	require.NoError(t, err)
	stream, err := xdr.NewZstdStream(file)
	require.NoError(t, err)
	for {
		entry := constructor()
		if err = stream.ReadOne(entry); err == io.EOF {
			break
		}
		require.NoError(t, err)
		consume(entry)
	}
	require.NoError(t, stream.Close())
}

func bulkTransfer(
	itest *integration.Test,
	bulkContractID xdr.ContractId,
	sender string,
	asset xdr.Asset,
	recipients *xdr.ScVec,
	amounts *xdr.ScVec,
) *txnbuild.InvokeHostFunction {
	return &txnbuild.InvokeHostFunction{
		HostFunction: xdr.HostFunction{
			Type: xdr.HostFunctionTypeHostFunctionTypeInvokeContract,
			InvokeContract: &xdr.InvokeContractArgs{
				ContractAddress: contractIDParam(bulkContractID),
				FunctionName:    "bulk_transfer",
				Args: xdr.ScVec{
					accountAddressParam(sender),
					contractAddressParam(stellarAssetContractID(itest, asset)),
					xdr.ScVal{Type: xdr.ScValTypeScvVec, Vec: &recipients},
					xdr.ScVal{Type: xdr.ScValTypeScvVec, Vec: &amounts},
				},
			},
		},
		SourceAccount: sender,
	}
}

func extractChanges(t *testing.T, networkPassphrase string, ledgers []xdr.LedgerCloseMeta) []ingest.Change {
	var changes []ingest.Change
	for _, ledger := range ledgers {
		reader, err := ingest.NewLedgerChangeReaderFromLedgerCloseMeta(networkPassphrase, ledger)
		require.NoError(t, err)
		for {
			var change ingest.Change
			change, err = reader.Read()
			if err == io.EOF {
				break
			}
			require.NoError(t, err)
			changes = append(changes, change)
		}
	}
	return changes
}

func extractTransactions(t *testing.T, networkPassphrase string, ledgers []xdr.LedgerCloseMeta) []ingest.LedgerTransaction {
	var transactions []ingest.LedgerTransaction
	for _, ledger := range ledgers {
		txReader, err := ingest.NewLedgerTransactionReaderFromLedgerCloseMeta(networkPassphrase, ledger)
		require.NoError(t, err)
		for {
			var tx ingest.LedgerTransaction
			tx, err = txReader.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}
			transactions = append(transactions, tx)
		}
	}
	return transactions
}

func groupChangesByLedgerKey(t *testing.T, changes []ingest.Change) map[string][]ingest.Change {
	byLedgerKey := map[string][]ingest.Change{}
	for _, change := range changes {
		key, err := change.LedgerKey()
		require.NoError(t, err)
		keyB64, err := key.MarshalBinaryBase64()
		require.NoError(t, err)
		byLedgerKey[keyB64] = append(byLedgerKey[keyB64], change)
	}
	return byLedgerKey
}

func requireChangesAreEqual(t *testing.T, a, b []ingest.Change) {
	aByLedgerKey := groupChangesByLedgerKey(t, a)
	bByLedgerKey := groupChangesByLedgerKey(t, b)

	require.Equal(t, len(aByLedgerKey), len(bByLedgerKey))
	for key, aChanges := range aByLedgerKey {
		bChanges := bByLedgerKey[key]
		require.Equal(t, len(aChanges), len(bChanges))
		for i, aChange := range aChanges {
			bChange := bChanges[i]
			require.Equal(t, aChange.Reason, bChange.Reason)
			require.Equal(t, aChange.Type, bChange.Type)
			if aChange.Pre == nil {
				require.Nil(t, bChange.Pre)
			} else {
				require.NoError(t, loadtest.UpdateLedgerSeqInLedgerEntries(aChange.Pre, func(u uint32) uint32 {
					return 0
				}))
				require.NoError(t, loadtest.UpdateLedgerSeqInLedgerEntries(bChange.Pre, func(u uint32) uint32 {
					return 0
				}))
				requireXDREquals(t, aChange.Pre, bChange.Pre)
			}
			if aChange.Post == nil {
				require.Nil(t, bChange.Post)
			} else {
				require.NoError(t, loadtest.UpdateLedgerSeqInLedgerEntries(aChange.Post, func(u uint32) uint32 {
					return 0
				}))
				require.NoError(t, loadtest.UpdateLedgerSeqInLedgerEntries(bChange.Post, func(u uint32) uint32 {
					return 0
				}))
				requireXDREquals(t, aChange.Post, bChange.Post)
			}
		}
	}
}

func requireTransactionsMatch(t *testing.T, a, b ingest.LedgerTransaction) {
	requireXDREquals(t, a.Hash, b.Hash)
	require.NoError(t, loadtest.UpdateLedgerSeqInLedgerEntries(&a.UnsafeMeta, func(u uint32) uint32 {
		return 0
	}))
	require.NoError(t, loadtest.UpdateLedgerSeqInLedgerEntries(&b.UnsafeMeta, func(u uint32) uint32 {
		return 0
	}))
	requireXDREquals(t, a.UnsafeMeta, b.UnsafeMeta)
	requireXDREquals(t, a.Result, b.Result)
	requireXDREquals(t, a.Envelope, b.Envelope)
	require.Equal(t, len(a.FeeChanges), len(b.FeeChanges))
	for i := range a.FeeChanges {
		aChange, bChange := a.FeeChanges[i], b.FeeChanges[i]
		require.NoError(t, loadtest.UpdateLedgerSeqInLedgerEntries(&aChange, func(u uint32) uint32 {
			return 0
		}))
		require.NoError(t, loadtest.UpdateLedgerSeqInLedgerEntries(&bChange, func(u uint32) uint32 {
			return 0
		}))
		requireXDREquals(t, aChange, bChange)
	}
	require.Equal(t, a.LedgerVersion, b.LedgerVersion)
}

func requireXDREquals(t *testing.T, a, b encoding.BinaryMarshaler) {
	ok, err := xdr.Equals(a, b)
	require.NoError(t, err)
	require.True(t, ok)
}

func txSubWorker(
	itest *integration.Test,
	subset []sorobanTransaction,
	horizonClient *horizonclient.Client,
	coreClient *stellarcore.Client,
	ledgerLock *sync.Mutex,
	ledgerMap map[int32]int,
	sequenceOffset int64,
) {
	var total time.Duration
	pending := map[string]bool{}
	for _, tx := range subset {
		account := txnbuild.NewSimpleAccount(tx.signer.Address(), tx.sequenceNumber+sequenceOffset)
		tx, err := itest.CreateSignedTransactionFromOps(&account, []*keypair.Full{tx.signer}, tx.op)
		require.NoError(itest.CurrentTest(), err)

		hash, err := tx.HashHex(itest.Config().NetworkPassphrase)
		require.NoError(itest.CurrentTest(), err)
		b64Tx, err := tx.Base64()
		require.NoError(itest.CurrentTest(), err)
		start := time.Now()
		resp, err := coreClient.SubmitTransaction(context.Background(), b64Tx)
		elapsed := time.Since(start)
		require.NoError(itest.CurrentTest(), err)
		require.Empty(itest.CurrentTest(), resp.Exception)
		require.False(itest.CurrentTest(), resp.IsException())
		require.Equal(itest.CurrentTest(), proto.TXStatusPending, resp.Status)
		pending[hash] = true
		total += elapsed
	}
	avg := total / time.Duration(len(subset))
	itest.CurrentTest().Logf("avg %v total %v", avg, total)

	start := time.Now()
	waitForTransactions(itest.CurrentTest(), horizonClient, pending, ledgerLock, ledgerMap)
	itest.CurrentTest().Logf("wait duration %v", time.Since(start))

}

func waitForTransactions(
	t *testing.T,
	client *horizonclient.Client,
	pending map[string]bool,
	ledgerLock *sync.Mutex,
	ledgerMap map[int32]int,
) {
	require.Eventually(t, func() bool {
		for hash := range pending {
			resp, err := client.TransactionDetail(hash)
			if err == nil {
				delete(pending, hash)
				require.True(t, resp.Successful)
				ledgerLock.Lock()
				ledgerMap[resp.Ledger]++
				ledgerLock.Unlock()
				continue
			}
			if horizonclient.IsNotFoundError(err) {
				continue
			} else {
				require.NoError(t, err)
			}
		}
		return len(pending) == 0
	}, time.Second*90, time.Millisecond*100)
}

func merge(itest *integration.Test, accountEntries []xdr.LedgerEntry, outputPath string, start, end uint32, transactionsPerLedger int) {
	ccConfig, err := itest.CreateCaptiveCoreConfig()
	require.NoError(itest.CurrentTest(), err)

	captiveCore, err := ledgerbackend.NewCaptive(ccConfig)
	require.NoError(itest.CurrentTest(), err)

	ctx := context.Background()
	require.NoError(
		itest.CurrentTest(),
		captiveCore.PrepareRange(ctx, ledgerbackend.BoundedRange(start, end)),
	)

	var writer *zstd.Encoder
	if outputPath != "" {
		file, err := os.Create(outputPath)
		require.NoError(itest.CurrentTest(), err)
		writer, err = zstd.NewWriter(file)
		require.NoError(itest.CurrentTest(), err)
		defer func() {
			require.NoError(itest.CurrentTest(), writer.Close())
			require.NoError(itest.CurrentTest(), file.Close())
		}()
	}

	accountSet := map[string]bool{}
	for _, entry := range accountEntries {
		accountSet[entry.Data.MustAccount().AccountId.Address()] = true
	}

	var merged xdr.LedgerCloseMeta
	var curBatch []xdr.LedgerCloseMeta
	var curCount int
	for ledgerSeq := start; ledgerSeq <= end; ledgerSeq++ {
		ledger, err := captiveCore.GetLedger(ctx, ledgerSeq)
		require.NoError(itest.CurrentTest(), err)

		if ledgerSeq == start {
			// the first ledger is a special case where we attach all the
			// ledger entry fixtures involved in the generated ledgers
			var changes xdr.LedgerEntryChanges
			for i := 0; i < len(accountEntries); i++ {
				entry := accountEntries[i]
				require.NoError(
					itest.CurrentTest(),
					loadtest.UpdateLedgerSeqInLedgerEntries(&entry, func(uint32) uint32 {
						return start
					}),
				)
				changes = append(changes, xdr.LedgerEntryChange{
					Type:    xdr.LedgerEntryChangeTypeLedgerEntryCreated,
					Created: &entry,
				})
			}
			var flag xdr.Uint32 = 1
			switch ledger.V {
			case 1:
				ledger.V1.UpgradesProcessing = append(ledger.V1.UpgradesProcessing, xdr.UpgradeEntryMeta{
					Upgrade: xdr.LedgerUpgrade{
						Type:     xdr.LedgerUpgradeTypeLedgerUpgradeFlags,
						NewFlags: &flag,
					},
					Changes: changes,
				})
			case 2:
				ledger.V2.UpgradesProcessing = append(ledger.V2.UpgradesProcessing, xdr.UpgradeEntryMeta{
					Upgrade: xdr.LedgerUpgrade{
						Type:     xdr.LedgerUpgradeTypeLedgerUpgradeFlags,
						NewFlags: &flag,
					},
					Changes: changes,
				})
			default:
				itest.CurrentTest().Fatalf("unsupported ledger version %d", ledger.V)
			}
			if outputPath != "" {
				require.NoError(itest.CurrentTest(), xdr.MarshalFramed(writer, ledger))
			}
			continue
		}

		transactionCount := ledger.CountTransactions()
		evictedKeys, err := ledger.EvictedLedgerKeys()
		require.NoError(itest.CurrentTest(), err)
		require.Empty(itest.CurrentTest(), evictedKeys)
		require.Empty(itest.CurrentTest(), ledger.UpgradesProcessing())
		if transactionCount == 0 {
			continue
		}

		if curCount == 0 {
			merged = copyLedger(itest.CurrentTest(), ledger)
			curBatch = append(curBatch, ledger)
		} else {
			ledgerDiff := int64(merged.LedgerSequence()) - int64(ledger.LedgerSequence())
			require.NoError(itest.CurrentTest(), loadtest.MergeLedgers(&merged, ledger, func(cur uint32) uint32 {
				newLedgerSeq := int64(cur) + ledgerDiff
				require.Less(itest.CurrentTest(), newLedgerSeq, int64(math.MaxUint32))
				require.Positive(itest.CurrentTest(), newLedgerSeq)
				return uint32(newLedgerSeq)
			}))
			curBatch = append(curBatch, ledger)
		}

		require.LessOrEqual(itest.CurrentTest(), curCount+transactionCount, transactionsPerLedger)
		curCount += transactionCount
		if curCount == transactionsPerLedger {
			if outputPath != "" {
				require.NoError(itest.CurrentTest(), xdr.MarshalFramed(writer, merged))
			}
			verifyMerge(itest, accountSet, merged, curBatch)
			curCount = 0
			curBatch = curBatch[:0]
		}
	}
	require.Zero(itest.CurrentTest(), curCount)
	require.NoError(itest.CurrentTest(), captiveCore.Close())
}

func verifyMerge(
	itest *integration.Test,
	accountSet map[string]bool,
	merged xdr.LedgerCloseMeta,
	source []xdr.LedgerCloseMeta,
) {
	networkPassphrase := itest.Config().NetworkPassphrase
	changes := extractChanges(itest.CurrentTest(), networkPassphrase, []xdr.LedgerCloseMeta{merged})
	for _, change := range changes {
		if change.Type != xdr.LedgerEntryTypeAccount {
			continue
		}
		ledgerKey, err := change.LedgerKey()
		require.NoError(itest.CurrentTest(), err)
		require.True(itest.CurrentTest(), accountSet[ledgerKey.MustAccount().AccountId.Address()])
	}
	// a merge is valid if the ordered list of changes emitted by the merged ledger is equal to
	// the list of changes emitted by dst concatenated by the list of changes emitted by src, or
	// in other words:
	// extractChanges(merge(dst, src)) == concat(extractChanges(dst), extractChanges(src))
	requireChangesAreEqual(
		itest.CurrentTest(),
		changes,
		extractChanges(itest.CurrentTest(), networkPassphrase, source),
	)

	originalTransactions := extractTransactions(itest.CurrentTest(), networkPassphrase, source)
	mergedTransactions := extractTransactions(itest.CurrentTest(), networkPassphrase, []xdr.LedgerCloseMeta{merged})
	require.Equal(itest.CurrentTest(), len(originalTransactions), len(mergedTransactions))
	for i, original := range originalTransactions {
		requireTransactionsMatch(itest.CurrentTest(), original, mergedTransactions[i])
	}
}

func copyLedger(t *testing.T, src xdr.LedgerCloseMeta) xdr.LedgerCloseMeta {
	var dst xdr.LedgerCloseMeta
	serialized, err := src.MarshalBinary()
	require.NoError(t, err)
	require.NoError(t, dst.UnmarshalBinary(serialized))
	return dst
}
