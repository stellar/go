package ledger

import (
	"fmt"
	"testing"
	"time"

	"github.com/stellar/go/historyarchive"
	utils "github.com/stellar/go/ingest/processors/processor_utils"
	"github.com/stellar/go/xdr"
	"github.com/stretchr/testify/assert"
)

func TestTransformLedger(t *testing.T) {
	type transformTest struct {
		input      utils.HistoryArchiveLedgerAndLCM
		wantOutput LedgerOutput
		wantErr    error
	}
	hardCodedLedger, err := makeLedgerTestInput()
	assert.NoError(t, err)

	hardCodedOutput, err := makeLedgerTestOutput()
	assert.NoError(t, err)

	tests := []transformTest{
		{
			utils.HistoryArchiveLedgerAndLCM{
				Ledger: historyarchive.Ledger{
					Header: xdr.LedgerHeaderHistoryEntry{
						Header: xdr.LedgerHeader{
							TotalCoins: -1,
						},
					},
				},
				LCM: xdr.LedgerCloseMeta{
					V: 1,
					V1: &xdr.LedgerCloseMetaV1{
						Ext: xdr.LedgerCloseMetaExt{
							V: 1,
							V1: &xdr.LedgerCloseMetaExtV1{
								SorobanFeeWrite1Kb: xdr.Int64(1234),
							},
						},
					},
				},
			},
			LedgerOutput{},
			fmt.Errorf("the total number of coins (-1) is negative for ledger 0 (ledger id=0)"),
		},
		{
			utils.HistoryArchiveLedgerAndLCM{
				Ledger: historyarchive.Ledger{
					Header: xdr.LedgerHeaderHistoryEntry{
						Header: xdr.LedgerHeader{
							FeePool: -1,
						},
					},
				},
				LCM: xdr.LedgerCloseMeta{
					V: 1,
					V1: &xdr.LedgerCloseMetaV1{
						Ext: xdr.LedgerCloseMetaExt{
							V: 1,
							V1: &xdr.LedgerCloseMetaExtV1{
								SorobanFeeWrite1Kb: xdr.Int64(1234),
							},
						},
					},
				},
			},
			LedgerOutput{},
			fmt.Errorf("the fee pool (-1) is negative for ledger 0 (ledger id=0)"),
		},
		{
			hardCodedLedger,
			hardCodedOutput,
			nil,
		},
	}

	for _, test := range tests {
		actualOutput, actualError := TransformLedger(test.input.Ledger, test.input.LCM)
		assert.Equal(t, test.wantErr, actualError)
		assert.Equal(t, test.wantOutput, actualOutput)
	}
}

func makeLedgerTestOutput() (output LedgerOutput, err error) {
	correctTime, err := time.Parse("2006-1-2 15:04:05 MST", "2020-07-12 20:09:07 UTC")
	if err != nil {
		return
	}

	correctBytes := []byte{0x41, 0x41, 0x41, 0x41, 0x44, 0x66, 0x59, 0x38, 0x46, 0x64, 0x44, 0x71, 0x39, 0x49, 0x72, 0x37, 0x31, 0x31, 0x47, 0x6b, 0x78, 0x4e, 0x2b, 0x74, 0x35, 0x55, 0x6f, 0x30, 0x53, 0x41, 0x55, 0x38, 0x52, 0x38, 0x57, 0x6e, 0x48, 0x57, 0x49, 0x6d, 0x61, 0x4b, 0x34, 0x4d, 0x77, 0x71, 0x49, 0x49, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x58, 0x77, 0x74, 0x74, 0x34, 0x77, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x48, 0x53, 0x6d, 0x53, 0x55, 0x4f, 0x6f, 0x68, 0x36, 0x7a, 0x37, 0x48, 0x6c, 0x62, 0x59, 0x51, 0x41, 0x41, 0x45, 0x49, 0x4c, 0x41, 0x79, 0x55, 0x61, 0x4a, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x5a, 0x41, 0x42, 0x4d, 0x53, 0x30, 0x41, 0x41, 0x41, 0x41, 0x50, 0x6f, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41}
	output = LedgerOutput{
		Sequence:           uint32(30578981),
		LedgerID:           131335723340005376,
		LedgerHash:         "26932dc4d84b5fabe9ae744cb43ce4c6daccf98c86a991b2a14945b1adac4d59",
		PreviousLedgerHash: "f63c15d0eaf48afbd751a4c4dfade54a3448053c47c5a71d622668ae0cc2a208",
		LedgerHeader:       string(correctBytes),
		ClosedAt:           correctTime,

		TotalCoins:      1054439020873472865,
		FeePool:         18153766209161,
		BaseFee:         100,
		BaseReserve:     5000000,
		MaxTxSetSize:    1000,
		ProtocolVersion: 13,

		TransactionCount:           1,
		OperationCount:             10,
		SuccessfulTransactionCount: 1,
		FailedTransactionCount:     1,
		TxSetOperationCount:        "13",
		SorobanFeeWrite1Kb:         1234,
	}
	return
}

func makeLedgerTestInput() (lcm utils.HistoryArchiveLedgerAndLCM, err error) {
	hardCodedTxSet := xdr.TransactionSet{
		Txs: []xdr.TransactionEnvelope{
			utils.CreateSampleTx(0, 3),
			utils.CreateSampleTx(1, 10),
		},
	}
	hardCodedTxProcessing := []xdr.TransactionResultPair{
		CreateSampleResultPair(false, 3),
		CreateSampleResultPair(true, 10),
	}
	ledger := historyarchive.Ledger{
		Header: xdr.LedgerHeaderHistoryEntry{
			Header: xdr.LedgerHeader{
				LedgerSeq:          30578981,
				TotalCoins:         1054439020873472865,
				FeePool:            18153766209161,
				BaseFee:            100,
				BaseReserve:        5000000,
				MaxTxSetSize:       1000,
				LedgerVersion:      13,
				PreviousLedgerHash: xdr.Hash{0xf6, 0x3c, 0x15, 0xd0, 0xea, 0xf4, 0x8a, 0xfb, 0xd7, 0x51, 0xa4, 0xc4, 0xdf, 0xad, 0xe5, 0x4a, 0x34, 0x48, 0x5, 0x3c, 0x47, 0xc5, 0xa7, 0x1d, 0x62, 0x26, 0x68, 0xae, 0xc, 0xc2, 0xa2, 0x8},
				ScpValue:           xdr.StellarValue{CloseTime: 1594584547},
			},
			Hash: xdr.Hash{0x26, 0x93, 0x2d, 0xc4, 0xd8, 0x4b, 0x5f, 0xab, 0xe9, 0xae, 0x74, 0x4c, 0xb4, 0x3c, 0xe4, 0xc6, 0xda, 0xcc, 0xf9, 0x8c, 0x86, 0xa9, 0x91, 0xb2, 0xa1, 0x49, 0x45, 0xb1, 0xad, 0xac, 0x4d, 0x59},
		},
		Transaction: xdr.TransactionHistoryEntry{
			LedgerSeq: 30578981,
			TxSet:     hardCodedTxSet,
		},
		TransactionResult: xdr.TransactionHistoryResultEntry{
			LedgerSeq: 30578981,
			TxResultSet: xdr.TransactionResultSet{
				Results: hardCodedTxProcessing,
			},
			Ext: xdr.TransactionHistoryResultEntryExt{},
		},
	}

	lcm = utils.HistoryArchiveLedgerAndLCM{
		Ledger: ledger,
		LCM: xdr.LedgerCloseMeta{
			V: 1,
			V1: &xdr.LedgerCloseMetaV1{
				Ext: xdr.LedgerCloseMetaExt{
					V: 1,
					V1: &xdr.LedgerCloseMetaExtV1{
						SorobanFeeWrite1Kb: xdr.Int64(1234),
					},
				},
			},
		},
	}

	return lcm, nil
}

func CreateSampleResultPair(successful bool, subOperationCount int) xdr.TransactionResultPair {
	resultCode := xdr.TransactionResultCodeTxFailed
	if successful {
		resultCode = xdr.TransactionResultCodeTxSuccess
	}
	operationResults := []xdr.OperationResult{}
	operationResultTr := &xdr.OperationResultTr{
		Type: xdr.OperationTypeCreateAccount,
		CreateAccountResult: &xdr.CreateAccountResult{
			Code: 0,
		},
	}

	for i := 0; i < subOperationCount; i++ {
		operationResults = append(operationResults, xdr.OperationResult{
			Code: xdr.OperationResultCodeOpInner,
			Tr:   operationResultTr,
		})
	}

	return xdr.TransactionResultPair{
		Result: xdr.TransactionResult{
			Result: xdr.TransactionResultResult{
				Code:    resultCode,
				Results: &operationResults,
			},
		},
	}
}
